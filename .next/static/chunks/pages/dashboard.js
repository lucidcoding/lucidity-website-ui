/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/dashboard"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css":
/*!*********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/**\\n * gridstack SASS styles 9.4.0\\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\\n */\\n.grid-stack {\\n  position: relative;\\n}\\n\\n.grid-stack-rtl {\\n  direction: ltr;\\n}\\n.grid-stack-rtl > .grid-stack-item {\\n  direction: rtl;\\n}\\n\\n.grid-stack-placeholder > .placeholder-content {\\n  background-color: rgba(0, 0, 0, 0.1);\\n  margin: 0;\\n  position: absolute;\\n  width: auto;\\n  z-index: 0 !important;\\n}\\n\\n.grid-stack > .grid-stack-item {\\n  position: absolute;\\n  top: 0px;\\n  left: 0%;\\n  padding: 0;\\n}\\n.grid-stack > .grid-stack-item > .grid-stack-item-content {\\n  margin: 0;\\n  position: absolute;\\n  width: auto;\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.grid-stack > .grid-stack-item.size-to-content:not(.size-to-content-max) > .grid-stack-item-content {\\n  overflow-y: hidden;\\n}\\n\\n.grid-stack-item > .ui-resizable-handle {\\n  position: absolute;\\n  font-size: 0.1px;\\n  display: block;\\n  touch-action: none;\\n}\\n.grid-stack-item.ui-resizable-disabled > .ui-resizable-handle, .grid-stack-item.ui-resizable-autohide > .ui-resizable-handle {\\n  display: none;\\n}\\n.grid-stack-item > .ui-resizable-ne,\\n.grid-stack-item > .ui-resizable-nw,\\n.grid-stack-item > .ui-resizable-se,\\n.grid-stack-item > .ui-resizable-sw {\\n  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDUxMS42MjYgNTExLjYyNyIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTExLjYyNiA1MTEuNjI3OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTMyOC45MDYsNDAxLjk5NGgtMzYuNTUzVjEwOS42MzZoMzYuNTUzYzQuOTQ4LDAsOS4yMzYtMS44MDksMTIuODQ3LTUuNDI2YzMuNjEzLTMuNjE1LDUuNDIxLTcuODk4LDUuNDIxLTEyLjg0NSAgIGMwLTQuOTQ5LTEuODAxLTkuMjMxLTUuNDI4LTEyLjg1MWwtNzMuMDg3LTczLjA5QzI2NS4wNDQsMS44MDksMjYwLjc2LDAsMjU1LjgxMywwYy00Ljk0OCwwLTkuMjI5LDEuODA5LTEyLjg0Nyw1LjQyNCAgIGwtNzMuMDg4LDczLjA5Yy0zLjYxOCwzLjYxOS01LjQyNCw3LjkwMi01LjQyNCwxMi44NTFjMCw0Ljk0NiwxLjgwNyw5LjIyOSw1LjQyNCwxMi44NDVjMy42MTksMy42MTcsNy45MDEsNS40MjYsMTIuODUsNS40MjYgICBoMzYuNTQ1djI5Mi4zNThoLTM2LjU0MmMtNC45NTIsMC05LjIzNSwxLjgwOC0xMi44NSw1LjQyMWMtMy42MTcsMy42MjEtNS40MjQsNy45MDUtNS40MjQsMTIuODU0ICAgYzAsNC45NDUsMS44MDcsOS4yMjcsNS40MjQsMTIuODQ3bDczLjA4OSw3My4wODhjMy42MTcsMy42MTcsNy44OTgsNS40MjQsMTIuODQ3LDUuNDI0YzQuOTUsMCw5LjIzNC0xLjgwNywxMi44NDktNS40MjQgICBsNzMuMDg3LTczLjA4OGMzLjYxMy0zLjYyLDUuNDIxLTcuOTAxLDUuNDIxLTEyLjg0N2MwLTQuOTQ4LTEuODA4LTkuMjMyLTUuNDIxLTEyLjg1NCAgIEMzMzguMTQyLDQwMy44MDIsMzMzLjg1Nyw0MDEuOTk0LDMyOC45MDYsNDAxLjk5NHoiIGZpbGw9IiM2NjY2NjYiLz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n}\\n.grid-stack-item > .ui-resizable-ne {\\n  transform: translate(0, 10px) rotate(45deg);\\n}\\n.grid-stack-item > .ui-resizable-sw {\\n  transform: rotate(45deg);\\n}\\n.grid-stack-item > .ui-resizable-nw {\\n  transform: translate(0, 10px) rotate(-45deg);\\n}\\n.grid-stack-item > .ui-resizable-se {\\n  transform: rotate(-45deg);\\n}\\n.grid-stack-item > .ui-resizable-nw {\\n  cursor: nw-resize;\\n  width: 20px;\\n  height: 20px;\\n  top: 0;\\n}\\n.grid-stack-item > .ui-resizable-n {\\n  cursor: n-resize;\\n  height: 10px;\\n  top: 0;\\n  left: 25px;\\n  right: 25px;\\n}\\n.grid-stack-item > .ui-resizable-ne {\\n  cursor: ne-resize;\\n  width: 20px;\\n  height: 20px;\\n  top: 0;\\n}\\n.grid-stack-item > .ui-resizable-e {\\n  cursor: e-resize;\\n  width: 10px;\\n  top: 15px;\\n  bottom: 15px;\\n}\\n.grid-stack-item > .ui-resizable-se {\\n  cursor: se-resize;\\n  width: 20px;\\n  height: 20px;\\n}\\n.grid-stack-item > .ui-resizable-s {\\n  cursor: s-resize;\\n  height: 10px;\\n  left: 25px;\\n  bottom: 0;\\n  right: 25px;\\n}\\n.grid-stack-item > .ui-resizable-sw {\\n  cursor: sw-resize;\\n  width: 20px;\\n  height: 20px;\\n}\\n.grid-stack-item > .ui-resizable-w {\\n  cursor: w-resize;\\n  width: 10px;\\n  top: 15px;\\n  bottom: 15px;\\n}\\n.grid-stack-item.ui-draggable-dragging > .ui-resizable-handle {\\n  display: none !important;\\n}\\n.grid-stack-item.ui-draggable-dragging {\\n  will-change: left, top;\\n  cursor: move;\\n}\\n.grid-stack-item.ui-resizable-resizing {\\n  will-change: width, height;\\n}\\n\\n.ui-draggable-dragging,\\n.ui-resizable-resizing {\\n  z-index: 10000;\\n}\\n.ui-draggable-dragging > .grid-stack-item-content,\\n.ui-resizable-resizing > .grid-stack-item-content {\\n  box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.2);\\n  opacity: 0.8;\\n}\\n\\n.grid-stack-animate,\\n.grid-stack-animate .grid-stack-item {\\n  transition: left 0.3s, top 0.3s, height 0.3s, width 0.3s;\\n}\\n\\n.grid-stack-animate .grid-stack-item.ui-draggable-dragging,\\n.grid-stack-animate .grid-stack-item.ui-resizable-resizing,\\n.grid-stack-animate .grid-stack-item.grid-stack-placeholder {\\n  transition: left 0s, top 0s, height 0s, width 0s;\\n}\\n\\n.gs-12 > .grid-stack-item {\\n  width: 8.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"1\\\"] {\\n  left: 8.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"2\\\"] {\\n  width: 16.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"2\\\"] {\\n  left: 16.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"3\\\"] {\\n  width: 25%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"3\\\"] {\\n  left: 25%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"4\\\"] {\\n  width: 33.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"4\\\"] {\\n  left: 33.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"5\\\"] {\\n  width: 41.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"5\\\"] {\\n  left: 41.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"6\\\"] {\\n  width: 50%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"6\\\"] {\\n  left: 50%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"7\\\"] {\\n  width: 58.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"7\\\"] {\\n  left: 58.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"8\\\"] {\\n  width: 66.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"8\\\"] {\\n  left: 66.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"9\\\"] {\\n  width: 75%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"9\\\"] {\\n  left: 75%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"10\\\"] {\\n  width: 83.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"10\\\"] {\\n  left: 83.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"11\\\"] {\\n  width: 91.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"11\\\"] {\\n  left: 91.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"12\\\"] {\\n  width: 100%;\\n}\\n\\n.gs-1 > .grid-stack-item {\\n  width: 100%;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/gridstack/dist/gridstack.css\"],\"names\":[],\"mappings\":\"AAAA;;;EAGE;AACF;EACE,kBAAkB;AACpB;;AAEA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,oCAAoC;EACpC,SAAS;EACT,kBAAkB;EAClB,WAAW;EACX,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,QAAQ;EACR,UAAU;AACZ;AACA;EACE,SAAS;EACT,kBAAkB;EAClB,WAAW;EACX,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,cAAc;EAEd,kBAAkB;AACpB;AACA;EACE,aAAa;AACf;AACA;;;;EAIE,61DAA61D;EAC71D,4BAA4B;EAC5B,2BAA2B;AAC7B;AACA;EACE,2CAA2C;AAC7C;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,4CAA4C;AAC9C;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,YAAY;EACZ,MAAM;AACR;AACA;EACE,gBAAgB;EAChB,YAAY;EACZ,MAAM;EACN,UAAU;EACV,WAAW;AACb;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,YAAY;EACZ,MAAM;AACR;AACA;EACE,gBAAgB;EAChB,WAAW;EACX,SAAS;EACT,YAAY;AACd;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,YAAY;AACd;AACA;EACE,gBAAgB;EAChB,YAAY;EACZ,UAAU;EACV,SAAS;EACT,WAAW;AACb;AACA;EACE,iBAAiB;EACjB,WAAW;EACX,YAAY;AACd;AACA;EACE,gBAAgB;EAChB,WAAW;EACX,SAAS;EACT,YAAY;AACd;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,sBAAsB;EACtB,YAAY;AACd;AACA;EACE,0BAA0B;AAC5B;;AAEA;;EAEE,cAAc;AAChB;AACA;;EAEE,0CAA0C;EAC1C,YAAY;AACd;;AAEA;;EAEE,wDAAwD;AAC1D;;AAEA;;;EAGE,gDAAgD;AAClD;;AAEA;EACE,aAAa;AACf;AACA;EACE,YAAY;AACd;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,UAAU;AACZ;AACA;EACE,SAAS;AACX;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,UAAU;AACZ;AACA;EACE,SAAS;AACX;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,UAAU;AACZ;AACA;EACE,SAAS;AACX;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,WAAW;AACb;;AAEA;EACE,WAAW;AACb\",\"sourcesContent\":[\"/**\\n * gridstack SASS styles 9.4.0\\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\\n */\\n.grid-stack {\\n  position: relative;\\n}\\n\\n.grid-stack-rtl {\\n  direction: ltr;\\n}\\n.grid-stack-rtl > .grid-stack-item {\\n  direction: rtl;\\n}\\n\\n.grid-stack-placeholder > .placeholder-content {\\n  background-color: rgba(0, 0, 0, 0.1);\\n  margin: 0;\\n  position: absolute;\\n  width: auto;\\n  z-index: 0 !important;\\n}\\n\\n.grid-stack > .grid-stack-item {\\n  position: absolute;\\n  top: 0px;\\n  left: 0%;\\n  padding: 0;\\n}\\n.grid-stack > .grid-stack-item > .grid-stack-item-content {\\n  margin: 0;\\n  position: absolute;\\n  width: auto;\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.grid-stack > .grid-stack-item.size-to-content:not(.size-to-content-max) > .grid-stack-item-content {\\n  overflow-y: hidden;\\n}\\n\\n.grid-stack-item > .ui-resizable-handle {\\n  position: absolute;\\n  font-size: 0.1px;\\n  display: block;\\n  -ms-touch-action: none;\\n  touch-action: none;\\n}\\n.grid-stack-item.ui-resizable-disabled > .ui-resizable-handle, .grid-stack-item.ui-resizable-autohide > .ui-resizable-handle {\\n  display: none;\\n}\\n.grid-stack-item > .ui-resizable-ne,\\n.grid-stack-item > .ui-resizable-nw,\\n.grid-stack-item > .ui-resizable-se,\\n.grid-stack-item > .ui-resizable-sw {\\n  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDUxMS42MjYgNTExLjYyNyIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTExLjYyNiA1MTEuNjI3OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTMyOC45MDYsNDAxLjk5NGgtMzYuNTUzVjEwOS42MzZoMzYuNTUzYzQuOTQ4LDAsOS4yMzYtMS44MDksMTIuODQ3LTUuNDI2YzMuNjEzLTMuNjE1LDUuNDIxLTcuODk4LDUuNDIxLTEyLjg0NSAgIGMwLTQuOTQ5LTEuODAxLTkuMjMxLTUuNDI4LTEyLjg1MWwtNzMuMDg3LTczLjA5QzI2NS4wNDQsMS44MDksMjYwLjc2LDAsMjU1LjgxMywwYy00Ljk0OCwwLTkuMjI5LDEuODA5LTEyLjg0Nyw1LjQyNCAgIGwtNzMuMDg4LDczLjA5Yy0zLjYxOCwzLjYxOS01LjQyNCw3LjkwMi01LjQyNCwxMi44NTFjMCw0Ljk0NiwxLjgwNyw5LjIyOSw1LjQyNCwxMi44NDVjMy42MTksMy42MTcsNy45MDEsNS40MjYsMTIuODUsNS40MjYgICBoMzYuNTQ1djI5Mi4zNThoLTM2LjU0MmMtNC45NTIsMC05LjIzNSwxLjgwOC0xMi44NSw1LjQyMWMtMy42MTcsMy42MjEtNS40MjQsNy45MDUtNS40MjQsMTIuODU0ICAgYzAsNC45NDUsMS44MDcsOS4yMjcsNS40MjQsMTIuODQ3bDczLjA4OSw3My4wODhjMy42MTcsMy42MTcsNy44OTgsNS40MjQsMTIuODQ3LDUuNDI0YzQuOTUsMCw5LjIzNC0xLjgwNywxMi44NDktNS40MjQgICBsNzMuMDg3LTczLjA4OGMzLjYxMy0zLjYyLDUuNDIxLTcuOTAxLDUuNDIxLTEyLjg0N2MwLTQuOTQ4LTEuODA4LTkuMjMyLTUuNDIxLTEyLjg1NCAgIEMzMzguMTQyLDQwMy44MDIsMzMzLjg1Nyw0MDEuOTk0LDMyOC45MDYsNDAxLjk5NHoiIGZpbGw9IiM2NjY2NjYiLz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n}\\n.grid-stack-item > .ui-resizable-ne {\\n  transform: translate(0, 10px) rotate(45deg);\\n}\\n.grid-stack-item > .ui-resizable-sw {\\n  transform: rotate(45deg);\\n}\\n.grid-stack-item > .ui-resizable-nw {\\n  transform: translate(0, 10px) rotate(-45deg);\\n}\\n.grid-stack-item > .ui-resizable-se {\\n  transform: rotate(-45deg);\\n}\\n.grid-stack-item > .ui-resizable-nw {\\n  cursor: nw-resize;\\n  width: 20px;\\n  height: 20px;\\n  top: 0;\\n}\\n.grid-stack-item > .ui-resizable-n {\\n  cursor: n-resize;\\n  height: 10px;\\n  top: 0;\\n  left: 25px;\\n  right: 25px;\\n}\\n.grid-stack-item > .ui-resizable-ne {\\n  cursor: ne-resize;\\n  width: 20px;\\n  height: 20px;\\n  top: 0;\\n}\\n.grid-stack-item > .ui-resizable-e {\\n  cursor: e-resize;\\n  width: 10px;\\n  top: 15px;\\n  bottom: 15px;\\n}\\n.grid-stack-item > .ui-resizable-se {\\n  cursor: se-resize;\\n  width: 20px;\\n  height: 20px;\\n}\\n.grid-stack-item > .ui-resizable-s {\\n  cursor: s-resize;\\n  height: 10px;\\n  left: 25px;\\n  bottom: 0;\\n  right: 25px;\\n}\\n.grid-stack-item > .ui-resizable-sw {\\n  cursor: sw-resize;\\n  width: 20px;\\n  height: 20px;\\n}\\n.grid-stack-item > .ui-resizable-w {\\n  cursor: w-resize;\\n  width: 10px;\\n  top: 15px;\\n  bottom: 15px;\\n}\\n.grid-stack-item.ui-draggable-dragging > .ui-resizable-handle {\\n  display: none !important;\\n}\\n.grid-stack-item.ui-draggable-dragging {\\n  will-change: left, top;\\n  cursor: move;\\n}\\n.grid-stack-item.ui-resizable-resizing {\\n  will-change: width, height;\\n}\\n\\n.ui-draggable-dragging,\\n.ui-resizable-resizing {\\n  z-index: 10000;\\n}\\n.ui-draggable-dragging > .grid-stack-item-content,\\n.ui-resizable-resizing > .grid-stack-item-content {\\n  box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.2);\\n  opacity: 0.8;\\n}\\n\\n.grid-stack-animate,\\n.grid-stack-animate .grid-stack-item {\\n  transition: left 0.3s, top 0.3s, height 0.3s, width 0.3s;\\n}\\n\\n.grid-stack-animate .grid-stack-item.ui-draggable-dragging,\\n.grid-stack-animate .grid-stack-item.ui-resizable-resizing,\\n.grid-stack-animate .grid-stack-item.grid-stack-placeholder {\\n  transition: left 0s, top 0s, height 0s, width 0s;\\n}\\n\\n.gs-12 > .grid-stack-item {\\n  width: 8.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"1\\\"] {\\n  left: 8.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"2\\\"] {\\n  width: 16.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"2\\\"] {\\n  left: 16.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"3\\\"] {\\n  width: 25%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"3\\\"] {\\n  left: 25%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"4\\\"] {\\n  width: 33.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"4\\\"] {\\n  left: 33.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"5\\\"] {\\n  width: 41.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"5\\\"] {\\n  left: 41.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"6\\\"] {\\n  width: 50%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"6\\\"] {\\n  left: 50%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"7\\\"] {\\n  width: 58.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"7\\\"] {\\n  left: 58.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"8\\\"] {\\n  width: 66.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"8\\\"] {\\n  left: 66.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"9\\\"] {\\n  width: 75%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"9\\\"] {\\n  left: 75%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"10\\\"] {\\n  width: 83.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"10\\\"] {\\n  left: 83.333%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"11\\\"] {\\n  width: 91.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-x=\\\"11\\\"] {\\n  left: 91.667%;\\n}\\n.gs-12 > .grid-stack-item[gs-w=\\\"12\\\"] {\\n  width: 100%;\\n}\\n\\n.gs-1 > .grid-stack-item {\\n  width: 100%;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxMV0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzExXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLmNzcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUM4RztBQUM5Ryw4QkFBOEIscUdBQTJCO0FBQ3pEO0FBQ0EsbUtBQW1LLHVCQUF1QixHQUFHLHFCQUFxQixtQkFBbUIsR0FBRyxzQ0FBc0MsbUJBQW1CLEdBQUcsb0RBQW9ELHlDQUF5QyxjQUFjLHVCQUF1QixnQkFBZ0IsMEJBQTBCLEdBQUcsb0NBQW9DLHVCQUF1QixhQUFhLGFBQWEsZUFBZSxHQUFHLDZEQUE2RCxjQUFjLHVCQUF1QixnQkFBZ0IsdUJBQXVCLHFCQUFxQixHQUFHLHVHQUF1Ryx1QkFBdUIsR0FBRyw2Q0FBNkMsdUJBQXVCLHFCQUFxQixtQkFBbUIsdUJBQXVCLEdBQUcsZ0lBQWdJLGtCQUFrQixHQUFHLHlKQUF5Siw2Q0FBNkMscXpEQUFxekQsaUNBQWlDLGdDQUFnQyxHQUFHLHVDQUF1QyxnREFBZ0QsR0FBRyx1Q0FBdUMsNkJBQTZCLEdBQUcsdUNBQXVDLGlEQUFpRCxHQUFHLHVDQUF1Qyw4QkFBOEIsR0FBRyx1Q0FBdUMsc0JBQXNCLGdCQUFnQixpQkFBaUIsV0FBVyxHQUFHLHNDQUFzQyxxQkFBcUIsaUJBQWlCLFdBQVcsZUFBZSxnQkFBZ0IsR0FBRyx1Q0FBdUMsc0JBQXNCLGdCQUFnQixpQkFBaUIsV0FBVyxHQUFHLHNDQUFzQyxxQkFBcUIsZ0JBQWdCLGNBQWMsaUJBQWlCLEdBQUcsdUNBQXVDLHNCQUFzQixnQkFBZ0Is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QUF5QyxrQkFBa0IsR0FBRyx5Q0FBeUMsbUJBQW1CLEdBQUcseUNBQXlDLGtCQUFrQixHQUFHLHlDQUF5QyxlQUFlLEdBQUcseUNBQXlDLGNBQWMsR0FBRyx5Q0FBeUMsbUJBQW1CLEdBQUcseUNBQXlDLGtCQUFrQixHQUFHLHlDQUF5QyxtQkFBbUIsR0FBRyx5Q0FBeUMsa0JBQWtCLEdBQUcseUNBQXlDLGVBQWUsR0FBRyx5Q0FBeUMsY0FBYyxHQUFHLDBDQUEwQyxtQkFBbUIsR0FBRywwQ0FBMEMsa0JBQWtCLEdBQUcsMENBQTBDLG1CQUFtQixHQUFHLDBDQUEwQyxrQkFBa0IsR0FBRywwQ0FBMEMsZ0JBQWdCLEdBQUcsOEJBQThCLGdCQUFnQixHQUFHLG1CQUFtQjtBQUN6OWQ7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLmNzcz9iZDVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIGdyaWRzdGFjayBTQVNTIHN0eWxlcyA5LjQuMFxcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcXG4gKi9cXG4uZ3JpZC1zdGFjayB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5ncmlkLXN0YWNrLXJ0bCB7XFxuICBkaXJlY3Rpb246IGx0cjtcXG59XFxuLmdyaWQtc3RhY2stcnRsID4gLmdyaWQtc3RhY2staXRlbSB7XFxuICBkaXJlY3Rpb246IHJ0bDtcXG59XFxuXFxuLmdyaWQtc3RhY2stcGxhY2Vob2xkZXIgPiAucGxhY2Vob2xkZXItY29udGVudCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICBtYXJnaW46IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogYXV0bztcXG4gIHotaW5kZXg6IDAgIWltcG9ydGFudDtcXG59XFxuXFxuLmdyaWQtc3RhY2sgPiAuZ3JpZC1zdGFjay1pdGVtIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMHB4O1xcbiAgbGVmdDogMCU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4uZ3JpZC1zdGFjayA+IC5ncmlkLXN0YWNrLWl0ZW0gPiAuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQge1xcbiAgbWFyZ2luOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IGF1dG87XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG4uZ3JpZC1zdGFjayA+IC5ncmlkLXN0YWNrLWl0ZW0uc2l6ZS10by1jb250ZW50Om5vdCguc2l6ZS10by1jb250ZW50LW1heCkgPiAuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQge1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbn1cXG5cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1oYW5kbGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZm9udC1zaXplOiAwLjFweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtLnVpLXJlc2l6YWJsZS1kaXNhYmxlZCA+IC51aS1yZXNpemFibGUtaGFuZGxlLCAuZ3JpZC1zdGFjay1pdGVtLnVpLXJlc2l6YWJsZS1hdXRvaGlkZSA+IC51aS1yZXNpemFibGUtaGFuZGxlIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW5lLFxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW53LFxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXNlLFxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXN3IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlhWE52TFRnNE5Ua3RNU0kvUGdvOElTMHRJRWRsYm1WeVlYUnZjam9nUVdSdlltVWdTV3hzZFhOMGNtRjBiM0lnTVRZdU1DNHdMQ0JUVmtjZ1JYaHdiM0owSUZCc2RXY3RTVzRnTGlCVFZrY2dWbVZ5YzJsdmJqb2dOaTR3TUNCQ2RXbHNaQ0F3S1NBZ0xTMCtDandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStDanh6ZG1jZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlCNGJXeHVjenA0YkdsdWF6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M5NGJHbHVheUlnZG1WeWMybHZiajBpTVM0eElpQnBaRDBpUTJGd1lWOHhJaUI0UFNJd2NIZ2lJSGs5SWpCd2VDSWdkMmxrZEdnOUlqRTJjSGdpSUdobGFXZG9kRDBpTVRad2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURVeE1TNDJNallnTlRFeExqWXlOeUlnYzNSNWJHVTlJbVZ1WVdKc1pTMWlZV05yWjNKdmRXNWtPbTVsZHlBd0lEQWdOVEV4TGpZeU5pQTFNVEV1TmpJM095SWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krQ2p4blBnb0pQSEJoZEdnZ1pEMGlUVE15T0M0NU1EWXNOREF4TGprNU5HZ3RNell1TlRVelZqRXdPUzQyTXpab016WXVOVFV6WXpRdU9UUTRMREFzT1M0eU16WXRNUzQ0TURrc01USXVPRFEzTFRVdU5ESTJZek11TmpFekxUTXVOakUxTERVdU5ESXhMVGN1T0RrNExEVXVOREl4TFRFeUxqZzBOU0FnSUdNd0xUUXVPVFE1TFRFdU9EQXhMVGt1TWpNeExUVXVOREk0TFRFeUxqZzFNV3d0TnpNdU1EZzNMVGN6TGpBNVF6STJOUzR3TkRRc01TNDRNRGtzTWpZd0xqYzJMREFzTWpVMUxqZ3hNeXd3WXkwMExqazBPQ3d3TFRrdU1qSTVMREV1T0RBNUxURXlMamcwTnl3MUxqUXlOQ0FnSUd3dE56TXVNRGc0TERjekxqQTVZeTB6TGpZeE9Dd3pMall4T1MwMUxqUXlOQ3czTGprd01pMDFMalF5TkN3eE1pNDROVEZqTUN3MExqazBOaXd4TGpnd055dzVMakl5T1N3MUxqUXlOQ3d4TWk0NE5EVmpNeTQyTVRrc015NDJNVGNzTnk0NU1ERXNOUzQwTWpZc01USXVPRFVzTlM0ME1qWWdJQ0JvTXpZdU5UUTFkakk1TWk0ek5UaG9MVE0yTGpVME1tTXROQzQ1TlRJc01DMDVMakl6TlN3eExqZ3dPQzB4TWk0NE5TdzFMalF5TVdNdE15NDJNVGNzTXk0Mk1qRXROUzQwTWpRc055NDVNRFV0TlM0ME1qUXNNVEl1T0RVMElDQWdZekFzTkM0NU5EVXNNUzQ0TURjc09TNHlNamNzTlM0ME1qUXNNVEl1T0RRM2JEY3pMakE0T1N3M015NHdPRGhqTXk0Mk1UY3NNeTQyTVRjc055NDRPVGdzTlM0ME1qUXNNVEl1T0RRM0xEVXVOREkwWXpRdU9UVXNNQ3c1TGpJek5DMHhMamd3Tnl3eE1pNDRORGt0TlM0ME1qUWdJQ0JzTnpNdU1EZzNMVGN6TGpBNE9HTXpMall4TXkwekxqWXlMRFV1TkRJeExUY3VPVEF4TERVdU5ESXhMVEV5TGpnME4yTXdMVFF1T1RRNExURXVPREE0TFRrdU1qTXlMVFV1TkRJeExURXlMamcxTkNBZ0lFTXpNemd1TVRReUxEUXdNeTQ0TURJc016TXpMamcxTnl3ME1ERXVPVGswTERNeU9DNDVNRFlzTkRBeExqazVOSG9pSUdacGJHdzlJaU0yTmpZMk5qWWlMejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhaejRLUEM5blBnbzhMM04yWno0Syk7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1uZSB7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAxMHB4KSByb3RhdGUoNDVkZWcpO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1zdyB7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW53IHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDEwcHgpIHJvdGF0ZSgtNDVkZWcpO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1zZSB7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1udyB7XFxuICBjdXJzb3I6IG53LXJlc2l6ZTtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgdG9wOiAwO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1uIHtcXG4gIGN1cnNvcjogbi1yZXNpemU7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAyNXB4O1xcbiAgcmlnaHQ6IDI1cHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW5lIHtcXG4gIGN1cnNvcjogbmUtcmVzaXplO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICB0b3A6IDA7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLWUge1xcbiAgY3Vyc29yOiBlLXJlc2l6ZTtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgdG9wOiAxNXB4O1xcbiAgYm90dG9tOiAxNXB4O1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1zZSB7XFxuICBjdXJzb3I6IHNlLXJlc2l6ZTtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtID4gLnVpLXJlc2l6YWJsZS1zIHtcXG4gIGN1cnNvcjogcy1yZXNpemU7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICBsZWZ0OiAyNXB4O1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDI1cHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXN3IHtcXG4gIGN1cnNvcjogc3ctcmVzaXplO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXcge1xcbiAgY3Vyc29yOiB3LXJlc2l6ZTtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgdG9wOiAxNXB4O1xcbiAgYm90dG9tOiAxNXB4O1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtLnVpLWRyYWdnYWJsZS1kcmFnZ2luZyA+IC51aS1yZXNpemFibGUtaGFuZGxlIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLmdyaWQtc3RhY2staXRlbS51aS1kcmFnZ2FibGUtZHJhZ2dpbmcge1xcbiAgd2lsbC1jaGFuZ2U6IGxlZnQsIHRvcDtcXG4gIGN1cnNvcjogbW92ZTtcXG59XFxuLmdyaWQtc3RhY2staXRlbS51aS1yZXNpemFibGUtcmVzaXppbmcge1xcbiAgd2lsbC1jaGFuZ2U6IHdpZHRoLCBoZWlnaHQ7XFxufVxcblxcbi51aS1kcmFnZ2FibGUtZHJhZ2dpbmcsXFxuLnVpLXJlc2l6YWJsZS1yZXNpemluZyB7XFxuICB6LWluZGV4OiAxMDAwMDtcXG59XFxuLnVpLWRyYWdnYWJsZS1kcmFnZ2luZyA+IC5ncmlkLXN0YWNrLWl0ZW0tY29udGVudCxcXG4udWktcmVzaXphYmxlLXJlc2l6aW5nID4gLmdyaWQtc3RhY2staXRlbS1jb250ZW50IHtcXG4gIGJveC1zaGFkb3c6IDFweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gIG9wYWNpdHk6IDAuODtcXG59XFxuXFxuLmdyaWQtc3RhY2stYW5pbWF0ZSxcXG4uZ3JpZC1zdGFjay1hbmltYXRlIC5ncmlkLXN0YWNrLWl0ZW0ge1xcbiAgdHJhbnNpdGlvbjogbGVmdCAwLjNzLCB0b3AgMC4zcywgaGVpZ2h0IDAuM3MsIHdpZHRoIDAuM3M7XFxufVxcblxcbi5ncmlkLXN0YWNrLWFuaW1hdGUgLmdyaWQtc3RhY2staXRlbS51aS1kcmFnZ2FibGUtZHJhZ2dpbmcsXFxuLmdyaWQtc3RhY2stYW5pbWF0ZSAuZ3JpZC1zdGFjay1pdGVtLnVpLXJlc2l6YWJsZS1yZXNpemluZyxcXG4uZ3JpZC1zdGFjay1hbmltYXRlIC5ncmlkLXN0YWNrLWl0ZW0uZ3JpZC1zdGFjay1wbGFjZWhvbGRlciB7XFxuICB0cmFuc2l0aW9uOiBsZWZ0IDBzLCB0b3AgMHMsIGhlaWdodCAwcywgd2lkdGggMHM7XFxufVxcblxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW0ge1xcbiAgd2lkdGg6IDguMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCIxXFxcIl0ge1xcbiAgbGVmdDogOC4zMzMlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjJcXFwiXSB7XFxuICB3aWR0aDogMTYuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCIyXFxcIl0ge1xcbiAgbGVmdDogMTYuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCIzXFxcIl0ge1xcbiAgd2lkdGg6IDI1JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCIzXFxcIl0ge1xcbiAgbGVmdDogMjUlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjRcXFwiXSB7XFxuICB3aWR0aDogMzMuMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCI0XFxcIl0ge1xcbiAgbGVmdDogMzMuMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCI1XFxcIl0ge1xcbiAgd2lkdGg6IDQxLjY2NyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3MteD1cXFwiNVxcXCJdIHtcXG4gIGxlZnQ6IDQxLjY2NyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiNlxcXCJdIHtcXG4gIHdpZHRoOiA1MCU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3MteD1cXFwiNlxcXCJdIHtcXG4gIGxlZnQ6IDUwJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCI3XFxcIl0ge1xcbiAgd2lkdGg6IDU4LjMzMyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3MteD1cXFwiN1xcXCJdIHtcXG4gIGxlZnQ6IDU4LjMzMyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiOFxcXCJdIHtcXG4gIHdpZHRoOiA2Ni42NjclO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjhcXFwiXSB7XFxuICBsZWZ0OiA2Ni42NjclO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjlcXFwiXSB7XFxuICB3aWR0aDogNzUlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjlcXFwiXSB7XFxuICBsZWZ0OiA3NSU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiMTBcXFwiXSB7XFxuICB3aWR0aDogODMuMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCIxMFxcXCJdIHtcXG4gIGxlZnQ6IDgzLjMzMyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiMTFcXFwiXSB7XFxuICB3aWR0aDogOTEuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCIxMVxcXCJdIHtcXG4gIGxlZnQ6IDkxLjY2NyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiMTJcXFwiXSB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLmdzLTEgPiAuZ3JpZC1zdGFjay1pdGVtIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2dyaWRzdGFjay5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7OztFQUdFO0FBQ0Y7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0Usb0NBQW9DO0VBQ3BDLFNBQVM7RUFDVCxrQkFBa0I7RUFDbEIsV0FBVztFQUNYLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsUUFBUTtFQUNSLFVBQVU7QUFDWjtBQUNBO0VBQ0UsU0FBUztFQUNULGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsa0JBQWtCO0VBQ2xCLGdCQUFnQjtBQUNsQjtBQUNBO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixjQUFjO0VBRWQsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7QUFDQTs7OztFQUlFLDYxREFBNjFEO0VBQzcxRCw0QkFBNEI7RUFDNUIsMkJBQTJCO0FBQzdCO0FBQ0E7RUFDRSwyQ0FBMkM7QUFDN0M7QUFDQTtFQUNFLHdCQUF3QjtBQUMxQjtBQUNBO0VBQ0UsNENBQTRDO0FBQzlDO0FBQ0E7RUFDRSx5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsWUFBWTtFQUNaLE1BQU07QUFDUjtBQUNBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixNQUFNO0VBQ04sVUFBVTtFQUNWLFdBQVc7QUFDYjtBQUNBO0VBQ0UsaUJBQWlCO0VBQ2pCLFdBQVc7RUFDWCxZQUFZO0VBQ1osTUFBTTtBQUNSO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsV0FBVztFQUNYLFNBQVM7RUFDVCxZQUFZO0FBQ2Q7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsWUFBWTtBQUNkO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsWUFBWTtFQUNaLFVBQVU7RUFDVixTQUFTO0VBQ1QsV0FBVztBQUNiO0FBQ0E7RUFDRSxpQkFBaUI7RUFDakIsV0FBVztFQUNYLFlBQVk7QUFDZDtBQUNBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFdBQVc7RUFDWCxTQUFTO0VBQ1QsWUFBWTtBQUNkO0FBQ0E7RUFDRSx3QkFBd0I7QUFDMUI7QUFDQTtFQUNFLHNCQUFzQjtFQUN0QixZQUFZO0FBQ2Q7QUFDQTtFQUNFLDBCQUEwQjtBQUM1Qjs7QUFFQTs7RUFFRSxjQUFjO0FBQ2hCO0FBQ0E7O0VBRUUsMENBQTBDO0VBQzFDLFlBQVk7QUFDZDs7QUFFQTs7RUFFRSx3REFBd0Q7QUFDMUQ7O0FBRUE7OztFQUdFLGdEQUFnRDtBQUNsRDs7QUFFQTtFQUNFLGFBQWE7QUFDZjtBQUNBO0VBQ0UsWUFBWTtBQUNkO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UsU0FBUztBQUNYO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7QUFDQTtFQUNFLGNBQWM7QUFDaEI7QUFDQTtFQUNFLGFBQWE7QUFDZjtBQUNBO0VBQ0UsVUFBVTtBQUNaO0FBQ0E7RUFDRSxTQUFTO0FBQ1g7QUFDQTtFQUNFLGNBQWM7QUFDaEI7QUFDQTtFQUNFLGFBQWE7QUFDZjtBQUNBO0VBQ0UsY0FBYztBQUNoQjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxVQUFVO0FBQ1o7QUFDQTtFQUNFLFNBQVM7QUFDWDtBQUNBO0VBQ0UsY0FBYztBQUNoQjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7QUFDQTtFQUNFLFdBQVc7QUFDYjs7QUFFQTtFQUNFLFdBQVc7QUFDYlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKipcXG4gKiBncmlkc3RhY2sgU0FTUyBzdHlsZXMgOS40LjBcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXFxuICovXFxuLmdyaWQtc3RhY2sge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uZ3JpZC1zdGFjay1ydGwge1xcbiAgZGlyZWN0aW9uOiBsdHI7XFxufVxcbi5ncmlkLXN0YWNrLXJ0bCA+IC5ncmlkLXN0YWNrLWl0ZW0ge1xcbiAgZGlyZWN0aW9uOiBydGw7XFxufVxcblxcbi5ncmlkLXN0YWNrLXBsYWNlaG9sZGVyID4gLnBsYWNlaG9sZGVyLWNvbnRlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgbWFyZ2luOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IGF1dG87XFxuICB6LWluZGV4OiAwICFpbXBvcnRhbnQ7XFxufVxcblxcbi5ncmlkLXN0YWNrID4gLmdyaWQtc3RhY2staXRlbSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDAlO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLmdyaWQtc3RhY2sgPiAuZ3JpZC1zdGFjay1pdGVtID4gLmdyaWQtc3RhY2staXRlbS1jb250ZW50IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG59XFxuLmdyaWQtc3RhY2sgPiAuZ3JpZC1zdGFjay1pdGVtLnNpemUtdG8tY29udGVudDpub3QoLnNpemUtdG8tY29udGVudC1tYXgpID4gLmdyaWQtc3RhY2staXRlbS1jb250ZW50IHtcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG59XFxuXFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGZvbnQtc2l6ZTogMC4xcHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0udWktcmVzaXphYmxlLWRpc2FibGVkID4gLnVpLXJlc2l6YWJsZS1oYW5kbGUsIC5ncmlkLXN0YWNrLWl0ZW0udWktcmVzaXphYmxlLWF1dG9oaWRlID4gLnVpLXJlc2l6YWJsZS1oYW5kbGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtbmUsXFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtbncsXFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtc2UsXFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtc3cge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWFYTnZMVGc0TlRrdE1TSS9QZ284SVMwdElFZGxibVZ5WVhSdmNqb2dRV1J2WW1VZ1NXeHNkWE4wY21GMGIzSWdNVFl1TUM0d0xDQlRWa2NnUlhod2IzSjBJRkJzZFdjdFNXNGdMaUJUVmtjZ1ZtVnljMmx2YmpvZ05pNHdNQ0JDZFdsc1pDQXdLU0FnTFMwK0Nqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK0NqeHpkbWNnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JaUI0Yld4dWN6cDRiR2x1YXowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzk0YkdsdWF5SWdkbVZ5YzJsdmJqMGlNUzR4SWlCcFpEMGlRMkZ3WVY4eElpQjRQU0l3Y0hnaUlIazlJakJ3ZUNJZ2QybGtkR2c5SWpFMmNIZ2lJR2hsYVdkb2REMGlNVFp3ZUNJZ2RtbGxkMEp2ZUQwaU1DQXdJRFV4TVM0Mk1qWWdOVEV4TGpZeU55SWdjM1I1YkdVOUltVnVZV0pzWlMxaVlXTnJaM0p2ZFc1a09tNWxkeUF3SURBZ05URXhMall5TmlBMU1URXVOakkzT3lJZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSStDanhuUGdvSlBIQmhkR2dnWkQwaVRUTXlPQzQ1TURZc05EQXhMams1TkdndE16WXVOVFV6VmpFd09TNDJNelpvTXpZdU5UVXpZelF1T1RRNExEQXNPUzR5TXpZdE1TNDRNRGtzTVRJdU9EUTNMVFV1TkRJMll6TXVOakV6TFRNdU5qRTFMRFV1TkRJeExUY3VPRGs0TERVdU5ESXhMVEV5TGpnME5TQWdJR013TFRRdU9UUTVMVEV1T0RBeExUa3VNak14TFRVdU5ESTRMVEV5TGpnMU1Xd3ROek11TURnM0xUY3pMakE1UXpJMk5TNHdORFFzTVM0NE1Ea3NNall3TGpjMkxEQXNNalUxTGpneE15d3dZeTAwTGprME9Dd3dMVGt1TWpJNUxERXVPREE1TFRFeUxqZzBOeXcxTGpReU5DQWdJR3d0TnpNdU1EZzRMRGN6TGpBNVl5MHpMall4T0N3ekxqWXhPUzAxTGpReU5DdzNMamt3TWkwMUxqUXlOQ3d4TWk0NE5URmpNQ3cwTGprME5pd3hMamd3Tnl3NUxqSXlPU3cxTGpReU5Dd3hNaTQ0TkRWak15NDJNVGtzTXk0Mk1UY3NOeTQ1TURFc05TNDBNallzTVRJdU9EVXNOUzQwTWpZZ0lDQm9Nell1TlRRMWRqSTVNaTR6TlRob0xUTTJMalUwTW1NdE5DNDVOVElzTUMwNUxqSXpOU3d4TGpnd09DMHhNaTQ0TlN3MUxqUXlNV010TXk0Mk1UY3NNeTQyTWpFdE5TNDBNalFzTnk0NU1EVXROUzQwTWpRc01USXVPRFUwSUNBZ1l6QXNOQzQ1TkRVc01TNDRNRGNzT1M0eU1qY3NOUzQwTWpRc01USXVPRFEzYkRjekxqQTRPU3czTXk0d09EaGpNeTQyTVRjc015NDJNVGNzTnk0NE9UZ3NOUzQwTWpRc01USXVPRFEzTERVdU5ESTBZelF1T1RVc01DdzVMakl6TkMweExqZ3dOeXd4TWk0NE5Ea3ROUzQwTWpRZ0lDQnNOek11TURnM0xUY3pMakE0T0dNekxqWXhNeTB6TGpZeUxEVXVOREl4TFRjdU9UQXhMRFV1TkRJeExURXlMamcwTjJNd0xUUXVPVFE0TFRFdU9EQTRMVGt1TWpNeUxUVXVOREl4TFRFeUxqZzFOQ0FnSUVNek16Z3VNVFF5TERRd015NDRNRElzTXpNekxqZzFOeXcwTURFdU9UazBMRE15T0M0NU1EWXNOREF4TGprNU5Ib2lJR1pwYkd3OUlpTTJOalkyTmpZaUx6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOFp6NEtQQzluUGdvOEwzTjJaejRLKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW5lIHtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDEwcHgpIHJvdGF0ZSg0NWRlZyk7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXN3IHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtbncge1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMTBweCkgcm90YXRlKC00NWRlZyk7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXNlIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW53IHtcXG4gIGN1cnNvcjogbnctcmVzaXplO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICB0b3A6IDA7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLW4ge1xcbiAgY3Vyc29yOiBuLXJlc2l6ZTtcXG4gIGhlaWdodDogMTBweDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDI1cHg7XFxuICByaWdodDogMjVweDtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtbmUge1xcbiAgY3Vyc29yOiBuZS1yZXNpemU7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIHRvcDogMDtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtZSB7XFxuICBjdXJzb3I6IGUtcmVzaXplO1xcbiAgd2lkdGg6IDEwcHg7XFxuICB0b3A6IDE1cHg7XFxuICBib3R0b206IDE1cHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXNlIHtcXG4gIGN1cnNvcjogc2UtcmVzaXplO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0gPiAudWktcmVzaXphYmxlLXMge1xcbiAgY3Vyc29yOiBzLXJlc2l6ZTtcXG4gIGhlaWdodDogMTBweDtcXG4gIGxlZnQ6IDI1cHg7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMjVweDtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtc3cge1xcbiAgY3Vyc29yOiBzdy1yZXNpemU7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG59XFxuLmdyaWQtc3RhY2staXRlbSA+IC51aS1yZXNpemFibGUtdyB7XFxuICBjdXJzb3I6IHctcmVzaXplO1xcbiAgd2lkdGg6IDEwcHg7XFxuICB0b3A6IDE1cHg7XFxuICBib3R0b206IDE1cHg7XFxufVxcbi5ncmlkLXN0YWNrLWl0ZW0udWktZHJhZ2dhYmxlLWRyYWdnaW5nID4gLnVpLXJlc2l6YWJsZS1oYW5kbGUge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtLnVpLWRyYWdnYWJsZS1kcmFnZ2luZyB7XFxuICB3aWxsLWNoYW5nZTogbGVmdCwgdG9wO1xcbiAgY3Vyc29yOiBtb3ZlO1xcbn1cXG4uZ3JpZC1zdGFjay1pdGVtLnVpLXJlc2l6YWJsZS1yZXNpemluZyB7XFxuICB3aWxsLWNoYW5nZTogd2lkdGgsIGhlaWdodDtcXG59XFxuXFxuLnVpLWRyYWdnYWJsZS1kcmFnZ2luZyxcXG4udWktcmVzaXphYmxlLXJlc2l6aW5nIHtcXG4gIHotaW5kZXg6IDEwMDAwO1xcbn1cXG4udWktZHJhZ2dhYmxlLWRyYWdnaW5nID4gLmdyaWQtc3RhY2staXRlbS1jb250ZW50LFxcbi51aS1yZXNpemFibGUtcmVzaXppbmcgPiAuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQge1xcbiAgYm94LXNoYWRvdzogMXB4IDRweCA2cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgb3BhY2l0eTogMC44O1xcbn1cXG5cXG4uZ3JpZC1zdGFjay1hbmltYXRlLFxcbi5ncmlkLXN0YWNrLWFuaW1hdGUgLmdyaWQtc3RhY2staXRlbSB7XFxuICB0cmFuc2l0aW9uOiBsZWZ0IDAuM3MsIHRvcCAwLjNzLCBoZWlnaHQgMC4zcywgd2lkdGggMC4zcztcXG59XFxuXFxuLmdyaWQtc3RhY2stYW5pbWF0ZSAuZ3JpZC1zdGFjay1pdGVtLnVpLWRyYWdnYWJsZS1kcmFnZ2luZyxcXG4uZ3JpZC1zdGFjay1hbmltYXRlIC5ncmlkLXN0YWNrLWl0ZW0udWktcmVzaXphYmxlLXJlc2l6aW5nLFxcbi5ncmlkLXN0YWNrLWFuaW1hdGUgLmdyaWQtc3RhY2staXRlbS5ncmlkLXN0YWNrLXBsYWNlaG9sZGVyIHtcXG4gIHRyYW5zaXRpb246IGxlZnQgMHMsIHRvcCAwcywgaGVpZ2h0IDBzLCB3aWR0aCAwcztcXG59XFxuXFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbSB7XFxuICB3aWR0aDogOC4zMzMlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjFcXFwiXSB7XFxuICBsZWZ0OiA4LjMzMyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiMlxcXCJdIHtcXG4gIHdpZHRoOiAxNi42NjclO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjJcXFwiXSB7XFxuICBsZWZ0OiAxNi42NjclO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjNcXFwiXSB7XFxuICB3aWR0aDogMjUlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjNcXFwiXSB7XFxuICBsZWZ0OiAyNSU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiNFxcXCJdIHtcXG4gIHdpZHRoOiAzMy4zMzMlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjRcXFwiXSB7XFxuICBsZWZ0OiAzMy4zMzMlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjVcXFwiXSB7XFxuICB3aWR0aDogNDEuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCI1XFxcIl0ge1xcbiAgbGVmdDogNDEuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCI2XFxcIl0ge1xcbiAgd2lkdGg6IDUwJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCI2XFxcIl0ge1xcbiAgbGVmdDogNTAlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXc9XFxcIjdcXFwiXSB7XFxuICB3aWR0aDogNTguMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy14PVxcXCI3XFxcIl0ge1xcbiAgbGVmdDogNTguMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCI4XFxcIl0ge1xcbiAgd2lkdGg6IDY2LjY2NyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3MteD1cXFwiOFxcXCJdIHtcXG4gIGxlZnQ6IDY2LjY2NyU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3Mtdz1cXFwiOVxcXCJdIHtcXG4gIHdpZHRoOiA3NSU7XFxufVxcbi5ncy0xMiA+IC5ncmlkLXN0YWNrLWl0ZW1bZ3MteD1cXFwiOVxcXCJdIHtcXG4gIGxlZnQ6IDc1JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCIxMFxcXCJdIHtcXG4gIHdpZHRoOiA4My4zMzMlO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjEwXFxcIl0ge1xcbiAgbGVmdDogODMuMzMzJTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCIxMVxcXCJdIHtcXG4gIHdpZHRoOiA5MS42NjclO1xcbn1cXG4uZ3MtMTIgPiAuZ3JpZC1zdGFjay1pdGVtW2dzLXg9XFxcIjExXFxcIl0ge1xcbiAgbGVmdDogOTEuNjY3JTtcXG59XFxuLmdzLTEyID4gLmdyaWQtc3RhY2staXRlbVtncy13PVxcXCIxMlxcXCJdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4uZ3MtMSA+IC5ncmlkLXN0YWNrLWl0ZW0ge1xcbiAgd2lkdGg6IDEwMCU7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"div.DashboardContainer_container__4EW4N {\\n  display: flex;\\n  flex-direction: row;\\n  align-items: stretch;\\n  min-height: 100vh;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml {\\n  width: 280px;\\n  background-color: rgb(25, 28, 36);\\n  display: flex;\\n  flex-direction: column;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml div.DashboardContainer_header__OJq71 {\\n  height: 82px;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml h2 {\\n  font-size: 15px;\\n  color: rgb(108, 114, 147);\\n  font-weight: bold;\\n  -webkit-margin-before: 38px;\\n          margin-block-start: 38px;\\n  -webkit-margin-after: 24px;\\n          margin-block-end: 24px;\\n  -webkit-margin-start: 24px;\\n          margin-inline-start: 24px;\\n  -webkit-margin-end: 24px;\\n          margin-inline-end: 24px;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml h2:first-of-type {\\n  -webkit-margin-before: 0;\\n          margin-block-start: 0;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button {\\n  padding: 10px 24px;\\n  background-color: transparent;\\n  color: #fff;\\n  border: 0;\\n  cursor: pointer;\\n  text-align: left;\\n  font-size: 15px;\\n  font-family: inherit;\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button:hover {\\n  background-color: rgb(0, 0, 0);\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button.DashboardContainer_noIcon__eTtmR {\\n  padding-left: 58px;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_icon__LsHeu {\\n  border-radius: 50%;\\n  margin-right: 10px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_icon__LsHeu:last-child {\\n  margin-right: 0;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_icon__LsHeu.DashboardContainer_spinOnExpand__ShEw2 {\\n  transition: transform 1s;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_icon__LsHeu.DashboardContainer_spinOnExpand__ShEw2.DashboardContainer_expanded__QbP9k {\\n  transform: rotate(180deg);\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_icon__LsHeu svg {\\n  fill: rgb(108, 114, 147);\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml button div.DashboardContainer_text__JsJCz {\\n  margin-top: -3px;\\n  flex-grow: 1;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml div.DashboardContainer_dropDown__l67OK {\\n  height: 0;\\n  display: flex;\\n  flex-direction: column;\\n  overflow: hidden;\\n  transition: height 1s;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_menu__G3tml div.DashboardContainer_dropDown__l67OK.DashboardContainer_expanded__QbP9k {\\n  height: auto;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_main__XqBoV {\\n  flex-grow: 1;\\n  background-color: rgb(0, 0, 0);\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_main__XqBoV > div.DashboardContainer_header__OJq71 {\\n  padding: 0 24px 0 24px;\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n  height: 82px;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_main__XqBoV > div.DashboardContainer_header__OJq71 h1 {\\n  padding-left: 3px;\\n  font-size: 20px;\\n  -webkit-margin-before: 0;\\n          margin-block-start: 0;\\n  -webkit-margin-after: 0;\\n          margin-block-end: 0;\\n  -webkit-margin-start: 0;\\n          margin-inline-start: 0;\\n  -webkit-margin-end: 0;\\n          margin-inline-end: 0;\\n  font-weight: 500;\\n  flex-grow: 1;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_main__XqBoV > div.DashboardContainer_gridStackContainer__E7U_J {\\n  padding: 0 24px 24px 24px;\\n  flex-grow: 1;\\n}\\ndiv.DashboardContainer_container__4EW4N > div.DashboardContainer_main__XqBoV > div.DashboardContainer_gridStackContainer__E7U_J > div.DashboardContainer_gridStack__CMR4X {\\n  margin: -12px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/DashboardContainer/DashboardContainer.module.scss\",\"webpack://styles/common.scss\"],\"names\":[],\"mappings\":\"AAEA;EACI,aAAA;EACA,mBAAA;EACA,oBAAA;EACA,iBAAA;AADJ;AAGI;EACI,YAAA;EACA,iCCHG;EDIH,aAAA;EACA,sBAAA;AADR;AAGQ;EACI,YAAA;AADZ;AAIQ;EACI,eCDE;EDEF,yBCdC;EDeD,iBAAA;EACA,2BCZU;UDYV,wBCZU;EDaV,0BCZI;UDYJ,sBCZI;EDaJ,0BCbI;UDaJ,yBCbI;EDcJ,wBCdI;UDcJ,uBCdI;ADYhB;AAIY;EACI,wBAAA;UAAA,qBAAA;AAFhB;AAMQ;EACI,kBAAA;EACA,6BAAA;EACA,WClCJ;EDmCI,SAAA;EACA,eAAA;EACA,gBAAA;EACA,eCrBE;EDsBF,oBAAA;EACA,aAAA;EACA,mBAAA;EACA,mBAAA;AAJZ;AAMY;EACI,8BCtCJ;ADkCZ;AAOY;EACI,kBC5Bc;ADuB9B;AAQY;EACI,kBAAA;EACA,kBC3CG;ED8CH,aAAA;EACA,mBAAA;EACA,uBAAA;AARhB;AAUgB;EACI,eAAA;AARpB;AAWgB;EACI,wBAAA;AATpB;AAUoB;EACI,yBAAA;AARxB;AAYgB;EACI,wBCpEP;AD0Db;AAcY;EACI,gBAAA;EACA,YAAA;AAZhB;AAgBQ;EACI,SAAA;EACA,aAAA;EACA,sBAAA;EACA,gBAAA;EACA,qBAAA;AAdZ;AAgBY;EACI,YAAA;AAdhB;AAmBI;EACI,YAAA;EACA,8BC3FI;AD0EZ;AAmBQ;EACI,sBAAA;EACA,aAAA;EACA,mBAAA;EACA,mBAAA;EACA,YC3FI;AD0EhB;AAoBY;EACI,iBAAA;EACA,eC9FH;ED+FG,wBAAA;UAAA,qBAAA;EACA,uBAAA;UAAA,mBAAA;EACA,uBAAA;UAAA,sBAAA;EACA,qBAAA;UAAA,oBAAA;EACA,gBAAA;EACA,YAAA;AAlBhB;AAwBQ;EACI,yBAAA;EACA,YAAA;AAtBZ;AAwBY;EACI,aAAA;AAtBhB\",\"sourcesContent\":[\"@import \\\"../../styles/common.scss\\\";\\r\\n\\r\\ndiv.container {\\r\\n    display: flex;\\r\\n    flex-direction: row;\\r\\n    align-items: stretch;\\r\\n    min-height: 100vh;\\r\\n\\r\\n    > div.menu {\\r\\n        width: 280px;\\r\\n        background-color: $grey-mid;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n\\r\\n        div.header {\\r\\n            height: $header-height;\\r\\n        }\\r\\n\\r\\n        h2 {\\r\\n            font-size: $medium-font;\\r\\n            color: $grey-light;\\r\\n            font-weight: bold;\\r\\n            margin-block-start: $extra-large-padding;\\r\\n            margin-block-end: $large-padding;\\r\\n            margin-inline-start: $large-padding;\\r\\n            margin-inline-end: $large-padding;\\r\\n\\r\\n            &:first-of-type {\\r\\n                margin-block-start: 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        button {\\r\\n            padding: $standard-padding $large-padding ;\\r\\n            background-color: transparent;\\r\\n            color: $white;\\r\\n            border: 0;\\r\\n            cursor: pointer;\\r\\n            text-align: left;\\r\\n            font-size: $medium-font;\\r\\n            font-family: inherit;\\r\\n            display: flex;\\r\\n            flex-direction: row;\\r\\n            align-items: center;\\r\\n\\r\\n            &:hover {\\r\\n                background-color: $grey-dark;\\r\\n            }\\r\\n\\r\\n            &.noIcon {\\r\\n                padding-left: $large-padding-and-icon-shim;\\r\\n            }\\r\\n\\r\\n            div.icon {\\r\\n                border-radius: 50%;\\r\\n                margin-right: $standard-padding;\\r\\n                //width: $standard-icon-size;\\r\\n                //@extend: $standard-icon-size;\\r\\n                display: flex;\\r\\n                align-items: center;\\r\\n                justify-content: center;\\r\\n                \\r\\n                &:last-child {\\r\\n                    margin-right: 0;\\r\\n                }\\r\\n\\r\\n                &.spinOnExpand {\\r\\n                    transition: transform 1s;\\r\\n                    &.expanded {\\r\\n                        transform: rotate(180deg);\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n                svg {\\r\\n                    fill: $grey-light;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            div.text {\\r\\n                margin-top: -3px;\\r\\n                flex-grow: 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        div.dropDown {\\r\\n            height: 0;\\r\\n            display: flex;\\r\\n            flex-direction: column;\\r\\n            overflow: hidden;\\r\\n            transition: height 1s;\\r\\n\\r\\n            &.expanded {\\r\\n                height: auto;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    > div.main {\\r\\n        flex-grow: 1;\\r\\n        background-color: $grey-dark;\\r\\n\\r\\n        > div.header {\\r\\n            padding: 0 $large-padding 0 $large-padding; \\r\\n            display: flex;\\r\\n            flex-direction: row;\\r\\n            align-items: center;\\r\\n            height: $header-height;\\r\\n\\r\\n\\r\\n            h1 {\\r\\n                padding-left: 3px; // Visual shim\\r\\n                font-size: $large-font;\\r\\n                margin-block-start: 0;\\r\\n                margin-block-end: 0;\\r\\n                margin-inline-start: 0;\\r\\n                margin-inline-end: 0;\\r\\n                font-weight: 500;\\r\\n                flex-grow: 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \\r\\n\\r\\n        > div.gridStackContainer {\\r\\n            padding: 0 $large-padding $large-padding $large-padding;\\r\\n            flex-grow: 1;\\r\\n\\r\\n            > div.gridStack {\\r\\n                margin: -12px;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\",\"$black: #000;\\r\\n$white: #fff;\\r\\n$transparent: rgba(255, 255, 255, 0);\\r\\n\\r\\n$primary: #582c83;\\r\\n\\r\\n$grey-light: rgb(108, 114, 147);\\r\\n$grey-mid: rgb(25, 28, 36);\\r\\n$grey-dark: rgb(0, 0, 0);\\r\\n\\r\\n$extra-large-padding: 38px;\\r\\n$large-padding: 24px;\\r\\n$standard-padding: 10px;\\r\\n$small-padding: 3px;\\r\\n\\r\\n$header-height: 82px;\\r\\n\\r\\n$large-font: 20px;\\r\\n$medium-font: 15px;\\r\\n\\r\\n$standard-icon-size: 24px;\\r\\n\\r\\n$large-padding-and-icon-shim: calc($large-padding + $standard-icon-size + $standard-padding);\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"DashboardContainer_container__4EW4N\",\n\t\"menu\": \"DashboardContainer_menu__G3tml\",\n\t\"header\": \"DashboardContainer_header__OJq71\",\n\t\"noIcon\": \"DashboardContainer_noIcon__eTtmR\",\n\t\"icon\": \"DashboardContainer_icon__LsHeu\",\n\t\"spinOnExpand\": \"DashboardContainer_spinOnExpand__ShEw2\",\n\t\"expanded\": \"DashboardContainer_expanded__QbP9k\",\n\t\"text\": \"DashboardContainer_text__JsJCz\",\n\t\"dropDown\": \"DashboardContainer_dropDown__l67OK\",\n\t\"main\": \"DashboardContainer_main__XqBoV\",\n\t\"gridStackContainer\": \"DashboardContainer_gridStackContainer__E7U_J\",\n\t\"gridStack\": \"DashboardContainer_gridStack__CMR4X\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL2NvbXBvbmVudHMvRGFzaGJvYXJkQ29udGFpbmVyL0Rhc2hib2FyZENvbnRhaW5lci5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHNLQUFrRjtBQUM1SDtBQUNBO0FBQ0EsbUZBQW1GLGtCQUFrQix3QkFBd0IseUJBQXlCLHNCQUFzQixHQUFHLGdGQUFnRixpQkFBaUIsc0NBQXNDLGtCQUFrQiwyQkFBMkIsR0FBRyxxSEFBcUgsaUJBQWlCLEdBQUcsbUZBQW1GLG9CQUFvQiw4QkFBOEIsc0JBQXNCLGdDQUFnQyxxQ0FBcUMsK0JBQStCLG1DQUFtQywrQkFBK0Isc0NBQXNDLDZCQUE2QixvQ0FBb0MsR0FBRyxpR0FBaUcsNkJBQTZCLGtDQUFrQyxHQUFHLHVGQUF1Rix1QkFBdUIsa0NBQWtDLGdCQUFnQixjQUFjLG9CQUFvQixxQkFBcUIsb0JBQW9CLHlCQUF5QixrQkFBa0Isd0JBQXdCLHdCQUF3QixHQUFHLDZGQUE2RixtQ0FBbUMsR0FBRyx3SEFBd0gsdUJB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QUF3QywrQkFBK0IsNkJBQTZCLG1DQUFtQyx5QkFBeUIsNEJBQTRCLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLHVCQUF1QixrQ0FBa0MscUdBQXFHLG1CQUFtQjtBQUM5cVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9EYXNoYm9hcmRDb250YWluZXIvRGFzaGJvYXJkQ29udGFpbmVyLm1vZHVsZS5zY3NzPzFlNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwge1xcbiAgd2lkdGg6IDI4MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1LCAyOCwgMzYpO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgZGl2LkRhc2hib2FyZENvbnRhaW5lcl9oZWFkZXJfX09KcTcxIHtcXG4gIGhlaWdodDogODJweDtcXG59XFxuZGl2LkRhc2hib2FyZENvbnRhaW5lcl9jb250YWluZXJfXzRFVzROID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9tZW51X19HM3RtbCBoMiB7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBjb2xvcjogcmdiKDEwOCwgMTE0LCAxNDcpO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAtd2Via2l0LW1hcmdpbi1iZWZvcmU6IDM4cHg7XFxuICAgICAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogMzhweDtcXG4gIC13ZWJraXQtbWFyZ2luLWFmdGVyOiAyNHB4O1xcbiAgICAgICAgICBtYXJnaW4tYmxvY2stZW5kOiAyNHB4O1xcbiAgLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDI0cHg7XFxuICAgICAgICAgIG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDI0cHg7XFxuICAtd2Via2l0LW1hcmdpbi1lbmQ6IDI0cHg7XFxuICAgICAgICAgIG1hcmdpbi1pbmxpbmUtZW5kOiAyNHB4O1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sIGgyOmZpcnN0LW9mLXR5cGUge1xcbiAgLXdlYmtpdC1tYXJnaW4tYmVmb3JlOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IDA7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgYnV0dG9uIHtcXG4gIHBhZGRpbmc6IDEwcHggMjRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6ICNmZmY7XFxuICBib3JkZXI6IDA7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgYnV0dG9uOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwLCAwLCAwKTtcXG59XFxuZGl2LkRhc2hib2FyZENvbnRhaW5lcl9jb250YWluZXJfXzRFVzROID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9tZW51X19HM3RtbCBidXR0b24uRGFzaGJvYXJkQ29udGFpbmVyX25vSWNvbl9fZVR0bVIge1xcbiAgcGFkZGluZy1sZWZ0OiA1OHB4O1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sIGJ1dHRvbiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX2ljb25fX0xzSGV1IHtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgYnV0dG9uIGRpdi5EYXNoYm9hcmRDb250YWluZXJfaWNvbl9fTHNIZXU6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgYnV0dG9uIGRpdi5EYXNoYm9hcmRDb250YWluZXJfaWNvbl9fTHNIZXUuRGFzaGJvYXJkQ29udGFpbmVyX3NwaW5PbkV4cGFuZF9fU2hFdzIge1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDFzO1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sIGJ1dHRvbiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX2ljb25fX0xzSGV1LkRhc2hib2FyZENvbnRhaW5lcl9zcGluT25FeHBhbmRfX1NoRXcyLkRhc2hib2FyZENvbnRhaW5lcl9leHBhbmRlZF9fUWJQOWsge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG59XFxuZGl2LkRhc2hib2FyZENvbnRhaW5lcl9jb250YWluZXJfXzRFVzROID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9tZW51X19HM3RtbCBidXR0b24gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9pY29uX19Mc0hldSBzdmcge1xcbiAgZmlsbDogcmdiKDEwOCwgMTE0LCAxNDcpO1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sIGJ1dHRvbiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX3RleHRfX0pzSkN6IHtcXG4gIG1hcmdpbi10b3A6IC0zcHg7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWVudV9fRzN0bWwgZGl2LkRhc2hib2FyZENvbnRhaW5lcl9kcm9wRG93bl9fbDY3T0sge1xcbiAgaGVpZ2h0OiAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdHJhbnNpdGlvbjogaGVpZ2h0IDFzO1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sIGRpdi5EYXNoYm9hcmRDb250YWluZXJfZHJvcERvd25fX2w2N09LLkRhc2hib2FyZENvbnRhaW5lcl9leHBhbmRlZF9fUWJQOWsge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21haW5fX1hxQm9WIHtcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwLCAwLCAwKTtcXG59XFxuZGl2LkRhc2hib2FyZENvbnRhaW5lcl9jb250YWluZXJfXzRFVzROID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9tYWluX19YcUJvViA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfaGVhZGVyX19PSnE3MSB7XFxuICBwYWRkaW5nOiAwIDI0cHggMCAyNHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgaGVpZ2h0OiA4MnB4O1xcbn1cXG5kaXYuRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE4gPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX21haW5fX1hxQm9WID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9oZWFkZXJfX09KcTcxIGgxIHtcXG4gIHBhZGRpbmctbGVmdDogM3B4O1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgLXdlYmtpdC1tYXJnaW4tYmVmb3JlOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IDA7XFxuICAtd2Via2l0LW1hcmdpbi1hZnRlcjogMDtcXG4gICAgICAgICAgbWFyZ2luLWJsb2NrLWVuZDogMDtcXG4gIC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwO1xcbiAgICAgICAgICBtYXJnaW4taW5saW5lLXN0YXJ0OiAwO1xcbiAgLXdlYmtpdC1tYXJnaW4tZW5kOiAwO1xcbiAgICAgICAgICBtYXJnaW4taW5saW5lLWVuZDogMDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcbmRpdi5EYXNoYm9hcmRDb250YWluZXJfY29udGFpbmVyX180RVc0TiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfbWFpbl9fWHFCb1YgPiBkaXYuRGFzaGJvYXJkQ29udGFpbmVyX2dyaWRTdGFja0NvbnRhaW5lcl9fRTdVX0oge1xcbiAgcGFkZGluZzogMCAyNHB4IDI0cHggMjRweDtcXG4gIGZsZXgtZ3JvdzogMTtcXG59XFxuZGl2LkRhc2hib2FyZENvbnRhaW5lcl9jb250YWluZXJfXzRFVzROID4gZGl2LkRhc2hib2FyZENvbnRhaW5lcl9tYWluX19YcUJvViA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfZ3JpZFN0YWNrQ29udGFpbmVyX19FN1VfSiA+IGRpdi5EYXNoYm9hcmRDb250YWluZXJfZ3JpZFN0YWNrX19DTVI0WCB7XFxuICBtYXJnaW46IC0xMnB4O1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9EYXNoYm9hcmRDb250YWluZXIvRGFzaGJvYXJkQ29udGFpbmVyLm1vZHVsZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vc3R5bGVzL2NvbW1vbi5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUVBO0VBQ0ksYUFBQTtFQUNBLG1CQUFBO0VBQ0Esb0JBQUE7RUFDQSxpQkFBQTtBQURKO0FBR0k7RUFDSSxZQUFBO0VBQ0EsaUNDSEc7RURJSCxhQUFBO0VBQ0Esc0JBQUE7QUFEUjtBQUdRO0VBQ0ksWUFBQTtBQURaO0FBSVE7RUFDSSxlQ0RFO0VERUYseUJDZEM7RURlRCxpQkFBQTtFQUNBLDJCQ1pVO1VEWVYsd0JDWlU7RURhViwwQkNaSTtVRFlKLHNCQ1pJO0VEYUosMEJDYkk7VURhSix5QkNiSTtFRGNKLHdCQ2RJO1VEY0osdUJDZEk7QURZaEI7QUFJWTtFQUNJLHdCQUFBO1VBQUEscUJBQUE7QUFGaEI7QUFNUTtFQUNJLGtCQUFBO0VBQ0EsNkJBQUE7RUFDQSxXQ2xDSjtFRG1DSSxTQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsZUNyQkU7RURzQkYsb0JBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxtQkFBQTtBQUpaO0FBTVk7RUFDSSw4QkN0Q0o7QURrQ1o7QUFPWTtFQUNJLGtCQzVCYztBRHVCOUI7QUFRWTtFQUNJLGtCQUFBO0VBQ0Esa0JDM0NHO0VEOENILGFBQUE7RUFDQSxtQkFBQTtFQUNBLHVCQUFBO0FBUmhCO0FBVWdCO0VBQ0ksZUFBQTtBQVJwQjtBQVdnQjtFQUNJLHdCQUFBO0FBVHBCO0FBVW9CO0VBQ0kseUJBQUE7QUFSeEI7QUFZZ0I7RUFDSSx3QkNwRVA7QUQwRGI7QUFjWTtFQUNJLGdCQUFBO0VBQ0EsWUFBQTtBQVpoQjtBQWdCUTtFQUNJLFNBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxnQkFBQTtFQUNBLHFCQUFBO0FBZFo7QUFnQlk7RUFDSSxZQUFBO0FBZGhCO0FBbUJJO0VBQ0ksWUFBQTtFQUNBLDhCQzNGSTtBRDBFWjtBQW1CUTtFQUNJLHNCQUFBO0VBQ0EsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQzNGSTtBRDBFaEI7QUFvQlk7RUFDSSxpQkFBQTtFQUNBLGVDOUZIO0VEK0ZHLHdCQUFBO1VBQUEscUJBQUE7RUFDQSx1QkFBQTtVQUFBLG1CQUFBO0VBQ0EsdUJBQUE7VUFBQSxzQkFBQTtFQUNBLHFCQUFBO1VBQUEsb0JBQUE7RUFDQSxnQkFBQTtFQUNBLFlBQUE7QUFsQmhCO0FBd0JRO0VBQ0kseUJBQUE7RUFDQSxZQUFBO0FBdEJaO0FBd0JZO0VBQ0ksYUFBQTtBQXRCaEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCBcXFwiLi4vLi4vc3R5bGVzL2NvbW1vbi5zY3NzXFxcIjtcXHJcXG5cXHJcXG5kaXYuY29udGFpbmVyIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcblxcclxcbiAgICA+IGRpdi5tZW51IHtcXHJcXG4gICAgICAgIHdpZHRoOiAyODBweDtcXHJcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRncmV5LW1pZDtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcblxcclxcbiAgICAgICAgZGl2LmhlYWRlciB7XFxyXFxuICAgICAgICAgICAgaGVpZ2h0OiAkaGVhZGVyLWhlaWdodDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGgyIHtcXHJcXG4gICAgICAgICAgICBmb250LXNpemU6ICRtZWRpdW0tZm9udDtcXHJcXG4gICAgICAgICAgICBjb2xvcjogJGdyZXktbGlnaHQ7XFxyXFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICAgICAgICAgICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAkZXh0cmEtbGFyZ2UtcGFkZGluZztcXHJcXG4gICAgICAgICAgICBtYXJnaW4tYmxvY2stZW5kOiAkbGFyZ2UtcGFkZGluZztcXHJcXG4gICAgICAgICAgICBtYXJnaW4taW5saW5lLXN0YXJ0OiAkbGFyZ2UtcGFkZGluZztcXHJcXG4gICAgICAgICAgICBtYXJnaW4taW5saW5lLWVuZDogJGxhcmdlLXBhZGRpbmc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgJjpmaXJzdC1vZi10eXBlIHtcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGJ1dHRvbiB7XFxyXFxuICAgICAgICAgICAgcGFkZGluZzogJHN0YW5kYXJkLXBhZGRpbmcgJGxhcmdlLXBhZGRpbmcgO1xcclxcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgICAgICAgIGNvbG9yOiAkd2hpdGU7XFxyXFxuICAgICAgICAgICAgYm9yZGVyOiAwO1xcclxcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcclxcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogJG1lZGl1bS1mb250O1xcclxcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcclxcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcblxcclxcbiAgICAgICAgICAgICY6aG92ZXIge1xcclxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZ3JleS1kYXJrO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAmLm5vSWNvbiB7XFxyXFxuICAgICAgICAgICAgICAgIHBhZGRpbmctbGVmdDogJGxhcmdlLXBhZGRpbmctYW5kLWljb24tc2hpbTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgZGl2Lmljb24ge1xcclxcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogJHN0YW5kYXJkLXBhZGRpbmc7XFxyXFxuICAgICAgICAgICAgICAgIC8vd2lkdGg6ICRzdGFuZGFyZC1pY29uLXNpemU7XFxyXFxuICAgICAgICAgICAgICAgIC8vQGV4dGVuZDogJHN0YW5kYXJkLWljb24tc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgICAgICAgICAgICAgIFxcclxcbiAgICAgICAgICAgICAgICAmOmxhc3QtY2hpbGQge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICYuc3Bpbk9uRXhwYW5kIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxcztcXHJcXG4gICAgICAgICAgICAgICAgICAgICYuZXhwYW5kZWQge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgXFxyXFxuICAgICAgICAgICAgICAgIHN2ZyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAkZ3JleS1saWdodDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBkaXYudGV4dCB7XFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbi10b3A6IC0zcHg7XFxyXFxuICAgICAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBkaXYuZHJvcERvd24ge1xcclxcbiAgICAgICAgICAgIGhlaWdodDogMDtcXHJcXG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBoZWlnaHQgMXM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgJi5leHBhbmRlZCB7XFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXV0bztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgPiBkaXYubWFpbiB7XFxyXFxuICAgICAgICBmbGV4LWdyb3c6IDE7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZ3JleS1kYXJrO1xcclxcblxcclxcbiAgICAgICAgPiBkaXYuaGVhZGVyIHtcXHJcXG4gICAgICAgICAgICBwYWRkaW5nOiAwICRsYXJnZS1wYWRkaW5nIDAgJGxhcmdlLXBhZGRpbmc7IFxcclxcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICAgICAgICAgIGhlaWdodDogJGhlYWRlci1oZWlnaHQ7XFxyXFxuXFxyXFxuXFxyXFxuICAgICAgICAgICAgaDEge1xcclxcbiAgICAgICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDNweDsgLy8gVmlzdWFsIHNoaW1cXHJcXG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAkbGFyZ2UtZm9udDtcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAwO1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW4tYmxvY2stZW5kOiAwO1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW4taW5saW5lLXN0YXJ0OiAwO1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW4taW5saW5lLWVuZDogMDtcXHJcXG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXHJcXG4gICAgICAgICAgICAgICAgZmxleC1ncm93OiAxO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIFxcclxcblxcclxcbiAgICAgICAgPiBkaXYuZ3JpZFN0YWNrQ29udGFpbmVyIHtcXHJcXG4gICAgICAgICAgICBwYWRkaW5nOiAwICRsYXJnZS1wYWRkaW5nICRsYXJnZS1wYWRkaW5nICRsYXJnZS1wYWRkaW5nO1xcclxcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICA+IGRpdi5ncmlkU3RhY2sge1xcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0xMnB4O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cIixcIiRibGFjazogIzAwMDtcXHJcXG4kd2hpdGU6ICNmZmY7XFxyXFxuJHRyYW5zcGFyZW50OiByZ2JhKDI1NSwgMjU1LCAyNTUsIDApO1xcclxcblxcclxcbiRwcmltYXJ5OiAjNTgyYzgzO1xcclxcblxcclxcbiRncmV5LWxpZ2h0OiByZ2IoMTA4LCAxMTQsIDE0Nyk7XFxyXFxuJGdyZXktbWlkOiByZ2IoMjUsIDI4LCAzNik7XFxyXFxuJGdyZXktZGFyazogcmdiKDAsIDAsIDApO1xcclxcblxcclxcbiRleHRyYS1sYXJnZS1wYWRkaW5nOiAzOHB4O1xcclxcbiRsYXJnZS1wYWRkaW5nOiAyNHB4O1xcclxcbiRzdGFuZGFyZC1wYWRkaW5nOiAxMHB4O1xcclxcbiRzbWFsbC1wYWRkaW5nOiAzcHg7XFxyXFxuXFxyXFxuJGhlYWRlci1oZWlnaHQ6IDgycHg7XFxyXFxuXFxyXFxuJGxhcmdlLWZvbnQ6IDIwcHg7XFxyXFxuJG1lZGl1bS1mb250OiAxNXB4O1xcclxcblxcclxcbiRzdGFuZGFyZC1pY29uLXNpemU6IDI0cHg7XFxyXFxuXFxyXFxuJGxhcmdlLXBhZGRpbmctYW5kLWljb24tc2hpbTogY2FsYygkbGFyZ2UtcGFkZGluZyArICRzdGFuZGFyZC1pY29uLXNpemUgKyAkc3RhbmRhcmQtcGFkZGluZyk7XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY29udGFpbmVyXCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX2NvbnRhaW5lcl9fNEVXNE5cIixcblx0XCJtZW51XCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX21lbnVfX0czdG1sXCIsXG5cdFwiaGVhZGVyXCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX2hlYWRlcl9fT0pxNzFcIixcblx0XCJub0ljb25cIjogXCJEYXNoYm9hcmRDb250YWluZXJfbm9JY29uX19lVHRtUlwiLFxuXHRcImljb25cIjogXCJEYXNoYm9hcmRDb250YWluZXJfaWNvbl9fTHNIZXVcIixcblx0XCJzcGluT25FeHBhbmRcIjogXCJEYXNoYm9hcmRDb250YWluZXJfc3Bpbk9uRXhwYW5kX19TaEV3MlwiLFxuXHRcImV4cGFuZGVkXCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX2V4cGFuZGVkX19RYlA5a1wiLFxuXHRcInRleHRcIjogXCJEYXNoYm9hcmRDb250YWluZXJfdGV4dF9fSnNKQ3pcIixcblx0XCJkcm9wRG93blwiOiBcIkRhc2hib2FyZENvbnRhaW5lcl9kcm9wRG93bl9fbDY3T0tcIixcblx0XCJtYWluXCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX21haW5fX1hxQm9WXCIsXG5cdFwiZ3JpZFN0YWNrQ29udGFpbmVyXCI6IFwiRGFzaGJvYXJkQ29udGFpbmVyX2dyaWRTdGFja0NvbnRhaW5lcl9fRTdVX0pcIixcblx0XCJncmlkU3RhY2tcIjogXCJEYXNoYm9hcmRDb250YWluZXJfZ3JpZFN0YWNrX19DTVI0WFwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"div.DashboardMenu_container__aK_uT {\\n  display: flex;\\n  flex-direction: row;\\n  align-items: stretch;\\n  min-height: 100vh;\\n  width: 280px;\\n  background-color: rgb(25, 28, 36);\\n  display: flex;\\n  flex-direction: column;\\n}\\ndiv.DashboardMenu_container__aK_uT div.DashboardMenu_header__tAe0y {\\n  height: 82px;\\n}\\ndiv.DashboardMenu_container__aK_uT h2 {\\n  font-size: 15px;\\n  color: rgb(108, 114, 147);\\n  font-weight: bold;\\n  -webkit-margin-before: 38px;\\n          margin-block-start: 38px;\\n  -webkit-margin-after: 24px;\\n          margin-block-end: 24px;\\n  -webkit-margin-start: 24px;\\n          margin-inline-start: 24px;\\n  -webkit-margin-end: 24px;\\n          margin-inline-end: 24px;\\n}\\ndiv.DashboardMenu_container__aK_uT h2:first-of-type {\\n  -webkit-margin-before: 0;\\n          margin-block-start: 0;\\n}\\ndiv.DashboardMenu_container__aK_uT button {\\n  padding: 10px 24px;\\n  background-color: transparent;\\n  color: #fff;\\n  border: 0;\\n  cursor: pointer;\\n  text-align: left;\\n  font-size: 15px;\\n  font-family: inherit;\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n}\\ndiv.DashboardMenu_container__aK_uT button:hover {\\n  background-color: rgb(0, 0, 0);\\n}\\ndiv.DashboardMenu_container__aK_uT button.DashboardMenu_noIcon__vWDyi {\\n  padding-left: 58px;\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_icon__NaKJB {\\n  border-radius: 50%;\\n  margin-right: 10px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_icon__NaKJB:last-child {\\n  margin-right: 0;\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_icon__NaKJB.DashboardMenu_spinOnExpand__3wIz3 {\\n  transition: transform 1s;\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_icon__NaKJB.DashboardMenu_spinOnExpand__3wIz3.DashboardMenu_expanded__z39NB {\\n  transform: rotate(180deg);\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_icon__NaKJB svg {\\n  fill: rgb(108, 114, 147);\\n}\\ndiv.DashboardMenu_container__aK_uT button div.DashboardMenu_text__XHvnM {\\n  margin-top: -3px;\\n  flex-grow: 1;\\n}\\ndiv.DashboardMenu_container__aK_uT div.DashboardMenu_dropDown__o1vjh {\\n  height: 0;\\n  display: flex;\\n  flex-direction: column;\\n  overflow: hidden;\\n  transition: height 1s;\\n}\\ndiv.DashboardMenu_container__aK_uT div.DashboardMenu_dropDown__o1vjh.DashboardMenu_expanded__z39NB {\\n  height: auto;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/DashboardMenu/DashboardMenu.module.scss\",\"webpack://styles/common.scss\"],\"names\":[],\"mappings\":\"AAEA;EACI,aAAA;EACA,mBAAA;EACA,oBAAA;EACA,iBAAA;EAEA,YAAA;EACA,iCCFO;EDGP,aAAA;EACA,sBAAA;AAFJ;AAII;EACI,YCCQ;ADHhB;AAKI;EACI,eAAA;EACA,yBCbK;EDcL,iBAAA;EACA,2BCXc;UDWd,wBCXc;EDYd,0BCXQ;UDWR,sBCXQ;EDYR,0BCZQ;UDYR,yBCZQ;EDaR,wBCbQ;UDaR,uBCbQ;ADUhB;AAKQ;EACI,wBAAA;UAAA,qBAAA;AAHZ;AAOI;EACI,kBAAA;EACA,6BAAA;EACA,WCjCA;EDkCA,SAAA;EACA,eAAA;EACA,gBAAA;EACA,eCpBM;EDqBN,oBAAA;EACA,aAAA;EACA,mBAAA;EACA,mBAAA;AALR;AAOQ;EACI,8BCrCA;ADgCZ;AAQQ;EACI,kBC3BkB;ADqB9B;AASQ;EACI,kBAAA;EACA,kBC1CO;ED6CP,aAAA;EACA,mBAAA;EACA,uBAAA;AATZ;AAWY;EACI,eAAA;AAThB;AAYY;EACI,wBAAA;AAVhB;AAWgB;EACI,yBAAA;AATpB;AAaY;EACI,wBCnEH;ADwDb;AAeQ;EACI,gBAAA;EACA,YAAA;AAbZ;AAiBI;EACI,SAAA;EACA,aAAA;EACA,sBAAA;EACA,gBAAA;EACA,qBAAA;AAfR;AAiBQ;EACI,YAAA;AAfZ\",\"sourcesContent\":[\"@import \\\"../../styles/common.scss\\\";\\r\\n\\r\\ndiv.container {\\r\\n    display: flex;\\r\\n    flex-direction: row;\\r\\n    align-items: stretch;\\r\\n    min-height: 100vh;\\r\\n\\r\\n    width: 280px;\\r\\n    background-color: $grey-mid;\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n\\r\\n    div.header {\\r\\n        height: $header-height;\\r\\n    }\\r\\n\\r\\n    h2 {\\r\\n        font-size: $medium-font;\\r\\n        color: $grey-light;\\r\\n        font-weight: bold;\\r\\n        margin-block-start: $extra-large-padding;\\r\\n        margin-block-end: $large-padding;\\r\\n        margin-inline-start: $large-padding;\\r\\n        margin-inline-end: $large-padding;\\r\\n\\r\\n        &:first-of-type {\\r\\n            margin-block-start: 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    button {\\r\\n        padding: $standard-padding $large-padding;\\r\\n        background-color: transparent;\\r\\n        color: $white;\\r\\n        border: 0;\\r\\n        cursor: pointer;\\r\\n        text-align: left;\\r\\n        font-size: $medium-font;\\r\\n        font-family: inherit;\\r\\n        display: flex;\\r\\n        flex-direction: row;\\r\\n        align-items: center;\\r\\n\\r\\n        &:hover {\\r\\n            background-color: $grey-dark;\\r\\n        }\\r\\n\\r\\n        &.noIcon {\\r\\n            padding-left: $large-padding-and-icon-shim;\\r\\n        }\\r\\n\\r\\n        div.icon {\\r\\n            border-radius: 50%;\\r\\n            margin-right: $standard-padding;\\r\\n            //width: $standard-icon-size;\\r\\n            //@extend: $standard-icon-size;\\r\\n            display: flex;\\r\\n            align-items: center;\\r\\n            justify-content: center;\\r\\n\\r\\n            &:last-child {\\r\\n                margin-right: 0;\\r\\n            }\\r\\n\\r\\n            &.spinOnExpand {\\r\\n                transition: transform 1s;\\r\\n                &.expanded {\\r\\n                    transform: rotate(180deg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            svg {\\r\\n                fill: $grey-light;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        div.text {\\r\\n            margin-top: -3px;\\r\\n            flex-grow: 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    div.dropDown {\\r\\n        height: 0;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        overflow: hidden;\\r\\n        transition: height 1s;\\r\\n\\r\\n        &.expanded {\\r\\n            height: auto;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"$black: #000;\\r\\n$white: #fff;\\r\\n$transparent: rgba(255, 255, 255, 0);\\r\\n\\r\\n$primary: #582c83;\\r\\n\\r\\n$grey-light: rgb(108, 114, 147);\\r\\n$grey-mid: rgb(25, 28, 36);\\r\\n$grey-dark: rgb(0, 0, 0);\\r\\n\\r\\n$extra-large-padding: 38px;\\r\\n$large-padding: 24px;\\r\\n$standard-padding: 10px;\\r\\n$small-padding: 3px;\\r\\n\\r\\n$header-height: 82px;\\r\\n\\r\\n$large-font: 20px;\\r\\n$medium-font: 15px;\\r\\n\\r\\n$standard-icon-size: 24px;\\r\\n\\r\\n$large-padding-and-icon-shim: calc($large-padding + $standard-icon-size + $standard-padding);\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"DashboardMenu_container__aK_uT\",\n\t\"header\": \"DashboardMenu_header__tAe0y\",\n\t\"noIcon\": \"DashboardMenu_noIcon__vWDyi\",\n\t\"icon\": \"DashboardMenu_icon__NaKJB\",\n\t\"spinOnExpand\": \"DashboardMenu_spinOnExpand__3wIz3\",\n\t\"expanded\": \"DashboardMenu_expanded__z39NB\",\n\t\"text\": \"DashboardMenu_text__XHvnM\",\n\t\"dropDown\": \"DashboardMenu_dropDown__o1vjh\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL2NvbXBvbmVudHMvRGFzaGJvYXJkTWVudS9EYXNoYm9hcmRNZW51Lm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsc0tBQWtGO0FBQzVIO0FBQ0E7QUFDQSw4RUFBOEUsa0JBQWtCLHdCQUF3Qix5QkFBeUIsc0JBQXNCLGlCQUFpQixzQ0FBc0Msa0JBQWtCLDJCQUEyQixHQUFHLHNFQUFzRSxpQkFBaUIsR0FBRyx5Q0FBeUMsb0JBQW9CLDhCQUE4QixzQkFBc0IsZ0NBQWdDLHFDQUFxQywrQkFBK0IsbUNBQW1DLCtCQUErQixzQ0FBc0MsNkJBQTZCLG9DQUFvQyxHQUFHLHVEQUF1RCw2QkFBNkIsa0NBQWtDLEdBQUcsNkNBQTZDLHVCQUF1QixrQ0FBa0MsZ0JBQWdCLGNBQWMsb0JBQW9CLHFCQUFxQixvQkFBb0IseUJBQXlCLGtCQUFrQix3QkFBd0Isd0JBQXdCLEdBQUcsbURBQW1ELG1DQUFtQyxHQUFHLHlFQUF5RSx1QkFBdUIsR0FBRywyRUFBMkUsdUJBQXVCLHVCQUF1QixrQkFBa0Isd0JBQXdCLDRCQUE0QixHQUFHLHNGQUFzRixvQkFBb0IsR0FBRyw2R0FBNkcsNkJBQTZCLEdBQUcsMklBQTJJLDhCQUE4QixHQUFHLCtFQUErRSw2QkFBNkIsR0FBRywyRUFBMkUscUJBQXFCLGlCQUFpQixHQUFHLHdFQUF3RSxjQUFjLGtCQUFrQiwyQkFBMkIscUJBQXFCLDBCQUEwQixHQUFHLHNHQUFzRyxpQkFBaUIsR0FBRyxPQUFPLGtKQUFrSixVQUFVLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxNQUFNLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFlBQVksVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLGFBQWEsT0FBTyxLQUFLLFdBQVcsWUFBWSxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssV0FBVyxVQUFVLEtBQUssTUFBTSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLFVBQVUsOERBQThELHVCQUF1QixzQkFBc0IsNEJBQTRCLDZCQUE2QiwwQkFBMEIseUJBQXlCLG9DQUFvQyxzQkFBc0IsK0JBQStCLHdCQUF3QixtQ0FBbUMsU0FBUyxnQkFBZ0Isb0NBQW9DLCtCQUErQiw4QkFBOEIscURBQXFELDZDQUE2QyxnREFBZ0QsOENBQThDLGlDQUFpQyxzQ0FBc0MsYUFBYSxTQUFTLG9CQUFvQixzREFBc0QsMENBQTBDLDBCQUEwQixzQkFBc0IsNEJBQTRCLDZCQUE2QixvQ0FBb0MsaUNBQWlDLDBCQUEwQixnQ0FBZ0MsZ0NBQWdDLHlCQUF5Qiw2Q0FBNkMsYUFBYSwwQkFBMEIsMkRBQTJELGFBQWEsMEJBQTBCLG1DQUFtQyxnREFBZ0QsNkNBQTZDLCtDQUErQyw4QkFBOEIsb0NBQW9DLHdDQUF3QyxrQ0FBa0Msb0NBQW9DLGlCQUFpQixvQ0FBb0MsNkNBQTZDLGdDQUFnQyxrREFBa0QscUJBQXFCLGlCQUFpQix5QkFBeUIsc0NBQXNDLGlCQUFpQixhQUFhLDBCQUEwQixpQ0FBaUMsNkJBQTZCLGFBQWEsU0FBUywwQkFBMEIsc0JBQXNCLDBCQUEwQixtQ0FBbUMsNkJBQTZCLGtDQUFrQyw0QkFBNEIsNkJBQTZCLGFBQWEsU0FBUyxLQUFLLG9CQUFvQixpQkFBaUIseUNBQXlDLDBCQUEwQix3Q0FBd0MsK0JBQStCLDZCQUE2QixtQ0FBbUMseUJBQXlCLDRCQUE0Qix3QkFBd0IsNkJBQTZCLDBCQUEwQix1QkFBdUIsa0NBQWtDLHFHQUFxRyxtQkFBbUI7QUFDbnBNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUvRGFzaGJvYXJkTWVudS5tb2R1bGUuc2Nzcz8yMGVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJkaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIHdpZHRoOiAyODBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNSwgMjgsIDM2KTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5kaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIGRpdi5EYXNoYm9hcmRNZW51X2hlYWRlcl9fdEFlMHkge1xcbiAgaGVpZ2h0OiA4MnB4O1xcbn1cXG5kaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIGgyIHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIGNvbG9yOiByZ2IoMTA4LCAxMTQsIDE0Nyk7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIC13ZWJraXQtbWFyZ2luLWJlZm9yZTogMzhweDtcXG4gICAgICAgICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAzOHB4O1xcbiAgLXdlYmtpdC1tYXJnaW4tYWZ0ZXI6IDI0cHg7XFxuICAgICAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IDI0cHg7XFxuICAtd2Via2l0LW1hcmdpbi1zdGFydDogMjRweDtcXG4gICAgICAgICAgbWFyZ2luLWlubGluZS1zdGFydDogMjRweDtcXG4gIC13ZWJraXQtbWFyZ2luLWVuZDogMjRweDtcXG4gICAgICAgICAgbWFyZ2luLWlubGluZS1lbmQ6IDI0cHg7XFxufVxcbmRpdi5EYXNoYm9hcmRNZW51X2NvbnRhaW5lcl9fYUtfdVQgaDI6Zmlyc3Qtb2YtdHlwZSB7XFxuICAtd2Via2l0LW1hcmdpbi1iZWZvcmU6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogMDtcXG59XFxuZGl2LkRhc2hib2FyZE1lbnVfY29udGFpbmVyX19hS191VCBidXR0b24ge1xcbiAgcGFkZGluZzogMTBweCAyNHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJvcmRlcjogMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuZGl2LkRhc2hib2FyZE1lbnVfY29udGFpbmVyX19hS191VCBidXR0b246aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAsIDAsIDApO1xcbn1cXG5kaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIGJ1dHRvbi5EYXNoYm9hcmRNZW51X25vSWNvbl9fdldEeWkge1xcbiAgcGFkZGluZy1sZWZ0OiA1OHB4O1xcbn1cXG5kaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIGJ1dHRvbiBkaXYuRGFzaGJvYXJkTWVudV9pY29uX19OYUtKQiB7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5kaXYuRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUIGJ1dHRvbiBkaXYuRGFzaGJvYXJkTWVudV9pY29uX19OYUtKQjpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG59XFxuZGl2LkRhc2hib2FyZE1lbnVfY29udGFpbmVyX19hS191VCBidXR0b24gZGl2LkRhc2hib2FyZE1lbnVfaWNvbl9fTmFLSkIuRGFzaGJvYXJkTWVudV9zcGluT25FeHBhbmRfXzN3SXozIHtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxcztcXG59XFxuZGl2LkRhc2hib2FyZE1lbnVfY29udGFpbmVyX19hS191VCBidXR0b24gZGl2LkRhc2hib2FyZE1lbnVfaWNvbl9fTmFLSkIuRGFzaGJvYXJkTWVudV9zcGluT25FeHBhbmRfXzN3SXozLkRhc2hib2FyZE1lbnVfZXhwYW5kZWRfX3ozOU5CIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxufVxcbmRpdi5EYXNoYm9hcmRNZW51X2NvbnRhaW5lcl9fYUtfdVQgYnV0dG9uIGRpdi5EYXNoYm9hcmRNZW51X2ljb25fX05hS0pCIHN2ZyB7XFxuICBmaWxsOiByZ2IoMTA4LCAxMTQsIDE0Nyk7XFxufVxcbmRpdi5EYXNoYm9hcmRNZW51X2NvbnRhaW5lcl9fYUtfdVQgYnV0dG9uIGRpdi5EYXNoYm9hcmRNZW51X3RleHRfX1hIdm5NIHtcXG4gIG1hcmdpbi10b3A6IC0zcHg7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcbmRpdi5EYXNoYm9hcmRNZW51X2NvbnRhaW5lcl9fYUtfdVQgZGl2LkRhc2hib2FyZE1lbnVfZHJvcERvd25fX28xdmpoIHtcXG4gIGhlaWdodDogMDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHRyYW5zaXRpb246IGhlaWdodCAxcztcXG59XFxuZGl2LkRhc2hib2FyZE1lbnVfY29udGFpbmVyX19hS191VCBkaXYuRGFzaGJvYXJkTWVudV9kcm9wRG93bl9fbzF2amguRGFzaGJvYXJkTWVudV9leHBhbmRlZF9fejM5TkIge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9EYXNoYm9hcmRNZW51L0Rhc2hib2FyZE1lbnUubW9kdWxlLnNjc3NcIixcIndlYnBhY2s6Ly9zdHlsZXMvY29tbW9uLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBRUE7RUFDSSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxvQkFBQTtFQUNBLGlCQUFBO0VBRUEsWUFBQTtFQUNBLGlDQ0ZPO0VER1AsYUFBQTtFQUNBLHNCQUFBO0FBRko7QUFJSTtFQUNJLFlDQ1E7QURIaEI7QUFLSTtFQUNJLGVBQUE7RUFDQSx5QkNiSztFRGNMLGlCQUFBO0VBQ0EsMkJDWGM7VURXZCx3QkNYYztFRFlkLDBCQ1hRO1VEV1Isc0JDWFE7RURZUiwwQkNaUTtVRFlSLHlCQ1pRO0VEYVIsd0JDYlE7VURhUix1QkNiUTtBRFVoQjtBQUtRO0VBQ0ksd0JBQUE7VUFBQSxxQkFBQTtBQUhaO0FBT0k7RUFDSSxrQkFBQTtFQUNBLDZCQUFBO0VBQ0EsV0NqQ0E7RURrQ0EsU0FBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGVDcEJNO0VEcUJOLG9CQUFBO0VBQ0EsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsbUJBQUE7QUFMUjtBQU9RO0VBQ0ksOEJDckNBO0FEZ0NaO0FBUVE7RUFDSSxrQkMzQmtCO0FEcUI5QjtBQVNRO0VBQ0ksa0JBQUE7RUFDQSxrQkMxQ087RUQ2Q1AsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsdUJBQUE7QUFUWjtBQVdZO0VBQ0ksZUFBQTtBQVRoQjtBQVlZO0VBQ0ksd0JBQUE7QUFWaEI7QUFXZ0I7RUFDSSx5QkFBQTtBQVRwQjtBQWFZO0VBQ0ksd0JDbkVIO0FEd0RiO0FBZVE7RUFDSSxnQkFBQTtFQUNBLFlBQUE7QUFiWjtBQWlCSTtFQUNJLFNBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxnQkFBQTtFQUNBLHFCQUFBO0FBZlI7QUFpQlE7RUFDSSxZQUFBO0FBZlpcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCBcXFwiLi4vLi4vc3R5bGVzL2NvbW1vbi5zY3NzXFxcIjtcXHJcXG5cXHJcXG5kaXYuY29udGFpbmVyIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcblxcclxcbiAgICB3aWR0aDogMjgwcHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRncmV5LW1pZDtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG5cXHJcXG4gICAgZGl2LmhlYWRlciB7XFxyXFxuICAgICAgICBoZWlnaHQ6ICRoZWFkZXItaGVpZ2h0O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGgyIHtcXHJcXG4gICAgICAgIGZvbnQtc2l6ZTogJG1lZGl1bS1mb250O1xcclxcbiAgICAgICAgY29sb3I6ICRncmV5LWxpZ2h0O1xcclxcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICAgICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6ICRleHRyYS1sYXJnZS1wYWRkaW5nO1xcclxcbiAgICAgICAgbWFyZ2luLWJsb2NrLWVuZDogJGxhcmdlLXBhZGRpbmc7XFxyXFxuICAgICAgICBtYXJnaW4taW5saW5lLXN0YXJ0OiAkbGFyZ2UtcGFkZGluZztcXHJcXG4gICAgICAgIG1hcmdpbi1pbmxpbmUtZW5kOiAkbGFyZ2UtcGFkZGluZztcXHJcXG5cXHJcXG4gICAgICAgICY6Zmlyc3Qtb2YtdHlwZSB7XFxyXFxuICAgICAgICAgICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAwO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGJ1dHRvbiB7XFxyXFxuICAgICAgICBwYWRkaW5nOiAkc3RhbmRhcmQtcGFkZGluZyAkbGFyZ2UtcGFkZGluZztcXHJcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgICAgY29sb3I6ICR3aGl0ZTtcXHJcXG4gICAgICAgIGJvcmRlcjogMDtcXHJcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICAgICAgICBmb250LXNpemU6ICRtZWRpdW0tZm9udDtcXHJcXG4gICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcclxcbiAgICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcblxcclxcbiAgICAgICAgJjpob3ZlciB7XFxyXFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyZXktZGFyaztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICYubm9JY29uIHtcXHJcXG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRsYXJnZS1wYWRkaW5nLWFuZC1pY29uLXNoaW07XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBkaXYuaWNvbiB7XFxyXFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogJHN0YW5kYXJkLXBhZGRpbmc7XFxyXFxuICAgICAgICAgICAgLy93aWR0aDogJHN0YW5kYXJkLWljb24tc2l6ZTtcXHJcXG4gICAgICAgICAgICAvL0BleHRlbmQ6ICRzdGFuZGFyZC1pY29uLXNpemU7XFxyXFxuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcblxcclxcbiAgICAgICAgICAgICY6bGFzdC1jaGlsZCB7XFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgJi5zcGluT25FeHBhbmQge1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMXM7XFxyXFxuICAgICAgICAgICAgICAgICYuZXhwYW5kZWQge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBzdmcge1xcclxcbiAgICAgICAgICAgICAgICBmaWxsOiAkZ3JleS1saWdodDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBkaXYudGV4dCB7XFxyXFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogLTNweDtcXHJcXG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZGl2LmRyb3BEb3duIHtcXHJcXG4gICAgICAgIGhlaWdodDogMDtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgICAgIHRyYW5zaXRpb246IGhlaWdodCAxcztcXHJcXG5cXHJcXG4gICAgICAgICYuZXhwYW5kZWQge1xcclxcbiAgICAgICAgICAgIGhlaWdodDogYXV0bztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cIixcIiRibGFjazogIzAwMDtcXHJcXG4kd2hpdGU6ICNmZmY7XFxyXFxuJHRyYW5zcGFyZW50OiByZ2JhKDI1NSwgMjU1LCAyNTUsIDApO1xcclxcblxcclxcbiRwcmltYXJ5OiAjNTgyYzgzO1xcclxcblxcclxcbiRncmV5LWxpZ2h0OiByZ2IoMTA4LCAxMTQsIDE0Nyk7XFxyXFxuJGdyZXktbWlkOiByZ2IoMjUsIDI4LCAzNik7XFxyXFxuJGdyZXktZGFyazogcmdiKDAsIDAsIDApO1xcclxcblxcclxcbiRleHRyYS1sYXJnZS1wYWRkaW5nOiAzOHB4O1xcclxcbiRsYXJnZS1wYWRkaW5nOiAyNHB4O1xcclxcbiRzdGFuZGFyZC1wYWRkaW5nOiAxMHB4O1xcclxcbiRzbWFsbC1wYWRkaW5nOiAzcHg7XFxyXFxuXFxyXFxuJGhlYWRlci1oZWlnaHQ6IDgycHg7XFxyXFxuXFxyXFxuJGxhcmdlLWZvbnQ6IDIwcHg7XFxyXFxuJG1lZGl1bS1mb250OiAxNXB4O1xcclxcblxcclxcbiRzdGFuZGFyZC1pY29uLXNpemU6IDI0cHg7XFxyXFxuXFxyXFxuJGxhcmdlLXBhZGRpbmctYW5kLWljb24tc2hpbTogY2FsYygkbGFyZ2UtcGFkZGluZyArICRzdGFuZGFyZC1pY29uLXNpemUgKyAkc3RhbmRhcmQtcGFkZGluZyk7XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY29udGFpbmVyXCI6IFwiRGFzaGJvYXJkTWVudV9jb250YWluZXJfX2FLX3VUXCIsXG5cdFwiaGVhZGVyXCI6IFwiRGFzaGJvYXJkTWVudV9oZWFkZXJfX3RBZTB5XCIsXG5cdFwibm9JY29uXCI6IFwiRGFzaGJvYXJkTWVudV9ub0ljb25fX3ZXRHlpXCIsXG5cdFwiaWNvblwiOiBcIkRhc2hib2FyZE1lbnVfaWNvbl9fTmFLSkJcIixcblx0XCJzcGluT25FeHBhbmRcIjogXCJEYXNoYm9hcmRNZW51X3NwaW5PbkV4cGFuZF9fM3dJejNcIixcblx0XCJleHBhbmRlZFwiOiBcIkRhc2hib2FyZE1lbnVfZXhwYW5kZWRfX3ozOU5CXCIsXG5cdFwidGV4dFwiOiBcIkRhc2hib2FyZE1lbnVfdGV4dF9fWEh2bk1cIixcblx0XCJkcm9wRG93blwiOiBcIkRhc2hib2FyZE1lbnVfZHJvcERvd25fX28xdmpoXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"div.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi {\\n  background-color: rgb(25, 28, 36);\\n  border-radius: 6px;\\n  display: flex;\\n  flex-direction: column;\\n}\\ndiv.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi div.GridStackTile_header__LiSNF {\\n  border-bottom: 1px solid rgb(0, 0, 0);\\n  padding: 0.75rem 1rem;\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n  cursor: move;\\n}\\ndiv.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi div.GridStackTile_header__LiSNF div.GridStackTile_title__J5mfc {\\n  flex-grow: 1;\\n}\\ndiv.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi div.GridStackTile_header__LiSNF button {\\n  padding: 0;\\n  height: 24px;\\n  width: 24px;\\n  z-index: inherit;\\n  background-color: transparent;\\n  border: 0;\\n  cursor: pointer;\\n  border-radius: 12px;\\n}\\ndiv.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi div.GridStackTile_header__LiSNF button:hover {\\n  background-color: rgb(0, 0, 0);\\n}\\ndiv.GridStackTile_container__z5Q9L div.GridStackTile_content__S72Zi div.GridStackTile_header__LiSNF button svg {\\n  fill: rgb(108, 114, 147);\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://components/GridStackTile/GridStackTile.module.scss\",\"webpack://styles/common.scss\"],\"names\":[],\"mappings\":\"AAGI;EACI,iCCGG;EDFH,kBAAA;EACA,aAAA;EACA,sBAAA;AAFR;AAIQ;EACI,qCAAA;EACA,qBAAA;EACA,aAAA;EACA,mBAAA;EACA,mBAAA;EACA,YAAA;AAFZ;AAIY;EACI,YAAA;AAFhB;AAKY;EACI,UAAA;EACA,YAAA;EACA,WAAA;EACA,gBAAA;EACA,6BAAA;EACA,SAAA;EACA,eAAA;EACA,mBAAA;AAHhB;AAKgB;EACI,8BCxBR;ADqBZ;AAMgB;EACI,wBC9BP;AD0Bb\",\"sourcesContent\":[\"@import \\\"../../styles/common.scss\\\";\\r\\n\\r\\ndiv.container {\\r\\n    div.content {\\r\\n        background-color: $grey-mid;\\r\\n        border-radius: 6px;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        \\r\\n        div.header {\\r\\n            border-bottom: 1px solid $grey-dark;\\r\\n            padding: 0.75rem 1rem;\\r\\n            display: flex;\\r\\n            flex-direction: row;\\r\\n            align-items: center;\\r\\n            cursor: move;\\r\\n\\r\\n            div.title {\\r\\n                flex-grow: 1;\\r\\n            }\\r\\n\\r\\n            button {\\r\\n                padding: 0 ;\\r\\n                height: 24px;\\r\\n                width: 24px;\\r\\n                z-index: inherit;\\r\\n                background-color: transparent;\\r\\n                border: 0;\\r\\n                cursor: pointer;\\r\\n                border-radius: 12px;\\r\\n\\r\\n                &:hover  {\\r\\n                    background-color: $grey-dark;\\r\\n                }\\r\\n    \\r\\n                svg {\\r\\n                    fill: $grey-light;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"$black: #000;\\r\\n$white: #fff;\\r\\n$transparent: rgba(255, 255, 255, 0);\\r\\n\\r\\n$primary: #582c83;\\r\\n\\r\\n$grey-light: rgb(108, 114, 147);\\r\\n$grey-mid: rgb(25, 28, 36);\\r\\n$grey-dark: rgb(0, 0, 0);\\r\\n\\r\\n$extra-large-padding: 38px;\\r\\n$large-padding: 24px;\\r\\n$standard-padding: 10px;\\r\\n$small-padding: 3px;\\r\\n\\r\\n$header-height: 82px;\\r\\n\\r\\n$large-font: 20px;\\r\\n$medium-font: 15px;\\r\\n\\r\\n$standard-icon-size: 24px;\\r\\n\\r\\n$large-padding-and-icon-shim: calc($large-padding + $standard-icon-size + $standard-padding);\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"GridStackTile_container__z5Q9L\",\n\t\"content\": \"GridStackTile_content__S72Zi\",\n\t\"header\": \"GridStackTile_header__LiSNF\",\n\t\"title\": \"GridStackTile_title__J5mfc\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL2NvbXBvbmVudHMvR3JpZFN0YWNrVGlsZS9HcmlkU3RhY2tUaWxlLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsc0tBQWtGO0FBQzVIO0FBQ0E7QUFDQSwrR0FBK0csc0NBQXNDLHVCQUF1QixrQkFBa0IsMkJBQTJCLEdBQUcsdUdBQXVHLDBDQUEwQywwQkFBMEIsa0JBQWtCLHdCQUF3Qix3QkFBd0IsaUJBQWlCLEdBQUcsc0lBQXNJLGlCQUFpQixHQUFHLDhHQUE4RyxlQUFlLGlCQUFpQixnQkFBZ0IscUJBQXFCLGtDQUFrQyxjQUFjLG9CQUFvQix3QkFBd0IsR0FBRyxvSEFBb0gsbUNBQW1DLEdBQUcsa0hBQWtILDZCQUE2QixHQUFHLE9BQU8sa0pBQWtKLFdBQVcsV0FBVyxVQUFVLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxVQUFVLEtBQUssS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxVQUFVLFdBQVcsTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLFlBQVksK0RBQStELHVCQUF1QixxQkFBcUIsd0NBQXdDLCtCQUErQiwwQkFBMEIsbUNBQW1DLG9DQUFvQyxvREFBb0Qsc0NBQXNDLDhCQUE4QixvQ0FBb0Msb0NBQW9DLDZCQUE2QiwrQkFBK0IsaUNBQWlDLGlCQUFpQiw0QkFBNEIsZ0NBQWdDLGlDQUFpQyxnQ0FBZ0MscUNBQXFDLGtEQUFrRCw4QkFBOEIsb0NBQW9DLHdDQUF3QyxrQ0FBa0MscURBQXFELHFCQUFxQixpQ0FBaUMsMENBQTBDLHFCQUFxQixpQkFBaUIsYUFBYSxTQUFTLEtBQUssb0JBQW9CLGlCQUFpQix5Q0FBeUMsMEJBQTBCLHdDQUF3QywrQkFBK0IsNkJBQTZCLG1DQUFtQyx5QkFBeUIsNEJBQTRCLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLHVCQUF1QixrQ0FBa0MscUdBQXFHLG1CQUFtQjtBQUNod0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0dyaWRTdGFja1RpbGUvR3JpZFN0YWNrVGlsZS5tb2R1bGUuc2Nzcz9hYzM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJkaXYuR3JpZFN0YWNrVGlsZV9jb250YWluZXJfX3o1UTlMIGRpdi5HcmlkU3RhY2tUaWxlX2NvbnRlbnRfX1M3MlppIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNSwgMjgsIDM2KTtcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5kaXYuR3JpZFN0YWNrVGlsZV9jb250YWluZXJfX3o1UTlMIGRpdi5HcmlkU3RhY2tUaWxlX2NvbnRlbnRfX1M3MlppIGRpdi5HcmlkU3RhY2tUaWxlX2hlYWRlcl9fTGlTTkYge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYigwLCAwLCAwKTtcXG4gIHBhZGRpbmc6IDAuNzVyZW0gMXJlbTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGN1cnNvcjogbW92ZTtcXG59XFxuZGl2LkdyaWRTdGFja1RpbGVfY29udGFpbmVyX196NVE5TCBkaXYuR3JpZFN0YWNrVGlsZV9jb250ZW50X19TNzJaaSBkaXYuR3JpZFN0YWNrVGlsZV9oZWFkZXJfX0xpU05GIGRpdi5HcmlkU3RhY2tUaWxlX3RpdGxlX19KNW1mYyB7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcbmRpdi5HcmlkU3RhY2tUaWxlX2NvbnRhaW5lcl9fejVROUwgZGl2LkdyaWRTdGFja1RpbGVfY29udGVudF9fUzcyWmkgZGl2LkdyaWRTdGFja1RpbGVfaGVhZGVyX19MaVNORiBidXR0b24ge1xcbiAgcGFkZGluZzogMDtcXG4gIGhlaWdodDogMjRweDtcXG4gIHdpZHRoOiAyNHB4O1xcbiAgei1pbmRleDogaW5oZXJpdDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiAwO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcXG59XFxuZGl2LkdyaWRTdGFja1RpbGVfY29udGFpbmVyX196NVE5TCBkaXYuR3JpZFN0YWNrVGlsZV9jb250ZW50X19TNzJaaSBkaXYuR3JpZFN0YWNrVGlsZV9oZWFkZXJfX0xpU05GIGJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMCwgMCk7XFxufVxcbmRpdi5HcmlkU3RhY2tUaWxlX2NvbnRhaW5lcl9fejVROUwgZGl2LkdyaWRTdGFja1RpbGVfY29udGVudF9fUzcyWmkgZGl2LkdyaWRTdGFja1RpbGVfaGVhZGVyX19MaVNORiBidXR0b24gc3ZnIHtcXG4gIGZpbGw6IHJnYigxMDgsIDExNCwgMTQ3KTtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvR3JpZFN0YWNrVGlsZS9HcmlkU3RhY2tUaWxlLm1vZHVsZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vc3R5bGVzL2NvbW1vbi5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUdJO0VBQ0ksaUNDR0c7RURGSCxrQkFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtBQUZSO0FBSVE7RUFDSSxxQ0FBQTtFQUNBLHFCQUFBO0VBQ0EsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQUFBO0FBRlo7QUFJWTtFQUNJLFlBQUE7QUFGaEI7QUFLWTtFQUNJLFVBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtFQUNBLGdCQUFBO0VBQ0EsNkJBQUE7RUFDQSxTQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0FBSGhCO0FBS2dCO0VBQ0ksOEJDeEJSO0FEcUJaO0FBTWdCO0VBQ0ksd0JDOUJQO0FEMEJiXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBpbXBvcnQgXFxcIi4uLy4uL3N0eWxlcy9jb21tb24uc2Nzc1xcXCI7XFxyXFxuXFxyXFxuZGl2LmNvbnRhaW5lciB7XFxyXFxuICAgIGRpdi5jb250ZW50IHtcXHJcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRncmV5LW1pZDtcXHJcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICAgICAgXFxyXFxuICAgICAgICBkaXYuaGVhZGVyIHtcXHJcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgJGdyZXktZGFyaztcXHJcXG4gICAgICAgICAgICBwYWRkaW5nOiAwLjc1cmVtIDFyZW07XFxyXFxuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgICAgICAgICAgY3Vyc29yOiBtb3ZlO1xcclxcblxcclxcbiAgICAgICAgICAgIGRpdi50aXRsZSB7XFxyXFxuICAgICAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgYnV0dG9uIHtcXHJcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCA7XFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjRweDtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI0cHg7XFxyXFxuICAgICAgICAgICAgICAgIHotaW5kZXg6IGluaGVyaXQ7XFxyXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgICAgICAgICAgICBib3JkZXI6IDA7XFxyXFxuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgJjpob3ZlciAge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyZXktZGFyaztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICBcXHJcXG4gICAgICAgICAgICAgICAgc3ZnIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICRncmV5LWxpZ2h0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufVxcclxcblwiLFwiJGJsYWNrOiAjMDAwO1xcclxcbiR3aGl0ZTogI2ZmZjtcXHJcXG4kdHJhbnNwYXJlbnQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMCk7XFxyXFxuXFxyXFxuJHByaW1hcnk6ICM1ODJjODM7XFxyXFxuXFxyXFxuJGdyZXktbGlnaHQ6IHJnYigxMDgsIDExNCwgMTQ3KTtcXHJcXG4kZ3JleS1taWQ6IHJnYigyNSwgMjgsIDM2KTtcXHJcXG4kZ3JleS1kYXJrOiByZ2IoMCwgMCwgMCk7XFxyXFxuXFxyXFxuJGV4dHJhLWxhcmdlLXBhZGRpbmc6IDM4cHg7XFxyXFxuJGxhcmdlLXBhZGRpbmc6IDI0cHg7XFxyXFxuJHN0YW5kYXJkLXBhZGRpbmc6IDEwcHg7XFxyXFxuJHNtYWxsLXBhZGRpbmc6IDNweDtcXHJcXG5cXHJcXG4kaGVhZGVyLWhlaWdodDogODJweDtcXHJcXG5cXHJcXG4kbGFyZ2UtZm9udDogMjBweDtcXHJcXG4kbWVkaXVtLWZvbnQ6IDE1cHg7XFxyXFxuXFxyXFxuJHN0YW5kYXJkLWljb24tc2l6ZTogMjRweDtcXHJcXG5cXHJcXG4kbGFyZ2UtcGFkZGluZy1hbmQtaWNvbi1zaGltOiBjYWxjKCRsYXJnZS1wYWRkaW5nICsgJHN0YW5kYXJkLWljb24tc2l6ZSArICRzdGFuZGFyZC1wYWRkaW5nKTtcIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjb250YWluZXJcIjogXCJHcmlkU3RhY2tUaWxlX2NvbnRhaW5lcl9fejVROUxcIixcblx0XCJjb250ZW50XCI6IFwiR3JpZFN0YWNrVGlsZV9jb250ZW50X19TNzJaaVwiLFxuXHRcImhlYWRlclwiOiBcIkdyaWRTdGFja1RpbGVfaGVhZGVyX19MaVNORlwiLFxuXHRcInRpdGxlXCI6IFwiR3JpZFN0YWNrVGlsZV90aXRsZV9fSjVtZmNcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CCode%5CPaul%5CD3Examples%5Clucidity-d3js%5Cpages%5Cdashboard.js&page=%2Fdashboard!":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CCode%5CPaul%5CD3Examples%5Clucidity-d3js%5Cpages%5Cdashboard.js&page=%2Fdashboard! ***!
  \*********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/dashboard\",\n      function () {\n        return __webpack_require__(/*! ./pages/dashboard.js */ \"./pages/dashboard.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/dashboard\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDQ29kZSU1Q1BhdWwlNUNEM0V4YW1wbGVzJTVDbHVjaWRpdHktZDNqcyU1Q3BhZ2VzJTVDZGFzaGJvYXJkLmpzJnBhZ2U9JTJGZGFzaGJvYXJkISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtEQUFzQjtBQUM3QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MzViMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL2Rhc2hib2FyZFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvZGFzaGJvYXJkLmpzXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9kYXNoYm9hcmRcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CCode%5CPaul%5CD3Examples%5Clucidity-d3js%5Cpages%5Cdashboard.js&page=%2Fdashboard!\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.css":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.css ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./gridstack.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./gridstack.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./gridstack.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[11].use[2]!./node_modules/gridstack/dist/gridstack.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLmNzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsME1BQThGO0FBQ2hILDBCQUEwQixtQkFBTyxDQUFDLGdmQUErTjs7QUFFalE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLGdmQUErTjtBQUNyTztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGdmQUErTjs7QUFFelA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2dyaWRzdGFjay5jc3M/YWIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzExXS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTFdLnVzZVsyXSEuL2dyaWRzdGFjay5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTFdLnVzZVsxXSEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxMV0udXNlWzJdIS4vZ3JpZHN0YWNrLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxMV0udXNlWzFdIS4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzExXS51c2VbMl0hLi9ncmlkc3RhY2suY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/gridstack.css\n"));

/***/ }),

/***/ "./components/DashboardContainer/DashboardContainer.module.scss":
/*!**********************************************************************!*\
  !*** ./components/DashboardContainer/DashboardContainer.module.scss ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardContainer.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardContainer.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardContainer.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardContainer/DashboardContainer.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Rhc2hib2FyZENvbnRhaW5lci9EYXNoYm9hcmRDb250YWluZXIubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLHVOQUEyRztBQUM3SCwwQkFBMEIsbUJBQU8sQ0FBQyxzOEJBQTBkOztBQUU1Zjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sczhCQUEwZDtBQUNoZTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHM4QkFBMGQ7O0FBRXBmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvRGFzaGJvYXJkQ29udGFpbmVyL0Rhc2hib2FyZENvbnRhaW5lci5tb2R1bGUuc2Nzcz9jYjM0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL0Rhc2hib2FyZENvbnRhaW5lci5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbNF0hLi9EYXNoYm9hcmRDb250YWluZXIubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbM10hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzRdIS4vRGFzaGJvYXJkQ29udGFpbmVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/DashboardContainer/DashboardContainer.module.scss\n"));

/***/ }),

/***/ "./components/DashboardMenu/DashboardMenu.module.scss":
/*!************************************************************!*\
  !*** ./components/DashboardMenu/DashboardMenu.module.scss ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardMenu.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardMenu.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./DashboardMenu.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/DashboardMenu/DashboardMenu.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUvRGFzaGJvYXJkTWVudS5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLHU3QkFBcWQ7O0FBRXZmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1N0JBQXFkO0FBQzNkO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdTdCQUFxZDs7QUFFL2U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9EYXNoYm9hcmRNZW51L0Rhc2hib2FyZE1lbnUubW9kdWxlLnNjc3M/YzhiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbNF0hLi9EYXNoYm9hcmRNZW51Lm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL0Rhc2hib2FyZE1lbnUubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbM10hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzRdIS4vRGFzaGJvYXJkTWVudS5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/DashboardMenu/DashboardMenu.module.scss\n"));

/***/ }),

/***/ "./components/GridStackTile/GridStackTile.module.scss":
/*!************************************************************!*\
  !*** ./components/GridStackTile/GridStackTile.module.scss ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./GridStackTile.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./GridStackTile.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./GridStackTile.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[9].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[7].oneOf[9].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[7].oneOf[9].use[4]!./components/GridStackTile/GridStackTile.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dyaWRTdGFja1RpbGUvR3JpZFN0YWNrVGlsZS5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLHU3QkFBcWQ7O0FBRXZmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1N0JBQXFkO0FBQzNkO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdTdCQUFxZDs7QUFFL2U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HcmlkU3RhY2tUaWxlL0dyaWRTdGFja1RpbGUubW9kdWxlLnNjc3M/OTc3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVszXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbNF0hLi9HcmlkU3RhY2tUaWxlLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVs0XSEuL0dyaWRTdGFja1RpbGUubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzldLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls5XS51c2VbM10hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbOV0udXNlWzRdIS4vR3JpZFN0YWNrVGlsZS5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/GridStackTile/GridStackTile.module.scss\n"));

/***/ }),

/***/ "./components/DashboardContainer/DashboardContainer.js":
/*!*************************************************************!*\
  !*** ./components/DashboardContainer/DashboardContainer.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _GridStackTile_GridStackTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GridStackTile/GridStackTile.js */ \"./components/GridStackTile/GridStackTile.js\");\n/* harmony import */ var gridstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gridstack */ \"./node_modules/gridstack/dist/gridstack.js\");\n/* harmony import */ var gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gridstack/dist/gridstack.css */ \"./node_modules/gridstack/dist/gridstack.css\");\n/* harmony import */ var gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DashboardContainer.module.scss */ \"./components/DashboardContainer/DashboardContainer.module.scss\");\n/* harmony import */ var _DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _DashboardMenu_DashboardMenu_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DashboardMenu/DashboardMenu.js */ \"./components/DashboardMenu/DashboardMenu.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst DashboardContainer = (props)=>{\n    _s();\n    const [periodExpanded, setPeriodExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const initialTileData = [\n        {\n            key: 0,\n            width: 4,\n            height: 3,\n            //x: 0,\n            //y: 0,\n            content: \"Some Data Metric\"\n        },\n        {\n            key: 1,\n            width: 4,\n            height: 3,\n            content: \"Another Data Metric\"\n        },\n        {\n            key: 2,\n            width: 4,\n            height: 3,\n            content: \"Third Data Metric\"\n        },\n        {\n            key: 3,\n            width: 4,\n            height: 3,\n            content: \"Fourth Data Metric\"\n        },\n        {\n            key: 4,\n            width: 4,\n            height: 3,\n            content: \"Fifth  Data Metric\"\n        }\n    ];\n    const timePeriodOptions = [\n        {\n            text: \"2023\"\n        },\n        {\n            text: \"2022\"\n        },\n        {\n            text: \"2021\"\n        },\n        {\n            text: \"2020\"\n        }\n    ];\n    const [tileData, setTileData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialTileData);\n    let grid;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        grid = gridstack__WEBPACK_IMPORTED_MODULE_3__.GridStack.init();\n        grid.margin(\"12px\");\n    });\n    const mounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const lastKeyAdded = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mounted.current) {\n            // do componentDidMount logic\n            mounted.current = true;\n        } else {\n            // do componentDidUpdate logic\n            if (lastKeyAdded.current) {\n                grid.makeWidget(\"#\".concat(lastKeyAdded.current));\n                lastKeyAdded.current = null;\n            }\n        }\n    });\n    const handleAddTile = ()=>{\n        const newTileData = [\n            ...tileData\n        ];\n        var existingKeys = newTileData.map((element)=>element.key);\n        var nextKey = Math.max(...existingKeys) + 1;\n        newTileData.push({\n            key: nextKey,\n            width: 1,\n            height: 1,\n            content: \"tile \".concat(nextKey)\n        });\n        setTileData(newTileData);\n        lastKeyAdded.current = nextKey;\n    };\n    const handleTileClose = (ref, key)=>{\n        grid.removeWidget(ref.current, false);\n        const newTileData = [\n            ...tileData\n        ];\n        var currentTile = newTileData.find((element)=>element.key == key);\n        var tileIndex = newTileData.indexOf(currentTile);\n        newTileData.splice(tileIndex, 1);\n        setTileData(newTileData);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DashboardMenu_DashboardMenu_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                handleAddTile: handleAddTile\n            }, void 0, false, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                lineNumber: 103,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default().main),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default().header),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            children: \"Analytics Dashboard\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                            lineNumber: 107,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                        lineNumber: 106,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default().gridStackContainer),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"grid-stack \".concat((_DashboardContainer_module_scss__WEBPACK_IMPORTED_MODULE_6___default().gridStack)),\n                            children: tileData.map((tileDatum, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_GridStackTile_GridStackTile_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    title: tileDatum.content,\n                                    gsWidth: tileDatum.width,\n                                    gsHeight: tileDatum.height,\n                                    gsX: tileDatum.x,\n                                    gsY: tileDatum.y,\n                                    gsId: tileDatum.key,\n                                    handleClose: (ref)=>handleTileClose(ref, tileDatum.key)\n                                }, tileDatum.key, false, {\n                                    fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                                    lineNumber: 112,\n                                    columnNumber: 29\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                            lineNumber: 110,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                        lineNumber: 109,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n                lineNumber: 105,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardContainer\\\\DashboardContainer.js\",\n        lineNumber: 102,\n        columnNumber: 9\n    }, undefined);\n};\n_s(DashboardContainer, \"2IfJsg/l2F+JFa8ub6s3MKhNZEk=\");\n_c = DashboardContainer;\n/* harmony default export */ __webpack_exports__[\"default\"] = (DashboardContainer);\nvar _c;\n$RefreshReg$(_c, \"DashboardContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Rhc2hib2FyZENvbnRhaW5lci9EYXNoYm9hcmRDb250YWluZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0U7QUFDUjtBQUN4QjtBQUNBO0FBQ2dCO0FBQ1E7QUFFOUQsTUFBTVMscUJBQXFCLENBQUNDOztJQUN4QixNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU1XLGtCQUFrQjtRQUNwQjtZQUNJQyxLQUFLO1lBQ0xDLE9BQU87WUFDUEMsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1BDLFNBQVM7UUFDYjtRQUNBO1lBQ0lILEtBQUs7WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7UUFDYjtRQUNBO1lBQ0lILEtBQUs7WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7UUFDYjtRQUNBO1lBQ0lILEtBQUs7WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7UUFDYjtRQUNBO1lBQ0lILEtBQUs7WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7UUFDYjtLQUNIO0lBRUQsTUFBTUMsb0JBQW9CO1FBQ3RCO1lBQUVDLE1BQU07UUFBTztRQUNmO1lBQUVBLE1BQU07UUFBTztRQUNmO1lBQUVBLE1BQU07UUFBTztRQUNmO1lBQUVBLE1BQU07UUFBTztLQUNsQjtJQUVELE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHbkIsK0NBQVFBLENBQUNXO0lBQ3pDLElBQUlTO0lBRUpyQixnREFBU0EsQ0FBQztRQUNOcUIsT0FBT2hCLGdEQUFTQSxDQUFDaUIsSUFBSTtRQUNyQkQsS0FBS0UsTUFBTSxDQUFDO0lBQ2hCO0lBRUEsTUFBTUMsVUFBVXRCLDZDQUFNQTtJQUN0QixNQUFNdUIsZUFBZXZCLDZDQUFNQSxDQUFDO0lBRTVCRixnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ3dCLFFBQVFFLE9BQU8sRUFBRTtZQUNsQiw2QkFBNkI7WUFDN0JGLFFBQVFFLE9BQU8sR0FBRztRQUN0QixPQUFPO1lBQ0gsOEJBQThCO1lBQzlCLElBQUlELGFBQWFDLE9BQU8sRUFBRTtnQkFDdEJMLEtBQUtNLFVBQVUsQ0FBQyxJQUF5QixPQUFyQkYsYUFBYUMsT0FBTztnQkFDeENELGFBQWFDLE9BQU8sR0FBRztZQUMzQjtRQUNKO0lBQ0o7SUFFQSxNQUFNRSxnQkFBZ0I7UUFDbEIsTUFBTUMsY0FBYztlQUFJVjtTQUFTO1FBQ2pDLElBQUlXLGVBQWVELFlBQVlFLEdBQUcsQ0FBQ0MsQ0FBQUEsVUFBV0EsUUFBUW5CLEdBQUc7UUFDekQsSUFBSW9CLFVBQVVDLEtBQUtDLEdBQUcsSUFBSUwsZ0JBQWdCO1FBRTFDRCxZQUFZTyxJQUFJLENBQUM7WUFDYnZCLEtBQUtvQjtZQUNMbkIsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVMsUUFBZ0IsT0FBUmlCO1FBQ3JCO1FBRUFiLFlBQVlTO1FBQ1pKLGFBQWFDLE9BQU8sR0FBR087SUFDM0I7SUFFQSxNQUFNSSxrQkFBa0IsQ0FBQ0MsS0FBS3pCO1FBQzFCUSxLQUFLa0IsWUFBWSxDQUFDRCxJQUFJWixPQUFPLEVBQUU7UUFDL0IsTUFBTUcsY0FBYztlQUFJVjtTQUFTO1FBQ2pDLElBQUlxQixjQUFjWCxZQUFZWSxJQUFJLENBQUMsQ0FBQ1QsVUFBWUEsUUFBUW5CLEdBQUcsSUFBSUE7UUFDL0QsSUFBSTZCLFlBQVliLFlBQVljLE9BQU8sQ0FBQ0g7UUFDcENYLFlBQVllLE1BQU0sQ0FBQ0YsV0FBVztRQUM5QnRCLFlBQVlTO0lBQ2hCO0lBRUEscUJBQ0ksOERBQUNnQjtRQUFJQyxXQUFXeEMsa0ZBQWdCOzswQkFDNUIsOERBQUNDLHVFQUFhQTtnQkFBQ3FCLGVBQWVBOzs7Ozs7MEJBRTlCLDhEQUFDaUI7Z0JBQUlDLFdBQVd4Qyw2RUFBVzs7a0NBQ3ZCLDhEQUFDdUM7d0JBQUlDLFdBQVd4QywrRUFBYTtrQ0FDekIsNEVBQUM0QztzQ0FBRzs7Ozs7Ozs7Ozs7a0NBRVIsOERBQUNMO3dCQUFJQyxXQUFXeEMsMkZBQXlCO2tDQUNyQyw0RUFBQ3VDOzRCQUFJQyxXQUFXLGNBQStCLE9BQWpCeEMsa0ZBQWdCO3NDQUN6Q2EsU0FBU1ksR0FBRyxDQUFDLENBQUNzQixXQUFXQyxzQkFDdEIsOERBQUNsRCx1RUFBYUE7b0NBQ1ZtRCxPQUFPRixVQUFVckMsT0FBTztvQ0FDeEJ3QyxTQUFTSCxVQUFVdkMsS0FBSztvQ0FDeEIyQyxVQUFVSixVQUFVdEMsTUFBTTtvQ0FDMUIyQyxLQUFLTCxVQUFVTSxDQUFDO29DQUNoQkMsS0FBS1AsVUFBVVEsQ0FBQztvQ0FFaEJDLE1BQU1ULFVBQVV4QyxHQUFHO29DQUNuQmtELGFBQWEsQ0FBQ3pCLE1BQVFELGdCQUFnQkMsS0FBS2UsVUFBVXhDLEdBQUc7bUNBRm5Ed0MsVUFBVXhDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdsRDtHQXpITUw7S0FBQUE7QUEySE4sK0RBQWVBLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Rhc2hib2FyZENvbnRhaW5lci9EYXNoYm9hcmRDb250YWluZXIuanM/MThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmLCBDb21wb25lbnQgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IEdyaWRTdGFja1RpbGUgZnJvbSAnLi4vR3JpZFN0YWNrVGlsZS9HcmlkU3RhY2tUaWxlLmpzJztcclxuaW1wb3J0IHsgR3JpZFN0YWNrIH0gZnJvbSAnZ3JpZHN0YWNrJztcclxuaW1wb3J0ICdncmlkc3RhY2svZGlzdC9ncmlkc3RhY2suY3NzJztcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0Rhc2hib2FyZENvbnRhaW5lci5tb2R1bGUuc2Nzcyc7XHJcbmltcG9ydCBEYXNoYm9hcmRNZW51IGZyb20gXCIuLi9EYXNoYm9hcmRNZW51L0Rhc2hib2FyZE1lbnUuanNcIjtcclxuXHJcbmNvbnN0IERhc2hib2FyZENvbnRhaW5lciA9IChwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgW3BlcmlvZEV4cGFuZGVkLCBzZXRQZXJpb2RFeHBhbmRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBpbml0aWFsVGlsZURhdGEgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiA0LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDMsXHJcbiAgICAgICAgICAgIC8veDogMCxcclxuICAgICAgICAgICAgLy95OiAwLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnU29tZSBEYXRhIE1ldHJpYydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiAxLFxyXG4gICAgICAgICAgICB3aWR0aDogNCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnQW5vdGhlciBEYXRhIE1ldHJpYydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiAyLFxyXG4gICAgICAgICAgICB3aWR0aDogNCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnVGhpcmQgRGF0YSBNZXRyaWMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogMyxcclxuICAgICAgICAgICAgd2lkdGg6IDQsXHJcbiAgICAgICAgICAgIGhlaWdodDogMyxcclxuICAgICAgICAgICAgY29udGVudDogJ0ZvdXJ0aCBEYXRhIE1ldHJpYydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiA0LFxyXG4gICAgICAgICAgICB3aWR0aDogNCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnRmlmdGggIERhdGEgTWV0cmljJ1xyXG4gICAgICAgIH1cclxuICAgIF07XHJcblxyXG4gICAgY29uc3QgdGltZVBlcmlvZE9wdGlvbnMgPSBbXHJcbiAgICAgICAgeyB0ZXh0OiAnMjAyMycgfSxcclxuICAgICAgICB7IHRleHQ6ICcyMDIyJyB9LFxyXG4gICAgICAgIHsgdGV4dDogJzIwMjEnIH0sXHJcbiAgICAgICAgeyB0ZXh0OiAnMjAyMCcgfSxcclxuICAgIF07XHJcblxyXG4gICAgY29uc3QgW3RpbGVEYXRhLCBzZXRUaWxlRGF0YV0gPSB1c2VTdGF0ZShpbml0aWFsVGlsZURhdGEpO1xyXG4gICAgbGV0IGdyaWQ7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBncmlkID0gR3JpZFN0YWNrLmluaXQoKTtcclxuICAgICAgICBncmlkLm1hcmdpbignMTJweCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbW91bnRlZCA9IHVzZVJlZigpO1xyXG4gICAgY29uc3QgbGFzdEtleUFkZGVkID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gZG8gY29tcG9uZW50RGlkTW91bnQgbG9naWNcclxuICAgICAgICAgICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkbyBjb21wb25lbnREaWRVcGRhdGUgbG9naWNcclxuICAgICAgICAgICAgaWYgKGxhc3RLZXlBZGRlZC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBncmlkLm1ha2VXaWRnZXQoYCMke2xhc3RLZXlBZGRlZC5jdXJyZW50fWApO1xyXG4gICAgICAgICAgICAgICAgbGFzdEtleUFkZGVkLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQWRkVGlsZSA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBuZXdUaWxlRGF0YSA9IFsuLi50aWxlRGF0YV07XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nS2V5cyA9IG5ld1RpbGVEYXRhLm1hcChlbGVtZW50ID0+IGVsZW1lbnQua2V5KTtcclxuICAgICAgICB2YXIgbmV4dEtleSA9IE1hdGgubWF4KC4uLmV4aXN0aW5nS2V5cykgKyAxO1xyXG5cclxuICAgICAgICBuZXdUaWxlRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAga2V5OiBuZXh0S2V5LFxyXG4gICAgICAgICAgICB3aWR0aDogMSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxyXG4gICAgICAgICAgICBjb250ZW50OiBgdGlsZSAke25leHRLZXl9YFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZXRUaWxlRGF0YShuZXdUaWxlRGF0YSk7XHJcbiAgICAgICAgbGFzdEtleUFkZGVkLmN1cnJlbnQgPSBuZXh0S2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRpbGVDbG9zZSA9IChyZWYsIGtleSkgPT4ge1xyXG4gICAgICAgIGdyaWQucmVtb3ZlV2lkZ2V0KHJlZi5jdXJyZW50LCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3VGlsZURhdGEgPSBbLi4udGlsZURhdGFdO1xyXG4gICAgICAgIHZhciBjdXJyZW50VGlsZSA9IG5ld1RpbGVEYXRhLmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnQua2V5ID09IGtleSk7XHJcbiAgICAgICAgdmFyIHRpbGVJbmRleCA9IG5ld1RpbGVEYXRhLmluZGV4T2YoY3VycmVudFRpbGUpO1xyXG4gICAgICAgIG5ld1RpbGVEYXRhLnNwbGljZSh0aWxlSW5kZXgsIDEpO1xyXG4gICAgICAgIHNldFRpbGVEYXRhKG5ld1RpbGVEYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XHJcbiAgICAgICAgICAgIDxEYXNoYm9hcmRNZW51IGhhbmRsZUFkZFRpbGU9e2hhbmRsZUFkZFRpbGV9PlxyXG4gICAgICAgICAgICA8L0Rhc2hib2FyZE1lbnU+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubWFpbn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgxPkFuYWx5dGljcyBEYXNoYm9hcmQ8L2gxPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmdyaWRTdGFja0NvbnRhaW5lcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BncmlkLXN0YWNrICR7c3R5bGVzLmdyaWRTdGFja31gfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RpbGVEYXRhLm1hcCgodGlsZURhdHVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxHcmlkU3RhY2tUaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpbGVEYXR1bS5jb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdzV2lkdGg9e3RpbGVEYXR1bS53aWR0aH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnc0hlaWdodD17dGlsZURhdHVtLmhlaWdodH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnc1g9e3RpbGVEYXR1bS54fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdzWT17dGlsZURhdHVtLnl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXt0aWxlRGF0dW0ua2V5fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdzSWQ9e3RpbGVEYXR1bS5rZXl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2U9eyhyZWYpID0+IGhhbmRsZVRpbGVDbG9zZShyZWYsIHRpbGVEYXR1bS5rZXkpfT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0dyaWRTdGFja1RpbGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXYgPlxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGFzaGJvYXJkQ29udGFpbmVyOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiQ29tcG9uZW50IiwiR3JpZFN0YWNrVGlsZSIsIkdyaWRTdGFjayIsInN0eWxlcyIsIkRhc2hib2FyZE1lbnUiLCJEYXNoYm9hcmRDb250YWluZXIiLCJwcm9wcyIsInBlcmlvZEV4cGFuZGVkIiwic2V0UGVyaW9kRXhwYW5kZWQiLCJpbml0aWFsVGlsZURhdGEiLCJrZXkiLCJ3aWR0aCIsImhlaWdodCIsImNvbnRlbnQiLCJ0aW1lUGVyaW9kT3B0aW9ucyIsInRleHQiLCJ0aWxlRGF0YSIsInNldFRpbGVEYXRhIiwiZ3JpZCIsImluaXQiLCJtYXJnaW4iLCJtb3VudGVkIiwibGFzdEtleUFkZGVkIiwiY3VycmVudCIsIm1ha2VXaWRnZXQiLCJoYW5kbGVBZGRUaWxlIiwibmV3VGlsZURhdGEiLCJleGlzdGluZ0tleXMiLCJtYXAiLCJlbGVtZW50IiwibmV4dEtleSIsIk1hdGgiLCJtYXgiLCJwdXNoIiwiaGFuZGxlVGlsZUNsb3NlIiwicmVmIiwicmVtb3ZlV2lkZ2V0IiwiY3VycmVudFRpbGUiLCJmaW5kIiwidGlsZUluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsIm1haW4iLCJoZWFkZXIiLCJoMSIsImdyaWRTdGFja0NvbnRhaW5lciIsImdyaWRTdGFjayIsInRpbGVEYXR1bSIsImluZGV4IiwidGl0bGUiLCJnc1dpZHRoIiwiZ3NIZWlnaHQiLCJnc1giLCJ4IiwiZ3NZIiwieSIsImdzSWQiLCJoYW5kbGVDbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/DashboardContainer/DashboardContainer.js\n"));

/***/ }),

/***/ "./components/DashboardMenu/DashboardMenu.js":
/*!***************************************************!*\
  !*** ./components/DashboardMenu/DashboardMenu.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gridstack/dist/gridstack.css */ \"./node_modules/gridstack/dist/gridstack.css\");\n/* harmony import */ var gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gridstack_dist_gridstack_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DashboardMenu.module.scss */ \"./components/DashboardMenu/DashboardMenu.module.scss\");\n/* harmony import */ var _DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _icons_calendar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../icons/calendar.js */ \"./icons/calendar.js\");\n/* harmony import */ var _icons_chart_line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../icons/chart-line.js */ \"./icons/chart-line.js\");\n/* harmony import */ var _icons_chart_bar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../icons/chart-bar.js */ \"./icons/chart-bar.js\");\n/* harmony import */ var _icons_chart_donut_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../icons/chart-donut.js */ \"./icons/chart-donut.js\");\n/* harmony import */ var _icons_chevron_down_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../icons/chevron-down.js */ \"./icons/chevron-down.js\");\n/* harmony import */ var _icons_gauge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../icons/gauge.js */ \"./icons/gauge.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst DashboardMenu = (props)=>{\n    _s();\n    const [periodExpanded, setPeriodExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const timePeriodOptions = [\n        {\n            text: \"2023\"\n        },\n        {\n            text: \"2022\"\n        },\n        {\n            text: \"2021\"\n        },\n        {\n            text: \"2020\"\n        }\n    ];\n    const handlePeriodClick = ()=>{\n        setPeriodExpanded(!periodExpanded);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().header)\n            }, void 0, false, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 27,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                children: \"Time Period\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 28,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: handlePeriodClick,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_calendar_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 31,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 30,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().text),\n                        children: \"All Time\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 33,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"\".concat((_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon), \" \").concat((_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().spinOnExpand), \" \").concat(periodExpanded ? (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().expanded) : \"\"),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_chevron_down_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 37,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 36,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 29,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().dropDown), \" \").concat(periodExpanded, \" ? 'styles.expanded' : ''}\"),\n                style: periodExpanded ? {\n                    height: 40 * timePeriodOptions.length + \"px\"\n                } : {},\n                children: timePeriodOptions.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().noIcon),\n                        onClick: props.handleAddTile,\n                        children: item.text\n                    }, index, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 42,\n                        columnNumber: 21\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 40,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                children: \"Add Widget\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 47,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: props.handleAddTile,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_gauge_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 50,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 49,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().text),\n                        children: \"Gauge\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 52,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 48,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: props.handleAddTile,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_chart_bar_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 58,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 57,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().text),\n                        children: \"Bar Chart\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 60,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 56,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: props.handleAddTile,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_chart_line_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 66,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 65,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().text),\n                        children: \"Graph\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 68,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 64,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: props.handleAddTile,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().icon),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_chart_donut_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                            lineNumber: 74,\n                            columnNumber: 21\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 73,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_DashboardMenu_module_scss__WEBPACK_IMPORTED_MODULE_9___default().text),\n                        children: \"Donut Chart\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                        lineNumber: 76,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n                lineNumber: 72,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\DashboardMenu\\\\DashboardMenu.js\",\n        lineNumber: 26,\n        columnNumber: 9\n    }, undefined);\n};\n_s(DashboardMenu, \"YcuZ3SamuTPRanHPCudR0RbXgmY=\");\n_c = DashboardMenu;\n/* harmony default export */ __webpack_exports__[\"default\"] = (DashboardMenu);\nvar _c;\n$RefreshReg$(_c, \"DashboardMenu\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUvRGFzaGJvYXJkTWVudS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRTtBQUNoQztBQUNXO0FBQ0U7QUFDRztBQUNGO0FBQ0k7QUFDRTtBQUNiO0FBRTdDLE1BQU1ZLGdCQUFnQixDQUFDQzs7SUFDbkIsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHYiwrQ0FBUUEsQ0FBQztJQUVyRCxNQUFNYyxvQkFBb0I7UUFDdEI7WUFBRUMsTUFBTTtRQUFPO1FBQ2Y7WUFBRUEsTUFBTTtRQUFPO1FBQ2Y7WUFBRUEsTUFBTTtRQUFPO1FBQ2Y7WUFBRUEsTUFBTTtRQUFPO0tBQ2xCO0lBRUQsTUFBTUMsb0JBQW9CO1FBQ3RCSCxrQkFBa0IsQ0FBQ0Q7SUFDdkI7SUFFQSxxQkFDSSw4REFBQ0s7UUFBSUMsV0FBV2YsNkVBQWdCOzswQkFDNUIsOERBQUNjO2dCQUFJQyxXQUFXZiwwRUFBYTs7Ozs7OzBCQUM3Qiw4REFBQ2tCOzBCQUFHOzs7Ozs7MEJBQ0osOERBQUNDO2dCQUFPQyxNQUFLO2dCQUFTQyxTQUFTUjs7a0NBQzNCLDhEQUFDQzt3QkFBSUMsV0FBV2Ysd0VBQVc7a0NBQ3ZCLDRFQUFDQywwREFBWUE7Ozs7Ozs7Ozs7a0NBRWpCLDhEQUFDYTt3QkFBSUMsV0FBV2Ysd0VBQVc7a0NBQUU7Ozs7OztrQ0FHN0IsOERBQUNjO3dCQUFJQyxXQUFXLEdBQWtCZixPQUFmQSx3RUFBVyxFQUFDLEtBQTBCUyxPQUF2QlQsZ0ZBQW1CLEVBQUMsS0FBeUMsT0FBdENTLGlCQUFpQlQsNEVBQWUsR0FBRztrQ0FDeEYsNEVBQUNLLDhEQUFlQTs7Ozs7Ozs7Ozs7Ozs7OzswQkFHeEIsOERBQUNTO2dCQUFJQyxXQUFXLEdBQXNCTixPQUFuQlQsNEVBQWUsRUFBQyxLQUFrQixPQUFmUyxnQkFBZTtnQkFBNkJpQixPQUFPakIsaUJBQWlCO29CQUFFa0IsUUFBUSxLQUFNaEIsa0JBQWtCaUIsTUFBTSxHQUFJO2dCQUFLLElBQUksQ0FBQzswQkFDM0pqQixrQkFBa0JrQixHQUFHLENBQUMsQ0FBQ0MsTUFBTUMsc0JBQzFCLDhEQUFDWjt3QkFBT0MsTUFBSzt3QkFBU0wsV0FBV2YsMEVBQWE7d0JBQUVxQixTQUFTYixNQUFNeUIsYUFBYTtrQ0FDdkVILEtBQUtsQixJQUFJO3VCQURxRW1COzs7Ozs7Ozs7OzBCQUszRiw4REFBQ2I7MEJBQUc7Ozs7OzswQkFDSiw4REFBQ0M7Z0JBQU9DLE1BQUs7Z0JBQVNDLFNBQVNiLE1BQU15QixhQUFhOztrQ0FDOUMsOERBQUNuQjt3QkFBSUMsV0FBV2Ysd0VBQVc7a0NBQ3ZCLDRFQUFDTSx1REFBU0E7Ozs7Ozs7Ozs7a0NBRWQsOERBQUNRO3dCQUFJQyxXQUFXZix3RUFBVztrQ0FBRTs7Ozs7Ozs7Ozs7OzBCQUlqQyw4REFBQ21CO2dCQUFPQyxNQUFLO2dCQUFTQyxTQUFTYixNQUFNeUIsYUFBYTs7a0NBQzlDLDhEQUFDbkI7d0JBQUlDLFdBQVdmLHdFQUFXO2tDQUN2Qiw0RUFBQ0csMkRBQVlBOzs7Ozs7Ozs7O2tDQUVqQiw4REFBQ1c7d0JBQUlDLFdBQVdmLHdFQUFXO2tDQUFFOzs7Ozs7Ozs7Ozs7MEJBSWpDLDhEQUFDbUI7Z0JBQU9DLE1BQUs7Z0JBQVNDLFNBQVNiLE1BQU15QixhQUFhOztrQ0FDOUMsOERBQUNuQjt3QkFBSUMsV0FBV2Ysd0VBQVc7a0NBQ3ZCLDRFQUFDRSw0REFBYUE7Ozs7Ozs7Ozs7a0NBRWxCLDhEQUFDWTt3QkFBSUMsV0FBV2Ysd0VBQVc7a0NBQUU7Ozs7Ozs7Ozs7OzswQkFJakMsOERBQUNtQjtnQkFBT0MsTUFBSztnQkFBU0MsU0FBU2IsTUFBTXlCLGFBQWE7O2tDQUM5Qyw4REFBQ25CO3dCQUFJQyxXQUFXZix3RUFBVztrQ0FDdkIsNEVBQUNJLDZEQUFjQTs7Ozs7Ozs7OztrQ0FFbkIsOERBQUNVO3dCQUFJQyxXQUFXZix3RUFBVztrQ0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTdDO0dBdkVNTztLQUFBQTtBQXlFTiwrREFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Rhc2hib2FyZE1lbnUvRGFzaGJvYXJkTWVudS5qcz8yYTM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYsIENvbXBvbmVudCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgJ2dyaWRzdGFjay9kaXN0L2dyaWRzdGFjay5jc3MnO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vRGFzaGJvYXJkTWVudS5tb2R1bGUuc2Nzcyc7XHJcbmltcG9ydCBDYWxlbmRhckljb24gZnJvbSAnLi4vLi4vaWNvbnMvY2FsZW5kYXIuanMnO1xyXG5pbXBvcnQgQ2hhcnRMaW5lSWNvbiBmcm9tICcuLi8uLi9pY29ucy9jaGFydC1saW5lLmpzJztcclxuaW1wb3J0IENoYXJ0QmFySWNvbiBmcm9tICcuLi8uLi9pY29ucy9jaGFydC1iYXIuanMnO1xyXG5pbXBvcnQgQ2hhcnREb251dEljb24gZnJvbSAnLi4vLi4vaWNvbnMvY2hhcnQtZG9udXQuanMnO1xyXG5pbXBvcnQgQ2hldnJvbkRvd25JY29uIGZyb20gJy4uLy4uL2ljb25zL2NoZXZyb24tZG93bi5qcyc7XHJcbmltcG9ydCBHYXVnZUljb24gZnJvbSAnLi4vLi4vaWNvbnMvZ2F1Z2UuanMnO1xyXG5cclxuY29uc3QgRGFzaGJvYXJkTWVudSA9IChwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgW3BlcmlvZEV4cGFuZGVkLCBzZXRQZXJpb2RFeHBhbmRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgdGltZVBlcmlvZE9wdGlvbnMgPSBbXHJcbiAgICAgICAgeyB0ZXh0OiAnMjAyMycgfSxcclxuICAgICAgICB7IHRleHQ6ICcyMDIyJyB9LFxyXG4gICAgICAgIHsgdGV4dDogJzIwMjEnIH0sXHJcbiAgICAgICAgeyB0ZXh0OiAnMjAyMCcgfSxcclxuICAgIF07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUGVyaW9kQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0UGVyaW9kRXhwYW5kZWQoIXBlcmlvZEV4cGFuZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PjwvZGl2PlxyXG4gICAgICAgICAgICA8aDI+VGltZSBQZXJpb2Q8L2gyPlxyXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXtoYW5kbGVQZXJpb2RDbGlja30+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmljb259PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYWxlbmRhckljb24+PC9DYWxlbmRhckljb24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGV4dH0+XHJcbiAgICAgICAgICAgICAgICAgICAgQWxsIFRpbWVcclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5pY29ufSAke3N0eWxlcy5zcGluT25FeHBhbmR9ICR7cGVyaW9kRXhwYW5kZWQgPyBzdHlsZXMuZXhwYW5kZWQgOiAnJ31gfT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hldnJvbkRvd25JY29uPjwvQ2hldnJvbkRvd25JY29uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7c3R5bGVzLmRyb3BEb3dufSAke3BlcmlvZEV4cGFuZGVkfSA/ICdzdHlsZXMuZXhwYW5kZWQnIDogJyd9YH0gc3R5bGU9e3BlcmlvZEV4cGFuZGVkID8geyBoZWlnaHQ6ICg0MCAqIHRpbWVQZXJpb2RPcHRpb25zLmxlbmd0aCkgKyAncHgnIH0gOiB7fX0+XHJcbiAgICAgICAgICAgICAgICB7dGltZVBlcmlvZE9wdGlvbnMubWFwKChpdGVtLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9e3N0eWxlcy5ub0ljb259IG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUFkZFRpbGV9IGtleT17aW5kZXh9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7aXRlbS50ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxoMj5BZGQgV2lkZ2V0PC9oMj5cclxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMuaGFuZGxlQWRkVGlsZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmljb259PlxyXG4gICAgICAgICAgICAgICAgICAgIDxHYXVnZUljb24+PC9HYXVnZUljb24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGV4dH0+XHJcbiAgICAgICAgICAgICAgICAgICAgR2F1Z2VcclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMuaGFuZGxlQWRkVGlsZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmljb259PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGFydEJhckljb24+PC9DaGFydEJhckljb24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGV4dH0+XHJcbiAgICAgICAgICAgICAgICAgICAgQmFyIENoYXJ0XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUFkZFRpbGV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pY29ufT5cclxuICAgICAgICAgICAgICAgICAgICA8Q2hhcnRMaW5lSWNvbj48L0NoYXJ0TGluZUljb24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGV4dH0+XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhcclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMuaGFuZGxlQWRkVGlsZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmljb259PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDaGFydERvbnV0SWNvbj48L0NoYXJ0RG9udXRJY29uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRleHR9PlxyXG4gICAgICAgICAgICAgICAgICAgIERvbnV0IENoYXJ0XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEYXNoYm9hcmRNZW51OyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiQ29tcG9uZW50Iiwic3R5bGVzIiwiQ2FsZW5kYXJJY29uIiwiQ2hhcnRMaW5lSWNvbiIsIkNoYXJ0QmFySWNvbiIsIkNoYXJ0RG9udXRJY29uIiwiQ2hldnJvbkRvd25JY29uIiwiR2F1Z2VJY29uIiwiRGFzaGJvYXJkTWVudSIsInByb3BzIiwicGVyaW9kRXhwYW5kZWQiLCJzZXRQZXJpb2RFeHBhbmRlZCIsInRpbWVQZXJpb2RPcHRpb25zIiwidGV4dCIsImhhbmRsZVBlcmlvZENsaWNrIiwiZGl2IiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiaGVhZGVyIiwiaDIiLCJidXR0b24iLCJ0eXBlIiwib25DbGljayIsImljb24iLCJzcGluT25FeHBhbmQiLCJleHBhbmRlZCIsImRyb3BEb3duIiwic3R5bGUiLCJoZWlnaHQiLCJsZW5ndGgiLCJtYXAiLCJpdGVtIiwiaW5kZXgiLCJub0ljb24iLCJoYW5kbGVBZGRUaWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/DashboardMenu/DashboardMenu.js\n"));

/***/ }),

/***/ "./components/GridStackTile/GridStackTile.js":
/*!***************************************************!*\
  !*** ./components/GridStackTile/GridStackTile.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _icons_close_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../icons/close.js */ \"./icons/close.js\");\n/* harmony import */ var _GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GridStackTile.module.scss */ \"./components/GridStackTile/GridStackTile.module.scss\");\n/* harmony import */ var _GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\nconst GridStackTile = (props)=>{\n    _s();\n    const tileRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"grid-stack-item border-dark \".concat((_GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().container)),\n        \"gs-w\": props.gsWidth,\n        \"gs-h\": props.gsHeight,\n        \"gs-x\": props.gsX,\n        \"gs-y\": props.gsY,\n        id: props.gsId,\n        ref: tileRef,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"grid-stack-item-content \".concat((_GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().content)),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().header),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_GridStackTile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().title),\n                            children: props.title\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n                            lineNumber: 19,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            onClick: ()=>props.handleClose(tileRef),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_icons_close_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n                                lineNumber: 23,\n                                columnNumber: 25\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n                            lineNumber: 22,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n                    lineNumber: 18,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: props.children\n                }, void 0, false, {\n                    fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n                    lineNumber: 26,\n                    columnNumber: 17\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n            lineNumber: 17,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\components\\\\GridStackTile\\\\GridStackTile.js\",\n        lineNumber: 9,\n        columnNumber: 9\n    }, undefined);\n};\n_s(GridStackTile, \"1hMJNSoDTheSTUYHOlSMC4gK9lI=\");\n_c = GridStackTile;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GridStackTile);\nvar _c;\n$RefreshReg$(_c, \"GridStackTile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dyaWRTdGFja1RpbGUvR3JpZFN0YWNrVGlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNDO0FBQ087QUFDSTtBQUVqRCxNQUFNSSxnQkFBZ0IsQ0FBQ0M7O0lBQ25CLE1BQU1DLFVBQVVMLDZDQUFNQSxDQUFDO0lBRXZCLHFCQUNJLDhEQUFDTTtRQUNHQyxXQUFXLCtCQUFnRCxPQUFqQkwsNkVBQWdCO1FBQzFETyxRQUFNTCxNQUFNTSxPQUFPO1FBQ25CQyxRQUFNUCxNQUFNUSxRQUFRO1FBQ3BCQyxRQUFNVCxNQUFNVSxHQUFHO1FBQ2ZDLFFBQU1YLE1BQU1ZLEdBQUc7UUFDZkMsSUFBSWIsTUFBTWMsSUFBSTtRQUNkQyxLQUFLZDtrQkFDTCw0RUFBQ0M7WUFBSUMsV0FBVywyQkFBMEMsT0FBZkwsMkVBQWM7OzhCQUNyRCw4REFBQ0k7b0JBQUlDLFdBQVdMLDBFQUFhOztzQ0FDekIsOERBQUNJOzRCQUFJQyxXQUFXTCx5RUFBWTtzQ0FDdkJFLE1BQU1rQixLQUFLOzs7Ozs7c0NBRWhCLDhEQUFDQzs0QkFBT0MsTUFBSzs0QkFBU0MsU0FBUyxJQUFNckIsTUFBTXNCLFdBQVcsQ0FBQ3JCO3NDQUNuRCw0RUFBQ0osdURBQVNBOzs7Ozs7Ozs7Ozs7Ozs7OzhCQUdsQiw4REFBQ0s7OEJBQ0lGLE1BQU11QixRQUFROzs7Ozs7Ozs7Ozs7Ozs7OztBQUtuQztHQTNCTXhCO0tBQUFBO0FBNkJOLCtEQUFlQSxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvR3JpZFN0YWNrVGlsZS9HcmlkU3RhY2tUaWxlLmpzPzhmM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgQ2xvc2VJY29uIGZyb20gJy4uLy4uL2ljb25zL2Nsb3NlLmpzJztcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0dyaWRTdGFja1RpbGUubW9kdWxlLnNjc3MnO1xyXG5cclxuY29uc3QgR3JpZFN0YWNrVGlsZSA9IChwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgdGlsZVJlZiA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgZ3JpZC1zdGFjay1pdGVtIGJvcmRlci1kYXJrICR7c3R5bGVzLmNvbnRhaW5lcn1gfVxyXG4gICAgICAgICAgICBncy13PXtwcm9wcy5nc1dpZHRofVxyXG4gICAgICAgICAgICBncy1oPXtwcm9wcy5nc0hlaWdodH1cclxuICAgICAgICAgICAgZ3MteD17cHJvcHMuZ3NYfVxyXG4gICAgICAgICAgICBncy15PXtwcm9wcy5nc1l9XHJcbiAgICAgICAgICAgIGlkPXtwcm9wcy5nc0lkfVxyXG4gICAgICAgICAgICByZWY9e3RpbGVSZWZ9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGdyaWQtc3RhY2staXRlbS1jb250ZW50ICR7c3R5bGVzLmNvbnRlbnR9YH0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy50aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBwcm9wcy5oYW5kbGVDbG9zZSh0aWxlUmVmKX0gPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2xvc2VJY29uPjwvQ2xvc2VJY29uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JpZFN0YWNrVGlsZTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwiQ2xvc2VJY29uIiwic3R5bGVzIiwiR3JpZFN0YWNrVGlsZSIsInByb3BzIiwidGlsZVJlZiIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImdzLXciLCJnc1dpZHRoIiwiZ3MtaCIsImdzSGVpZ2h0IiwiZ3MteCIsImdzWCIsImdzLXkiLCJnc1kiLCJpZCIsImdzSWQiLCJyZWYiLCJjb250ZW50IiwiaGVhZGVyIiwidGl0bGUiLCJidXR0b24iLCJ0eXBlIiwib25DbGljayIsImhhbmRsZUNsb3NlIiwiY2hpbGRyZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/GridStackTile/GridStackTile.js\n"));

/***/ }),

/***/ "./icons/calendar.js":
/*!***************************!*\
  !*** ./icons/calendar.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CalendarIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m19 19h-14v-11h14m-3-7v2h-8v-2h-2v2h-1c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-14c0-1.11-.9-2-2-2h-1v-2m-1 11h-5v5h5z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\calendar.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\calendar.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = CalendarIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CalendarIcon);\nvar _c;\n$RefreshReg$(_c, \"CalendarIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jYWxlbmRhci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsZUFBZSxrQkFDakIsOERBQUNDO1FBQUlDLFFBQU87UUFBS0MsU0FBUTtRQUFZQyxPQUFNO1FBQUtDLE9BQU07a0JBQ2xELDRFQUFDQztZQUNHQyxHQUFFOzs7Ozs7Ozs7OztLQUhSUDtBQU9OLCtEQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ljb25zL2NhbGVuZGFyLmpzP2FmODMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2FsZW5kYXJJY29uID0gKCkgPT4gKFxyXG4gICAgPHN2ZyBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB3aWR0aD1cIjI0XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxyXG4gICAgICAgIDxwYXRoXHJcbiAgICAgICAgICAgIGQ9XCJtMTkgMTloLTE0di0xMWgxNG0tMy03djJoLTh2LTJoLTJ2MmgtMWMtMS4xMSAwLTIgLjg5LTIgMnYxNGEyIDIgMCAwIDAgMiAyaDE0YTIgMiAwIDAgMCAyLTJ2LTE0YzAtMS4xMS0uOS0yLTItMmgtMXYtMm0tMSAxMWgtNXY1aDV6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhckljb247Il0sIm5hbWVzIjpbIkNhbGVuZGFySWNvbiIsInN2ZyIsImhlaWdodCIsInZpZXdCb3giLCJ3aWR0aCIsInhtbG5zIiwicGF0aCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./icons/calendar.js\n"));

/***/ }),

/***/ "./icons/chart-bar.js":
/*!****************************!*\
  !*** ./icons/chart-bar.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ChartBarIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m22 21h-20v-18h2v16h2v-9h4v9h2v-13h4v13h2v-5h4z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-bar.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-bar.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = ChartBarIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChartBarIcon);\nvar _c;\n$RefreshReg$(_c, \"ChartBarIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jaGFydC1iYXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGVBQWUsa0JBQ2pCLDhEQUFDQztRQUFJQyxRQUFPO1FBQUtDLFNBQVE7UUFBWUMsT0FBTTtRQUFLQyxPQUFNO2tCQUNsRCw0RUFBQ0M7WUFBS0MsR0FBRTs7Ozs7Ozs7Ozs7S0FGVlA7QUFNTiwrREFBZUEsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9pY29ucy9jaGFydC1iYXIuanM/YTIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDaGFydEJhckljb24gPSAoKSA9PiAoXHJcbiAgICA8c3ZnIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICAgICAgPHBhdGggZD1cIm0yMiAyMWgtMjB2LTE4aDJ2MTZoMnYtOWg0djloMnYtMTNoNHYxM2gydi01aDR6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGFydEJhckljb247Il0sIm5hbWVzIjpbIkNoYXJ0QmFySWNvbiIsInN2ZyIsImhlaWdodCIsInZpZXdCb3giLCJ3aWR0aCIsInhtbG5zIiwicGF0aCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./icons/chart-bar.js\n"));

/***/ }),

/***/ "./icons/chart-donut.js":
/*!******************************!*\
  !*** ./icons/chart-donut.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ChartDonutIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m13 2.05v3.03c3.39.49 6 3.39 6 6.92 0 .9-.18 1.75-.5 2.54l2.62 1.53c.56-1.24.88-2.62.88-4.07 0-5.18-3.95-9.45-9-9.95m-1 16.95a7 7 0 0 1 -7-7c0-3.53 2.61-6.43 6-6.92v-3.03c-5.06.5-9 4.76-9 9.95a10 10 0 0 0 10 10c3.3 0 6.23-1.61 8.05-4.09l-2.6-1.53c-1.28 1.62-3.24 2.62-5.45 2.62z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-donut.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-donut.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = ChartDonutIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChartDonutIcon);\nvar _c;\n$RefreshReg$(_c, \"ChartDonutIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jaGFydC1kb251dC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsaUJBQWlCLGtCQUNuQiw4REFBQ0M7UUFBSUMsUUFBTztRQUFLQyxTQUFRO1FBQVlDLE9BQU07UUFBS0MsT0FBTTtrQkFDbEQsNEVBQUNDO1lBQ0dDLEdBQUU7Ozs7Ozs7Ozs7O0tBSFJQO0FBT04sK0RBQWVBLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaWNvbnMvY2hhcnQtZG9udXQuanM/ZWVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDaGFydERvbnV0SWNvbiA9ICgpID0+IChcclxuICAgIDxzdmcgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICBkPVwibTEzIDIuMDV2My4wM2MzLjM5LjQ5IDYgMy4zOSA2IDYuOTIgMCAuOS0uMTggMS43NS0uNSAyLjU0bDIuNjIgMS41M2MuNTYtMS4yNC44OC0yLjYyLjg4LTQuMDcgMC01LjE4LTMuOTUtOS40NS05LTkuOTVtLTEgMTYuOTVhNyA3IDAgMCAxIC03LTdjMC0zLjUzIDIuNjEtNi40MyA2LTYuOTJ2LTMuMDNjLTUuMDYuNS05IDQuNzYtOSA5Ljk1YTEwIDEwIDAgMCAwIDEwIDEwYzMuMyAwIDYuMjMtMS42MSA4LjA1LTQuMDlsLTIuNi0xLjUzYy0xLjI4IDEuNjItMy4yNCAyLjYyLTUuNDUgMi42MnpcIiAvPlxyXG4gICAgPC9zdmc+XHJcbilcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoYXJ0RG9udXRJY29uOyJdLCJuYW1lcyI6WyJDaGFydERvbnV0SWNvbiIsInN2ZyIsImhlaWdodCIsInZpZXdCb3giLCJ3aWR0aCIsInhtbG5zIiwicGF0aCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./icons/chart-donut.js\n"));

/***/ }),

/***/ "./icons/chart-line.js":
/*!*****************************!*\
  !*** ./icons/chart-line.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ChartLineIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m16 11.78 4.24-7.33 1.73 1-5.23 9.05-6.51-3.75-4.77 8.25h16.54v2h-20v-18h2v14.54l5.5-9.54z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-line.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chart-line.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = ChartLineIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChartLineIcon);\nvar _c;\n$RefreshReg$(_c, \"ChartLineIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jaGFydC1saW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxnQkFBZ0Isa0JBQ2xCLDhEQUFDQztRQUFJQyxRQUFPO1FBQUtDLFNBQVE7UUFBWUMsT0FBTTtRQUFLQyxPQUFNO2tCQUNsRCw0RUFBQ0M7WUFDR0MsR0FBRTs7Ozs7Ozs7Ozs7S0FIUlA7QUFPTiwrREFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9pY29ucy9jaGFydC1saW5lLmpzPzdlZWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2hhcnRMaW5lSWNvbiA9ICgpID0+IChcclxuICAgIDxzdmcgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICBkPVwibTE2IDExLjc4IDQuMjQtNy4zMyAxLjczIDEtNS4yMyA5LjA1LTYuNTEtMy43NS00Ljc3IDguMjVoMTYuNTR2MmgtMjB2LTE4aDJ2MTQuNTRsNS41LTkuNTR6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGFydExpbmVJY29uOyJdLCJuYW1lcyI6WyJDaGFydExpbmVJY29uIiwic3ZnIiwiaGVpZ2h0Iiwidmlld0JveCIsIndpZHRoIiwieG1sbnMiLCJwYXRoIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./icons/chart-line.js\n"));

/***/ }),

/***/ "./icons/chevron-down.js":
/*!*******************************!*\
  !*** ./icons/chevron-down.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ChevronDownIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m7.41 8.58 4.59 4.59 4.59-4.59 1.41 1.42-6 6-6-6z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chevron-down.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\chevron-down.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = ChevronDownIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChevronDownIcon);\nvar _c;\n$RefreshReg$(_c, \"ChevronDownIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jaGV2cm9uLWRvd24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGtCQUFrQixrQkFDcEIsOERBQUNDO1FBQUlDLFFBQU87UUFBS0MsU0FBUTtRQUFZQyxPQUFNO1FBQUtDLE9BQU07a0JBQ2xELDRFQUFDQztZQUFLQyxHQUFFOzs7Ozs7Ozs7OztLQUZWUDtBQU1OLCtEQUFlQSxlQUFlQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ljb25zL2NoZXZyb24tZG93bi5qcz80YzkzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENoZXZyb25Eb3duSWNvbiA9ICgpID0+IChcclxuICAgIDxzdmcgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgICA8cGF0aCBkPVwibTcuNDEgOC41OCA0LjU5IDQuNTkgNC41OS00LjU5IDEuNDEgMS40Mi02IDYtNi02elwiIC8+XHJcbiAgICA8L3N2Zz5cclxuKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hldnJvbkRvd25JY29uOyJdLCJuYW1lcyI6WyJDaGV2cm9uRG93bkljb24iLCJzdmciLCJoZWlnaHQiLCJ2aWV3Qm94Iiwid2lkdGgiLCJ4bWxucyIsInBhdGgiLCJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./icons/chevron-down.js\n"));

/***/ }),

/***/ "./icons/close.js":
/*!************************!*\
  !*** ./icons/close.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst CloseIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m19 6.41-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\close.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\close.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = CloseIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CloseIcon);\nvar _c;\n$RefreshReg$(_c, \"CloseIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9jbG9zZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsWUFBWSxrQkFDZCw4REFBQ0M7UUFBSUMsUUFBTztRQUFLQyxTQUFRO1FBQVlDLE9BQU07UUFBS0MsT0FBTTtrQkFDbEQsNEVBQUNDO1lBQUtDLEdBQUU7Ozs7Ozs7Ozs7O0tBRlZQO0FBTU4sK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaWNvbnMvY2xvc2UuanM/ZmE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDbG9zZUljb24gPSAoKSA9PiAoXHJcbiAgICA8c3ZnIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICAgICAgPHBhdGggZD1cIm0xOSA2LjQxLTEuNDEtMS40MS01LjU5IDUuNTktNS41OS01LjU5LTEuNDEgMS40MSA1LjU5IDUuNTktNS41OSA1LjU5IDEuNDEgMS40MSA1LjU5LTUuNTkgNS41OSA1LjU5IDEuNDEtMS40MS01LjU5LTUuNTl6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBDbG9zZUljb247Il0sIm5hbWVzIjpbIkNsb3NlSWNvbiIsInN2ZyIsImhlaWdodCIsInZpZXdCb3giLCJ3aWR0aCIsInhtbG5zIiwicGF0aCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./icons/close.js\n"));

/***/ }),

/***/ "./icons/gauge.js":
/*!************************!*\
  !*** ./icons/gauge.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst GaugeIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n            d: \"m12 2a10 10 0 0 0 -10 10 10 10 0 0 0 10 10 10 10 0 0 0 10-10 10 10 0 0 0 -10-10m0 2a8 8 0 0 1 8 8c0 2.4-1 4.5-2.7 6-1.4-1.3-3.3-2-5.3-2s-3.8.7-5.3 2c-1.7-1.5-2.7-3.6-2.7-6a8 8 0 0 1 8-8m2 1.89c-.38.01-.74.26-.9.65l-1.29 3.23-.1.23c-.71.13-1.3.6-1.57 1.26-.41 1.03.09 2.19 1.12 2.6s2.19-.09 2.6-1.12c.26-.66.14-1.42-.29-1.98l.1-.26 1.29-3.21.01-.03c.2-.51-.05-1.09-.56-1.3-.13-.05-.26-.07-.41-.07m-4 .11a1 1 0 0 0 -1 1 1 1 0 0 0 1 1 1 1 0 0 0 1-1 1 1 0 0 0 -1-1m-3 3a1 1 0 0 0 -1 1 1 1 0 0 0 1 1 1 1 0 0 0 1-1 1 1 0 0 0 -1-1m10 0a1 1 0 0 0 -1 1 1 1 0 0 0 1 1 1 1 0 0 0 1-1 1 1 0 0 0 -1-1z\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\gauge.js\",\n            lineNumber: 3,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\icons\\\\gauge.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n_c = GaugeIcon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GaugeIcon);\nvar _c;\n$RefreshReg$(_c, \"GaugeIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pY29ucy9nYXVnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsWUFBWSxrQkFDZCw4REFBQ0M7UUFBSUMsUUFBTztRQUFLQyxTQUFRO1FBQVlDLE9BQU07UUFBS0MsT0FBTTtrQkFDbEQsNEVBQUNDO1lBQUtDLEdBQUU7Ozs7Ozs7Ozs7O0tBRlZQO0FBTU4sK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaWNvbnMvZ2F1Z2UuanM/Mzk3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBHYXVnZUljb24gPSAoKSA9PiAoXHJcbiAgICA8c3ZnIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICAgICAgPHBhdGggZD1cIm0xMiAyYTEwIDEwIDAgMCAwIC0xMCAxMCAxMCAxMCAwIDAgMCAxMCAxMCAxMCAxMCAwIDAgMCAxMC0xMCAxMCAxMCAwIDAgMCAtMTAtMTBtMCAyYTggOCAwIDAgMSA4IDhjMCAyLjQtMSA0LjUtMi43IDYtMS40LTEuMy0zLjMtMi01LjMtMnMtMy44LjctNS4zIDJjLTEuNy0xLjUtMi43LTMuNi0yLjctNmE4IDggMCAwIDEgOC04bTIgMS44OWMtLjM4LjAxLS43NC4yNi0uOS42NWwtMS4yOSAzLjIzLS4xLjIzYy0uNzEuMTMtMS4zLjYtMS41NyAxLjI2LS40MSAxLjAzLjA5IDIuMTkgMS4xMiAyLjZzMi4xOS0uMDkgMi42LTEuMTJjLjI2LS42Ni4xNC0xLjQyLS4yOS0xLjk4bC4xLS4yNiAxLjI5LTMuMjEuMDEtLjAzYy4yLS41MS0uMDUtMS4wOS0uNTYtMS4zLS4xMy0uMDUtLjI2LS4wNy0uNDEtLjA3bS00IC4xMWExIDEgMCAwIDAgLTEgMSAxIDEgMCAwIDAgMSAxIDEgMSAwIDAgMCAxLTEgMSAxIDAgMCAwIC0xLTFtLTMgM2ExIDEgMCAwIDAgLTEgMSAxIDEgMCAwIDAgMSAxIDEgMSAwIDAgMCAxLTEgMSAxIDAgMCAwIC0xLTFtMTAgMGExIDEgMCAwIDAgLTEgMSAxIDEgMCAwIDAgMSAxIDEgMSAwIDAgMCAxLTEgMSAxIDAgMCAwIC0xLTF6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBHYXVnZUljb247Il0sIm5hbWVzIjpbIkdhdWdlSWNvbiIsInN2ZyIsImhlaWdodCIsInZpZXdCb3giLCJ3aWR0aCIsInhtbG5zIiwicGF0aCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./icons/gauge.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-base-impl.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-base-impl.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDBaseImplement: function() { return /* binding */ DDBaseImplement; }\n/* harmony export */ });\n/**\n * dd-base-impl.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ class DDBaseImplement {\n    /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */ get disabled() {\n        return this._disabled;\n    }\n    on(event, callback) {\n        this._eventRegister[event] = callback;\n    }\n    off(event) {\n        delete this._eventRegister[event];\n    }\n    enable() {\n        this._disabled = false;\n    }\n    disable() {\n        this._disabled = true;\n    }\n    destroy() {\n        delete this._eventRegister;\n    }\n    triggerEvent(eventName, event) {\n        if (!this.disabled && this._eventRegister && this._eventRegister[eventName]) return this._eventRegister[eventName](event);\n    }\n    constructor(){\n        /** @internal */ this._eventRegister = {};\n    }\n} //# sourceMappingURL=dd-base-impl.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtYmFzZS1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxNQUFNQTtJQUtULGlIQUFpSCxHQUNqSCxJQUFJQyxXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUNDLFNBQVM7SUFBRTtJQUN4Q0MsR0FBR0MsS0FBSyxFQUFFQyxRQUFRLEVBQUU7UUFDaEIsSUFBSSxDQUFDQyxjQUFjLENBQUNGLE1BQU0sR0FBR0M7SUFDakM7SUFDQUUsSUFBSUgsS0FBSyxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUNFLGNBQWMsQ0FBQ0YsTUFBTTtJQUNyQztJQUNBSSxTQUFTO1FBQ0wsSUFBSSxDQUFDTixTQUFTLEdBQUc7SUFDckI7SUFDQU8sVUFBVTtRQUNOLElBQUksQ0FBQ1AsU0FBUyxHQUFHO0lBQ3JCO0lBQ0FRLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ0osY0FBYztJQUM5QjtJQUNBSyxhQUFhQyxTQUFTLEVBQUVSLEtBQUssRUFBRTtRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDSCxRQUFRLElBQUksSUFBSSxDQUFDSyxjQUFjLElBQUksSUFBSSxDQUFDQSxjQUFjLENBQUNNLFVBQVUsRUFDdkUsT0FBTyxJQUFJLENBQUNOLGNBQWMsQ0FBQ00sVUFBVSxDQUFDUjtJQUM5QztJQXhCQVMsYUFBYztRQUNWLGNBQWMsR0FDZCxJQUFJLENBQUNQLGNBQWMsR0FBRyxDQUFDO0lBQzNCO0FBc0JKLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1iYXNlLWltcGwuanM/MzUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLWJhc2UtaW1wbC50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmV4cG9ydCBjbGFzcyBEREJhc2VJbXBsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0ZXIgPSB7fTtcbiAgICB9XG4gICAgLyoqIHJldHVybnMgdGhlIGVuYWJsZSBzdGF0ZSwgYnV0IHlvdSBoYXZlIHRvIGNhbGwgZW5hYmxlKCkvZGlzYWJsZSgpIHRvIGNoYW5nZSAoYXMgb3RoZXIgdGhpbmdzIG5lZWQgdG8gaGFwcGVuKSAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0ZXJbZXZlbnRdID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9mZihldmVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRSZWdpc3RlcltldmVudF07XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRSZWdpc3RlcjtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50KGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuX2V2ZW50UmVnaXN0ZXIgJiYgdGhpcy5fZXZlbnRSZWdpc3RlcltldmVudE5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50UmVnaXN0ZXJbZXZlbnROYW1lXShldmVudCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtYmFzZS1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJEREJhc2VJbXBsZW1lbnQiLCJkaXNhYmxlZCIsIl9kaXNhYmxlZCIsIm9uIiwiZXZlbnQiLCJjYWxsYmFjayIsIl9ldmVudFJlZ2lzdGVyIiwib2ZmIiwiZW5hYmxlIiwiZGlzYWJsZSIsImRlc3Ryb3kiLCJ0cmlnZ2VyRXZlbnQiLCJldmVudE5hbWUiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-base-impl.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-draggable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-draggable.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDraggable: function() { return /* binding */ DDDraggable; }\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-draggable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n// let count = 0; // TEST\nclass DDDraggable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__.DDBaseImplement {\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        if (this.disabled === false) return;\n        super.enable();\n        this.dragEl.addEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.addEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n            this.dragEl.addEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n        // this.dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n        }\n        this.el.classList.remove(\"ui-draggable-disabled\");\n    }\n    disable() {\n        let forDestroy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        if (this.disabled === true) return;\n        super.disable();\n        this.dragEl.removeEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.removeEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n            this.dragEl.removeEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n        }\n        if (!forDestroy) this.el.classList.add(\"ui-draggable-disabled\");\n    }\n    destroy() {\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        delete this.dragTimeout;\n        if (this.dragging) this._mouseUp(this.mouseDownEvent);\n        this.disable(true);\n        delete this.el;\n        delete this.helper;\n        delete this.option;\n        super.destroy();\n    }\n    updateOption(opts) {\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        return this;\n    }\n    /** @internal call when mouse goes down before a dragstart happens */ _mouseDown(e) {\n        // don't let more than one widget handle mouseStart\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled) return;\n        if (e.button !== 0) return true; // only left click\n        // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n        if (e.target.closest(skipMouseDown)) return true;\n        if (this.option.cancel) {\n            if (e.target.closest(this.option.cancel)) return true;\n        }\n        // REMOVE: why would we get the event if it wasn't for us or child ?\n        // make sure we are clicking on a drag handle or child of it...\n        // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n        // let className = this.option.handle.substring(1);\n        // let el = e.target as HTMLElement;\n        // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n        // if (!el) return;\n        this.mouseDownEvent = e;\n        delete this.dragging;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n        // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n        document.addEventListener(\"mousemove\", this._mouseMove, true); // true=capture, not bubble\n        document.addEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.addEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove);\n            this.dragEl.addEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend);\n        }\n        e.preventDefault();\n        // preventDefault() prevents blur event which occurs just after mousedown event.\n        // if an editable content has focus, then blur must be call\n        if (document.activeElement) document.activeElement.blur();\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled = true;\n        return true;\n    }\n    /** @internal method to call actual drag event */ _callDrag(e) {\n        if (!this.dragging) return;\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"drag\"\n        });\n        if (this.option.drag) {\n            this.option.drag(ev, this.ui());\n        }\n        this.triggerEvent(\"drag\", ev);\n    }\n    /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */ _mouseMove(e) {\n        // console.log(`${count++} move ${e.x},${e.y}`)\n        let s = this.mouseDownEvent;\n        if (this.dragging) {\n            this._dragFollow(e);\n            // delay actual grid handling drag until we pause for a while if set\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) {\n                const pause = Number.isInteger(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) ? _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag : 100;\n                if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n                this.dragTimeout = window.setTimeout(()=>this._callDrag(e), pause);\n            } else {\n                this._callDrag(e);\n            }\n        } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n            var _this_el_gridstackNode;\n            /**\n             * don't start unless we've moved at least 3 pixels\n             */ this.dragging = true;\n            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement = this;\n            // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n            let grid = (_this_el_gridstackNode = this.el.gridstackNode) === null || _this_el_gridstackNode === void 0 ? void 0 : _this_el_gridstackNode.grid;\n            if (grid) {\n                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = grid.el.ddElement.ddDroppable;\n            } else {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            }\n            this.helper = this._createHelper(e);\n            this._setupHelperContainmentStyle();\n            this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n                target: this.el,\n                type: \"dragstart\"\n            });\n            this._setupHelperStyle(e);\n            if (this.option.start) {\n                this.option.start(ev, this.ui());\n            }\n            this.triggerEvent(\"dragstart\", ev);\n        }\n        e.preventDefault(); // needed otherwise we get text sweep text selection as we drag around\n        return true;\n    }\n    /** @internal call when the mouse gets released to drop the item at current location */ _mouseUp(e) {\n        document.removeEventListener(\"mousemove\", this._mouseMove, true);\n        document.removeEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.removeEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove, true);\n            this.dragEl.removeEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend, true);\n        }\n        if (this.dragging) {\n            var _DDManager_dropElement;\n            delete this.dragging;\n            // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n            if (((_DDManager_dropElement = _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement) === null || _DDManager_dropElement === void 0 ? void 0 : _DDManager_dropElement.el) === this.el.parentElement) {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            }\n            this.helperContainment.style.position = this.parentOriginStylePosition || null;\n            if (this.helper === this.el) {\n                this._removeHelperStyle();\n            } else {\n                this.helper.remove();\n            }\n            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n                target: this.el,\n                type: \"dragstop\"\n            });\n            if (this.option.stop) {\n                this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n            }\n            this.triggerEvent(\"dragstop\", ev);\n            // call the droppable method to receive the item\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement) {\n                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement.drop(e);\n            }\n        }\n        delete this.helper;\n        delete this.mouseDownEvent;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled;\n        e.preventDefault();\n    }\n    /** @internal create a clone copy (or user defined method) of the original drag item if set */ _createHelper(event) {\n        let helper = this.el;\n        if (typeof this.option.helper === \"function\") {\n            helper = this.option.helper(event);\n        } else if (this.option.helper === \"clone\") {\n            helper = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneNode(this.el);\n        }\n        if (!document.body.contains(helper)) {\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.appendTo(helper, this.option.appendTo === \"parent\" ? this.el.parentElement : this.option.appendTo);\n        }\n        if (helper === this.el) {\n            this.dragElementOriginStyle = DDDraggable.originStyleProp.map((prop)=>this.el.style[prop]);\n        }\n        return helper;\n    }\n    /** @internal set the fix position of the dragged item */ _setupHelperStyle(e) {\n        this.helper.classList.add(\"ui-draggable-dragging\");\n        // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n        const style = this.helper.style;\n        style.pointerEvents = \"none\"; // needed for over items to get enter/leave\n        // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n        style.width = this.dragOffset.width + \"px\";\n        style.height = this.dragOffset.height + \"px\";\n        style.willChange = \"left, top\";\n        style.position = \"fixed\"; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n        this._dragFollow(e); // now position it\n        style.transition = \"none\"; // show up instantly\n        setTimeout(()=>{\n            if (this.helper) {\n                style.transition = null; // recover animation\n            }\n        }, 0);\n        return this;\n    }\n    /** @internal restore back the original style before dragging */ _removeHelperStyle() {\n        var _this_helper;\n        this.helper.classList.remove(\"ui-draggable-dragging\");\n        let node = (_this_helper = this.helper) === null || _this_helper === void 0 ? void 0 : _this_helper.gridstackNode;\n        // don't bother restoring styles if we're gonna remove anyway...\n        if (!(node === null || node === void 0 ? void 0 : node._isAboutToRemove) && this.dragElementOriginStyle) {\n            let helper = this.helper;\n            // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n            // TODO: this also removes resizing animation which doesn't have this issue, but others.\n            // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n            // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n            // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n            let transition = this.dragElementOriginStyle[\"transition\"] || null;\n            helper.style.transition = this.dragElementOriginStyle[\"transition\"] = \"none\"; // can't be NULL #1973\n            DDDraggable.originStyleProp.forEach((prop)=>helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n            setTimeout(()=>helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n        }\n        delete this.dragElementOriginStyle;\n        return this;\n    }\n    /** @internal updates the top/left position to follow the mouse */ _dragFollow(e) {\n        let containmentRect = {\n            left: 0,\n            top: 0\n        };\n        // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n        //   const { left, top } = this.helperContainment.getBoundingClientRect();\n        //   containmentRect = { left, top };\n        // }\n        const style = this.helper.style;\n        const offset = this.dragOffset;\n        style.left = e.clientX + offset.offsetLeft - containmentRect.left + \"px\";\n        style.top = e.clientY + offset.offsetTop - containmentRect.top + \"px\";\n    }\n    /** @internal */ _setupHelperContainmentStyle() {\n        this.helperContainment = this.helper.parentElement;\n        if (this.helper.style.position !== \"fixed\") {\n            this.parentOriginStylePosition = this.helperContainment.style.position;\n            if (getComputedStyle(this.helperContainment).position.match(/static/)) {\n                this.helperContainment.style.position = \"relative\";\n            }\n        }\n        return this;\n    }\n    /** @internal */ _getDragOffset(event, el, parent) {\n        // in case ancestor has transform/perspective css properties that change the viewpoint\n        let xformOffsetX = 0;\n        let xformOffsetY = 0;\n        if (parent) {\n            const testEl = document.createElement(\"div\");\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addElStyles(testEl, {\n                opacity: \"0\",\n                position: \"fixed\",\n                top: 0 + \"px\",\n                left: 0 + \"px\",\n                width: \"1px\",\n                height: \"1px\",\n                zIndex: \"-999999\"\n            });\n            parent.appendChild(testEl);\n            const testElPosition = testEl.getBoundingClientRect();\n            parent.removeChild(testEl);\n            xformOffsetX = testElPosition.left;\n            xformOffsetY = testElPosition.top;\n        // TODO: scale ?\n        }\n        const targetOffset = el.getBoundingClientRect();\n        return {\n            left: targetOffset.left,\n            top: targetOffset.top,\n            offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n            offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n            width: targetOffset.width,\n            height: targetOffset.height\n        };\n    }\n    /** @internal TODO: set to public as called by DDDroppable! */ ui() {\n        const containmentEl = this.el.parentElement;\n        const containmentRect = containmentEl.getBoundingClientRect();\n        const offset = this.helper.getBoundingClientRect();\n        return {\n            position: {\n                top: offset.top - containmentRect.top,\n                left: offset.left - containmentRect.left\n            }\n        };\n    }\n    constructor(el, option = {}){\n        super();\n        this.el = el;\n        this.option = option;\n        // get the element that is actually supposed to be dragged by\n        let handleName = option.handle.substring(1);\n        this.dragEl = el.classList.contains(handleName) ? el : el.querySelector(option.handle) || el;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseDown = this._mouseDown.bind(this);\n        this._mouseMove = this._mouseMove.bind(this);\n        this._mouseUp = this._mouseUp.bind(this);\n        this.enable();\n    }\n}\n/** @internal properties we change during dragging, and restore back */ DDDraggable.originStyleProp = [\n    \"transition\",\n    \"pointerEvents\",\n    \"position\",\n    \"left\",\n    \"top\",\n    \"minWidth\",\n    \"willChange\"\n];\n //# sourceMappingURL=dd-draggable.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZHJhZ2dhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3dDO0FBQ1Q7QUFDaUI7QUFDa0M7QUFDbkYsdUVBQXVFO0FBQ3ZFLE1BQU1RLGdCQUFnQjtBQUN0Qix5QkFBeUI7QUFDekIsTUFBTUMsb0JBQW9CUCwwREFBZUE7SUFjckNRLEdBQUdDLEtBQUssRUFBRUMsUUFBUSxFQUFFO1FBQ2hCLEtBQUssQ0FBQ0YsR0FBR0MsT0FBT0M7SUFDcEI7SUFDQUMsSUFBSUYsS0FBSyxFQUFFO1FBQ1AsS0FBSyxDQUFDRSxJQUFJRjtJQUNkO0lBQ0FHLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE9BQ2xCO1FBQ0osS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0UsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ0MsVUFBVTtRQUN6RCxJQUFJZiw4Q0FBT0EsRUFBRTtZQUNULElBQUksQ0FBQ2EsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQyxjQUFjWCxpREFBVUE7WUFDckQsSUFBSSxDQUFDVSxNQUFNLENBQUNDLGdCQUFnQixDQUFDLGVBQWVWLGtEQUFXQTtRQUN2RCx1RkFBdUY7UUFDM0Y7UUFDQSxJQUFJLENBQUNZLEVBQUUsQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLENBQUM7SUFDN0I7SUFDQUMsVUFBNEI7WUFBcEJDLGFBQUFBLGlFQUFhO1FBQ2pCLElBQUksSUFBSSxDQUFDUixRQUFRLEtBQUssTUFDbEI7UUFDSixLQUFLLENBQUNPO1FBQ04sSUFBSSxDQUFDTixNQUFNLENBQUNRLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDTixVQUFVO1FBQzVELElBQUlmLDhDQUFPQSxFQUFFO1lBQ1QsSUFBSSxDQUFDYSxNQUFNLENBQUNRLG1CQUFtQixDQUFDLGNBQWNsQixpREFBVUE7WUFDeEQsSUFBSSxDQUFDVSxNQUFNLENBQUNRLG1CQUFtQixDQUFD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QUFZOUcsRUFBRSxFQUFFZSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUs7UUFDTCxJQUFJLENBQUNmLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNlLE1BQU0sR0FBR0E7UUFDZCw2REFBNkQ7UUFDN0QsSUFBSWdHLGFBQWFoRyxPQUFPaUcsTUFBTSxDQUFDQyxTQUFTLENBQUM7UUFDekMsSUFBSSxDQUFDcEgsTUFBTSxHQUFHRyxHQUFHQyxTQUFTLENBQUN3RSxRQUFRLENBQUNzQyxjQUFjL0csS0FBS0EsR0FBR2tILGFBQWEsQ0FBQ25HLE9BQU9pRyxNQUFNLEtBQUtoSDtRQUMxRiwrR0FBK0c7UUFDL0csSUFBSSxDQUFDRCxVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNvSCxJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUNwRixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNvRixJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUN2RyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUN1RyxJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLENBQUN4SCxNQUFNO0lBQ2Y7QUFvVEo7QUFDQSxxRUFBcUUsR0FDckVMLFlBQVlzRixlQUFlLEdBQUc7SUFBQztJQUFjO0lBQWlCO0lBQVk7SUFBUTtJQUFPO0lBQVk7Q0FBYTtBQUMzRixDQUN2Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2RkLWRyYWdnYWJsZS5qcz8xMzYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtZHJhZ2dhYmxlLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEtMjAyMiBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERNYW5hZ2VyIH0gZnJvbSAnLi9kZC1tYW5hZ2VyJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBEREJhc2VJbXBsZW1lbnQgfSBmcm9tICcuL2RkLWJhc2UtaW1wbCc7XG5pbXBvcnQgeyBpc1RvdWNoLCB0b3VjaGVuZCwgdG91Y2htb3ZlLCB0b3VjaHN0YXJ0LCBwb2ludGVyZG93biB9IGZyb20gJy4vZGQtdG91Y2gnO1xuLy8gbWFrZSBzdXJlIHdlIGFyZSBub3QgY2xpY2tpbmcgb24ga25vd24gb2JqZWN0IHRoYXQgaGFuZGxlcyBtb3VzZURvd25cbmNvbnN0IHNraXBNb3VzZURvd24gPSAnaW5wdXQsdGV4dGFyZWEsYnV0dG9uLHNlbGVjdCxvcHRpb24sW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0sLnVpLXJlc2l6YWJsZS1oYW5kbGUnO1xuLy8gbGV0IGNvdW50ID0gMDsgLy8gVEVTVFxuY2xhc3MgREREcmFnZ2FibGUgZXh0ZW5kcyBEREJhc2VJbXBsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb24gPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xuICAgICAgICAvLyBnZXQgdGhlIGVsZW1lbnQgdGhhdCBpcyBhY3R1YWxseSBzdXBwb3NlZCB0byBiZSBkcmFnZ2VkIGJ5XG4gICAgICAgIGxldCBoYW5kbGVOYW1lID0gb3B0aW9uLmhhbmRsZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHRoaXMuZHJhZ0VsID0gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGhhbmRsZU5hbWUpID8gZWwgOiBlbC5xdWVyeVNlbGVjdG9yKG9wdGlvbi5oYW5kbGUpIHx8IGVsO1xuICAgICAgICAvLyBjcmVhdGUgdmFyIGV2ZW50IGJpbmRpbmcgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgYW5kIHN0aWxsIGxvb2sgbGlrZSBUUyBtZXRob2RzICh1bmxpa2UgYW5vbnltb3VzIGZ1bmN0aW9ucylcbiAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdGhpcy5fbW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNlTW92ZSA9IHRoaXMuX21vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZVVwID0gdGhpcy5fbW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50KSB7XG4gICAgICAgIHN1cGVyLm9mZihldmVudCk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICAgICAgdGhpcy5kcmFnRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlcmRvd24pO1xuICAgICAgICAgICAgLy8gdGhpcy5kcmFnRWwuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7IC8vIG5vdCBuZWVkZWQgdW5saWtlIHBvaW50ZXJkb3duIGRvYyBjb21tZW50XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1kcmFnZ2FibGUtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZGlzYWJsZShmb3JEZXN0cm95ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5kcmFnRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlcmRvd24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yRGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndWktZHJhZ2dhYmxlLWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdUaW1lb3V0KVxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRyYWdUaW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZHJhZ1RpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgdGhpcy5fbW91c2VVcCh0aGlzLm1vdXNlRG93bkV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNhYmxlKHRydWUpO1xuICAgICAgICBkZWxldGUgdGhpcy5lbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGVscGVyO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb247XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlT3B0aW9uKG9wdHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaChrZXkgPT4gdGhpcy5vcHRpb25ba2V5XSA9IG9wdHNba2V5XSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGwgd2hlbiBtb3VzZSBnb2VzIGRvd24gYmVmb3JlIGEgZHJhZ3N0YXJ0IGhhcHBlbnMgKi9cbiAgICBfbW91c2VEb3duKGUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG4gICAgICAgIGlmIChERE1hbmFnZXIubW91c2VIYW5kbGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gb25seSBsZWZ0IGNsaWNrXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IGNsaWNraW5nIG9uIGtub3duIG9iamVjdCB0aGF0IGhhbmRsZXMgbW91c2VEb3duLCBvciBvbmVzIHN1cHBsaWVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KHNraXBNb3VzZURvd24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5jYW5jZWwpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KHRoaXMub3B0aW9uLmNhbmNlbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUkVNT1ZFOiB3aHkgd291bGQgd2UgZ2V0IHRoZSBldmVudCBpZiBpdCB3YXNuJ3QgZm9yIHVzIG9yIGNoaWxkID9cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBjbGlja2luZyBvbiBhIGRyYWcgaGFuZGxlIG9yIGNoaWxkIG9mIGl0Li4uXG4gICAgICAgIC8vIE5vdGU6IHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhhdCdzIGhhbmRsZSBpcyBhbiBpbW1lZGlhdGUgY2hpbGQsIGFzIG1vdXNlSGFuZGxlZCB3aWxsIHByZXZlbnQgcGFyZW50cyBmcm9tIGFsc28gaGFuZGxpbmcgaXQgKGxvd2VzdCB3aW5zKVxuICAgICAgICAvLyBsZXQgY2xhc3NOYW1lID0gdGhpcy5vcHRpb24uaGFuZGxlLnN1YnN0cmluZygxKTtcbiAgICAgICAgLy8gbGV0IGVsID0gZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIC8vIHdoaWxlIChlbCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHsgZWwgPSBlbC5wYXJlbnRFbGVtZW50OyB9XG4gICAgICAgIC8vIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgdGhpcy5tb3VzZURvd25FdmVudCA9IGU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xuICAgICAgICBkZWxldGUgRERNYW5hZ2VyLmRyYWdFbGVtZW50O1xuICAgICAgICBkZWxldGUgRERNYW5hZ2VyLmRyb3BFbGVtZW50O1xuICAgICAgICAvLyBkb2N1bWVudCBoYW5kbGVyIHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgbW92ZXMgYXMgdGhlIGl0ZW0gaXMgJ2ZpeGVkJyBwb3NpdGlvbiwgYW5kIGNhcHR1cmU9dHJ1ZSBzbyBXRSBnZXQgYSBmaXJzdCBjcmFja1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZU1vdmUsIHRydWUpOyAvLyB0cnVlPWNhcHR1cmUsIG5vdCBidWJibGVcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNlVXAsIHRydWUpO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gcHJldmVudERlZmF1bHQoKSBwcmV2ZW50cyBibHVyIGV2ZW50IHdoaWNoIG9jY3VycyBqdXN0IGFmdGVyIG1vdXNlZG93biBldmVudC5cbiAgICAgICAgLy8gaWYgYW4gZWRpdGFibGUgY29udGVudCBoYXMgZm9jdXMsIHRoZW4gYmx1ciBtdXN0IGJlIGNhbGxcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgRERNYW5hZ2VyLm1vdXNlSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIG1ldGhvZCB0byBjYWxsIGFjdHVhbCBkcmFnIGV2ZW50ICovXG4gICAgX2NhbGxEcmFnKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChlLCB7IHRhcmdldDogdGhpcy5lbCwgdHlwZTogJ2RyYWcnIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uZHJhZykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24uZHJhZyhldiwgdGhpcy51aSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZHJhZycsIGV2KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsZWQgd2hlbiB0aGUgbWFpbiBwYWdlIChhZnRlciBzdWNjZXNzZnVsIG1vdXNlZG93bikgcmVjZWl2ZXMgYSBtb3ZlIGV2ZW50IHRvIGRyYWcgdGhlIGl0ZW0gYXJvdW5kIHRoZSBzY3JlZW4gKi9cbiAgICBfbW91c2VNb3ZlKGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7Y291bnQrK30gbW92ZSAke2UueH0sJHtlLnl9YClcbiAgICAgICAgbGV0IHMgPSB0aGlzLm1vdXNlRG93bkV2ZW50O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0ZvbGxvdyhlKTtcbiAgICAgICAgICAgIC8vIGRlbGF5IGFjdHVhbCBncmlkIGhhbmRsaW5nIGRyYWcgdW50aWwgd2UgcGF1c2UgZm9yIGEgd2hpbGUgaWYgc2V0XG4gICAgICAgICAgICBpZiAoRERNYW5hZ2VyLnBhdXNlRHJhZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdXNlID0gTnVtYmVyLmlzSW50ZWdlcihERE1hbmFnZXIucGF1c2VEcmFnKSA/IERETWFuYWdlci5wYXVzZURyYWcgOiAxMDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1RpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kcmFnVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX2NhbGxEcmFnKGUpLCBwYXVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRHJhZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhlLnggLSBzLngpICsgTWF0aC5hYnMoZS55IC0gcy55KSA+IDMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZG9uJ3Qgc3RhcnQgdW5sZXNzIHdlJ3ZlIG1vdmVkIGF0IGxlYXN0IDMgcGl4ZWxzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgRERNYW5hZ2VyLmRyYWdFbGVtZW50ID0gdGhpcztcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGRyYWdnaW5nIGFuIGFjdHVhbCBncmlkIGl0ZW0sIHNldCB0aGUgY3VycmVudCBkcm9wIGFzIHRoZSBncmlkICh0byBkZXRlY3QgZW50ZXIvbGVhdmUpXG4gICAgICAgICAgICBsZXQgZ3JpZCA9IHRoaXMuZWwuZ3JpZHN0YWNrTm9kZT8uZ3JpZDtcbiAgICAgICAgICAgIGlmIChncmlkKSB7XG4gICAgICAgICAgICAgICAgRERNYW5hZ2VyLmRyb3BFbGVtZW50ID0gZ3JpZC5lbC5kZEVsZW1lbnQuZGREcm9wcGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgRERNYW5hZ2VyLmRyb3BFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWxwZXIgPSB0aGlzLl9jcmVhdGVIZWxwZXIoZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEhlbHBlckNvbnRhaW5tZW50U3R5bGUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldCA9IHRoaXMuX2dldERyYWdPZmZzZXQoZSwgdGhpcy5lbCwgdGhpcy5oZWxwZXJDb250YWlubWVudCk7XG4gICAgICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChlLCB7IHRhcmdldDogdGhpcy5lbCwgdHlwZTogJ2RyYWdzdGFydCcgfSk7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEhlbHBlclN0eWxlKGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb24uc3RhcnQoZXYsIHRoaXMudWkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gbmVlZGVkIG90aGVyd2lzZSB3ZSBnZXQgdGV4dCBzd2VlcCB0ZXh0IHNlbGVjdGlvbiBhcyB3ZSBkcmFnIGFyb3VuZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsIHdoZW4gdGhlIG1vdXNlIGdldHMgcmVsZWFzZWQgdG8gZHJvcCB0aGUgaXRlbSBhdCBjdXJyZW50IGxvY2F0aW9uICovXG4gICAgX21vdXNlVXAoZSkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZU1vdmUsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGRyb3AgdGFyZ2V0IGlmIGRyYWdnaW5nIG92ZXIgb3Vyc2VsZiAoYWxyZWFkeSBwYXJlbnRlZCwganVzdCBtb3ZpbmcgZHVyaW5nIHN0b3AgY2FsbGJhY2sgYmVsb3cpXG4gICAgICAgICAgICBpZiAoRERNYW5hZ2VyLmRyb3BFbGVtZW50Py5lbCA9PT0gdGhpcy5lbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcm9wRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVscGVyQ29udGFpbm1lbnQuc3R5bGUucG9zaXRpb24gPSB0aGlzLnBhcmVudE9yaWdpblN0eWxlUG9zaXRpb24gfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbHBlciA9PT0gdGhpcy5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUhlbHBlclN0eWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ID0gVXRpbHMuaW5pdEV2ZW50KGUsIHsgdGFyZ2V0OiB0aGlzLmVsLCB0eXBlOiAnZHJhZ3N0b3AnIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uLnN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbi5zdG9wKGV2KTsgLy8gTk9URTogZGVzdHJveSgpIHdpbGwgYmUgY2FsbGVkIHdoZW4gcmVtb3ZpbmcgaXRlbSwgc28gZXhwZWN0IE5VTEwgcHRyIGFmdGVyIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2RyYWdzdG9wJywgZXYpO1xuICAgICAgICAgICAgLy8gY2FsbCB0aGUgZHJvcHBhYmxlIG1ldGhvZCB0byByZWNlaXZlIHRoZSBpdGVtXG4gICAgICAgICAgICBpZiAoRERNYW5hZ2VyLmRyb3BFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgRERNYW5hZ2VyLmRyb3BFbGVtZW50LmRyb3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaGVscGVyO1xuICAgICAgICBkZWxldGUgdGhpcy5tb3VzZURvd25FdmVudDtcbiAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcmFnRWxlbWVudDtcbiAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcm9wRWxlbWVudDtcbiAgICAgICAgZGVsZXRlIERETWFuYWdlci5tb3VzZUhhbmRsZWQ7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjcmVhdGUgYSBjbG9uZSBjb3B5IChvciB1c2VyIGRlZmluZWQgbWV0aG9kKSBvZiB0aGUgb3JpZ2luYWwgZHJhZyBpdGVtIGlmIHNldCAqL1xuICAgIF9jcmVhdGVIZWxwZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IGhlbHBlciA9IHRoaXMuZWw7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb24uaGVscGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBoZWxwZXIgPSB0aGlzLm9wdGlvbi5oZWxwZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uLmhlbHBlciA9PT0gJ2Nsb25lJykge1xuICAgICAgICAgICAgaGVscGVyID0gVXRpbHMuY2xvbmVOb2RlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhoZWxwZXIpKSB7XG4gICAgICAgICAgICBVdGlscy5hcHBlbmRUbyhoZWxwZXIsIHRoaXMub3B0aW9uLmFwcGVuZFRvID09PSAncGFyZW50JyA/IHRoaXMuZWwucGFyZW50RWxlbWVudCA6IHRoaXMub3B0aW9uLmFwcGVuZFRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVscGVyID09PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbGVtZW50T3JpZ2luU3R5bGUgPSBERERyYWdnYWJsZS5vcmlnaW5TdHlsZVByb3AubWFwKHByb3AgPT4gdGhpcy5lbC5zdHlsZVtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBlcjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBzZXQgdGhlIGZpeCBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBpdGVtICovXG4gICAgX3NldHVwSGVscGVyU3R5bGUoZSkge1xuICAgICAgICB0aGlzLmhlbHBlci5jbGFzc0xpc3QuYWRkKCd1aS1kcmFnZ2FibGUtZHJhZ2dpbmcnKTtcbiAgICAgICAgLy8gVE9ETzogc2V0IGFsbCBhdCBvbmNlIHdpdGggc3R5bGUuY3NzVGV4dCArPSAuLi4gPyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY4NTkzXG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5oZWxwZXIuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7IC8vIG5lZWRlZCBmb3Igb3ZlciBpdGVtcyB0byBnZXQgZW50ZXIvbGVhdmVcbiAgICAgICAgLy8gc3R5bGUuY3Vyc29yID0gJ21vdmUnOyAvLyAgVE9ETzogY2FuJ3Qgc2V0IHdpdGggcG9pbnRlckV2ZW50cz1ub25lICEgKGRvbmUgaW4gQ1NTIGFzIHdlbGwpXG4gICAgICAgIHN0eWxlLndpZHRoID0gdGhpcy5kcmFnT2Zmc2V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gdGhpcy5kcmFnT2Zmc2V0LmhlaWdodCArICdweCc7XG4gICAgICAgIHN0eWxlLndpbGxDaGFuZ2UgPSAnbGVmdCwgdG9wJztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnOyAvLyBsZXQgdXMgZHJhZyBiZXR3ZWVuIGdyaWRzIGJ5IG5vdCBjbGlwcGluZyBhcyBwYXJlbnQgLmdyaWQtc3RhY2sgaXMgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgdGhpcy5fZHJhZ0ZvbGxvdyhlKTsgLy8gbm93IHBvc2l0aW9uIGl0XG4gICAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7IC8vIHNob3cgdXAgaW5zdGFudGx5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVscGVyKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNpdGlvbiA9IG51bGw7IC8vIHJlY292ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCByZXN0b3JlIGJhY2sgdGhlIG9yaWdpbmFsIHN0eWxlIGJlZm9yZSBkcmFnZ2luZyAqL1xuICAgIF9yZW1vdmVIZWxwZXJTdHlsZSgpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndWktZHJhZ2dhYmxlLWRyYWdnaW5nJyk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWxwZXI/LmdyaWRzdGFja05vZGU7XG4gICAgICAgIC8vIGRvbid0IGJvdGhlciByZXN0b3Jpbmcgc3R5bGVzIGlmIHdlJ3JlIGdvbm5hIHJlbW92ZSBhbnl3YXkuLi5cbiAgICAgICAgaWYgKCFub2RlPy5faXNBYm91dFRvUmVtb3ZlICYmIHRoaXMuZHJhZ0VsZW1lbnRPcmlnaW5TdHlsZSkge1xuICAgICAgICAgICAgbGV0IGhlbHBlciA9IHRoaXMuaGVscGVyO1xuICAgICAgICAgICAgLy8gZG9uJ3QgYW5pbWF0ZSwgb3RoZXJ3aXNlIHdlIGFuaW1hdGUgb2Zmc2V0ZWQgd2hlbiBzd2l0Y2hpbmcgYmFjayB0byAnYWJzb2x1dGUnIGZyb20gJ2ZpeGVkJy5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgYWxzbyByZW1vdmVzIHJlc2l6aW5nIGFuaW1hdGlvbiB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBpc3N1ZSwgYnV0IG90aGVycy5cbiAgICAgICAgICAgIC8vIElkZWFsbHkgYm90aCB3b3VsZCBhbmltYXRlICgnbW92ZScgd291bGQgaW1tZWRpYXRlbHkgcmVzdG9yZSAnYWJzb2x1dGUnIGFuZCBhZGp1c3QgY29vcmRpbmF0ZSB0byBtYXRjaCxcbiAgICAgICAgICAgIC8vIHRoZW4gdHJpZ2dlciBhIGRlbGF5IChyZXBhaW50KSB0byByZXN0b3JlIHRvIGZpbmFsIGRlc3Qgd2l0aCBhbmltYXRlKSBidXQgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSAncmVzaXplc3RvcCdcbiAgICAgICAgICAgIC8vIGlzIGNhbGxlZCBBRlRFUiAndHJhbnNpdGlvbmVuZCcgZXZlbnQgaXMgcmVjZWl2ZWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9pc3N1ZXMvMjAzMylcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uID0gdGhpcy5kcmFnRWxlbWVudE9yaWdpblN0eWxlWyd0cmFuc2l0aW9uJ10gfHwgbnVsbDtcbiAgICAgICAgICAgIGhlbHBlci5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5kcmFnRWxlbWVudE9yaWdpblN0eWxlWyd0cmFuc2l0aW9uJ10gPSAnbm9uZSc7IC8vIGNhbid0IGJlIE5VTEwgIzE5NzNcbiAgICAgICAgICAgIERERHJhZ2dhYmxlLm9yaWdpblN0eWxlUHJvcC5mb3JFYWNoKHByb3AgPT4gaGVscGVyLnN0eWxlW3Byb3BdID0gdGhpcy5kcmFnRWxlbWVudE9yaWdpblN0eWxlW3Byb3BdIHx8IG51bGwpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBoZWxwZXIuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb24sIDUwKTsgLy8gcmVjb3ZlciBhbmltYXRpb24gZnJvbSBzYXZlZCB2YXJzIGFmdGVyIGEgcGF1c2UgKDAgaXNuJ3QgZW5vdWdoICMxOTczKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRyYWdFbGVtZW50T3JpZ2luU3R5bGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIHVwZGF0ZXMgdGhlIHRvcC9sZWZ0IHBvc2l0aW9uIHRvIGZvbGxvdyB0aGUgbW91c2UgKi9cbiAgICBfZHJhZ0ZvbGxvdyhlKSB7XG4gICAgICAgIGxldCBjb250YWlubWVudFJlY3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICAvLyBpZiAodGhpcy5oZWxwZXIuc3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHsgLy8gd2UgdXNlICdmaXhlZCdcbiAgICAgICAgLy8gICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gdGhpcy5oZWxwZXJDb250YWlubWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gICBjb250YWlubWVudFJlY3QgPSB7IGxlZnQsIHRvcCB9O1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5oZWxwZXIuc3R5bGU7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZHJhZ09mZnNldDtcbiAgICAgICAgc3R5bGUubGVmdCA9IGUuY2xpZW50WCArIG9mZnNldC5vZmZzZXRMZWZ0IC0gY29udGFpbm1lbnRSZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS50b3AgPSBlLmNsaWVudFkgKyBvZmZzZXQub2Zmc2V0VG9wIC0gY29udGFpbm1lbnRSZWN0LnRvcCArICdweCc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2V0dXBIZWxwZXJDb250YWlubWVudFN0eWxlKCkge1xuICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXIucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuaGVscGVyLnN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE9yaWdpblN0eWxlUG9zaXRpb24gPSB0aGlzLmhlbHBlckNvbnRhaW5tZW50LnN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcy5oZWxwZXJDb250YWlubWVudCkucG9zaXRpb24ubWF0Y2goL3N0YXRpYy8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJDb250YWlubWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0RHJhZ09mZnNldChldmVudCwgZWwsIHBhcmVudCkge1xuICAgICAgICAvLyBpbiBjYXNlIGFuY2VzdG9yIGhhcyB0cmFuc2Zvcm0vcGVyc3BlY3RpdmUgY3NzIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgdGhlIHZpZXdwb2ludFxuICAgICAgICBsZXQgeGZvcm1PZmZzZXRYID0gMDtcbiAgICAgICAgbGV0IHhmb3JtT2Zmc2V0WSA9IDA7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgVXRpbHMuYWRkRWxTdHlsZXModGVzdEVsLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzAnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHRvcDogMCArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdDogMCArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxcHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzFweCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiAnLTk5OTk5OScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0ZXN0RWwpO1xuICAgICAgICAgICAgY29uc3QgdGVzdEVsUG9zaXRpb24gPSB0ZXN0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGVzdEVsKTtcbiAgICAgICAgICAgIHhmb3JtT2Zmc2V0WCA9IHRlc3RFbFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICB4Zm9ybU9mZnNldFkgPSB0ZXN0RWxQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAvLyBUT0RPOiBzY2FsZSA/XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcbiAgICAgICAgICAgIHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcbiAgICAgICAgICAgIG9mZnNldExlZnQ6IC1ldmVudC5jbGllbnRYICsgdGFyZ2V0T2Zmc2V0LmxlZnQgLSB4Zm9ybU9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRUb3A6IC1ldmVudC5jbGllbnRZICsgdGFyZ2V0T2Zmc2V0LnRvcCAtIHhmb3JtT2Zmc2V0WSxcbiAgICAgICAgICAgIHdpZHRoOiB0YXJnZXRPZmZzZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRhcmdldE9mZnNldC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBUT0RPOiBzZXQgdG8gcHVibGljIGFzIGNhbGxlZCBieSBERERyb3BwYWJsZSEgKi9cbiAgICB1aSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbm1lbnRFbCA9IHRoaXMuZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGFpbm1lbnRSZWN0ID0gY29udGFpbm1lbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5oZWxwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIGNvbnRhaW5tZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBjb250YWlubWVudFJlY3QubGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogbm90IHVzZWQgYnkgR3JpZFN0YWNrIGZvciBub3cuLi5cbiAgICAgICAgICAgIGhlbHBlcjogW3RoaXMuaGVscGVyXSwgLy9UaGUgb2JqZWN0IGFyciByZXByZXNlbnRpbmcgdGhlIGhlbHBlciB0aGF0J3MgYmVpbmcgZHJhZ2dlZC5cbiAgICAgICAgICAgIG9mZnNldDogeyB0b3A6IG9mZnNldC50b3AsIGxlZnQ6IG9mZnNldC5sZWZ0IH0gLy8gQ3VycmVudCBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBhcyB7IHRvcCwgbGVmdCB9IG9iamVjdC5cbiAgICAgICAgICAgICovXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIGNoYW5nZSBkdXJpbmcgZHJhZ2dpbmcsIGFuZCByZXN0b3JlIGJhY2sgKi9cbkRERHJhZ2dhYmxlLm9yaWdpblN0eWxlUHJvcCA9IFsndHJhbnNpdGlvbicsICdwb2ludGVyRXZlbnRzJywgJ3Bvc2l0aW9uJywgJ2xlZnQnLCAndG9wJywgJ21pbldpZHRoJywgJ3dpbGxDaGFuZ2UnXTtcbmV4cG9ydCB7IERERHJhZ2dhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZC1kcmFnZ2FibGUuanMubWFwIl0sIm5hbWVzIjpbIkRETWFuYWdlciIsIlV0aWxzIiwiRERCYXNlSW1wbGVtZW50IiwiaXNUb3VjaCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hzdGFydCIsInBvaW50ZXJkb3duIiwic2tpcE1vdXNlRG93biIsIkRERHJhZ2dhYmxlIiwib24iLCJldmVudCIsImNhbGxiYWNrIiwib2ZmIiwiZW5hYmxlIiwiZGlzYWJsZWQiLCJkcmFnRWwiLCJhZGRFdmVudExpc3RlbmVyIiwiX21vdXNlRG93biIsImVsIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiZGlzYWJsZSIsImZvckRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkIiwiZGVzdHJveSIsImRyYWdUaW1lb3V0Iiwid2luZG93IiwiY2xlYXJUaW1lb3V0IiwiZHJhZ2dpbmciLCJfbW91c2VVcCIsIm1vdXNlRG93bkV2ZW50IiwiaGVscGVyIiwib3B0aW9uIiwidXBkYXRlT3B0aW9uIiwib3B0cyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZSIsIm1vdXNlSGFuZGxlZCIsImJ1dHRvbiIsInRhcmdldCIsImNsb3Nlc3QiLCJjYW5jZWwiLCJkcmFnRWxlbWVudCIsImRyb3BFbGVtZW50IiwiZG9jdW1lbnQiLCJfbW91c2VNb3ZlIiwicHJldmVudERlZmF1bHQiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsIl9jYWxsRHJhZyIsImV2IiwiaW5pdEV2ZW50IiwidHlwZSIsImRyYWciLCJ1aSIsInRyaWdnZXJFdmVudCIsInMiLCJfZHJhZ0ZvbGxvdyIsInBhdXNlRHJhZyIsInBhdXNlIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic2V0VGltZW91dCIsIk1hdGgiLCJhYnMiLCJ4IiwieSIsImdyaWQiLCJncmlkc3RhY2tOb2RlIiwiZGRFbGVtZW50IiwiZGREcm9wcGFibGUiLCJfY3JlYXRlSGVscGVyIiwiX3NldHVwSGVscGVyQ29udGFpbm1lbnRTdHlsZSIsImRyYWdPZmZzZXQiLCJfZ2V0RHJhZ09mZnNldCIsImhlbHBlckNvbnRhaW5tZW50IiwiX3NldHVwSGVscGVyU3R5bGUiLCJzdGFydCIsInBhcmVudEVsZW1lbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwicGFyZW50T3JpZ2luU3R5bGVQb3NpdGlvbiIsIl9yZW1vdmVIZWxwZXJTdHlsZSIsInN0b3AiLCJkcm9wIiwiY2xvbmVOb2RlIiwiYm9keSIsImNvbnRhaW5zIiwiYXBwZW5kVG8iLCJkcmFnRWxlbWVudE9yaWdpblN0eWxlIiwib3JpZ2luU3R5bGVQcm9wIiwibWFwIiwicHJvcCIsInBvaW50ZXJFdmVudHMiLCJ3aWR0aCIsImhlaWdodCIsIndpbGxDaGFuZ2UiLCJ0cmFuc2l0aW9uIiwibm9kZSIsIl9pc0Fib3V0VG9SZW1vdmUiLCJjb250YWlubWVudFJlY3QiLCJsZWZ0IiwidG9wIiwib2Zmc2V0IiwiY2xpZW50WCIsIm9mZnNldExlZnQiLCJjbGllbnRZIiwib2Zmc2V0VG9wIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm1hdGNoIiwicGFyZW50IiwieGZvcm1PZmZzZXRYIiwieGZvcm1PZmZzZXRZIiwidGVzdEVsIiwiY3JlYXRlRWxlbWVudCIsImFkZEVsU3R5bGVzIiwib3BhY2l0eSIsInpJbmRleCIsImFwcGVuZENoaWxkIiwidGVzdEVsUG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZW1vdmVDaGlsZCIsInRhcmdldE9mZnNldCIsImNvbnRhaW5tZW50RWwiLCJjb25zdHJ1Y3RvciIsImhhbmRsZU5hbWUiLCJoYW5kbGUiLCJzdWJzdHJpbmciLCJxdWVyeVNlbGVjdG9yIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-draggable.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-droppable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-droppable.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDroppable: function() { return /* binding */ DDDroppable; }\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-droppable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\n// let count = 0; // TEST\nclass DDDroppable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        if (this.disabled === false) return;\n        super.enable();\n        this.el.classList.add(\"ui-droppable\");\n        this.el.classList.remove(\"ui-droppable-disabled\");\n        this.el.addEventListener(\"mouseenter\", this._mouseEnter);\n        this.el.addEventListener(\"mouseleave\", this._mouseLeave);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.el.addEventListener(\"pointerenter\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n            this.el.addEventListener(\"pointerleave\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n        }\n    }\n    disable() {\n        let forDestroy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        if (this.disabled === true) return;\n        super.disable();\n        this.el.classList.remove(\"ui-droppable\");\n        if (!forDestroy) this.el.classList.add(\"ui-droppable-disabled\");\n        this.el.removeEventListener(\"mouseenter\", this._mouseEnter);\n        this.el.removeEventListener(\"mouseleave\", this._mouseLeave);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.el.removeEventListener(\"pointerenter\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n            this.el.removeEventListener(\"pointerleave\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n        }\n    }\n    destroy() {\n        this.disable(true);\n        this.el.classList.remove(\"ui-droppable\");\n        this.el.classList.remove(\"ui-droppable-disabled\");\n        super.destroy();\n    }\n    updateOption(opts) {\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        this._setupAccept();\n        return this;\n    }\n    /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */ _mouseEnter(e) {\n        // console.log(`${count++} Enter ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) return;\n        if (!this._canDrop(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement.el)) return;\n        e.preventDefault();\n        e.stopPropagation();\n        // make sure when we enter this, that the last one gets a leave FIRST to correctly cleanup as we don't always do\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement && _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) {\n            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement._mouseLeave(e);\n        }\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = this;\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"dropover\"\n        });\n        if (this.option.over) {\n            this.option.over(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"dropover\", ev);\n        this.el.classList.add(\"ui-droppable-over\");\n    // console.log('tracking'); // TEST\n    }\n    /** @internal called when the item is leaving our area, stop tracking if we had moving item */ _mouseLeave(e) {\n        // console.log(`${count++} Leave ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement || _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) return;\n        e.preventDefault();\n        e.stopPropagation();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"dropout\"\n        });\n        if (this.option.out) {\n            this.option.out(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"dropout\", ev);\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement === this) {\n            delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            // console.log('not tracking'); // TEST\n            // if we're still over a parent droppable, send it an enter as we don't get one from leaving nested children\n            let parentDrop;\n            let parent = this.el.parentElement;\n            while(!parentDrop && parent){\n                var _parent_ddElement;\n                parentDrop = (_parent_ddElement = parent.ddElement) === null || _parent_ddElement === void 0 ? void 0 : _parent_ddElement.ddDroppable;\n                parent = parent.parentElement;\n            }\n            if (parentDrop) {\n                parentDrop._mouseEnter(e);\n            }\n        }\n    }\n    /** item is being dropped on us - called by the drag mouseup handler - this calls the client drop event */ drop(e) {\n        e.preventDefault();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"drop\"\n        });\n        if (this.option.drop) {\n            this.option.drop(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"drop\", ev);\n    }\n    /** @internal true if element matches the string/method accept option */ _canDrop(el) {\n        return el && (!this.accept || this.accept(el));\n    }\n    /** @internal */ _setupAccept() {\n        if (!this.option.accept) return this;\n        if (typeof this.option.accept === \"string\") {\n            this.accept = (el)=>el.classList.contains(this.option.accept) || el.matches(this.option.accept);\n        } else {\n            this.accept = this.option.accept;\n        }\n        return this;\n    }\n    /** @internal */ _ui(drag) {\n        return {\n            draggable: drag.el,\n            ...drag.ui()\n        };\n    }\n    constructor(el, opts = {}){\n        super();\n        this.el = el;\n        this.option = opts;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseEnter = this._mouseEnter.bind(this);\n        this._mouseLeave = this._mouseLeave.bind(this);\n        this.enable();\n        this._setupAccept();\n    }\n} //# sourceMappingURL=dd-droppable.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZHJvcHBhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3dDO0FBQ1E7QUFDakI7QUFDaUM7QUFDakUseUJBQXlCO0FBQ2xCLE1BQU1NLG9CQUFvQkwsMERBQWVBO0lBVzVDTSxHQUFHQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTtRQUNoQixLQUFLLENBQUNGLEdBQUdDLE9BQU9DO0lBQ3BCO0lBQ0FDLElBQUlGLEtBQUssRUFBRTtRQUNQLEtBQUssQ0FBQ0UsSUFBSUY7SUFDZDtJQUNBRyxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxPQUNsQjtRQUNKLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNFLEVBQUUsQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDRixFQUFFLENBQUNDLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDO1FBQ3pCLElBQUksQ0FBQ0gsRUFBRSxDQUFDSSxnQkFBZ0IsQ0FBQyxjQUFjLElBQUksQ0FBQ0MsV0FBVztRQUN2RCxJQUFJLENBQUNMLEVBQUUsQ0FBQ0ksZ0JBQWdCLENBQUMsY0FBYyxJQUFJLENBQUNFLFdBQVc7UUFDdkQsSUFBSWhCLDhDQUFPQSxFQUFFO1lBQ1QsSUFBSSxDQUFDVSxFQUFFLENBQUNJLGdCQUFnQixDQUFDLGdCQUFnQmIsbURBQVlBO1lBQ3JELElBQUksQ0FBQ1MsRUFBRSxDQUFDSSxnQkFBZ0IsQ0FBQyxnQkFBZ0JaLG1EQUFZQTtRQUN6RDtJQUNKO0lBQ0FlLFVBQTRCO1lBQXBCQyxhQUFBQSxpRUFBYTtRQUNqQixJQUFJLElBQUksQ0FBQ1QsUUFBUSxLQUFLLE1BQ2xCO1FBQ0osS0FBSyxDQUFDUTtRQUNOLElBQUksQ0FBQ1AsRUFBRSxDQUFDQyxTQUFTLENBQUNFLE1BQU0sQ0FBQztRQUN6QixJQUFJLENBQUNLLFlBQ0QsSUFBSSxDQUFDUixFQUFFLENBQUNDLFNBQVMsQ0FBQ0MsR0FB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USxDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3NCLE1BQU0sS0FBS3ZDLEdBQUd5QyxPQUFPLENBQUMsSUFBSSxDQUFDeEIsTUFBTSxDQUFDc0IsTUFBTTtRQUNwRyxPQUNLO1lBQ0QsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSSxDQUFDdEIsTUFBTSxDQUFDc0IsTUFBTTtRQUNwQztRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0EsY0FBYyxHQUNkVCxJQUFJWSxJQUFJLEVBQUU7UUFDTixPQUFPO1lBQ0hDLFdBQVdELEtBQUsxQyxFQUFFO1lBQ2xCLEdBQUcwQyxLQUFLRSxFQUFFLEVBQUU7UUFDaEI7SUFDSjtJQXRJQUMsWUFBWTdDLEVBQUUsRUFBRVksT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUN2QixLQUFLO1FBQ0wsSUFBSSxDQUFDWixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDaUIsTUFBTSxHQUFHTDtRQUNkLCtHQUErRztRQUMvRyxJQUFJLENBQUNQLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVcsQ0FBQ3lDLElBQUksQ0FBQyxJQUFJO1FBQzdDLElBQUksQ0FBQ3hDLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVcsQ0FBQ3dDLElBQUksQ0FBQyxJQUFJO1FBQzdDLElBQUksQ0FBQ2hELE1BQU07UUFDWCxJQUFJLENBQUNvQixZQUFZO0lBQ3JCO0FBOEhKLEVBQ0Esd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1kcm9wcGFibGUuanM/ZGIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLWRyb3BwYWJsZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IERETWFuYWdlciB9IGZyb20gJy4vZGQtbWFuYWdlcic7XG5pbXBvcnQgeyBEREJhc2VJbXBsZW1lbnQgfSBmcm9tICcuL2RkLWJhc2UtaW1wbCc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgaXNUb3VjaCwgcG9pbnRlcmVudGVyLCBwb2ludGVybGVhdmUgfSBmcm9tICcuL2RkLXRvdWNoJztcbi8vIGxldCBjb3VudCA9IDA7IC8vIFRFU1RcbmV4cG9ydCBjbGFzcyBERERyb3BwYWJsZSBleHRlbmRzIEREQmFzZUltcGxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0cztcbiAgICAgICAgLy8gY3JlYXRlIHZhciBldmVudCBiaW5kaW5nIHNvIHdlIGNhbiBlYXNpbHkgcmVtb3ZlIGFuZCBzdGlsbCBsb29rIGxpa2UgVFMgbWV0aG9kcyAodW5saWtlIGFub255bW91cyBmdW5jdGlvbnMpXG4gICAgICAgIHRoaXMuX21vdXNlRW50ZXIgPSB0aGlzLl9tb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNlTGVhdmUgPSB0aGlzLl9tb3VzZUxlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIHRoaXMuX3NldHVwQWNjZXB0KCk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlci5vbihldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBvZmYoZXZlbnQpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50KTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLmVuYWJsZSgpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLWRyb3BwYWJsZScpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWRyb3BwYWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9tb3VzZUVudGVyKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fbW91c2VMZWF2ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJlbnRlcicsIHBvaW50ZXJlbnRlcik7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHBvaW50ZXJsZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzYWJsZShmb3JEZXN0cm95ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1kcm9wcGFibGUnKTtcbiAgICAgICAgaWYgKCFmb3JEZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd1aS1kcm9wcGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fbW91c2VFbnRlcik7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX21vdXNlTGVhdmUpO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZW50ZXInLCBwb2ludGVyZW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCBwb2ludGVybGVhdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSh0cnVlKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1kcm9wcGFibGUnKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1kcm9wcGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVPcHRpb24ob3B0cykge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRzKS5mb3JFYWNoKGtleSA9PiB0aGlzLm9wdGlvbltrZXldID0gb3B0c1trZXldKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBY2NlcHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHdoZW4gdGhlIGN1cnNvciBlbnRlcnMgb3VyIGFyZWEgLSBwcmVwYXJlIGZvciBhIHBvc3NpYmxlIGRyb3AgYW5kIHRyYWNrIGxlYXZpbmcgKi9cbiAgICBfbW91c2VFbnRlcihlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IEVudGVyICR7dGhpcy5lbC5pZCB8fCAodGhpcy5lbCBhcyBHcmlkSFRNTEVsZW1lbnQpLmdyaWRzdGFjay5vcHRzLmlkfWApOyAvLyBURVNUXG4gICAgICAgIGlmICghRERNYW5hZ2VyLmRyYWdFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX2NhbkRyb3AoRERNYW5hZ2VyLmRyYWdFbGVtZW50LmVsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2hlbiB3ZSBlbnRlciB0aGlzLCB0aGF0IHRoZSBsYXN0IG9uZSBnZXRzIGEgbGVhdmUgRklSU1QgdG8gY29ycmVjdGx5IGNsZWFudXAgYXMgd2UgZG9uJ3QgYWx3YXlzIGRvXG4gICAgICAgIGlmIChERE1hbmFnZXIuZHJvcEVsZW1lbnQgJiYgRERNYW5hZ2VyLmRyb3BFbGVtZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBERE1hbmFnZXIuZHJvcEVsZW1lbnQuX21vdXNlTGVhdmUoZSk7XG4gICAgICAgIH1cbiAgICAgICAgRERNYW5hZ2VyLmRyb3BFbGVtZW50ID0gdGhpcztcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZSwgeyB0YXJnZXQ6IHRoaXMuZWwsIHR5cGU6ICdkcm9wb3ZlcicgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5vdmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5vdmVyKGV2LCB0aGlzLl91aShERE1hbmFnZXIuZHJhZ0VsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZHJvcG92ZXInLCBldik7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndWktZHJvcHBhYmxlLW92ZXInKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RyYWNraW5nJyk7IC8vIFRFU1RcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsZWQgd2hlbiB0aGUgaXRlbSBpcyBsZWF2aW5nIG91ciBhcmVhLCBzdG9wIHRyYWNraW5nIGlmIHdlIGhhZCBtb3ZpbmcgaXRlbSAqL1xuICAgIF9tb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7Y291bnQrK30gTGVhdmUgJHt0aGlzLmVsLmlkIHx8ICh0aGlzLmVsIGFzIEdyaWRIVE1MRWxlbWVudCkuZ3JpZHN0YWNrLm9wdHMuaWR9YCk7IC8vIFRFU1RcbiAgICAgICAgaWYgKCFERE1hbmFnZXIuZHJhZ0VsZW1lbnQgfHwgRERNYW5hZ2VyLmRyb3BFbGVtZW50ICE9PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGV2ID0gVXRpbHMuaW5pdEV2ZW50KGUsIHsgdGFyZ2V0OiB0aGlzLmVsLCB0eXBlOiAnZHJvcG91dCcgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5vdXQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLm91dChldiwgdGhpcy5fdWkoRERNYW5hZ2VyLmRyYWdFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Ryb3BvdXQnLCBldik7XG4gICAgICAgIGlmIChERE1hbmFnZXIuZHJvcEVsZW1lbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBERE1hbmFnZXIuZHJvcEVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbm90IHRyYWNraW5nJyk7IC8vIFRFU1RcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIG92ZXIgYSBwYXJlbnQgZHJvcHBhYmxlLCBzZW5kIGl0IGFuIGVudGVyIGFzIHdlIGRvbid0IGdldCBvbmUgZnJvbSBsZWF2aW5nIG5lc3RlZCBjaGlsZHJlblxuICAgICAgICAgICAgbGV0IHBhcmVudERyb3A7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnREcm9wICYmIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudERyb3AgPSBwYXJlbnQuZGRFbGVtZW50Py5kZERyb3BwYWJsZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnREcm9wKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RHJvcC5fbW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogaXRlbSBpcyBiZWluZyBkcm9wcGVkIG9uIHVzIC0gY2FsbGVkIGJ5IHRoZSBkcmFnIG1vdXNldXAgaGFuZGxlciAtIHRoaXMgY2FsbHMgdGhlIGNsaWVudCBkcm9wIGV2ZW50ICovXG4gICAgZHJvcChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZSwgeyB0YXJnZXQ6IHRoaXMuZWwsIHR5cGU6ICdkcm9wJyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLmRyb3ApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLmRyb3AoZXYsIHRoaXMuX3VpKERETWFuYWdlci5kcmFnRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdkcm9wJywgZXYpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIHRydWUgaWYgZWxlbWVudCBtYXRjaGVzIHRoZSBzdHJpbmcvbWV0aG9kIGFjY2VwdCBvcHRpb24gKi9cbiAgICBfY2FuRHJvcChlbCkge1xuICAgICAgICByZXR1cm4gZWwgJiYgKCF0aGlzLmFjY2VwdCB8fCB0aGlzLmFjY2VwdChlbCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldHVwQWNjZXB0KCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uLmFjY2VwdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uLmFjY2VwdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0ID0gKGVsKSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb24uYWNjZXB0KSB8fCBlbC5tYXRjaGVzKHRoaXMub3B0aW9uLmFjY2VwdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdCA9IHRoaXMub3B0aW9uLmFjY2VwdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91aShkcmFnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IGRyYWcuZWwsXG4gICAgICAgICAgICAuLi5kcmFnLnVpKClcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZC1kcm9wcGFibGUuanMubWFwIl0sIm5hbWVzIjpbIkRETWFuYWdlciIsIkREQmFzZUltcGxlbWVudCIsIlV0aWxzIiwiaXNUb3VjaCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsIkRERHJvcHBhYmxlIiwib24iLCJldmVudCIsImNhbGxiYWNrIiwib2ZmIiwiZW5hYmxlIiwiZGlzYWJsZWQiLCJlbCIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfbW91c2VFbnRlciIsIl9tb3VzZUxlYXZlIiwiZGlzYWJsZSIsImZvckRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInVwZGF0ZU9wdGlvbiIsIm9wdHMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm9wdGlvbiIsIl9zZXR1cEFjY2VwdCIsImUiLCJkcmFnRWxlbWVudCIsIl9jYW5Ecm9wIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJkcm9wRWxlbWVudCIsImV2IiwiaW5pdEV2ZW50IiwidGFyZ2V0IiwidHlwZSIsIm92ZXIiLCJfdWkiLCJ0cmlnZ2VyRXZlbnQiLCJvdXQiLCJwYXJlbnREcm9wIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImRkRWxlbWVudCIsImRkRHJvcHBhYmxlIiwiZHJvcCIsImFjY2VwdCIsImNvbnRhaW5zIiwibWF0Y2hlcyIsImRyYWciLCJkcmFnZ2FibGUiLCJ1aSIsImNvbnN0cnVjdG9yIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-droppable.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-element.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-element.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDElement: function() { return /* binding */ DDElement; }\n/* harmony export */ });\n/* harmony import */ var _dd_resizable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable */ \"./node_modules/gridstack/dist/dd-resizable.js\");\n/* harmony import */ var _dd_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-draggable */ \"./node_modules/gridstack/dist/dd-draggable.js\");\n/* harmony import */ var _dd_droppable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-droppable */ \"./node_modules/gridstack/dist/dd-droppable.js\");\n/**\n * dd-elements.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n\n\nclass DDElement {\n    static init(el) {\n        if (!el.ddElement) {\n            el.ddElement = new DDElement(el);\n        }\n        return el.ddElement;\n    }\n    on(eventName, callback) {\n        if (this.ddDraggable && [\n            \"drag\",\n            \"dragstart\",\n            \"dragstop\"\n        ].indexOf(eventName) > -1) {\n            this.ddDraggable.on(eventName, callback);\n        } else if (this.ddDroppable && [\n            \"drop\",\n            \"dropover\",\n            \"dropout\"\n        ].indexOf(eventName) > -1) {\n            this.ddDroppable.on(eventName, callback);\n        } else if (this.ddResizable && [\n            \"resizestart\",\n            \"resize\",\n            \"resizestop\"\n        ].indexOf(eventName) > -1) {\n            this.ddResizable.on(eventName, callback);\n        }\n        return this;\n    }\n    off(eventName) {\n        if (this.ddDraggable && [\n            \"drag\",\n            \"dragstart\",\n            \"dragstop\"\n        ].indexOf(eventName) > -1) {\n            this.ddDraggable.off(eventName);\n        } else if (this.ddDroppable && [\n            \"drop\",\n            \"dropover\",\n            \"dropout\"\n        ].indexOf(eventName) > -1) {\n            this.ddDroppable.off(eventName);\n        } else if (this.ddResizable && [\n            \"resizestart\",\n            \"resize\",\n            \"resizestop\"\n        ].indexOf(eventName) > -1) {\n            this.ddResizable.off(eventName);\n        }\n        return this;\n    }\n    setupDraggable(opts) {\n        if (!this.ddDraggable) {\n            this.ddDraggable = new _dd_draggable__WEBPACK_IMPORTED_MODULE_1__.DDDraggable(this.el, opts);\n        } else {\n            this.ddDraggable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanDraggable() {\n        if (this.ddDraggable) {\n            this.ddDraggable.destroy();\n            delete this.ddDraggable;\n        }\n        return this;\n    }\n    setupResizable(opts) {\n        if (!this.ddResizable) {\n            this.ddResizable = new _dd_resizable__WEBPACK_IMPORTED_MODULE_0__.DDResizable(this.el, opts);\n        } else {\n            this.ddResizable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanResizable() {\n        if (this.ddResizable) {\n            this.ddResizable.destroy();\n            delete this.ddResizable;\n        }\n        return this;\n    }\n    setupDroppable(opts) {\n        if (!this.ddDroppable) {\n            this.ddDroppable = new _dd_droppable__WEBPACK_IMPORTED_MODULE_2__.DDDroppable(this.el, opts);\n        } else {\n            this.ddDroppable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanDroppable() {\n        if (this.ddDroppable) {\n            this.ddDroppable.destroy();\n            delete this.ddDroppable;\n        }\n        return this;\n    }\n    constructor(el){\n        this.el = el;\n    }\n} //# sourceMappingURL=dd-element.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBQzRDO0FBQ0E7QUFDQTtBQUN0QyxNQUFNRztJQUNULE9BQU9DLEtBQUtDLEVBQUUsRUFBRTtRQUNaLElBQUksQ0FBQ0EsR0FBR0MsU0FBUyxFQUFFO1lBQ2ZELEdBQUdDLFNBQVMsR0FBRyxJQUFJSCxVQUFVRTtRQUNqQztRQUNBLE9BQU9BLEdBQUdDLFNBQVM7SUFDdkI7SUFJQUMsR0FBR0MsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNDLFdBQVcsSUFBSTtZQUFDO1lBQVE7WUFBYTtTQUFXLENBQUNDLE9BQU8sQ0FBQ0gsYUFBYSxDQUFDLEdBQUc7WUFDL0UsSUFBSSxDQUFDRSxXQUFXLENBQUNILEVBQUUsQ0FBQ0MsV0FBV0M7UUFDbkMsT0FDSyxJQUFJLElBQUksQ0FBQ0csV0FBVyxJQUFJO1lBQUM7WUFBUTtZQUFZO1NBQVUsQ0FBQ0QsT0FBTyxDQUFDSCxhQUFhLENBQUMsR0FBRztZQUNsRixJQUFJLENBQUNJLFdBQVcsQ0FBQ0wsRUFBRSxDQUFDQyxXQUFXQztRQUNuQyxPQUNLLElBQUksSUFBSSxDQUFDSSxXQUFXLElBQUk7WUFBQztZQUFlO1lBQVU7U0FBYSxDQUFDRixPQUFPLENBQUNILGFBQWEsQ0FBQyxHQUFHO1lBQzFGLElBQUksQ0FBQ0ssV0FBVyxDQUFDTixFQUFFLENBQUNDLFdBQVdDO1FBQ25DO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQUssSUFBSU4sU0FBUyxFQUFFO1FBQ1gsSUFBSSxJQUFJLENBQUNFLFdBQVcsSUFBSTtZQUFDO1lBQVE7WUFBYTtTQUFXLENBQUNDLE9BQU8sQ0FBQ0gsYUFBYSxDQUFDLEdBQUc7WUFDL0UsSUFBSSxDQUFDRSxXQUFXLENBQUNJLEdBQUcsQ0FBQ047UUFDekIsT0FDSyxJQUFJLElBQUksQ0FBQ0ksV0FBVyxJQUFJO1lBQUM7WUFBUTtZQUFZO1NBQVUsQ0FBQ0QsT0FBTyxDQUFDSCxhQUFhLENBQUMsR0FBRztZQUNsRixJQUFJLENBQUNJLFdBQVcsQ0FBQ0UsR0FBRyxDQUFDTjtRQUN6QixPQUNLLElBQUksSUFBSSxDQUFDSyxXQUFXLElBQUk7WUFBQztZQUFlO1lBQVU7U0FBYSxDQUFDRixPQUFPLENBQUNILGFBQWEsQ0FBQyxHQUFHO1lBQzFGLElBQUksQ0FBQ0ssV0FBVyxDQUFDQyxHQUFHLENBQUNOO1FBQ3pCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQU8sZUFBZUMsSUFBSSxFQUFFO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUNOLFdBQVcsRUFBRTtZQUNuQixJQUFJLENBQUNBLFdBQVcsR0FBRyxJQUFJVCxzREFBV0EsQ0FBQyxJQUFJLENBQUNJLEVBQUUsRUFBRVc7UUFDaEQsT0FDSztZQUNELElBQUksQ0FBQ04sV0FBVyxDQUFDTyxZQUFZLENBQUNEO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQUUsaUJBQWlCO1FBQ2IsSUFBSSxJQUFJLENBQUNSLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUNBLFdBQVcsQ0FBQ1MsT0FBTztZQUN4QixPQUFPLElBQUksQ0FBQ1QsV0FBVztRQUMzQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FVLGVBQWVKLElBQUksRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDSCxXQUFXLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSWIsc0RBQVdBLENBQUMsSUFBSSxDQUFDSyxFQUFFLEVBQUVXO1FBQ2hELE9BQ0s7WUFDRCxJQUFJLENBQUNILFdBQVcsQ0FBQ0ksWUFBWSxDQUFDRDtRQUNsQztRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FLLGlCQUFpQjtRQUNiLElBQUksSUFBSSxDQUFDUixXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDQSxXQUFXLENBQUNNLE9BQU87WUFDeEIsT0FBTyxJQUFJLENBQUNOLFdBQVc7UUFDM0I7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBUyxlQUFlTixJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ0osV0FBVyxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUlWLHNEQUFXQSxDQUFDLElBQUksQ0FBQ0csRUFBRSxFQUFFVztRQUNoRCxPQUNLO1lBQ0QsSUFBSSxDQUFDSixXQUFXLENBQUNLLFlBQVksQ0FBQ0Q7UUFDbEM7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBTyxpQkFBaUI7UUFDYixJQUFJLElBQUksQ0FBQ1gsV0FBVyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDTyxPQUFPO1lBQ3hCLE9BQU8sSUFBSSxDQUFDUCxXQUFXO1FBQzNCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUExRUFZLFlBQVluQixFQUFFLENBQUU7UUFDWixJQUFJLENBQUNBLEVBQUUsR0FBR0E7SUFDZDtBQXlFSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZWxlbWVudC5qcz8zOGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtZWxlbWVudHMudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERSZXNpemFibGUgfSBmcm9tICcuL2RkLXJlc2l6YWJsZSc7XG5pbXBvcnQgeyBERERyYWdnYWJsZSB9IGZyb20gJy4vZGQtZHJhZ2dhYmxlJztcbmltcG9ydCB7IERERHJvcHBhYmxlIH0gZnJvbSAnLi9kZC1kcm9wcGFibGUnO1xuZXhwb3J0IGNsYXNzIERERWxlbWVudCB7XG4gICAgc3RhdGljIGluaXQoZWwpIHtcbiAgICAgICAgaWYgKCFlbC5kZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsLmRkRWxlbWVudCA9IG5ldyBEREVsZW1lbnQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5kZEVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5kZERyYWdnYWJsZSAmJiBbJ2RyYWcnLCAnZHJhZ3N0YXJ0JywgJ2RyYWdzdG9wJ10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcmFnZ2FibGUub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZERyb3BwYWJsZSAmJiBbJ2Ryb3AnLCAnZHJvcG92ZXInLCAnZHJvcG91dCddLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRkRHJvcHBhYmxlLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGRSZXNpemFibGUgJiYgWydyZXNpemVzdGFydCcsICdyZXNpemUnLCAncmVzaXplc3RvcCddLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRkRHJhZ2dhYmxlICYmIFsnZHJhZycsICdkcmFnc3RhcnQnLCAnZHJhZ3N0b3AnXS5pbmRleE9mKGV2ZW50TmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS5vZmYoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRkRHJvcHBhYmxlICYmIFsnZHJvcCcsICdkcm9wb3ZlcicsICdkcm9wb3V0J10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZFJlc2l6YWJsZSAmJiBbJ3Jlc2l6ZXN0YXJ0JywgJ3Jlc2l6ZScsICdyZXNpemVzdG9wJ10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGRSZXNpemFibGUub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldHVwRHJhZ2dhYmxlKG9wdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRkRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRkRHJhZ2dhYmxlID0gbmV3IERERHJhZ2dhYmxlKHRoaXMuZWwsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS51cGRhdGVPcHRpb24ob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFuRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5kZERyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZERyYWdnYWJsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0dXBSZXNpemFibGUob3B0cykge1xuICAgICAgICBpZiAoIXRoaXMuZGRSZXNpemFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGRSZXNpemFibGUgPSBuZXcgRERSZXNpemFibGUodGhpcy5lbCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLnVwZGF0ZU9wdGlvbihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2xlYW5SZXNpemFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRkUmVzaXphYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRkUmVzaXphYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXR1cERyb3BwYWJsZShvcHRzKSB7XG4gICAgICAgIGlmICghdGhpcy5kZERyb3BwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kZERyb3BwYWJsZSA9IG5ldyBERERyb3BwYWJsZSh0aGlzLmVsLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUudXBkYXRlT3B0aW9uKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhbkRyb3BwYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGREcm9wcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGREcm9wcGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtZWxlbWVudC5qcy5tYXAiXSwibmFtZXMiOlsiRERSZXNpemFibGUiLCJERERyYWdnYWJsZSIsIkRERHJvcHBhYmxlIiwiRERFbGVtZW50IiwiaW5pdCIsImVsIiwiZGRFbGVtZW50Iiwib24iLCJldmVudE5hbWUiLCJjYWxsYmFjayIsImRkRHJhZ2dhYmxlIiwiaW5kZXhPZiIsImRkRHJvcHBhYmxlIiwiZGRSZXNpemFibGUiLCJvZmYiLCJzZXR1cERyYWdnYWJsZSIsIm9wdHMiLCJ1cGRhdGVPcHRpb24iLCJjbGVhbkRyYWdnYWJsZSIsImRlc3Ryb3kiLCJzZXR1cFJlc2l6YWJsZSIsImNsZWFuUmVzaXphYmxlIiwic2V0dXBEcm9wcGFibGUiLCJjbGVhbkRyb3BwYWJsZSIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-element.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-gridstack.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-gridstack.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDGridStack: function() { return /* binding */ DDGridStack; }\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-element */ \"./node_modules/gridstack/dist/dd-element.js\");\n/**\n * dd-gridstack.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n\n\n// let count = 0; // TEST\n/**\n * HTML Native Mouse and Touch Events Drag and Drop functionality.\n */ class DDGridStack {\n    resizable(el, opts, key, value) {\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\n            } else if (opts === \"destroy\") {\n                dEl.ddResizable && dEl.cleanResizable();\n            } else if (opts === \"option\") {\n                dEl.setupResizable({\n                    [key]: value\n                });\n            } else {\n                const grid = dEl.el.gridstackNode.grid;\n                let handles = dEl.el.getAttribute(\"gs-resize-handles\") ? dEl.el.getAttribute(\"gs-resize-handles\") : grid.opts.resizable.handles;\n                let autoHide = !grid.opts.alwaysShowResizeHandle;\n                dEl.setupResizable({\n                    ...grid.opts.resizable,\n                    ...{\n                        handles,\n                        autoHide\n                    },\n                    ...{\n                        start: opts.start,\n                        stop: opts.stop,\n                        resize: opts.resize\n                    }\n                });\n            }\n        });\n        return this;\n    }\n    draggable(el, opts, key, value) {\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\n            } else if (opts === \"destroy\") {\n                dEl.ddDraggable && dEl.cleanDraggable();\n            } else if (opts === \"option\") {\n                dEl.setupDraggable({\n                    [key]: value\n                });\n            } else {\n                const grid = dEl.el.gridstackNode.grid;\n                dEl.setupDraggable({\n                    ...grid.opts.draggable,\n                    ...{\n                        // containment: (grid.parentGridItem && !grid.opts.dragOut) ? grid.el.parentElement : (grid.opts.draggable.containment || null),\n                        start: opts.start,\n                        stop: opts.stop,\n                        drag: opts.drag\n                    }\n                });\n            }\n        });\n        return this;\n    }\n    dragIn(el, opts) {\n        this._getDDElements(el).forEach((dEl)=>dEl.setupDraggable(opts));\n        return this;\n    }\n    droppable(el, opts, key, value) {\n        if (typeof opts.accept === \"function\" && !opts._accept) {\n            opts._accept = opts.accept;\n            opts.accept = (el)=>opts._accept(el);\n        }\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddDroppable && dEl.ddDroppable[opts]();\n            } else if (opts === \"destroy\") {\n                if (dEl.ddDroppable) {\n                    dEl.cleanDroppable();\n                }\n            } else if (opts === \"option\") {\n                dEl.setupDroppable({\n                    [key]: value\n                });\n            } else {\n                dEl.setupDroppable(opts);\n            }\n        });\n        return this;\n    }\n    /** true if element is droppable */ isDroppable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);\n    }\n    /** true if element is draggable */ isDraggable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);\n    }\n    /** true if element is draggable */ isResizable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);\n    }\n    on(el, name, callback) {\n        this._getDDElements(el).forEach((dEl)=>dEl.on(name, (event)=>{\n                callback(event, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.el : event.target, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.helper : null);\n            }));\n        return this;\n    }\n    off(el, name) {\n        this._getDDElements(el).forEach((dEl)=>dEl.off(name));\n        return this;\n    }\n    /** @internal returns a list of DD elements, creating them on the fly by default */ _getDDElements(els) {\n        let create = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        let hosts = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.getElements(els);\n        if (!hosts.length) return [];\n        let list = hosts.map((e)=>e.ddElement || (create ? _dd_element__WEBPACK_IMPORTED_MODULE_2__.DDElement.init(e) : null));\n        if (!create) {\n            list.filter((d)=>d);\n        } // remove nulls\n        return list;\n    }\n} //# sourceMappingURL=dd-gridstack.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZ3JpZHN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDK0I7QUFDUztBQUNBO0FBQ3pDLHlCQUF5QjtBQUN6Qjs7Q0FFQyxHQUNNLE1BQU1HO0lBQ1RDLFVBQVVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUM1QixJQUFJLENBQUNDLGNBQWMsQ0FBQ0osSUFBSUssT0FBTyxDQUFDQyxDQUFBQTtZQUM1QixJQUFJTCxTQUFTLGFBQWFBLFNBQVMsVUFBVTtnQkFDekNLLElBQUlDLFdBQVcsSUFBSUQsSUFBSUMsV0FBVyxDQUFDTixLQUFLLElBQUksOERBQThEO1lBQzlHLE9BQ0ssSUFBSUEsU0FBUyxXQUFXO2dCQUN6QkssSUFBSUMsV0FBVyxJQUFJRCxJQUFJRSxjQUFjO1lBQ3pDLE9BQ0ssSUFBSVAsU0FBUyxVQUFVO2dCQUN4QkssSUFBSUcsY0FBYyxDQUFDO29CQUFFLENBQUNQLElBQUksRUFBRUM7Z0JBQU07WUFDdEMsT0FDSztnQkFDRCxNQUFNTyxPQUFPSixJQUFJTixFQUFFLENBQUNXLGFBQWEsQ0FBQ0QsSUFBSTtnQkFDdEMsSUFBSUUsVUFBVU4sSUFBSU4sRUFBRSxDQUFDYSxZQUFZLENBQUMsdUJBQXVCUCxJQUFJTixFQUFFLENBQUNhLFlBQVksQ0FBQyx1QkFBdUJILEtBQUtULElBQUksQ0FBQ0YsU0FBUyxDQUFDYSxPQUFPO2dCQUMvSCxJQUFJRSxXQUFXLENBQUNKLEtBQUtULElBQUksQ0FBQ2Msc0JBQXNCO2dCQUNoRFQsSUFBSUcsY0FBYyxDQUFDO29CQUNmLEdBQUdDLEtBQUtULElBQUksQ0FBQ0YsU0FBUztvQkFDdEIsR0FBRzt3QkFBRWE7d0JBQVNFO29CQUFTLENBQUM7b0JBQ3hCLEdBQUc7d0JBQ0NFLE9BQU9mLEtBQUtlLEtBQUs7d0JBQ2pCQyxNQUFNaEIsS0FBS2dCLElBQUk7d0JBQ2ZDLFFBQVFqQixLQUFL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QXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1ncmlkc3RhY2suanM/NjQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLWdyaWRzdGFjay50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRERNYW5hZ2VyIH0gZnJvbSAnLi9kZC1tYW5hZ2VyJztcbmltcG9ydCB7IERERWxlbWVudCB9IGZyb20gJy4vZGQtZWxlbWVudCc7XG4vLyBsZXQgY291bnQgPSAwOyAvLyBURVNUXG4vKipcbiAqIEhUTUwgTmF0aXZlIE1vdXNlIGFuZCBUb3VjaCBFdmVudHMgRHJhZyBhbmQgRHJvcCBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgRERHcmlkU3RhY2sge1xuICAgIHJlc2l6YWJsZShlbCwgb3B0cywga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9nZXREREVsZW1lbnRzKGVsKS5mb3JFYWNoKGRFbCA9PiB7XG4gICAgICAgICAgICBpZiAob3B0cyA9PT0gJ2Rpc2FibGUnIHx8IG9wdHMgPT09ICdlbmFibGUnKSB7XG4gICAgICAgICAgICAgICAgZEVsLmRkUmVzaXphYmxlICYmIGRFbC5kZFJlc2l6YWJsZVtvcHRzXSgpOyAvLyBjYW4ndCBjcmVhdGUgREQgYXMgaXQgcmVxdWlyZXMgb3B0aW9ucyBmb3Igc2V0dXBSZXNpemFibGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgICAgICAgICAgICAgZEVsLmRkUmVzaXphYmxlICYmIGRFbC5jbGVhblJlc2l6YWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBSZXNpemFibGUoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkID0gZEVsLmVsLmdyaWRzdGFja05vZGUuZ3JpZDtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlcyA9IGRFbC5lbC5nZXRBdHRyaWJ1dGUoJ2dzLXJlc2l6ZS1oYW5kbGVzJykgPyBkRWwuZWwuZ2V0QXR0cmlidXRlKCdncy1yZXNpemUtaGFuZGxlcycpIDogZ3JpZC5vcHRzLnJlc2l6YWJsZS5oYW5kbGVzO1xuICAgICAgICAgICAgICAgIGxldCBhdXRvSGlkZSA9ICFncmlkLm9wdHMuYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZTtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBSZXNpemFibGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5ncmlkLm9wdHMucmVzaXphYmxlLFxuICAgICAgICAgICAgICAgICAgICAuLi57IGhhbmRsZXMsIGF1dG9IaWRlIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvcHRzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcDogb3B0cy5zdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRzLnJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhZ2dhYmxlKGVsLCBvcHRzLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSAnZGlzYWJsZScgfHwgb3B0cyA9PT0gJ2VuYWJsZScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcmFnZ2FibGUgJiYgZEVsLmRkRHJhZ2dhYmxlW29wdHNdKCk7IC8vIGNhbid0IGNyZWF0ZSBERCBhcyBpdCByZXF1aXJlcyBvcHRpb25zIGZvciBzZXR1cERyYWdnYWJsZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcmFnZ2FibGUgJiYgZEVsLmNsZWFuRHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgIGRFbC5zZXR1cERyYWdnYWJsZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWQgPSBkRWwuZWwuZ3JpZHN0YWNrTm9kZS5ncmlkO1xuICAgICAgICAgICAgICAgIGRFbC5zZXR1cERyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdyaWQub3B0cy5kcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5tZW50OiAoZ3JpZC5wYXJlbnRHcmlkSXRlbSAmJiAhZ3JpZC5vcHRzLmRyYWdPdXQpID8gZ3JpZC5lbC5wYXJlbnRFbGVtZW50IDogKGdyaWQub3B0cy5kcmFnZ2FibGUuY29udGFpbm1lbnQgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogb3B0cy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IG9wdHMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWc6IG9wdHMuZHJhZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhZ0luKGVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5zZXR1cERyYWdnYWJsZShvcHRzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkcm9wcGFibGUoZWwsIG9wdHMsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmFjY2VwdCA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3B0cy5fYWNjZXB0KSB7XG4gICAgICAgICAgICBvcHRzLl9hY2NlcHQgPSBvcHRzLmFjY2VwdDtcbiAgICAgICAgICAgIG9wdHMuYWNjZXB0ID0gKGVsKSA9PiBvcHRzLl9hY2NlcHQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSAnZGlzYWJsZScgfHwgb3B0cyA9PT0gJ2VuYWJsZScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcm9wcGFibGUgJiYgZEVsLmRkRHJvcHBhYmxlW29wdHNdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICAgICAgICBpZiAoZEVsLmRkRHJvcHBhYmxlKSB7IC8vIGVycm9yIHRvIGNhbGwgZGVzdHJveSBpZiBub3QgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZEVsLmNsZWFuRHJvcHBhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBEcm9wcGFibGUoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBEcm9wcGFibGUob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcm9wcGFibGUgKi9cbiAgICBpc0Ryb3BwYWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZERyb3BwYWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkRHJvcHBhYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcmFnZ2FibGUgKi9cbiAgICBpc0RyYWdnYWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZERyYWdnYWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkRHJhZ2dhYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcmFnZ2FibGUgKi9cbiAgICBpc1Jlc2l6YWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZFJlc2l6YWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkUmVzaXphYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgb24oZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5vbihuYW1lLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBERE1hbmFnZXIuZHJhZ0VsZW1lbnQgPyBERE1hbmFnZXIuZHJhZ0VsZW1lbnQuZWwgOiBldmVudC50YXJnZXQsIERETWFuYWdlci5kcmFnRWxlbWVudCA/IERETWFuYWdlci5kcmFnRWxlbWVudC5oZWxwZXIgOiBudWxsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGVsLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5vZmYobmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCByZXR1cm5zIGEgbGlzdCBvZiBERCBlbGVtZW50cywgY3JlYXRpbmcgdGhlbSBvbiB0aGUgZmx5IGJ5IGRlZmF1bHQgKi9cbiAgICBfZ2V0RERFbGVtZW50cyhlbHMsIGNyZWF0ZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGhvc3RzID0gVXRpbHMuZ2V0RWxlbWVudHMoZWxzKTtcbiAgICAgICAgaWYgKCFob3N0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBsaXN0ID0gaG9zdHMubWFwKGUgPT4gZS5kZEVsZW1lbnQgfHwgKGNyZWF0ZSA/IERERWxlbWVudC5pbml0KGUpIDogbnVsbCkpO1xuICAgICAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICAgICAgbGlzdC5maWx0ZXIoZCA9PiBkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgbnVsbHNcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtZ3JpZHN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJVdGlscyIsIkRETWFuYWdlciIsIkRERWxlbWVudCIsIkRER3JpZFN0YWNrIiwicmVzaXphYmxlIiwiZWwiLCJvcHRzIiwia2V5IiwidmFsdWUiLCJfZ2V0RERFbGVtZW50cyIsImZvckVhY2giLCJkRWwiLCJkZFJlc2l6YWJsZSIsImNsZWFuUmVzaXphYmxlIiwic2V0dXBSZXNpemFibGUiLCJncmlkIiwiZ3JpZHN0YWNrTm9kZSIsImhhbmRsZXMiLCJnZXRBdHRyaWJ1dGUiLCJhdXRvSGlkZSIsImFsd2F5c1Nob3dSZXNpemVIYW5kbGUiLCJzdGFydCIsInN0b3AiLCJyZXNpemUiLCJkcmFnZ2FibGUiLCJkZERyYWdnYWJsZSIsImNsZWFuRHJhZ2dhYmxlIiwic2V0dXBEcmFnZ2FibGUiLCJkcmFnIiwiZHJhZ0luIiwiZHJvcHBhYmxlIiwiYWNjZXB0IiwiX2FjY2VwdCIsImRkRHJvcHBhYmxlIiwiY2xlYW5Ecm9wcGFibGUiLCJzZXR1cERyb3BwYWJsZSIsImlzRHJvcHBhYmxlIiwiZGRFbGVtZW50IiwiZGlzYWJsZWQiLCJpc0RyYWdnYWJsZSIsImlzUmVzaXphYmxlIiwib24iLCJuYW1lIiwiY2FsbGJhY2siLCJldmVudCIsImRyYWdFbGVtZW50IiwidGFyZ2V0IiwiaGVscGVyIiwib2ZmIiwiZWxzIiwiY3JlYXRlIiwiaG9zdHMiLCJnZXRFbGVtZW50cyIsImxlbmd0aCIsImxpc3QiLCJtYXAiLCJlIiwiaW5pdCIsImZpbHRlciIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-gridstack.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-manager.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-manager.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDManager: function() { return /* binding */ DDManager; }\n/* harmony export */ });\n/**\n * dd-manager.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ /**\n * globals that are shared across Drag & Drop instances\n */ class DDManager {\n} //# sourceMappingURL=dd-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBQ0Q7O0NBRUMsR0FDTSxNQUFNQTtBQUNiLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1tYW5hZ2VyLmpzPzVkMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZC1tYW5hZ2VyLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbi8qKlxuICogZ2xvYmFscyB0aGF0IGFyZSBzaGFyZWQgYWNyb3NzIERyYWcgJiBEcm9wIGluc3RhbmNlc1xuICovXG5leHBvcnQgY2xhc3MgRERNYW5hZ2VyIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbIkRETWFuYWdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-manager.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable-handle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable-handle.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizableHandle: function() { return /* binding */ DDResizableHandle; }\n/* harmony export */ });\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-resizable-handle.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \nclass DDResizableHandle {\n    /** @internal */ _init() {\n        const el = document.createElement(\"div\");\n        el.classList.add(\"ui-resizable-handle\");\n        el.classList.add(\"\".concat(DDResizableHandle.prefix).concat(this.dir));\n        el.style.zIndex = \"100\";\n        el.style.userSelect = \"none\";\n        this.el = el;\n        this.host.appendChild(this.el);\n        this.el.addEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.addEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n            this.el.addEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n        // this.el.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n        }\n        return this;\n    }\n    /** call this when resize handle needs to be removed and cleaned up */ destroy() {\n        if (this.moving) this._mouseUp(this.mouseDownEvent);\n        this.el.removeEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.removeEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n            this.el.removeEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n        }\n        this.host.removeChild(this.el);\n        delete this.el;\n        delete this.host;\n        return this;\n    }\n    /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */ _mouseDown(e) {\n        this.mouseDownEvent = e;\n        document.addEventListener(\"mousemove\", this._mouseMove, true); // capture, not bubble\n        document.addEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.addEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n            this.el.addEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _mouseMove(e) {\n        let s = this.mouseDownEvent;\n        if (this.moving) {\n            this._triggerEvent(\"move\", e);\n        } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n            // don't start unless we've moved at least 3 pixels\n            this.moving = true;\n            this._triggerEvent(\"start\", this.mouseDownEvent);\n            this._triggerEvent(\"move\", e);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _mouseUp(e) {\n        if (this.moving) {\n            this._triggerEvent(\"stop\", e);\n        }\n        document.removeEventListener(\"mousemove\", this._mouseMove, true);\n        document.removeEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.removeEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n            this.el.removeEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n        }\n        delete this.moving;\n        delete this.mouseDownEvent;\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _triggerEvent(name, event) {\n        if (this.option[name]) this.option[name](event);\n        return this;\n    }\n    constructor(host, direction, option){\n        /** @internal true after we've moved enough pixels to start a resize */ this.moving = false;\n        this.host = host;\n        this.dir = direction;\n        this.option = option;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseDown = this._mouseDown.bind(this);\n        this._mouseMove = this._mouseMove.bind(this);\n        this._mouseUp = this._mouseUp.bind(this);\n        this._init();\n    }\n}\n/** @internal */ DDResizableHandle.prefix = \"ui-resizable-\";\n //# sourceMappingURL=dd-resizable-handle.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtcmVzaXphYmxlLWhhbmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUNrRjtBQUNuRixNQUFNSztJQWFGLGNBQWMsR0FDZEMsUUFBUTtRQUNKLE1BQU1DLEtBQUtDLFNBQVNDLGFBQWEsQ0FBQztRQUNsQ0YsR0FBR0csU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDakJKLEdBQUdHLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLEdBQThCLE9BQTNCTixrQkFBa0JPLE1BQU0sRUFBWSxPQUFULElBQUksQ0FBQ0MsR0FBRztRQUN2RE4sR0FBR08sS0FBSyxDQUFDQyxNQUFNLEdBQUc7UUFDbEJSLEdBQUdPLEtBQUssQ0FBQ0UsVUFBVSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1QsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ1UsSUFBSSxDQUFDQyxXQUFXLENBQUMsSUFBSSxDQUFDWCxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsRUFBRSxDQUFDWSxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ0MsVUFBVTtRQUNyRCxJQUFJcEIsOENBQU9BLEVBQUU7WUFDVCxJQUFJLENBQUNPLEVBQUUsQ0FBQ1ksZ0JBQWdCLENBQUMsY0FBY2YsaURBQVVBO1lBQ2pELElBQUksQ0FBQ0csRUFBRSxDQUFDWSxnQkFBZ0IsQ0FBQyxlQUFlbEIsa0RBQVdBO1FBQ25ELG1GQUFtRjtRQUN2RjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0Esb0VBQW9FLEdBQ3BFb0IsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDQyxNQUFNLEVBQ1gsSUFBSSxDQUFDQyxRQUFRLENBQUMsSUFBSSxDQUFDQyxjQUFjO1FBQ3JDLElBQUksQ0FBQ2pCLEVBQUUsQ0FBQ2tCLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDTCxVQUFVO1FBQ3hELElBQUlwQiw4Q0FBT0EsRUFBRTtZQUNULElBQUksQ0FBQ08sRUFBRSxDQUFDa0IsbUJBQW1CLENBQUMsY0FB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QUMsSUFBSTtRQUMzQyxJQUFJLENBQUNkLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ2MsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxDQUFDbUIsSUFBSSxDQUFDLElBQUk7UUFDdkMsSUFBSSxDQUFDcEMsS0FBSztJQUNkO0FBaUZKO0FBQ0EsY0FBYyxHQUNkRCxrQkFBa0JPLE1BQU0sR0FBRztBQUNFLENBQzdCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtcmVzaXphYmxlLWhhbmRsZS5qcz85MTQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtcmVzaXphYmxlLWhhbmRsZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IGlzVG91Y2gsIHBvaW50ZXJkb3duLCB0b3VjaGVuZCwgdG91Y2htb3ZlLCB0b3VjaHN0YXJ0IH0gZnJvbSAnLi9kZC10b3VjaCc7XG5jbGFzcyBERFJlc2l6YWJsZUhhbmRsZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgZGlyZWN0aW9uLCBvcHRpb24pIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCB0cnVlIGFmdGVyIHdlJ3ZlIG1vdmVkIGVub3VnaCBwaXhlbHMgdG8gc3RhcnQgYSByZXNpemUgKi9cbiAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xuICAgICAgICAvLyBjcmVhdGUgdmFyIGV2ZW50IGJpbmRpbmcgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgYW5kIHN0aWxsIGxvb2sgbGlrZSBUUyBtZXRob2RzICh1bmxpa2UgYW5vbnltb3VzIGZ1bmN0aW9ucylcbiAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdGhpcy5fbW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNlTW92ZSA9IHRoaXMuX21vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZVVwID0gdGhpcy5fbW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndWktcmVzaXphYmxlLWhhbmRsZScpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGAke0REUmVzaXphYmxlSGFuZGxlLnByZWZpeH0ke3RoaXMuZGlyfWApO1xuICAgICAgICBlbC5zdHlsZS56SW5kZXggPSAnMTAwJztcbiAgICAgICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmhvc3QuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJkb3duKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZWwuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7IC8vIG5vdCBuZWVkZWQgdW5saWtlIHBvaW50ZXJkb3duIGRvYyBjb21tZW50XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBjYWxsIHRoaXMgd2hlbiByZXNpemUgaGFuZGxlIG5lZWRzIHRvIGJlIHJlbW92ZWQgYW5kIGNsZWFuZWQgdXAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZpbmcpXG4gICAgICAgICAgICB0aGlzLl9tb3VzZVVwKHRoaXMubW91c2VEb3duRXZlbnQpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bik7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBwb2ludGVyZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0LnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICBkZWxldGUgdGhpcy5lbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIG9uIG1vdXNlIGRvd24gb24gdXM6IGNhcHR1cmUgbW92ZSBvbiB0aGUgZW50aXJlIGRvY3VtZW50IChtb3VzZSBtaWdodCBub3Qgc3RheSBvbiB1cykgdW50aWwgd2UgcmVsZWFzZSB0aGUgbW91c2UgKi9cbiAgICBfbW91c2VEb3duKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd25FdmVudCA9IGU7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlTW92ZSwgdHJ1ZSk7IC8vIGNhcHR1cmUsIG5vdCBidWJibGVcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNlVXAsIHRydWUpO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbW91c2VNb3ZlKGUpIHtcbiAgICAgICAgbGV0IHMgPSB0aGlzLm1vdXNlRG93bkV2ZW50O1xuICAgICAgICBpZiAodGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgnbW92ZScsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGUueCAtIHMueCkgKyBNYXRoLmFicyhlLnkgLSBzLnkpID4gMikge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgc3RhcnQgdW5sZXNzIHdlJ3ZlIG1vdmVkIGF0IGxlYXN0IDMgcGl4ZWxzXG4gICAgICAgICAgICB0aGlzLm1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ3N0YXJ0JywgdGhpcy5tb3VzZURvd25FdmVudCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ21vdmUnLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbW91c2VVcChlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdzdG9wJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNlVXAsIHRydWUpO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5tb3Zpbmc7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1vdXNlRG93bkV2ZW50O1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckV2ZW50KG5hbWUsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbltuYW1lXSlcbiAgICAgICAgICAgIHRoaXMub3B0aW9uW25hbWVdKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuRERSZXNpemFibGVIYW5kbGUucHJlZml4ID0gJ3VpLXJlc2l6YWJsZS0nO1xuZXhwb3J0IHsgRERSZXNpemFibGVIYW5kbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLXJlc2l6YWJsZS1oYW5kbGUuanMubWFwIl0sIm5hbWVzIjpbImlzVG91Y2giLCJwb2ludGVyZG93biIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hzdGFydCIsIkREUmVzaXphYmxlSGFuZGxlIiwiX2luaXQiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInByZWZpeCIsImRpciIsInN0eWxlIiwiekluZGV4IiwidXNlclNlbGVjdCIsImhvc3QiLCJhcHBlbmRDaGlsZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfbW91c2VEb3duIiwiZGVzdHJveSIsIm1vdmluZyIsIl9tb3VzZVVwIiwibW91c2VEb3duRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJlIiwiX21vdXNlTW92ZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwicyIsIl90cmlnZ2VyRXZlbnQiLCJNYXRoIiwiYWJzIiwieCIsInkiLCJuYW1lIiwiZXZlbnQiLCJvcHRpb24iLCJjb25zdHJ1Y3RvciIsImRpcmVjdGlvbiIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-resizable-handle.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizable: function() { return /* binding */ DDResizable; }\n/* harmony export */ });\n/* harmony import */ var _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable-handle */ \"./node_modules/gridstack/dist/dd-resizable-handle.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * dd-resizable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\nclass DDResizable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        super.enable();\n        this.el.classList.remove(\"ui-resizable-disabled\");\n        this._setupAutoHide(this.option.autoHide);\n    }\n    disable() {\n        super.disable();\n        this.el.classList.add(\"ui-resizable-disabled\");\n        this._setupAutoHide(false);\n    }\n    destroy() {\n        this._removeHandlers();\n        this._setupAutoHide(false);\n        delete this.el;\n        super.destroy();\n    }\n    updateOption(opts) {\n        let updateHandles = opts.handles && opts.handles !== this.option.handles;\n        let updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        if (updateHandles) {\n            this._removeHandlers();\n            this._setupHandlers();\n        }\n        if (updateAutoHide) {\n            this._setupAutoHide(this.option.autoHide);\n        }\n        return this;\n    }\n    /** @internal turns auto hide on/off */ _setupAutoHide(auto) {\n        if (auto) {\n            this.el.classList.add(\"ui-resizable-autohide\");\n            // use mouseover and not mouseenter to get better performance and track for nested cases\n            this.el.addEventListener(\"mouseover\", this._mouseOver);\n            this.el.addEventListener(\"mouseout\", this._mouseOut);\n        } else {\n            this.el.classList.remove(\"ui-resizable-autohide\");\n            this.el.removeEventListener(\"mouseover\", this._mouseOver);\n            this.el.removeEventListener(\"mouseout\", this._mouseOut);\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement === this) {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n            }\n        }\n        return this;\n    }\n    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mouseOver(e) {\n        // console.log(`${count++} pre-enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        // already over a child, ignore. Ideally we just call e.stopPropagation() but see https://github.com/gridstack/gridstack.js/issues/2018\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement || _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.dragElement) return;\n        _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement = this;\n        // console.log(`${count++} enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        this.el.classList.remove(\"ui-resizable-autohide\");\n    }\n    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mouseOut(e) {\n        // console.log(`${count++} pre-leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement !== this) return;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n        // console.log(`${count++} leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        this.el.classList.add(\"ui-resizable-autohide\");\n    }\n    /** @internal */ _setupHandlers() {\n        let handlerDirection = this.option.handles || \"e,s,se\";\n        if (handlerDirection === \"all\") {\n            handlerDirection = \"n,e,s,w,se,sw,ne,nw\";\n        }\n        this.handlers = handlerDirection.split(\",\").map((dir)=>dir.trim()).map((dir)=>new _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__.DDResizableHandle(this.el, dir, {\n                start: (event)=>{\n                    this._resizeStart(event);\n                },\n                stop: (event)=>{\n                    this._resizeStop(event);\n                },\n                move: (event)=>{\n                    this._resizing(event, dir);\n                }\n            }));\n        return this;\n    }\n    /** @internal */ _resizeStart(event) {\n        this.originalRect = this.el.getBoundingClientRect();\n        this.scrollEl = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getScrollElement(this.el);\n        this.scrollY = this.scrollEl.scrollTop;\n        this.scrolled = 0;\n        this.startEvent = event;\n        this._setupHelper();\n        this._applyChange();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resizestart\",\n            target: this.el\n        });\n        if (this.option.start) {\n            this.option.start(ev, this._ui());\n        }\n        this.el.classList.add(\"ui-resizable-resizing\");\n        this.triggerEvent(\"resizestart\", ev);\n        return this;\n    }\n    /** @internal */ _resizing(event, dir) {\n        this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n        this.temporalRect = this._getChange(event, dir);\n        this._applyChange();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resize\",\n            target: this.el\n        });\n        if (this.option.resize) {\n            this.option.resize(ev, this._ui());\n        }\n        this.triggerEvent(\"resize\", ev);\n        return this;\n    }\n    /** @internal */ _resizeStop(event) {\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resizestop\",\n            target: this.el\n        });\n        if (this.option.stop) {\n            this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n        }\n        this.el.classList.remove(\"ui-resizable-resizing\");\n        this.triggerEvent(\"resizestop\", ev);\n        this._cleanHelper();\n        delete this.startEvent;\n        delete this.originalRect;\n        delete this.temporalRect;\n        delete this.scrollY;\n        delete this.scrolled;\n        return this;\n    }\n    /** @internal */ _setupHelper() {\n        this.elOriginStyleVal = DDResizable._originStyleProp.map((prop)=>this.el.style[prop]);\n        this.parentOriginStylePosition = this.el.parentElement.style.position;\n        if (getComputedStyle(this.el.parentElement).position.match(/static/)) {\n            this.el.parentElement.style.position = \"relative\";\n        }\n        this.el.style.position = \"absolute\";\n        this.el.style.opacity = \"0.8\";\n        return this;\n    }\n    /** @internal */ _cleanHelper() {\n        DDResizable._originStyleProp.forEach((prop, i)=>{\n            this.el.style[prop] = this.elOriginStyleVal[i] || null;\n        });\n        this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n        return this;\n    }\n    /** @internal */ _getChange(event, dir) {\n        const oEvent = this.startEvent;\n        const newRect = {\n            width: this.originalRect.width,\n            height: this.originalRect.height + this.scrolled,\n            left: this.originalRect.left,\n            top: this.originalRect.top - this.scrolled\n        };\n        const offsetX = event.clientX - oEvent.clientX;\n        const offsetY = event.clientY - oEvent.clientY;\n        if (dir.indexOf(\"e\") > -1) {\n            newRect.width += offsetX;\n        } else if (dir.indexOf(\"w\") > -1) {\n            newRect.width -= offsetX;\n            newRect.left += offsetX;\n        }\n        if (dir.indexOf(\"s\") > -1) {\n            newRect.height += offsetY;\n        } else if (dir.indexOf(\"n\") > -1) {\n            newRect.height -= offsetY;\n            newRect.top += offsetY;\n        }\n        const constrain = this._constrainSize(newRect.width, newRect.height);\n        if (Math.round(newRect.width) !== Math.round(constrain.width)) {\n            if (dir.indexOf(\"w\") > -1) {\n                newRect.left += newRect.width - constrain.width;\n            }\n            newRect.width = constrain.width;\n        }\n        if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n            if (dir.indexOf(\"n\") > -1) {\n                newRect.top += newRect.height - constrain.height;\n            }\n            newRect.height = constrain.height;\n        }\n        return newRect;\n    }\n    /** @internal constrain the size to the set min/max values */ _constrainSize(oWidth, oHeight) {\n        const maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;\n        const minWidth = this.option.minWidth || oWidth;\n        const maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;\n        const minHeight = this.option.minHeight || oHeight;\n        const width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n        const height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n        return {\n            width,\n            height\n        };\n    }\n    /** @internal */ _applyChange() {\n        let containmentRect = {\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n        };\n        if (this.el.style.position === \"absolute\") {\n            const containmentEl = this.el.parentElement;\n            const { left, top } = containmentEl.getBoundingClientRect();\n            containmentRect = {\n                left,\n                top,\n                width: 0,\n                height: 0\n            };\n        }\n        if (!this.temporalRect) return this;\n        Object.keys(this.temporalRect).forEach((key)=>{\n            const value = this.temporalRect[key];\n            this.el.style[key] = value - containmentRect[key] + \"px\";\n        });\n        return this;\n    }\n    /** @internal */ _removeHandlers() {\n        this.handlers.forEach((handle)=>handle.destroy());\n        delete this.handlers;\n        return this;\n    }\n    constructor(el, opts = {}){\n        super();\n        /** @internal */ this._ui = ()=>{\n            const containmentEl = this.el.parentElement;\n            const containmentRect = containmentEl.getBoundingClientRect();\n            const newRect = {\n                width: this.originalRect.width,\n                height: this.originalRect.height + this.scrolled,\n                left: this.originalRect.left,\n                top: this.originalRect.top - this.scrolled\n            };\n            const rect = this.temporalRect || newRect;\n            return {\n                position: {\n                    left: rect.left - containmentRect.left,\n                    top: rect.top - containmentRect.top\n                },\n                size: {\n                    width: rect.width,\n                    height: rect.height\n                }\n            };\n        };\n        this.el = el;\n        this.option = opts;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseOver = this._mouseOver.bind(this);\n        this._mouseOut = this._mouseOut.bind(this);\n        this.enable();\n        this._setupAutoHide(this.option.autoHide);\n        this._setupHandlers();\n    }\n}\n/** @internal */ DDResizable._originStyleProp = [\n    \"width\",\n    \"height\",\n    \"position\",\n    \"left\",\n    \"top\",\n    \"opacity\",\n    \"zIndex\"\n];\n //# sourceMappingURL=dd-resizable.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtcmVzaXphYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3lEO0FBQ1Q7QUFDakI7QUFDUztBQUN6QyxNQUFNSSxvQkFBb0JILDBEQUFlQTtJQStDckNJLEdBQUdDLEtBQUssRUFBRUMsUUFBUSxFQUFFO1FBQ2hCLEtBQUssQ0FBQ0YsR0FBR0MsT0FBT0M7SUFDcEI7SUFDQUMsSUFBSUYsS0FBSyxFQUFFO1FBQ1AsS0FBSyxDQUFDRSxJQUFJRjtJQUNkO0lBQ0FHLFNBQVM7UUFDTCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxFQUFFLENBQUNDLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDO1FBQ3pCLElBQUksQ0FBQ0MsY0FBYyxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO0lBQzVDO0lBQ0FDLFVBQVU7UUFDTixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDTixFQUFFLENBQUNDLFNBQVMsQ0FBQ00sR0FBRyxDQUFDO1FBQ3RCLElBQUksQ0FBQ0osY0FBYyxDQUFDO0lBQ3hCO0lBQ0FLLFVBQVU7UUFDTixJQUFJLENBQUNDLGVBQWU7UUFDcEIsSUFBSSxDQUFDTixjQUFjLENBQUM7UUFDcEIsT0FBTyxJQUFJLENBQUNILEVBQUU7UUFDZCxLQUFLLENBQUNRO0lBQ1Y7SUFDQUUsYUFBYUMsSUFBSSxFQUFFO1FBQ2YsSUFBSUMsZ0JBQWlCRCxLQUFLRSxPQUFPLElBQUlGLEtBQUtFLE9BQU8sS0FBSyxJQUFJLENBQUNULE1BQU0sQ0FBQ1MsT0FBTztRQUN6RSxJQUFJQyxpQkFBa0JILEtBQUtOLFFBQVEsSUFBSU0sS0FBS04sUUFBUSxLQUFLLElBQUksQ0FBQ0QsTUFBTSxDQUFDQyxRQUFRO1FBQzdFVSxPQUFPQyxJQUFJLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBTyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2MsSUFBSSxHQUFHUCxJQUFJLENBQUNPLElBQUk7UUFDN0QsSUFBSU4sZUFBZTtZQUNmLElBQUksQ0FBQ0gsZUFBZTtZQUNwQixJQUFJLENBQUNVLGNBQWM7UUFDdkI7UUFDQSxJQUFJTCxnQkFBZ0I7WUFDaEIsSUFBSSxDQUFDWCxjQUFjLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVE7UUFDNUM7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBLHFDQUFxQyxHQUNyQ0YsZUFBZWlCLElBQUksRUFBRTtRQUNqQixJQUFJQSxNQUFNO1lBQ04sSUFBSSxDQUFDcEIsRUFBRSxDQUFDQyxTQUFTLENBQUNNLEdBQUcsQ0FBQztZQUN0Qix3RkFBd0Y7WUFDeEYsSUFBSSxDQUFDUCxFQUFFLENBQUNxQixnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ0MsVUFBVTtZQUNyRCxJQUFJLENBQUN0QixFQUFFLENBQUNxQixnQkFBZ0IsQ0FBQyxZQUFZLElBQUksQ0FBQ0UsU0FBUztRQUN2RCxPQUNLO1lBQ0QsSUFBSSxDQUFDdkIsRUFBRSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sQ0FBQztZQUN6QixJQUFJLENBQUNGLEVBQUUsQ0FBQ3dCLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDRixVQUFVO1lBQ3hELElBQUksQ0FBQ3RCLEVBQUUsQ0FBQ3dCLG1CQUFtQixDQUFDLFlBQVksSUFBSSxDQUFDRCxTQUFTO1lBQ3RELElBQUk5QixrREFBU0EsQ0FBQ2dDLGlCQUFpQixLQUFLLElBQUksRUFBRTtnQkFDdEMsT0FBT2hDLGtEQUFTQSxDQUFDZ0MsaUJBQWlCO1lBQ3RDO1FBQ0o7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBLGNBQWMsR0FDZCw2REFBNkQ7SUFDN0RILFdBQVdJLENBQUMsRUFBRTtRQUNWLDRGQUE0RjtRQUM1Rix1SUFBdUk7UUFDdkksSUFBSWpDLGtEQUFTQSxDQUFDZ0MsaUJBQWlCLElBQUloQyxrREFBU0EsQ0FBQ2tDLFdBQVcsRUFDcEQ7UUFDSmxDLGtEQUFTQSxDQUFDZ0MsaUJBQWlCLEdBQUcsSUFBSTtRQUNsQyx3RkFBd0Y7UUFDeEYsSUFBSSxDQUFDekIsRUFBRSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sQ0FBQztJQUM3QjtJQUNBLGNBQWMsR0FDZCw2REFBNkQ7SUFDN0RxQixVQUFVRyxDQUFDLEVBQUU7UUFDVCw0RkFBNEY7UUFDNUYsSUFBSWpDLGtEQUFTQSxDQUFDZ0MsaUJBQWlCLEtBQUssSUFBSSxFQUNwQztRQUNKLE9BQU9oQyxrREFBU0EsQ0FBQ2dDLGlCQUFpQjtRQUNsQyx3RkFBd0Y7UUFDeEYsSUFBSSxDQUFDekIsRUFBRSxDQUFDQyxTQUFTLENBQUNNLEdBQUcsQ0FBQztJQUMxQjtJQUNBLGNBQWMsR0FDZFksaUJBQWlCO1FBQ2IsSUFBSVMsbUJBQW1CLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ1MsT0FBTyxJQUFJO1FBQzlDLElBQUllLHFCQUFxQixPQUFPO1lBQzVCQSxtQkFBbUI7UUFDdkI7UUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBR0QsaUJBQWlCRSxLQUFLLENBQUMsS0FDbENDLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxJQUNuQkYsR0FBRyxDQUFDQyxDQUFBQSxNQUFPLElBQUkxQyxtRUFBaUJBLENBQUMsSUFBSSxDQUFDVSxFQUFFLEVBQUVnQyxLQUFLO2dCQUNoREUsT0FBTyxDQUFDdEM7b0JBQ0osSUFBSSxDQUFDdUMsWUFBWSxDQUFDdkM7Z0JBQ3RCO2dCQUNBd0MsTUFBTSxDQUFDeEM7b0JBQ0gsSUFBSSxDQUFDeUMsV0FBVyxDQUFDekM7Z0JBQ3JCO2dCQUNBMEMsTUFBTSxDQUFDMUM7b0JBQ0gsSUFBSSxDQUFDMkMsU0FBUyxDQUFDM0MsT0FBT29DO2dCQUMxQjtZQUNKO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxjQUFjLEdBQ2RHLGFBQWF2QyxLQUFLLEVBQUU7UUFDaEIsSUFBSSxDQUFDNEMsWUFBWSxHQUFHLElBQUksQ0FBQ3hDLEVBQUUsQ0FBQ3lDLHFCQUFxQjtRQUNqRCxJQUFJLENBQUNDLFFBQVEsR0FBR2xELHlDQUFLQSxDQUFDbUQsZ0JBQWdCLENBQUMsSUFBSSxDQUFDM0MsRUFBRTtRQUM5QyxJQUFJLENBQUM0QyxPQUFPLEdBQUcsSUFBSSxDQUFDRixRQUFRLENBQUNHLFNBQVM7UUFDdEMsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxVQUFVLEdBQUduRDtRQUNsQixJQUFJLENBQUNvRCxZQUFZO1FBQ2pCLElBQUksQ0FBQ0MsWUFBWTtRQUNqQixNQUFNQyxLQUFLMUQseUNBQUtBLENBQUMyRCxTQUFTLENBQUN2RCxPQUFPO1lBQUV3RCxNQUFNO1lBQWVDLFFBQVEsSUFBSSxDQUFDckQsRUFBRTtRQUFDO1FBQ3pFLElBQUksSUFBSSxDQUFDSSxNQUFNLENBQUM4QixLQUFLLEVBQUU7WUFDbkIsSUFBSSxDQUFDOUIsTUFBTSxDQUFDOEIsS0FBSyxDQUFDZ0IsSUFBSSxJQUFJLENBQUNJLEdBQUc7UUFDbEM7UUFDQSxJQUFJLENBQUN0RCxFQUFFLENBQUNDLFNBQVMsQ0FBQ00sR0FBRyxDQUFDO1FBQ3RCLElBQUksQ0FBQ2dELFlBQVksQ0FBQyxlQUFlTDtRQUNqQyxPQUFPLElBQUk7SUFDZjtJQUNBLGNBQWMsR0FDZFgsVUFBVTNDLEtBQUssRUFBRW9DLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNjLFFBQVEsR0FBRyxJQUFJLENBQUNKLFFBQVEsQ0FBQ0csU0FBUyxHQUFHLElBQUksQ0FBQ0QsT0FBTztRQUN0RCxJQUFJLENBQUNZLFlBQVksR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQzdELE9BQU9vQztRQUMzQyxJQUFJLENBQUNpQixZQUFZO1FBQ2pCLE1BQU1DLEtBQUsxRCx5Q0FBS0EsQ0FBQzJELFNBQVMsQ0FBQ3ZELE9BQU87WUFBRXdELE1BQU07WUFBVUMsUUFBUSxJQUFJLENBQUNyRCxFQUFFO1FBQUM7UUFDcEUsSUFBSSxJQUFJLENBQUNJLE1BQU0sQ0FBQ3NELE1BQU0sRUFBRTtZQUNwQixJQUFJLENBQUN0RCxNQUFNLENBQUNzRCxNQUFNLENBQUNSLElBQUksSUFBSSxDQUFDSSxHQUFHO1FBQ25DO1FBQ0EsSUFBSSxDQUFDQyxZQUFZLENBQUMsVUFBVUw7UUFDNUIsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxjQUFjLEdBQ2RiLFlBQVl6QyxLQUFLLEVBQUU7UUFDZixNQUFNc0QsS0FBSzFELHlDQUFLQSxDQUFDMkQsU0FBUyxDQUFDdkQsT0FBTztZQUFFd0QsTUFBTTtZQUFjQyxRQUFRLElBQUksQ0FBQ3JELEVBQUU7UUFBQztRQUN4RSxJQUFJLElBQUksQ0FBQ0ksTUFBTSxDQUFDZ0MsSUFBSSxFQUFFO1lBQ2xCLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ2dDLElBQUksQ0FBQ2MsS0FBSyxpREFBaUQ7UUFDM0U7UUFDQSxJQUFJLENBQUNsRCxFQUFFLENBQUNDLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDO1FBQ3pCLElBQUksQ0FBQ3FELFlBQVksQ0FBQyxjQUFjTDtRQUNoQyxJQUFJLENBQUNTLFlBQVk7UUFDakIsT0FBTyxJQUFJLENBQUNaLFVBQVU7UUFDdEIsT0FBTyxJQUFJLENBQUNQLFlBQVk7UUFDeEIsT0FBTyxJQUFJLENBQUNnQixZQUFZO1FBQ3hCLE9BQU8sSUFBSSxDQUFDWixPQUFPO1FBQ25CLE9BQU8sSUFBSSxDQUFDRSxRQUFRO1FBQ3BCLE9BQU8sSUFBSTtJQUNmO0lBQ0EsY0FBYyxHQUNkRSxlQUFlO1FBQ1gsSUFBSSxDQUFDWSxnQkFBZ0IsR0FBR2xFLFlBQVltRSxnQkFBZ0IsQ0FBQzlCLEdBQUcsQ0FBQytCLENBQUFBLE9BQVEsSUFBSSxDQUFDOUQsRUFBRSxDQUFDK0QsS0FBSyxDQUFDRCxLQUFLO1FBQ3BGLElBQUksQ0FBQ0UseUJBQXlCLEdBQUcsSUFBSSxDQUFDaEUsRUFBRSxDQUFDaUUsYUFBYSxDQUFDRixLQUFLLENBQUNHLFFBQVE7UUFDckUsSUFBSUMsaUJBQWlCLElBQUksQ0FBQ25FLEVBQUUsQ0FBQ2lFLGFBQWEsRUFBRUMsUUFBUSxDQUFDRSxLQUFLLENBQUMsV0FBVztZQUNsRSxJQUFJLENBQUNwRSxFQUFFLENBQUNpRSxhQUFhLENBQUNGLEtBQUssQ0FBQ0csUUFBUSxHQUFHO1FBQzNDO1FBQ0EsSUFBSSxDQUFDbEUsRUFBRSxDQUFDK0QsS0FBSyxDQUFDRyxRQUFRLEdBQUc7UUFDekIsSUFBSSxDQUFDbEUsRUFBRSxDQUFDK0QsS0FBSyxDQUFDTSxPQUFPLEdBQUc7UUFDeEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxjQUFjLEdBQ2RWLGVBQWU7UUFDWGpFLFlBQVltRSxnQkFBZ0IsQ0FBQzVDLE9BQU8sQ0FBQyxDQUFDNkMsTUFBTVE7WUFDeEMsSUFBSSxDQUFDdEUsRUFBRSxDQUFDK0QsS0FBSyxDQUFDRCxLQUFLLEdBQUcsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ1UsRUFBRSxJQUFJO1FBQ3REO1FBQ0EsSUFBSSxDQUFDdEUsRUFBRSxDQUFDaUUsYUFBYSxDQUFDRixLQUFLLENBQUNHLFFBQVEsR0FBRyxJQUFJLENBQUNGLHlCQUF5QixJQUFJO1FBQ3pFLE9BQU8sSUFBSTtJQUNmO0lBQ0EsY0FBYyxHQUNkUCxXQUFXN0QsS0FBSyxFQUFFb0MsR0FBRyxFQUFFO1FBQ25CLE1BQU11QyxTQUFTLElBQUksQ0FBQ3hCLFVBQVU7UUFDOUIsTUFBTXlCLFVBQVU7WUFDWkMsT0FBTyxJQUFJLENBQUNqQyxZQUFZLENBQUNpQyxLQUFLO1lBQzlCQyxRQUFRLElBQUksQ0FBQ2xDLFlBQVksQ0FBQ2tDLE1BQU0sR0FBRyxJQUFJLENBQUM1QixRQUFRO1lBQ2hENkIsTUFBTSxJQUFJLENBQUNuQyxZQUFZLENBQUNtQyxJQUFJO1lBQzVCQyxLQUFLLElBQUksQ0FBQ3BDLFlBQVksQ0FBQ29DLEdBQUcsR0FBRyxJQUFJLENBQUM5QixRQUFRO1FBQzlDO1FBQ0EsTUFBTStCLFVBQVVqRixNQUFNa0YsT0FBTyxHQUFHUCxPQUFPTyxPQUFPO1FBQzlDLE1BQU1DLFVBQVVuRixNQUFNb0YsT0FBTyxHQUFHVCxPQUFPUyxPQUFPO1FBQzlDLElBQUloRCxJQUFJaUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQ3ZCVCxRQUFRQyxLQUFLLElBQUlJO1FBQ3JCLE9BQ0ssSUFBSTdDLElBQUlpRCxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUc7WUFDNUJULFFBQVFDLEtBQUssSUFBSUk7WUFDakJMLFFBQVFHLElBQUksSUFBSUU7UUFDcEI7UUFDQSxJQUFJN0MsSUFBSWlELE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRztZQUN2QlQsUUFBUUUsTUFBTSxJQUFJSztRQUN0QixPQUNLLElBQUkvQyxJQUFJaUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQzVCVCxRQUFRRSxNQUFNLElBQUlLO1lBQ2xCUCxRQUFRSSxHQUFHLElBQUlHO1FBQ25CO1FBQ0EsTUFBTUcsWUFBWSxJQUFJLENBQUNDLGNBQWMsQ0FBQ1gsUUFBUUMsS0FBSyxFQUFFRCxRQUFRRSxNQUFNO1FBQ25FLElBQUlVLEtBQUtDLEtBQUssQ0FBQ2IsUUFBUUMsS0FBSyxNQUFNVyxLQUFLQyxLQUFLLENBQUNILFVBQVVULEtBQUssR0FBRztZQUMzRCxJQUFJekMsSUFBSWlELE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRztnQkFDdkJULFFBQVFHLElBQUksSUFBSUgsUUFBUUMsS0FBSyxHQUFHUyxVQUFVVCxLQUFLO1lBQ25EO1lBQ0FELFFBQVFDLEtBQUssR0FBR1MsVUFBVVQsS0FBSztRQUNuQztRQUNBLElBQUlXLEtBQUtDLEtBQUssQ0FBQ2IsUUFBUUUsTUFBTSxNQUFNVSxLQUFLQyxLQUFLLENBQUNILFVBQVVSLE1BQU0sR0FBRztZQUM3RCxJQUFJMUMsSUFBSWlELE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRztnQkFDdkJULFFBQVFJLEdBQUcsSUFBSUosUUFBUUUsTUFBTSxHQUFHUSxVQUFVUixNQUFNO1lBQ3BEO1lBQ0FGLFFBQVFFLE1BQU0sR0FBR1EsVUFBVVIsTUFBTTtRQUNyQztRQUNBLE9BQU9GO0lBQ1g7SUFDQSwyREFBMkQsR0FDM0RXLGVBQWVHLE1BQU0sRUFBRUMsT0FBTyxFQUFFO1FBQzVCLE1BQU1DLFdBQVcsSUFBSSxDQUFDcEYsTUFBTSxDQUFDb0YsUUFBUSxJQUFJQyxPQUFPQyxnQkFBZ0I7UUFDaEUsTUFBTUMsV0FBVyxJQUFJLENBQUN2RixNQUFNLENBQUN1RixRQUFRLElBQUlMO1FBQ3pDLE1BQU1NLFlBQVksSUFBSSxDQUFDeEYsTUFBTSxDQUFDd0YsU0FBUyxJQUFJSCxPQUFPQyxnQkFBZ0I7UUFDbEUsTUFBTUcsWUFBWSxJQUFJLENBQUN6RixNQUFNLENBQUN5RixTQUFTLElBQUlOO1FBQzNDLE1BQU1kLFFBQVFXLEtBQUtVLEdBQUcsQ0FBQ04sVUFBVUosS0FBS1csR0FBRyxDQUFDSixVQUFVTDtRQUNwRCxNQUFNWixTQUFTVSxLQUFLVSxHQUFHLENBQUNGLFdBQVdSLEtBQUtXLEdBQUcsQ0FBQ0YsV0FBV047UUFDdkQsT0FBTztZQUFFZDtZQUFPQztRQUFPO0lBQzNCO0lBQ0EsY0FBYyxHQUNkekIsZUFBZTtRQUNYLElBQUkrQyxrQkFBa0I7WUFBRXJCLE1BQU07WUFBR0MsS0FBSztZQUFHSCxPQUFPO1lBQUdDLFFBQVE7UUFBRTtRQUM3RCxJQUFJLElBQUksQ0FBQzFFLEVBQUUsQ0FBQytELEtBQUssQ0FBQ0csUUFBUSxLQUFLLFlBQVk7WUFDdkMsTUFBTStCLGdCQUFnQixJQUFJLENBQUNqRyxFQUFFLENBQUNpRSxhQUFhO1lBQzNDLE1BQU0sRUFBRVUsSUFBSSxFQUFFQyxHQUFHLEVBQUUsR0FBR3FCLGNBQWN4RCxxQkFBcUI7WUFDekR1RCxrQkFBa0I7Z0JBQUVyQjtnQkFBTUM7Z0JBQUtILE9BQU87Z0JBQUdDLFFBQVE7WUFBRTtRQUN2RDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNsQixZQUFZLEVBQ2xCLE9BQU8sSUFBSTtRQUNmekMsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ3dDLFlBQVksRUFBRXZDLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDbkMsTUFBTWdGLFFBQVEsSUFBSSxDQUFDMUMsWUFBWSxDQUFDdEMsSUFBSTtZQUNwQyxJQUFJLENBQUNsQixFQUFFLENBQUMrRCxLQUFLLENBQUM3QyxJQUFJLEdBQUdnRixRQUFRRixlQUFlLENBQUM5RSxJQUFJLEdBQUc7UUFDeEQ7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBLGNBQWMsR0FDZFQsa0JBQWtCO1FBQ2QsSUFBSSxDQUFDb0IsUUFBUSxDQUFDWixPQUFPLENBQUNrRixDQUFBQSxTQUFVQSxPQUFPM0YsT0FBTztRQUM5QyxPQUFPLElBQUksQ0FBQ3FCLFFBQVE7UUFDcEIsT0FBTyxJQUFJO0lBQ2Y7SUFwUkF1RSxZQUFZcEcsRUFBRSxFQUFFVyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ3ZCLEtBQUs7UUFDTCxjQUFjLEdBQ2QsSUFBSSxDQUFDMkMsR0FBRyxHQUFHO1lBQ1AsTUFBTTJDLGdCQUFnQixJQUFJLENBQUNqRyxFQUFFLENBQUNpRSxhQUFhO1lBQzNDLE1BQU0rQixrQkFBa0JDLGNBQWN4RCxxQkFBcUI7WUFDM0QsTUFBTStCLFVBQVU7Z0JBQ1pDLE9BQU8sSUFBSSxDQUFDakMsWUFBWSxDQUFDaUMsS0FBSztnQkFDOUJDLFFBQVEsSUFBSSxDQUFDbEMsWUFBWSxDQUFDa0MsTUFBTSxHQUFHLElBQUksQ0FBQzVCLFFBQVE7Z0JBQ2hENkIsTUFBTSxJQUFJLENBQUNuQyxZQUFZLENBQUNtQyxJQUFJO2dCQUM1QkMsS0FBSyxJQUFJLENBQUNwQyxZQUFZLENBQUNvQyxHQUFHLEdBQUcsSUFBSSxDQUFDOUIsUUFBUTtZQUM5QztZQUNBLE1BQU11RCxPQUFPLElBQUksQ0FBQzdDLFlBQVksSUFBSWdCO1lBQ2xDLE9BQU87Z0JBQ0hOLFVBQVU7b0JBQ05TLE1BQU0wQixLQUFLMUIsSUFBSSxHQUFHcUIsZ0JBQWdCckIsSUFBSTtvQkFDdENDLEtBQUt5QixLQUFLekIsR0FBRyxHQUFHb0IsZ0JBQWdCcEIsR0FBRztnQkFDdkM7Z0JBQ0EwQixNQUFNO29CQUNGN0IsT0FBTzRCLEtBQUs1QixLQUFLO29CQUNqQkMsUUFBUTJCLEtBQUszQixNQUFNO2dCQUN2QjtZQWNKO1FBQ0o7UUFDQSxJQUFJLENBQUMxRSxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDSSxNQUFNLEdBQUdPO1FBQ2QsK0dBQStHO1FBQy9HLElBQUksQ0FBQ1csVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDaUYsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDaEYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDZ0YsSUFBSSxDQUFDLElBQUk7UUFDekMsSUFBSSxDQUFDeEcsTUFBTTtRQUNYLElBQUksQ0FBQ0ksY0FBYyxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1FBQ3hDLElBQUksQ0FBQ2MsY0FBYztJQUN2QjtBQXdPSjtBQUNBLGNBQWMsR0FDZHpCLFlBQVltRSxnQkFBZ0IsR0FBRztJQUFDO0lBQVM7SUFBVTtJQUFZO0lBQVE7SUFBTztJQUFXO0NBQVM7QUFDM0UsQ0FDdkIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1yZXNpemFibGUuanM/YjQyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLXJlc2l6YWJsZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IEREUmVzaXphYmxlSGFuZGxlIH0gZnJvbSAnLi9kZC1yZXNpemFibGUtaGFuZGxlJztcbmltcG9ydCB7IEREQmFzZUltcGxlbWVudCB9IGZyb20gJy4vZGQtYmFzZS1pbXBsJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBERE1hbmFnZXIgfSBmcm9tICcuL2RkLW1hbmFnZXInO1xuY2xhc3MgRERSZXNpemFibGUgZXh0ZW5kcyBEREJhc2VJbXBsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl91aSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5tZW50RWwgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBjb250YWlubWVudFJlY3QgPSBjb250YWlubWVudEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgbmV3UmVjdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5vcmlnaW5hbFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9yaWdpbmFsUmVjdC5oZWlnaHQgKyB0aGlzLnNjcm9sbGVkLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMub3JpZ2luYWxSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLm9yaWdpbmFsUmVjdC50b3AgLSB0aGlzLnNjcm9sbGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMudGVtcG9yYWxSZWN0IHx8IG5ld1JlY3Q7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIGNvbnRhaW5tZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gY29udGFpbm1lbnRSZWN0LnRvcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBHcmlkc3RhY2sgT05MWSBuZWVkcyBwb3NpdGlvbiBzZXQgYWJvdmUuLi4ga2VlcCBhcm91bmQgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICBlbGVtZW50OiBbdGhpcy5lbF0sIC8vIFRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBlbGVtZW50IHRvIGJlIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICBoZWxwZXI6IFtdLCAvLyBUT0RPOiBub3Qgc3VwcG9ydCB5ZXQgLSBUaGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaGVscGVyIHRoYXQncyBiZWluZyByZXNpemVkXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50OiBbdGhpcy5lbF0sLy8gd2UgZG9uJ3Qgd3JhcCBoZXJlLCBzbyBzaW1wbGlmeSBhcyB0aGlzLmVsIC8vVGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIGVsZW1lbnQgYmVmb3JlIGl0IGlzIHdyYXBwZWRcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBvc2l0aW9uOiB7IC8vIFRoZSBwb3NpdGlvbiByZXByZXNlbnRlZCBhcyB7IGxlZnQsIHRvcCB9IGJlZm9yZSB0aGUgcmVzaXphYmxlIGlzIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMub3JpZ2luYWxSZWN0LmxlZnQgLSBjb250YWlubWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5vcmlnaW5hbFJlY3QudG9wIC0gY29udGFpbm1lbnRSZWN0LnRvcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTaXplOiB7IC8vIFRoZSBzaXplIHJlcHJlc2VudGVkIGFzIHsgd2lkdGgsIGhlaWdodCB9IGJlZm9yZSB0aGUgcmVzaXphYmxlIGlzIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLm9yaWdpbmFsUmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcmlnaW5hbFJlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0cztcbiAgICAgICAgLy8gY3JlYXRlIHZhciBldmVudCBiaW5kaW5nIHNvIHdlIGNhbiBlYXNpbHkgcmVtb3ZlIGFuZCBzdGlsbCBsb29rIGxpa2UgVFMgbWV0aG9kcyAodW5saWtlIGFub255bW91cyBmdW5jdGlvbnMpXG4gICAgICAgIHRoaXMuX21vdXNlT3ZlciA9IHRoaXMuX21vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZU91dCA9IHRoaXMuX21vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIHRoaXMuX3NldHVwQXV0b0hpZGUodGhpcy5vcHRpb24uYXV0b0hpZGUpO1xuICAgICAgICB0aGlzLl9zZXR1cEhhbmRsZXJzKCk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlci5vbihldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBvZmYoZXZlbnQpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50KTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1yZXNpemFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBdXRvSGlkZSh0aGlzLm9wdGlvbi5hdXRvSGlkZSk7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd1aS1yZXNpemFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBdXRvSGlkZShmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX3NldHVwQXV0b0hpZGUoZmFsc2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5lbDtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVPcHRpb24ob3B0cykge1xuICAgICAgICBsZXQgdXBkYXRlSGFuZGxlcyA9IChvcHRzLmhhbmRsZXMgJiYgb3B0cy5oYW5kbGVzICE9PSB0aGlzLm9wdGlvbi5oYW5kbGVzKTtcbiAgICAgICAgbGV0IHVwZGF0ZUF1dG9IaWRlID0gKG9wdHMuYXV0b0hpZGUgJiYgb3B0cy5hdXRvSGlkZSAhPT0gdGhpcy5vcHRpb24uYXV0b0hpZGUpO1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRzKS5mb3JFYWNoKGtleSA9PiB0aGlzLm9wdGlvbltrZXldID0gb3B0c1trZXldKTtcbiAgICAgICAgaWYgKHVwZGF0ZUhhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUhhbmRsZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZUF1dG9IaWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEF1dG9IaWRlKHRoaXMub3B0aW9uLmF1dG9IaWRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCB0dXJucyBhdXRvIGhpZGUgb24vb2ZmICovXG4gICAgX3NldHVwQXV0b0hpZGUoYXV0bykge1xuICAgICAgICBpZiAoYXV0bykge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd1aS1yZXNpemFibGUtYXV0b2hpZGUnKTtcbiAgICAgICAgICAgIC8vIHVzZSBtb3VzZW92ZXIgYW5kIG5vdCBtb3VzZWVudGVyIHRvIGdldCBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHRyYWNrIGZvciBuZXN0ZWQgY2FzZXNcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fbW91c2VPdmVyKTtcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9tb3VzZU91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLXJlc2l6YWJsZS1hdXRvaGlkZScpO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9tb3VzZU92ZXIpO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX21vdXNlT3V0KTtcbiAgICAgICAgICAgIGlmIChERE1hbmFnZXIub3ZlclJlc2l6ZUVsZW1lbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgRERNYW5hZ2VyLm92ZXJSZXNpemVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9tb3VzZU92ZXIoZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtjb3VudCsrfSBwcmUtZW50ZXIgJHsodGhpcy5lbCBhcyBHcmlkSXRlbUhUTUxFbGVtZW50KS5ncmlkc3RhY2tOb2RlLl9pZH1gKVxuICAgICAgICAvLyBhbHJlYWR5IG92ZXIgYSBjaGlsZCwgaWdub3JlLiBJZGVhbGx5IHdlIGp1c3QgY2FsbCBlLnN0b3BQcm9wYWdhdGlvbigpIGJ1dCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyaWRzdGFjay9ncmlkc3RhY2suanMvaXNzdWVzLzIwMThcbiAgICAgICAgaWYgKERETWFuYWdlci5vdmVyUmVzaXplRWxlbWVudCB8fCBERE1hbmFnZXIuZHJhZ0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIERETWFuYWdlci5vdmVyUmVzaXplRWxlbWVudCA9IHRoaXM7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IGVudGVyICR7KHRoaXMuZWwgYXMgR3JpZEl0ZW1IVE1MRWxlbWVudCkuZ3JpZHN0YWNrTm9kZS5faWR9YClcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCd1aS1yZXNpemFibGUtYXV0b2hpZGUnKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfbW91c2VPdXQoZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtjb3VudCsrfSBwcmUtbGVhdmUgJHsodGhpcy5lbCBhcyBHcmlkSXRlbUhUTUxFbGVtZW50KS5ncmlkc3RhY2tOb2RlLl9pZH1gKVxuICAgICAgICBpZiAoRERNYW5hZ2VyLm92ZXJSZXNpemVFbGVtZW50ICE9PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgRERNYW5hZ2VyLm92ZXJSZXNpemVFbGVtZW50O1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtjb3VudCsrfSBsZWF2ZSAkeyh0aGlzLmVsIGFzIEdyaWRJdGVtSFRNTEVsZW1lbnQpLmdyaWRzdGFja05vZGUuX2lkfWApXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndWktcmVzaXphYmxlLWF1dG9oaWRlJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2V0dXBIYW5kbGVycygpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJEaXJlY3Rpb24gPSB0aGlzLm9wdGlvbi5oYW5kbGVzIHx8ICdlLHMsc2UnO1xuICAgICAgICBpZiAoaGFuZGxlckRpcmVjdGlvbiA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIGhhbmRsZXJEaXJlY3Rpb24gPSAnbixlLHMsdyxzZSxzdyxuZSxudyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJEaXJlY3Rpb24uc3BsaXQoJywnKVxuICAgICAgICAgICAgLm1hcChkaXIgPT4gZGlyLnRyaW0oKSlcbiAgICAgICAgICAgIC5tYXAoZGlyID0+IG5ldyBERFJlc2l6YWJsZUhhbmRsZSh0aGlzLmVsLCBkaXIsIHtcbiAgICAgICAgICAgIHN0YXJ0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVTdGFydChldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplU3RvcChldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXppbmcoZXZlbnQsIGRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVzaXplU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFJlY3QgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnNjcm9sbEVsID0gVXRpbHMuZ2V0U2Nyb2xsRWxlbWVudCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5zY3JvbGxZID0gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuc2Nyb2xsZWQgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5fc2V0dXBIZWxwZXIoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2UoKTtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZXZlbnQsIHsgdHlwZTogJ3Jlc2l6ZXN0YXJ0JywgdGFyZ2V0OiB0aGlzLmVsIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnN0YXJ0KGV2LCB0aGlzLl91aSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLXJlc2l6YWJsZS1yZXNpemluZycpO1xuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgncmVzaXplc3RhcnQnLCBldik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlc2l6aW5nKGV2ZW50LCBkaXIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxlZCA9IHRoaXMuc2Nyb2xsRWwuc2Nyb2xsVG9wIC0gdGhpcy5zY3JvbGxZO1xuICAgICAgICB0aGlzLnRlbXBvcmFsUmVjdCA9IHRoaXMuX2dldENoYW5nZShldmVudCwgZGlyKTtcbiAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2UoKTtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZXZlbnQsIHsgdHlwZTogJ3Jlc2l6ZScsIHRhcmdldDogdGhpcy5lbCB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLnJlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmVzaXplKGV2LCB0aGlzLl91aSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgncmVzaXplJywgZXYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZXNpemVTdG9wKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ID0gVXRpbHMuaW5pdEV2ZW50KGV2ZW50LCB7IHR5cGU6ICdyZXNpemVzdG9wJywgdGFyZ2V0OiB0aGlzLmVsIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24uc3RvcChldik7IC8vIE5vdGU6IHVpKCkgbm90IHVzZWQgYnkgZ3JpZHN0YWNrIHNvIGRvbid0IHBhc3NcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLXJlc2l6YWJsZS1yZXNpemluZycpO1xuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgncmVzaXplc3RvcCcsIGV2KTtcbiAgICAgICAgdGhpcy5fY2xlYW5IZWxwZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RhcnRFdmVudDtcbiAgICAgICAgZGVsZXRlIHRoaXMub3JpZ2luYWxSZWN0O1xuICAgICAgICBkZWxldGUgdGhpcy50ZW1wb3JhbFJlY3Q7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjcm9sbFk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjcm9sbGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXR1cEhlbHBlcigpIHtcbiAgICAgICAgdGhpcy5lbE9yaWdpblN0eWxlVmFsID0gRERSZXNpemFibGUuX29yaWdpblN0eWxlUHJvcC5tYXAocHJvcCA9PiB0aGlzLmVsLnN0eWxlW3Byb3BdKTtcbiAgICAgICAgdGhpcy5wYXJlbnRPcmlnaW5TdHlsZVBvc2l0aW9uID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uO1xuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsLnBhcmVudEVsZW1lbnQpLnBvc2l0aW9uLm1hdGNoKC9zdGF0aWMvKSkge1xuICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gJzAuOCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NsZWFuSGVscGVyKCkge1xuICAgICAgICBERFJlc2l6YWJsZS5fb3JpZ2luU3R5bGVQcm9wLmZvckVhY2goKHByb3AsIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcF0gPSB0aGlzLmVsT3JpZ2luU3R5bGVWYWxbaV0gfHwgbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucGFyZW50T3JpZ2luU3R5bGVQb3NpdGlvbiB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRDaGFuZ2UoZXZlbnQsIGRpcikge1xuICAgICAgICBjb25zdCBvRXZlbnQgPSB0aGlzLnN0YXJ0RXZlbnQ7XG4gICAgICAgIGNvbnN0IG5ld1JlY3QgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5vcmlnaW5hbFJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMub3JpZ2luYWxSZWN0LmhlaWdodCArIHRoaXMuc2Nyb2xsZWQsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLm9yaWdpbmFsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiB0aGlzLm9yaWdpbmFsUmVjdC50b3AgLSB0aGlzLnNjcm9sbGVkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5jbGllbnRYIC0gb0V2ZW50LmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5jbGllbnRZIC0gb0V2ZW50LmNsaWVudFk7XG4gICAgICAgIGlmIChkaXIuaW5kZXhPZignZScpID4gLTEpIHtcbiAgICAgICAgICAgIG5ld1JlY3Qud2lkdGggKz0gb2Zmc2V0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIuaW5kZXhPZigndycpID4gLTEpIHtcbiAgICAgICAgICAgIG5ld1JlY3Qud2lkdGggLT0gb2Zmc2V0WDtcbiAgICAgICAgICAgIG5ld1JlY3QubGVmdCArPSBvZmZzZXRYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIuaW5kZXhPZigncycpID4gLTEpIHtcbiAgICAgICAgICAgIG5ld1JlY3QuaGVpZ2h0ICs9IG9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyLmluZGV4T2YoJ24nKSA+IC0xKSB7XG4gICAgICAgICAgICBuZXdSZWN0LmhlaWdodCAtPSBvZmZzZXRZO1xuICAgICAgICAgICAgbmV3UmVjdC50b3AgKz0gb2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdHJhaW4gPSB0aGlzLl9jb25zdHJhaW5TaXplKG5ld1JlY3Qud2lkdGgsIG5ld1JlY3QuaGVpZ2h0KTtcbiAgICAgICAgaWYgKE1hdGgucm91bmQobmV3UmVjdC53aWR0aCkgIT09IE1hdGgucm91bmQoY29uc3RyYWluLndpZHRoKSkgeyAvLyByb3VuZCB0byBpZ25vcmUgc2xpZ2h0IHJvdW5kLW9mZiBlcnJvcnNcbiAgICAgICAgICAgIGlmIChkaXIuaW5kZXhPZigndycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdSZWN0LmxlZnQgKz0gbmV3UmVjdC53aWR0aCAtIGNvbnN0cmFpbi53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JlY3Qud2lkdGggPSBjb25zdHJhaW4ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGgucm91bmQobmV3UmVjdC5oZWlnaHQpICE9PSBNYXRoLnJvdW5kKGNvbnN0cmFpbi5oZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoZGlyLmluZGV4T2YoJ24nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVjdC50b3AgKz0gbmV3UmVjdC5oZWlnaHQgLSBjb25zdHJhaW4uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmVjdC5oZWlnaHQgPSBjb25zdHJhaW4uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdSZWN0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNvbnN0cmFpbiB0aGUgc2l6ZSB0byB0aGUgc2V0IG1pbi9tYXggdmFsdWVzICovXG4gICAgX2NvbnN0cmFpblNpemUob1dpZHRoLCBvSGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5vcHRpb24ubWF4V2lkdGggfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5vcHRpb24ubWluV2lkdGggfHwgb1dpZHRoO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbi5tYXhIZWlnaHQgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGNvbnN0IG1pbkhlaWdodCA9IHRoaXMub3B0aW9uLm1pbkhlaWdodCB8fCBvSGVpZ2h0O1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCBNYXRoLm1heChtaW5XaWR0aCwgb1dpZHRoKSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKG1heEhlaWdodCwgTWF0aC5tYXgobWluSGVpZ2h0LCBvSGVpZ2h0KSk7XG4gICAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBseUNoYW5nZSgpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5tZW50UmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIGlmICh0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWlubWVudEVsID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IGNvbnRhaW5tZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb250YWlubWVudFJlY3QgPSB7IGxlZnQsIHRvcCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50ZW1wb3JhbFJlY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy50ZW1wb3JhbFJlY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50ZW1wb3JhbFJlY3Rba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGVba2V5XSA9IHZhbHVlIC0gY29udGFpbm1lbnRSZWN0W2tleV0gKyAncHgnO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVtb3ZlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaChoYW5kbGUgPT4gaGFuZGxlLmRlc3Ryb3koKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5ERFJlc2l6YWJsZS5fb3JpZ2luU3R5bGVQcm9wID0gWyd3aWR0aCcsICdoZWlnaHQnLCAncG9zaXRpb24nLCAnbGVmdCcsICd0b3AnLCAnb3BhY2l0eScsICd6SW5kZXgnXTtcbmV4cG9ydCB7IEREUmVzaXphYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZC1yZXNpemFibGUuanMubWFwIl0sIm5hbWVzIjpbIkREUmVzaXphYmxlSGFuZGxlIiwiRERCYXNlSW1wbGVtZW50IiwiVXRpbHMiLCJERE1hbmFnZXIiLCJERFJlc2l6YWJsZSIsIm9uIiwiZXZlbnQiLCJjYWxsYmFjayIsIm9mZiIsImVuYWJsZSIsImVsIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiX3NldHVwQXV0b0hpZGUiLCJvcHRpb24iLCJhdXRvSGlkZSIsImRpc2FibGUiLCJhZGQiLCJkZXN0cm95IiwiX3JlbW92ZUhhbmRsZXJzIiwidXBkYXRlT3B0aW9uIiwib3B0cyIsInVwZGF0ZUhhbmRsZXMiLCJoYW5kbGVzIiwidXBkYXRlQXV0b0hpZGUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIl9zZXR1cEhhbmRsZXJzIiwiYXV0byIsImFkZEV2ZW50TGlzdGVuZXIiLCJfbW91c2VPdmVyIiwiX21vdXNlT3V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm92ZXJSZXNpemVFbGVtZW50IiwiZSIsImRyYWdFbGVtZW50IiwiaGFuZGxlckRpcmVjdGlvbiIsImhhbmRsZXJzIiwic3BsaXQiLCJtYXAiLCJkaXIiLCJ0cmltIiwic3RhcnQiLCJfcmVzaXplU3RhcnQiLCJzdG9wIiwiX3Jlc2l6ZVN0b3AiLCJtb3ZlIiwiX3Jlc2l6aW5nIiwib3JpZ2luYWxSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsRWwiLCJnZXRTY3JvbGxFbGVtZW50Iiwic2Nyb2xsWSIsInNjcm9sbFRvcCIsInNjcm9sbGVkIiwic3RhcnRFdmVudCIsIl9zZXR1cEhlbHBlciIsIl9hcHBseUNoYW5nZSIsImV2IiwiaW5pdEV2ZW50IiwidHlwZSIsInRhcmdldCIsIl91aSIsInRyaWdnZXJFdmVudCIsInRlbXBvcmFsUmVjdCIsIl9nZXRDaGFuZ2UiLCJyZXNpemUiLCJfY2xlYW5IZWxwZXIiLCJlbE9yaWdpblN0eWxlVmFsIiwiX29yaWdpblN0eWxlUHJvcCIsInByb3AiLCJzdHlsZSIsInBhcmVudE9yaWdpblN0eWxlUG9zaXRpb24iLCJwYXJlbnRFbGVtZW50IiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwibWF0Y2giLCJvcGFjaXR5IiwiaSIsIm9FdmVudCIsIm5ld1JlY3QiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ0b3AiLCJvZmZzZXRYIiwiY2xpZW50WCIsIm9mZnNldFkiLCJjbGllbnRZIiwiaW5kZXhPZiIsImNvbnN0cmFpbiIsIl9jb25zdHJhaW5TaXplIiwiTWF0aCIsInJvdW5kIiwib1dpZHRoIiwib0hlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibWluSGVpZ2h0IiwibWluIiwibWF4IiwiY29udGFpbm1lbnRSZWN0IiwiY29udGFpbm1lbnRFbCIsInZhbHVlIiwiaGFuZGxlIiwiY29uc3RydWN0b3IiLCJyZWN0Iiwic2l6ZSIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-resizable.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-touch.js":
/*!*************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-touch.js ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTouch: function() { return /* binding */ isTouch; },\n/* harmony export */   pointerdown: function() { return /* binding */ pointerdown; },\n/* harmony export */   pointerenter: function() { return /* binding */ pointerenter; },\n/* harmony export */   pointerleave: function() { return /* binding */ pointerleave; },\n/* harmony export */   touchend: function() { return /* binding */ touchend; },\n/* harmony export */   touchmove: function() { return /* binding */ touchmove; },\n/* harmony export */   touchstart: function() { return /* binding */ touchstart; }\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * touch.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n/**\n * Detect touch support - Windows Surface devices and other touch devices\n * should we use this instead ? (what we had for always showing resize handles)\n * /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n */ const isTouch =  true && typeof document !== \"undefined\" && (\"ontouchstart\" in document || \"ontouchstart\" in window || window.DocumentTouch && document instanceof window.DocumentTouch || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);\n// interface TouchCoord {x: number, y: number};\nclass DDTouch {\n}\n/**\n* Get the x,y position of a touch event\n*/ // function getTouchCoords(e: TouchEvent): TouchCoord {\n//   return {\n//     x: e.changedTouches[0].pageX,\n//     y: e.changedTouches[0].pageY\n//   };\n// }\n/**\n * Simulate a mouse event based on a corresponding touch event\n * @param {Object} e A touch event\n * @param {String} simulatedType The corresponding mouse event\n */ function simulateMouseEvent(e, simulatedType) {\n    // Ignore multi-touch events\n    if (e.touches.length > 1) return;\n    // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n    if (e.cancelable) e.preventDefault();\n    const touch = e.changedTouches[0], simulatedEvent = document.createEvent(\"MouseEvents\");\n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null // relatedTarget\n    );\n    // Dispatch the simulated event to the target element\n    e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Simulate a mouse event based on a corresponding Pointer event\n * @param {Object} e A pointer event\n * @param {String} simulatedType The corresponding mouse event\n */ function simulatePointerMouseEvent(e, simulatedType) {\n    // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n    if (e.cancelable) e.preventDefault();\n    const simulatedEvent = document.createEvent(\"MouseEvents\");\n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null // relatedTarget\n    );\n    // Dispatch the simulated event to the target element\n    e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Handle the touchstart events\n * @param {Object} e The widget element's touchstart event\n */ function touchstart(e) {\n    // Ignore the event if another widget is already being handled\n    if (DDTouch.touchHandled) return;\n    DDTouch.touchHandled = true;\n    // Simulate the mouse events\n    // simulateMouseEvent(e, 'mouseover');\n    // simulateMouseEvent(e, 'mousemove');\n    simulateMouseEvent(e, \"mousedown\");\n}\n/**\n * Handle the touchmove events\n * @param {Object} e The document's touchmove event\n */ function touchmove(e) {\n    // Ignore event if not handled by us\n    if (!DDTouch.touchHandled) return;\n    simulateMouseEvent(e, \"mousemove\");\n}\n/**\n * Handle the touchend events\n * @param {Object} e The document's touchend event\n */ function touchend(e) {\n    // Ignore event if not handled\n    if (!DDTouch.touchHandled) return;\n    // cancel delayed leave event when we release on ourself which happens BEFORE we get this!\n    if (DDTouch.pointerLeaveTimeout) {\n        window.clearTimeout(DDTouch.pointerLeaveTimeout);\n        delete DDTouch.pointerLeaveTimeout;\n    }\n    const wasDragging = !!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n    // Simulate the mouseup event\n    simulateMouseEvent(e, \"mouseup\");\n    // simulateMouseEvent(event, 'mouseout');\n    // If the touch interaction did not move, it should trigger a click\n    if (!wasDragging) {\n        simulateMouseEvent(e, \"click\");\n    }\n    // Unset the flag to allow other widgets to inherit the touch event\n    DDTouch.touchHandled = false;\n}\n/**\n * Note we don't get touchenter/touchleave (which are deprecated)\n * see https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter\n * so instead of PointerEvent to still get enter/leave and send the matching mouse event.\n */ function pointerdown(e) {\n    // console.log(\"pointer down\")\n    if (e.pointerType === \"mouse\") return;\n    e.target.releasePointerCapture(e.pointerId); // <- Important!\n}\nfunction pointerenter(e) {\n    // ignore the initial one we get on pointerdown on ourself\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n        // console.log('pointerenter ignored');\n        return;\n    }\n    // console.log('pointerenter');\n    if (e.pointerType === \"mouse\") return;\n    simulatePointerMouseEvent(e, \"mouseenter\");\n}\nfunction pointerleave(e) {\n    // ignore the leave on ourself we get before releasing the mouse over ourself\n    // by delaying sending the event and having the up event cancel us\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n        // console.log('pointerleave ignored');\n        return;\n    }\n    if (e.pointerType === \"mouse\") return;\n    DDTouch.pointerLeaveTimeout = window.setTimeout(()=>{\n        delete DDTouch.pointerLeaveTimeout;\n        // console.log('pointerleave delayed');\n        simulatePointerMouseEvent(e, \"mouseleave\");\n    }, 10);\n} //# sourceMappingURL=dd-touch.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtdG91Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDd0M7QUFDekM7Ozs7Q0FJQyxHQUNNLE1BQU1DLFVBQVUsS0FBa0IsSUFBZSxPQUFPQyxhQUFhLGVBQ3ZFLG1CQUFrQkEsWUFDWixrQkFBa0JDLFVBR2pCQSxPQUFPQyxhQUFhLElBQUlGLG9CQUFvQkMsT0FBT0MsYUFBYSxJQUNqRUMsVUFBVUMsY0FBYyxHQUFHLEtBRTNCRCxVQUFVRSxnQkFBZ0IsR0FBRyxHQUFHO0FBQzNDLCtDQUErQztBQUMvQyxNQUFNQztBQUNOO0FBQ0E7O0FBRUEsR0FDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsT0FBTztBQUNQLElBQUk7QUFDSjs7OztDQUlDLEdBQ0QsU0FBU0MsbUJBQW1CQyxDQUFDLEVBQUVDLGFBQWE7SUFDeEMsNEJBQTRCO0lBQzVCLElBQUlELEVBQUVFLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHLEdBQ25CO0lBQ0oscUZBQXFGO0lBQ3JGLElBQUlILEVBQUVJLFVBQVUsRUFDWkosRUFBRUssY0FBYztJQUNwQixNQUFNQyxRQUFRTixFQUFFTyxjQUFjLENBQUMsRUFBRSxFQUFFQyxpQkFBaUJoQixTQUFTaUIsV0FBVyxDQUFDO0lBQ3pFLDJFQUEyRTtJQUMzRUQsZUFBZUUsY0FBYyxDQUFDVCxlQUM5QixNQUNBLE1BQ0FSLFFBQ0EsR0FDQWEsTUFBTUssT0FBTyxFQUNiTCxNQUFNTSxPQUFPLEVBQ2JOLE1BQU1PLE9BQU8sRUFDYlAsTUFBTVEsT0FBTyxFQUNiLE9BQ0EsT0FDQSxPQUNBLE9BQ0EsR0FDQSxLQUFLLGdCQUFnQjs7SUFFckIscURBQXFEO0lBQ3JEZCxFQUFFZSxNQUFNLENBQUNDLGFBQWEsQ0FBQ1I7QUFDM0I7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU1MsMEJBQTBCakIsQ0FBQyxFQUFFQyxhQUFhO0lBQy9DLHFGQUFxRjtJQUNyRixJQUFJRCxFQUFFSSxVQUFVLEVBQ1pKLEVBQUVLLGNBQWM7SUFDcEIsTUFBTUcsaUJBQWlCaEIsU0FBU2lCLFdBQVcsQ0FBQztJQUM1QywyRUFBMkU7SUFDM0VELGVBQWVFLGNBQWMsQ0FBQ1QsZUFDOUIsTUFDQSxNQUNBUixRQUNBLEdBQ0FPLEVBQUVXLE9BQU8sRUFDVFgsRUFBRVksT0FBTyxFQUNUWixFQUFFYSxPQUFPLEVBQ1RiLEVBQUVjLE9BQU8sRUFDVCxPQUNBLE9BQ0EsT0FDQSxPQUNBLEdBQ0EsS0FBSyxnQkFBZ0I7O0lBRXJCLHFEQUFxRDtJQUNyRGQsRUFBRWUsTUFBTSxDQUFDQyxhQUFhLENBQUNSO0FBQzNCO0FBQ0E7OztDQUdDLEdBQ00sU0FBU1UsV0FBV2xCLENBQUM7SUFDeEIsOERBQThEO0lBQzlELElBQUlGLFFBQVFxQixZQUFZLEVBQ3BCO0lBQ0pyQixRQUFRcUIsWUFBWSxHQUFHO0lBQ3ZCLDRCQUE0QjtJQUM1QixzQ0FBc0M7SUFDdEMsc0NBQXNDO0lBQ3RDcEIsbUJBQW1CQyxHQUFHO0FBQzFCO0FBQ0E7OztDQUdDLEdBQ00sU0FBU29CLFVBQVVwQixDQUFDO0lBQ3ZCLG9DQUFvQztJQUNwQyxJQUFJLENBQUNGLFFBQVFxQixZQUFZLEVBQ3JCO0lBQ0pwQixtQkFBbUJDLEdBQUc7QUFDMUI7QUFDQTs7O0NBR0MsR0FDTSxTQUFTcUIsU0FBU3JCLENBQUM7SUFDdEIsOEJBQThCO0lBQzlCLElBQUksQ0FBQ0YsUUFBUXFCLFlBQVksRUFDckI7SUFDSiwwRkFBMEY7SUFDMUYsSUFBSXJCLFFBQVF3QixtQkFBbUIsRUFBRTtRQUM3QjdCLE9BQU84QixZQUFZLENBQUN6QixRQUFRd0IsbUJBQW1CO1FBQy9DLE9BQU94QixRQUFRd0IsbUJBQW1CO0lBQ3RDO0lBQ0EsTUFBTUUsY0FBYyxDQUFDLENBQUNsQyxrREFBU0EsQ0FBQ21DLFdBQVc7SUFDM0MsNkJBQTZCO0lBQzdCMUIsbUJBQW1CQyxHQUFHO0lBQ3RCLHlDQUF5QztJQUN6QyxtRUFBbUU7SUFDbkUsSUFBSSxDQUFDd0IsYUFBYTtRQUNkekIsbUJBQW1CQyxHQUFHO0lBQzFCO0lBQ0EsbUVBQW1FO0lBQ25FRixRQUFRcUIsWUFBWSxHQUFHO0FBQzNCO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNPLFlBQVkxQixDQUFDO0lBQ3pCLDhCQUE4QjtJQUM5QixJQUFJQSxFQUFFMkIsV0FBVyxLQUFLLFNBQ2xCO0lBQ0ozQixFQUFFZSxNQUFNLENBQUNhLHFCQUFxQixDQUFDNUIsRUFBRTZCLFNBQVMsR0FBRyxnQkFBZ0I7QUFDakU7QUFDTyxTQUFTQyxhQUFhOUIsQ0FBQztJQUMxQiwwREFBMEQ7SUFDMUQsSUFBSSxDQUFDVixrREFBU0EsQ0FBQ21DLFdBQVcsRUFBRTtRQUN4Qix1Q0FBdUM7UUFDdkM7SUFDSjtJQUNBLCtCQUErQjtJQUMvQixJQUFJekIsRUFBRTJCLFdBQVcsS0FBSyxTQUNsQjtJQUNKViwwQkFBMEJqQixHQUFHO0FBQ2pDO0FBQ08sU0FBUytCLGFBQWEvQixDQUFDO0lBQzFCLDZFQUE2RTtJQUM3RSxrRUFBa0U7SUFDbEUsSUFBSSxDQUFDVixrREFBU0EsQ0FBQ21DLFdBQVcsRUFBRTtRQUN4Qix1Q0FBdUM7UUFDdkM7SUFDSjtJQUNBLElBQUl6QixFQUFFMkIsV0FBVyxLQUFLLFNBQ2xCO0lBQ0o3QixRQUFRd0IsbUJBQW1CLEdBQUc3QixPQUFPdUMsVUFBVSxDQUFDO1FBQzVDLE9BQU9sQyxRQUFRd0IsbUJBQW1CO1FBQ2xDLHVDQUF1QztRQUN2Q0wsMEJBQTBCakIsR0FBRztJQUNqQyxHQUFHO0FBQ1AsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2RkLXRvdWNoLmpzP2E1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0b3VjaC50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG5pbXBvcnQgeyBERE1hbmFnZXIgfSBmcm9tICcuL2RkLW1hbmFnZXInO1xuLyoqXG4gKiBEZXRlY3QgdG91Y2ggc3VwcG9ydCAtIFdpbmRvd3MgU3VyZmFjZSBkZXZpY2VzIGFuZCBvdGhlciB0b3VjaCBkZXZpY2VzXG4gKiBzaG91bGQgd2UgdXNlIHRoaXMgaW5zdGVhZCA/ICh3aGF0IHdlIGhhZCBmb3IgYWx3YXlzIHNob3dpbmcgcmVzaXplIGhhbmRsZXMpXG4gKiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVG91Y2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50XG4gICAgICAgIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvd1xuICAgICAgICAvLyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50IC8vIHRydWUgb24gV2luZG93cyAxMCBDaHJvbWUgZGVza3RvcCBzbyBkb24ndCB1c2UgdGhpc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB8fCAod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaClcbiAgICAgICAgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDApO1xuLy8gaW50ZXJmYWNlIFRvdWNoQ29vcmQge3g6IG51bWJlciwgeTogbnVtYmVyfTtcbmNsYXNzIEREVG91Y2gge1xufVxuLyoqXG4qIEdldCB0aGUgeCx5IHBvc2l0aW9uIG9mIGEgdG91Y2ggZXZlbnRcbiovXG4vLyBmdW5jdGlvbiBnZXRUb3VjaENvb3JkcyhlOiBUb3VjaEV2ZW50KTogVG91Y2hDb29yZCB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgeDogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCxcbi8vICAgICB5OiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZXG4vLyAgIH07XG4vLyB9XG4vKipcbiAqIFNpbXVsYXRlIGEgbW91c2UgZXZlbnQgYmFzZWQgb24gYSBjb3JyZXNwb25kaW5nIHRvdWNoIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZSBBIHRvdWNoIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2ltdWxhdGVkVHlwZSBUaGUgY29ycmVzcG9uZGluZyBtb3VzZSBldmVudFxuICovXG5mdW5jdGlvbiBzaW11bGF0ZU1vdXNlRXZlbnQoZSwgc2ltdWxhdGVkVHlwZSkge1xuICAgIC8vIElnbm9yZSBtdWx0aS10b3VjaCBldmVudHNcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBQcmV2ZW50IFwiSWdub3JlZCBhdHRlbXB0IHRvIGNhbmNlbCBhIHRvdWNobW92ZSBldmVudCB3aXRoIGNhbmNlbGFibGU9ZmFsc2VcIiBlcnJvcnNcbiAgICBpZiAoZS5jYW5jZWxhYmxlKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLCBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHNpbXVsYXRlZCBtb3VzZSBldmVudCB1c2luZyB0aGUgdG91Y2ggZXZlbnQncyBjb29yZGluYXRlc1xuICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHNpbXVsYXRlZFR5cGUsIC8vIHR5cGVcbiAgICB0cnVlLCAvLyBidWJibGVzXG4gICAgdHJ1ZSwgLy8gY2FuY2VsYWJsZVxuICAgIHdpbmRvdywgLy8gdmlld1xuICAgIDEsIC8vIGRldGFpbFxuICAgIHRvdWNoLnNjcmVlblgsIC8vIHNjcmVlblhcbiAgICB0b3VjaC5zY3JlZW5ZLCAvLyBzY3JlZW5ZXG4gICAgdG91Y2guY2xpZW50WCwgLy8gY2xpZW50WFxuICAgIHRvdWNoLmNsaWVudFksIC8vIGNsaWVudFlcbiAgICBmYWxzZSwgLy8gY3RybEtleVxuICAgIGZhbHNlLCAvLyBhbHRLZXlcbiAgICBmYWxzZSwgLy8gc2hpZnRLZXlcbiAgICBmYWxzZSwgLy8gbWV0YUtleVxuICAgIDAsIC8vIGJ1dHRvblxuICAgIG51bGwgLy8gcmVsYXRlZFRhcmdldFxuICAgICk7XG4gICAgLy8gRGlzcGF0Y2ggdGhlIHNpbXVsYXRlZCBldmVudCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbn1cbi8qKlxuICogU2ltdWxhdGUgYSBtb3VzZSBldmVudCBiYXNlZCBvbiBhIGNvcnJlc3BvbmRpbmcgUG9pbnRlciBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGUgQSBwb2ludGVyIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2ltdWxhdGVkVHlwZSBUaGUgY29ycmVzcG9uZGluZyBtb3VzZSBldmVudFxuICovXG5mdW5jdGlvbiBzaW11bGF0ZVBvaW50ZXJNb3VzZUV2ZW50KGUsIHNpbXVsYXRlZFR5cGUpIHtcbiAgICAvLyBQcmV2ZW50IFwiSWdub3JlZCBhdHRlbXB0IHRvIGNhbmNlbCBhIHRvdWNobW92ZSBldmVudCB3aXRoIGNhbmNlbGFibGU9ZmFsc2VcIiBlcnJvcnNcbiAgICBpZiAoZS5jYW5jZWxhYmxlKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzaW11bGF0ZWQgbW91c2UgZXZlbnQgdXNpbmcgdGhlIHRvdWNoIGV2ZW50J3MgY29vcmRpbmF0ZXNcbiAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChzaW11bGF0ZWRUeXBlLCAvLyB0eXBlXG4gICAgdHJ1ZSwgLy8gYnViYmxlc1xuICAgIHRydWUsIC8vIGNhbmNlbGFibGVcbiAgICB3aW5kb3csIC8vIHZpZXdcbiAgICAxLCAvLyBkZXRhaWxcbiAgICBlLnNjcmVlblgsIC8vIHNjcmVlblhcbiAgICBlLnNjcmVlblksIC8vIHNjcmVlbllcbiAgICBlLmNsaWVudFgsIC8vIGNsaWVudFhcbiAgICBlLmNsaWVudFksIC8vIGNsaWVudFlcbiAgICBmYWxzZSwgLy8gY3RybEtleVxuICAgIGZhbHNlLCAvLyBhbHRLZXlcbiAgICBmYWxzZSwgLy8gc2hpZnRLZXlcbiAgICBmYWxzZSwgLy8gbWV0YUtleVxuICAgIDAsIC8vIGJ1dHRvblxuICAgIG51bGwgLy8gcmVsYXRlZFRhcmdldFxuICAgICk7XG4gICAgLy8gRGlzcGF0Y2ggdGhlIHNpbXVsYXRlZCBldmVudCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbn1cbi8qKlxuICogSGFuZGxlIHRoZSB0b3VjaHN0YXJ0IGV2ZW50c1xuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIHdpZGdldCBlbGVtZW50J3MgdG91Y2hzdGFydCBldmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG91Y2hzdGFydChlKSB7XG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBhbm90aGVyIHdpZGdldCBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcbiAgICBpZiAoRERUb3VjaC50b3VjaEhhbmRsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBERFRvdWNoLnRvdWNoSGFuZGxlZCA9IHRydWU7XG4gICAgLy8gU2ltdWxhdGUgdGhlIG1vdXNlIGV2ZW50c1xuICAgIC8vIHNpbXVsYXRlTW91c2VFdmVudChlLCAnbW91c2VvdmVyJyk7XG4gICAgLy8gc2ltdWxhdGVNb3VzZUV2ZW50KGUsICdtb3VzZW1vdmUnKTtcbiAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZSwgJ21vdXNlZG93bicpO1xufVxuLyoqXG4gKiBIYW5kbGUgdGhlIHRvdWNobW92ZSBldmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBkb2N1bWVudCdzIHRvdWNobW92ZSBldmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG91Y2htb3ZlKGUpIHtcbiAgICAvLyBJZ25vcmUgZXZlbnQgaWYgbm90IGhhbmRsZWQgYnkgdXNcbiAgICBpZiAoIUREVG91Y2gudG91Y2hIYW5kbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGUsICdtb3VzZW1vdmUnKTtcbn1cbi8qKlxuICogSGFuZGxlIHRoZSB0b3VjaGVuZCBldmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBkb2N1bWVudCdzIHRvdWNoZW5kIGV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b3VjaGVuZChlKSB7XG4gICAgLy8gSWdub3JlIGV2ZW50IGlmIG5vdCBoYW5kbGVkXG4gICAgaWYgKCFERFRvdWNoLnRvdWNoSGFuZGxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGNhbmNlbCBkZWxheWVkIGxlYXZlIGV2ZW50IHdoZW4gd2UgcmVsZWFzZSBvbiBvdXJzZWxmIHdoaWNoIGhhcHBlbnMgQkVGT1JFIHdlIGdldCB0aGlzIVxuICAgIGlmIChERFRvdWNoLnBvaW50ZXJMZWF2ZVRpbWVvdXQpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChERFRvdWNoLnBvaW50ZXJMZWF2ZVRpbWVvdXQpO1xuICAgICAgICBkZWxldGUgRERUb3VjaC5wb2ludGVyTGVhdmVUaW1lb3V0O1xuICAgIH1cbiAgICBjb25zdCB3YXNEcmFnZ2luZyA9ICEhRERNYW5hZ2VyLmRyYWdFbGVtZW50O1xuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGUsICdtb3VzZXVwJyk7XG4gICAgLy8gc2ltdWxhdGVNb3VzZUV2ZW50KGV2ZW50LCAnbW91c2VvdXQnKTtcbiAgICAvLyBJZiB0aGUgdG91Y2ggaW50ZXJhY3Rpb24gZGlkIG5vdCBtb3ZlLCBpdCBzaG91bGQgdHJpZ2dlciBhIGNsaWNrXG4gICAgaWYgKCF3YXNEcmFnZ2luZykge1xuICAgICAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZSwgJ2NsaWNrJyk7XG4gICAgfVxuICAgIC8vIFVuc2V0IHRoZSBmbGFnIHRvIGFsbG93IG90aGVyIHdpZGdldHMgdG8gaW5oZXJpdCB0aGUgdG91Y2ggZXZlbnRcbiAgICBERFRvdWNoLnRvdWNoSGFuZGxlZCA9IGZhbHNlO1xufVxuLyoqXG4gKiBOb3RlIHdlIGRvbid0IGdldCB0b3VjaGVudGVyL3RvdWNobGVhdmUgKHdoaWNoIGFyZSBkZXByZWNhdGVkKVxuICogc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3OTA4MzM5L2pzLXRvdWNoLWVxdWl2YWxlbnQtZm9yLW1vdXNlZW50ZXJcbiAqIHNvIGluc3RlYWQgb2YgUG9pbnRlckV2ZW50IHRvIHN0aWxsIGdldCBlbnRlci9sZWF2ZSBhbmQgc2VuZCB0aGUgbWF0Y2hpbmcgbW91c2UgZXZlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludGVyZG93bihlKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJwb2ludGVyIGRvd25cIilcbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGUudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7IC8vIDwtIEltcG9ydGFudCFcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludGVyZW50ZXIoZSkge1xuICAgIC8vIGlnbm9yZSB0aGUgaW5pdGlhbCBvbmUgd2UgZ2V0IG9uIHBvaW50ZXJkb3duIG9uIG91cnNlbGZcbiAgICBpZiAoIURETWFuYWdlci5kcmFnRWxlbWVudCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncG9pbnRlcmVudGVyIGlnbm9yZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygncG9pbnRlcmVudGVyJyk7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpXG4gICAgICAgIHJldHVybjtcbiAgICBzaW11bGF0ZVBvaW50ZXJNb3VzZUV2ZW50KGUsICdtb3VzZWVudGVyJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlcmxlYXZlKGUpIHtcbiAgICAvLyBpZ25vcmUgdGhlIGxlYXZlIG9uIG91cnNlbGYgd2UgZ2V0IGJlZm9yZSByZWxlYXNpbmcgdGhlIG1vdXNlIG92ZXIgb3Vyc2VsZlxuICAgIC8vIGJ5IGRlbGF5aW5nIHNlbmRpbmcgdGhlIGV2ZW50IGFuZCBoYXZpbmcgdGhlIHVwIGV2ZW50IGNhbmNlbCB1c1xuICAgIGlmICghRERNYW5hZ2VyLmRyYWdFbGVtZW50KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwb2ludGVybGVhdmUgaWdub3JlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKVxuICAgICAgICByZXR1cm47XG4gICAgRERUb3VjaC5wb2ludGVyTGVhdmVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgRERUb3VjaC5wb2ludGVyTGVhdmVUaW1lb3V0O1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncG9pbnRlcmxlYXZlIGRlbGF5ZWQnKTtcbiAgICAgICAgc2ltdWxhdGVQb2ludGVyTW91c2VFdmVudChlLCAnbW91c2VsZWF2ZScpO1xuICAgIH0sIDEwKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLXRvdWNoLmpzLm1hcCJdLCJuYW1lcyI6WyJERE1hbmFnZXIiLCJpc1RvdWNoIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJEb2N1bWVudFRvdWNoIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiRERUb3VjaCIsInNpbXVsYXRlTW91c2VFdmVudCIsImUiLCJzaW11bGF0ZWRUeXBlIiwidG91Y2hlcyIsImxlbmd0aCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJzaW11bGF0ZWRFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwidGFyZ2V0IiwiZGlzcGF0Y2hFdmVudCIsInNpbXVsYXRlUG9pbnRlck1vdXNlRXZlbnQiLCJ0b3VjaHN0YXJ0IiwidG91Y2hIYW5kbGVkIiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyTGVhdmVUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwid2FzRHJhZ2dpbmciLCJkcmFnRWxlbWVudCIsInBvaW50ZXJkb3duIiwicG9pbnRlclR5cGUiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJzZXRUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-touch.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack-engine.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-engine.js ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridStackEngine: function() { return /* binding */ GridStackEngine; }\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/**\n * gridstack-engine.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n/**\n * Defines the GridStack engine that does most no DOM grid manipulation.\n * See GridStack methods and vars for descriptions.\n *\n * NOTE: values should not be modified directly - call the main GridStack API instead\n */ class GridStackEngine {\n    batchUpdate() {\n        let flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, doPack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (!!this.batchMode === flag) return this;\n        this.batchMode = flag;\n        if (flag) {\n            this._prevFloat = this._float;\n            this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n            this.cleanNodes();\n            this.saveInitial(); // since begin update (which is called multiple times) won't do this\n        } else {\n            this._float = this._prevFloat;\n            delete this._prevFloat;\n            if (doPack) this._packNodes();\n            this._notify();\n        }\n        return this;\n    }\n    // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n    _useEntireRowArea(node, nn) {\n        return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n    }\n    /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n     * return true if we moved. */ _fixCollisions(node) {\n        let nn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node, collide = arguments.length > 2 ? arguments[2] : void 0, opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n        collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n        if (!collide) return false;\n        // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n        if (node._moving && !opt.nested && !this.float) {\n            if (this.swap(node, collide)) return true;\n        }\n        // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n        let area = nn;\n        if (this._useEntireRowArea(node, nn)) {\n            area = {\n                x: 0,\n                w: this.column,\n                y: nn.y,\n                h: nn.h\n            };\n            collide = this.collide(node, area, opt.skip); // force new hit\n        }\n        let didMove = false;\n        let newOpt = {\n            nested: true,\n            pack: false\n        };\n        while(collide = collide || this.collide(node, area, opt.skip)){\n            let moved;\n            // if colliding with a locked item OR moving down with top gravity (and collide could move up) -> skip past the collide,\n            // but remember that skip down so we only do this once (and push others otherwise).\n            if (collide.locked || node._moving && !node._skipDown && nn.y > node.y && !this.float && // can take space we had, or before where we're going\n            (!this.collide(collide, {\n                ...collide,\n                y: node.y\n            }, node) || !this.collide(collide, {\n                ...collide,\n                y: nn.y - collide.h\n            }, node))) {\n                node._skipDown = node._skipDown || nn.y > node.y;\n                moved = this.moveNode(node, {\n                    ...nn,\n                    y: collide.y + collide.h,\n                    ...newOpt\n                });\n                if (collide.locked && moved) {\n                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, node); // moving after lock become our new desired location\n                } else if (!collide.locked && moved && opt.pack) {\n                    // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n                    this._packNodes();\n                    nn.y = collide.y + collide.h;\n                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n                }\n                didMove = didMove || moved;\n            } else {\n                // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n                moved = this.moveNode(collide, {\n                    ...collide,\n                    y: nn.y + nn.h,\n                    skip: node,\n                    ...newOpt\n                });\n            }\n            if (!moved) {\n                return didMove;\n            } // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n            collide = undefined;\n        }\n        return didMove;\n    }\n    /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */ collide(skip) {\n        let area = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : skip, skip2 = arguments.length > 2 ? arguments[2] : void 0;\n        const skipId = skip._id;\n        const skip2Id = skip2 === null || skip2 === void 0 ? void 0 : skip2._id;\n        return this.nodes.find((n)=>n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n    }\n    collideAll(skip) {\n        let area = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : skip, skip2 = arguments.length > 2 ? arguments[2] : void 0;\n        const skipId = skip._id;\n        const skip2Id = skip2 === null || skip2 === void 0 ? void 0 : skip2._id;\n        return this.nodes.filter((n)=>n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n    }\n    /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */ directionCollideCoverage(node, o, collides) {\n        if (!o.rect || !node._rect) return;\n        let r0 = node._rect; // where started\n        let r = {\n            ...o.rect\n        }; // where we are\n        // update dragged rect to show where it's coming from (above or below, etc...)\n        if (r.y > r0.y) {\n            r.h += r.y - r0.y;\n            r.y = r0.y;\n        } else {\n            r.h += r0.y - r.y;\n        }\n        if (r.x > r0.x) {\n            r.w += r.x - r0.x;\n            r.x = r0.x;\n        } else {\n            r.w += r0.x - r.x;\n        }\n        let collide;\n        let overMax = 0.5; // need >50%\n        collides.forEach((n)=>{\n            if (n.locked || !n._rect) return;\n            let r2 = n._rect; // overlapping target\n            let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE;\n            // depending on which side we started from, compute the overlap % of coverage\n            // (ex: from above/below we only compute the max horizontal line coverage)\n            if (r0.y < r2.y) {\n                yOver = (r.y + r.h - r2.y) / r2.h;\n            } else if (r0.y + r0.h > r2.y + r2.h) {\n                yOver = (r2.y + r2.h - r.y) / r2.h;\n            }\n            if (r0.x < r2.x) {\n                xOver = (r.x + r.w - r2.x) / r2.w;\n            } else if (r0.x + r0.w > r2.x + r2.w) {\n                xOver = (r2.x + r2.w - r.x) / r2.w;\n            }\n            let over = Math.min(xOver, yOver);\n            if (over > overMax) {\n                overMax = over;\n                collide = n;\n            }\n        });\n        o.collide = collide; // save it so we don't have to find it again\n        return collide;\n    }\n    /** does a pixel coverage returning the node that has the most coverage by area */ /*\n    protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n      let collide: GridStackNode;\n      let overMax = 0;\n      collides.forEach(n => {\n        if (n.locked || !n._rect) return;\n        let over = Utils.areaIntercept(r, n._rect);\n        if (over > overMax) {\n          overMax = over;\n          collide = n;\n        }\n      });\n      return {collide, over: overMax};\n    }\n    */ /** called to cache the nodes pixel rectangles used for collision detection during drag */ cacheRects(w, h, top, right, bottom, left) {\n        this.nodes.forEach((n)=>n._rect = {\n                y: n.y * h + top,\n                x: n.x * w + left,\n                w: n.w * w - left - right,\n                h: n.h * h - top - bottom\n            });\n        return this;\n    }\n    /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */ swap(a, b) {\n        if (!b || b.locked || !a || a.locked) return false;\n        function _doSwap() {\n            let x = b.x, y = b.y;\n            b.x = a.x;\n            b.y = a.y; // b -> a position\n            if (a.h != b.h) {\n                a.x = x;\n                a.y = b.y + b.h; // a -> goes after b\n            } else if (a.w != b.w) {\n                a.x = b.x + b.w;\n                a.y = y; // a -> goes after b\n            } else {\n                a.x = x;\n                a.y = y; // a -> old b position\n            }\n            a._dirty = b._dirty = true;\n            return true;\n        }\n        let touching; // remember if we called it (vs undefined)\n        // same size and same row or column, and touching\n        if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b))) return _doSwap();\n        if (touching === false) return; // IFF ran test and fail, bail out\n        // check for taking same columns (but different height) and touching\n        if (a.w === b.w && a.x === b.x && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n            if (b.y < a.y) {\n                let t = a;\n                a = b;\n                b = t;\n            } // swap a <-> b vars so a is first\n            return _doSwap();\n        }\n        if (touching === false) return;\n        // check if taking same row (but different width) and touching\n        if (a.h === b.h && a.y === b.y && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n            if (b.x < a.x) {\n                let t = a;\n                a = b;\n                b = t;\n            } // swap a <-> b vars so a is first\n            return _doSwap();\n        }\n        return false;\n    }\n    isAreaEmpty(x, y, w, h) {\n        let nn = {\n            x: x || 0,\n            y: y || 0,\n            w: w || 1,\n            h: h || 1\n        };\n        return !this.collide(nn);\n    }\n    /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */ compact() {\n        let layout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"compact\", doSort = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (this.nodes.length === 0) return this;\n        if (doSort) this.sortNodes();\n        const wasBatch = this.batchMode;\n        if (!wasBatch) this.batchUpdate();\n        const wasColumnResize = this._inColumnResize;\n        if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n        let copyNodes = this.nodes;\n        this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n        copyNodes.forEach((n, index, list)=>{\n            let after;\n            if (!n.locked) {\n                n.autoPosition = true;\n                if (layout === \"list\" && index) after = list[index - 1];\n            }\n            this.addNode(n, false, after); // 'false' for add event trigger\n        });\n        if (!wasColumnResize) delete this._inColumnResize;\n        if (!wasBatch) this.batchUpdate(false);\n        return this;\n    }\n    /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */ set float(val) {\n        if (this._float === val) return;\n        this._float = val || false;\n        if (!val) {\n            this._packNodes()._notify();\n        }\n    }\n    /** float getter method */ get float() {\n        return this._float || false;\n    }\n    /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */ sortNodes() {\n        let dir = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, column = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.column;\n        this.nodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, dir, column);\n        return this;\n    }\n    /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */ _packNodes() {\n        if (this.batchMode) {\n            return this;\n        }\n        this.sortNodes(); // first to last\n        if (this.float) {\n            // restore original Y pos\n            this.nodes.forEach((n)=>{\n                if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n                let newY = n.y;\n                while(newY > n._orig.y){\n                    --newY;\n                    let collide = this.collide(n, {\n                        x: n.x,\n                        y: newY,\n                        w: n.w,\n                        h: n.h\n                    });\n                    if (!collide) {\n                        n._dirty = true;\n                        n.y = newY;\n                    }\n                }\n            });\n        } else {\n            // top gravity pack\n            this.nodes.forEach((n, i)=>{\n                if (n.locked) return;\n                while(n.y > 0){\n                    let newY = i === 0 ? 0 : n.y - 1;\n                    let canBeMoved = i === 0 || !this.collide(n, {\n                        x: n.x,\n                        y: newY,\n                        w: n.w,\n                        h: n.h\n                    });\n                    if (!canBeMoved) break;\n                    // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n                    // and move items back. The user 'change' CB should detect changes from the original\n                    // starting position instead.\n                    n._dirty = n.y !== newY;\n                    n.y = newY;\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * given a random node, makes sure it's coordinates/values are valid in the current grid\n     * @param node to adjust\n     * @param resizing if out of bound, resize down or move into the grid to fit ?\n     */ prepareNode(node, resizing) {\n        node = node || {};\n        var _node__id;\n        node._id = (_node__id = node._id) !== null && _node__id !== void 0 ? _node__id : GridStackEngine._idSeq++;\n        // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n        if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n            node.autoPosition = true;\n        }\n        // assign defaults for missing required fields\n        let defaults = {\n            x: 0,\n            y: 0,\n            w: 1,\n            h: 1\n        };\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.defaults(node, defaults);\n        if (!node.autoPosition) {\n            delete node.autoPosition;\n        }\n        if (!node.noResize) {\n            delete node.noResize;\n        }\n        if (!node.noMove) {\n            delete node.noMove;\n        }\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sanitizeMinMax(node);\n        // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n        if (typeof node.x == \"string\") {\n            node.x = Number(node.x);\n        }\n        if (typeof node.y == \"string\") {\n            node.y = Number(node.y);\n        }\n        if (typeof node.w == \"string\") {\n            node.w = Number(node.w);\n        }\n        if (typeof node.h == \"string\") {\n            node.h = Number(node.h);\n        }\n        if (isNaN(node.x)) {\n            node.x = defaults.x;\n            node.autoPosition = true;\n        }\n        if (isNaN(node.y)) {\n            node.y = defaults.y;\n            node.autoPosition = true;\n        }\n        if (isNaN(node.w)) {\n            node.w = defaults.w;\n        }\n        if (isNaN(node.h)) {\n            node.h = defaults.h;\n        }\n        return this.nodeBoundFix(node, resizing);\n    }\n    /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */ nodeBoundFix(node, resizing) {\n        let before = node._orig || _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n        if (node.maxW) {\n            node.w = Math.min(node.w, node.maxW);\n        }\n        if (node.maxH) {\n            node.h = Math.min(node.h, node.maxH);\n        }\n        if (node.minW && node.minW <= this.column) {\n            node.w = Math.max(node.w, node.minW);\n        }\n        if (node.minH) {\n            node.h = Math.max(node.h, node.minH);\n        }\n        // if user loaded a larger than allowed widget for current # of columns,\n        // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n        // IFF we're not in the middle of column resizing!\n        const saveOrig = (node.x || 0) + (node.w || 1) > this.column;\n        if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {\n            let copy = {\n                ...node\n            }; // need _id + positions\n            if (copy.autoPosition || copy.x === undefined) {\n                delete copy.x;\n                delete copy.y;\n            } else copy.x = Math.min(11, copy.x);\n            copy.w = Math.min(12, copy.w || 1);\n            this.cacheOneLayout(copy, 12);\n        }\n        if (node.w > this.column) {\n            node.w = this.column;\n        } else if (node.w < 1) {\n            node.w = 1;\n        }\n        if (this.maxRow && node.h > this.maxRow) {\n            node.h = this.maxRow;\n        } else if (node.h < 1) {\n            node.h = 1;\n        }\n        if (node.x < 0) {\n            node.x = 0;\n        }\n        if (node.y < 0) {\n            node.y = 0;\n        }\n        if (node.x + node.w > this.column) {\n            if (resizing) {\n                node.w = this.column - node.x;\n            } else {\n                node.x = this.column - node.w;\n            }\n        }\n        if (this.maxRow && node.y + node.h > this.maxRow) {\n            if (resizing) {\n                node.h = this.maxRow - node.y;\n            } else {\n                node.y = this.maxRow - node.h;\n            }\n        }\n        if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, before)) {\n            node._dirty = true;\n        }\n        return node;\n    }\n    /** returns a list of modified nodes from their original values */ getDirtyNodes(verify) {\n        // compare original x,y,w,h instead as _dirty can be a temporary state\n        if (verify) {\n            return this.nodes.filter((n)=>n._dirty && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig));\n        }\n        return this.nodes.filter((n)=>n._dirty);\n    }\n    /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */ _notify(removedNodes) {\n        if (this.batchMode || !this.onChange) return this;\n        let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n        this.onChange(dirtyNodes);\n        return this;\n    }\n    /** @internal remove dirty and last tried info */ cleanNodes() {\n        if (this.batchMode) return this;\n        this.nodes.forEach((n)=>{\n            delete n._dirty;\n            delete n._lastTried;\n        });\n        return this;\n    }\n    /** @internal called to save initial position/size to track real dirty state.\n     * Note: should be called right after we call change event (so next API is can detect changes)\n     * as well as right before we start move/resize/enter (so we can restore items to prev values) */ saveInitial() {\n        this.nodes.forEach((n)=>{\n            n._orig = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n            delete n._dirty;\n        });\n        this._hasLocked = this.nodes.some((n)=>n.locked);\n        return this;\n    }\n    /** @internal restore all the nodes back to initial values (called when we leave) */ restoreInitial() {\n        this.nodes.forEach((n)=>{\n            if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig)) return;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, n._orig);\n            n._dirty = true;\n        });\n        this._notify();\n        return this;\n    }\n    /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.\n     * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.\n     * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped\n     */ findEmptyPosition(node) {\n        let nodeList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.nodes, column = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.column, after = arguments.length > 3 ? arguments[3] : void 0;\n        let start = after ? after.y * column + (after.x + after.w) : 0;\n        let found = false;\n        for(let i = start; !found; ++i){\n            let x = i % column;\n            let y = Math.floor(i / column);\n            if (x + node.w > column) {\n                continue;\n            }\n            let box = {\n                x,\n                y,\n                w: node.w,\n                h: node.h\n            };\n            if (!nodeList.find((n)=>_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(box, n))) {\n                if (node.x !== x || node.y !== y) node._dirty = true;\n                node.x = x;\n                node.y = y;\n                delete node.autoPosition;\n                found = true;\n            }\n        }\n        return found;\n    }\n    /** call to add the given node to our list, fixing collision and re-packing */ addNode(node) {\n        let triggerAddEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, after = arguments.length > 2 ? arguments[2] : void 0;\n        let dup = this.nodes.find((n)=>n._id === node._id);\n        if (dup) return dup; // prevent inserting twice! return it instead.\n        // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n        node = this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n        delete node._temporaryRemoved;\n        delete node._removeDOM;\n        let skipCollision;\n        if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n            delete node.autoPosition; // found our slot\n            skipCollision = true;\n        }\n        this.nodes.push(node);\n        if (triggerAddEvent) {\n            this.addedNodes.push(node);\n        }\n        if (!skipCollision) this._fixCollisions(node);\n        if (!this.batchMode) {\n            this._packNodes()._notify();\n        }\n        return node;\n    }\n    removeNode(node) {\n        let removeDOM = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, triggerEvent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (!this.nodes.find((n)=>n._id === node._id)) {\n            // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n            return this;\n        }\n        if (triggerEvent) {\n            this.removedNodes.push(node);\n        }\n        if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n        // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n        this.nodes = this.nodes.filter((n)=>n._id !== node._id);\n        if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n        this._notify([\n            node\n        ]);\n        return this;\n    }\n    removeAll() {\n        let removeDOM = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        delete this._layouts;\n        if (!this.nodes.length) return this;\n        removeDOM && this.nodes.forEach((n)=>n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n        this.removedNodes = this.nodes;\n        this.nodes = [];\n        return this._notify(this.removedNodes);\n    }\n    /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.\n     * In more complicated cases (maxRow) it will attempt at moving the item and fixing\n     * others in a clone first, then apply those changes if still within specs. */ moveNodeCheck(node, o) {\n        // if (node.locked) return false;\n        if (!this.changedPosConstrain(node, o)) return false;\n        o.pack = true;\n        // simpler case: move item directly...\n        if (!this.maxRow) {\n            return this.moveNode(node, o);\n        }\n        // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n        let clonedNode;\n        let clone = new GridStackEngine({\n            column: this.column,\n            float: this.float,\n            nodes: this.nodes.map((n)=>{\n                if (n._id === node._id) {\n                    clonedNode = {\n                        ...n\n                    };\n                    return clonedNode;\n                }\n                return {\n                    ...n\n                };\n            })\n        });\n        if (!clonedNode) return false;\n        // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse\n        // (case where widget was somehow added past our max #2449)\n        let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);\n        // else check if we can force a swap (float=true, or different shapes) on non-resize\n        if (!canMove && !o.resizing && o.collide) {\n            let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n            if (this.swap(node, collide)) {\n                this._notify();\n                return true;\n            }\n        }\n        if (!canMove) return false;\n        // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n        // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n        clone.nodes.filter((n)=>n._dirty).forEach((c)=>{\n            let n = this.nodes.find((a)=>a._id === c._id);\n            if (!n) return;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, c);\n            n._dirty = true;\n        });\n        this._notify();\n        return true;\n    }\n    /** return true if can fit in grid height constrain only (always true if no maxRow) */ willItFit(node) {\n        delete node._willFitPos;\n        if (!this.maxRow) return true;\n        // create a clone with NO maxRow and check if still within size\n        let clone = new GridStackEngine({\n            column: this.column,\n            float: this.float,\n            nodes: this.nodes.map((n)=>{\n                return {\n                    ...n\n                };\n            })\n        });\n        let n = {\n            ...node\n        }; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n        this.cleanupNode(n);\n        delete n.el;\n        delete n._id;\n        delete n.content;\n        delete n.grid;\n        clone.addNode(n);\n        if (clone.getRow() <= this.maxRow) {\n            node._willFitPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n            return true;\n        }\n        return false;\n    }\n    /** true if x,y or w,h are different after clamping to min/max */ changedPosConstrain(node, p) {\n        // first make sure w,h are set for caller\n        p.w = p.w || node.w;\n        p.h = p.h || node.h;\n        if (node.x !== p.x || node.y !== p.y) return true;\n        // check constrained w,h\n        if (node.maxW) {\n            p.w = Math.min(p.w, node.maxW);\n        }\n        if (node.maxH) {\n            p.h = Math.min(p.h, node.maxH);\n        }\n        if (node.minW) {\n            p.w = Math.max(p.w, node.minW);\n        }\n        if (node.minH) {\n            p.h = Math.max(p.h, node.minH);\n        }\n        return node.w !== p.w || node.h !== p.h;\n    }\n    /** return true if the passed in node was actually moved (checks for no-op and locked) */ moveNode(node, o) {\n        if (!node || /*node.locked ||*/ !o) return false;\n        let wasUndefinedPack;\n        if (o.pack === undefined && !this.batchMode) {\n            wasUndefinedPack = o.pack = true;\n        }\n        // constrain the passed in values and check if we're still changing our node\n        if (typeof o.x !== \"number\") {\n            o.x = node.x;\n        }\n        if (typeof o.y !== \"number\") {\n            o.y = node.y;\n        }\n        if (typeof o.w !== \"number\") {\n            o.w = node.w;\n        }\n        if (typeof o.h !== \"number\") {\n            o.h = node.h;\n        }\n        let resizing = node.w !== o.w || node.h !== o.h;\n        let nn = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, o);\n        nn = this.nodeBoundFix(nn, resizing);\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(o, nn);\n        if (!o.forceCollide && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, o)) return false;\n        let prevPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n        // check if we will need to fix collision at our new location\n        let collides = this.collideAll(node, nn, o.skip);\n        let needToMove = true;\n        if (collides.length) {\n            var _node_grid_opts, _node_grid;\n            let activeDrag = node._moving && !o.nested;\n            // check to make sure we actually collided over 50% surface area while dragging\n            let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n            // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n            if (activeDrag && collide && ((_node_grid = node.grid) === null || _node_grid === void 0 ? void 0 : (_node_grid_opts = _node_grid.opts) === null || _node_grid_opts === void 0 ? void 0 : _node_grid_opts.subGridDynamic) && !node.grid._isTemp) {\n                let over = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.areaIntercept(o.rect, collide._rect);\n                let a1 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(o.rect);\n                let a2 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(collide._rect);\n                let perc = over / (a1 < a2 ? a1 : a2);\n                if (perc > .8) {\n                    collide.grid.makeSubGrid(collide.el, undefined, node);\n                    collide = undefined;\n                }\n            }\n            if (collide) {\n                needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n            } else {\n                needToMove = false; // we didn't cover >50% for a move, skip...\n                if (wasUndefinedPack) delete o.pack;\n            }\n        }\n        // now move (to the original ask vs the collision version which might differ) and repack things\n        if (needToMove) {\n            node._dirty = true;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n        }\n        if (o.pack) {\n            this._packNodes()._notify();\n        }\n        return !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, prevPos); // pack might have moved things back\n    }\n    getRow() {\n        return this.nodes.reduce((row, n)=>Math.max(row, n.y + n.h), 0);\n    }\n    beginUpdate(node) {\n        if (!node._updating) {\n            node._updating = true;\n            delete node._skipDown;\n            if (!this.batchMode) this.saveInitial();\n        }\n        return this;\n    }\n    endUpdate() {\n        let n = this.nodes.find((n)=>n._updating);\n        if (n) {\n            delete n._updating;\n            delete n._skipDown;\n        }\n        return this;\n    }\n    /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n     * returning a list of widgets for serialization */ save() {\n        let saveElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, saveCB = arguments.length > 1 ? arguments[1] : void 0;\n        var _this__layouts;\n        // use the highest layout for any saved info so we can have full detail on reload #1849\n        let len = (_this__layouts = this._layouts) === null || _this__layouts === void 0 ? void 0 : _this__layouts.length;\n        let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;\n        let list = [];\n        this.sortNodes();\n        this.nodes.forEach((n)=>{\n            let wl = layout === null || layout === void 0 ? void 0 : layout.find((l)=>l._id === n._id);\n            // use layout info fields instead if set\n            let w = {\n                ...n,\n                ...wl || {}\n            };\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.removeInternalForSave(w, !saveElement);\n            if (saveCB) saveCB(n, w);\n            list.push(w);\n        });\n        return list;\n    }\n    /** @internal called whenever a node is added or moved - updates the cached layouts */ layoutsNodesChange(nodes) {\n        if (!this._layouts || this._inColumnResize) return this;\n        // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n        this._layouts.forEach((layout, column)=>{\n            if (!layout || column === this.column) return this;\n            if (column < this.column) {\n                this._layouts[column] = undefined;\n            } else {\n                // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n                // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n                let ratio = column / this.column;\n                nodes.forEach((node)=>{\n                    if (!node._orig) return; // didn't change (newly added ?)\n                    let n = layout.find((l)=>l._id === node._id);\n                    if (!n) return; // no cache for new nodes. Will use those values.\n                    // Y changed, push down same amount\n                    // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n                    if (n.y >= 0 && node.y !== node._orig.y) {\n                        n.y += node.y - node._orig.y;\n                    }\n                    // X changed, scale from new position\n                    if (node.x !== node._orig.x) {\n                        n.x = Math.round(node.x * ratio);\n                    }\n                    // width changed, scale from new width\n                    if (node.w !== node._orig.w) {\n                        n.w = Math.round(node.w * ratio);\n                    }\n                // ...height always carries over from cache\n                });\n            }\n        });\n        return this;\n    }\n    /**\n     * @internal Called to scale the widget width & position up/down based on the column change.\n     * Note we store previous layouts (especially original ones) to make it possible to go\n     * from say 12 -> 1 -> 12 and get back to where we were.\n     *\n     * @param prevColumn previous number of columns\n     * @param column  new column number\n     * @param nodes different sorted list (ex: DOM order) instead of current list\n     * @param layout specify the type of re-layout that will happen (position, size, etc...).\n     * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n     */ columnChanged(prevColumn, column, nodes) {\n        let layout = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"moveScale\";\n        if (!this.nodes.length || !column || prevColumn === column) return this;\n        // simpler shortcuts layouts\n        const doCompact = layout === \"compact\" || layout === \"list\";\n        if (doCompact) {\n            this.sortNodes(1, prevColumn); // sort with original layout once and only once (new column will affect order otherwise)\n        }\n        // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n        if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n        this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n        let newNodes = [];\n        // if we're going to 1 column and using DOM order (item passed in) rather than default sorting, then generate that layout\n        let domOrder = false;\n        if (column === 1 && (nodes === null || nodes === void 0 ? void 0 : nodes.length)) {\n            domOrder = true;\n            let top = 0;\n            nodes.forEach((n)=>{\n                n.x = 0;\n                n.w = 1;\n                n.y = Math.max(n.y, top);\n                top = n.y + n.h;\n            });\n            newNodes = nodes;\n            nodes = [];\n        } else {\n            nodes = doCompact ? this.nodes : _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, -1, prevColumn); // current column reverse sorting so we can insert last to front (limit collision)\n        }\n        // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n        // generate next size down from where we are (looks more natural as you gradually size down).\n        if (column > prevColumn && this._layouts) {\n            var _this__layouts_lastIndex;\n            const cacheNodes = this._layouts[column] || [];\n            // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n            // by pretending we came from that larger column by assigning those values as starting point\n            let lastIndex = this._layouts.length - 1;\n            if (!cacheNodes.length && prevColumn !== lastIndex && ((_this__layouts_lastIndex = this._layouts[lastIndex]) === null || _this__layouts_lastIndex === void 0 ? void 0 : _this__layouts_lastIndex.length)) {\n                prevColumn = lastIndex;\n                this._layouts[lastIndex].forEach((cacheNode)=>{\n                    let n = nodes.find((n)=>n._id === cacheNode._id);\n                    if (n) {\n                        // still current, use cache info positions\n                        if (!doCompact && !cacheNode.autoPosition) {\n                            var _cacheNode_x;\n                            n.x = (_cacheNode_x = cacheNode.x) !== null && _cacheNode_x !== void 0 ? _cacheNode_x : n.x;\n                            var _cacheNode_y;\n                            n.y = (_cacheNode_y = cacheNode.y) !== null && _cacheNode_y !== void 0 ? _cacheNode_y : n.y;\n                        }\n                        var _cacheNode_w;\n                        n.w = (_cacheNode_w = cacheNode.w) !== null && _cacheNode_w !== void 0 ? _cacheNode_w : n.w;\n                        if (cacheNode.x == undefined || cacheNode.y === undefined) n.autoPosition = true;\n                    }\n                });\n            }\n            // if we found cache re-use those nodes that are still current\n            cacheNodes.forEach((cacheNode)=>{\n                let j = nodes.findIndex((n)=>n._id === cacheNode._id);\n                if (j !== -1) {\n                    const n = nodes[j];\n                    // still current, use cache info positions\n                    if (doCompact) {\n                        n.w = cacheNode.w; // only w is used, and don't trim the list\n                        return;\n                    }\n                    if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n                        this.findEmptyPosition(cacheNode, newNodes);\n                    }\n                    if (!cacheNode.autoPosition) {\n                        var _cacheNode_x;\n                        n.x = (_cacheNode_x = cacheNode.x) !== null && _cacheNode_x !== void 0 ? _cacheNode_x : n.x;\n                        var _cacheNode_y;\n                        n.y = (_cacheNode_y = cacheNode.y) !== null && _cacheNode_y !== void 0 ? _cacheNode_y : n.y;\n                        var _cacheNode_w;\n                        n.w = (_cacheNode_w = cacheNode.w) !== null && _cacheNode_w !== void 0 ? _cacheNode_w : n.w;\n                        newNodes.push(n);\n                    }\n                    nodes.splice(j, 1);\n                }\n            });\n        }\n        // much simpler layout that just compacts\n        if (doCompact) {\n            this.compact(layout, false);\n        } else {\n            // ...and add any extra non-cached ones\n            if (nodes.length) {\n                if (typeof layout === \"function\") {\n                    layout(column, prevColumn, newNodes, nodes);\n                } else if (!domOrder) {\n                    let ratio = doCompact || layout === \"none\" ? 1 : column / prevColumn;\n                    let move = layout === \"move\" || layout === \"moveScale\";\n                    let scale = layout === \"scale\" || layout === \"moveScale\";\n                    nodes.forEach((node)=>{\n                        // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n                        node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);\n                        node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);\n                        newNodes.push(node);\n                    });\n                    nodes = [];\n                }\n            }\n            // finally re-layout them in reverse order (to get correct placement)\n            if (!domOrder) newNodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(newNodes, -1, column);\n            this._inColumnResize = true; // prevent cache update\n            this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n            newNodes.forEach((node)=>{\n                this.addNode(node, false); // 'false' for add event trigger\n                delete node._orig; // make sure the commit doesn't try to restore things back to original\n            });\n        }\n        this.nodes.forEach((n)=>delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n        this.batchUpdate(false, !doCompact);\n        delete this._inColumnResize;\n        return this;\n    }\n    /**\n     * call to cache the given layout internally to the given location so we can restore back when column changes size\n     * @param nodes list of nodes\n     * @param column corresponding column index to save it under\n     * @param clear if true, will force other caches to be removed (default false)\n     */ cacheLayout(nodes, column) {\n        let clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        let copy = [];\n        nodes.forEach((n, i)=>{\n            var _n__id;\n            n._id = (_n__id = n._id) !== null && _n__id !== void 0 ? _n__id : GridStackEngine._idSeq++; // make sure we have an id in case this is new layout, else re-use id already set\n            copy[i] = {\n                x: n.x,\n                y: n.y,\n                w: n.w,\n                _id: n._id\n            }; // only thing we change is x,y,w and id to find it back\n        });\n        this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n        this._layouts[column] = copy;\n        return this;\n    }\n    /**\n     * call to cache the given node layout internally to the given location so we can restore back when column changes size\n     * @param node single node to cache\n     * @param column corresponding column index to save it under\n     */ cacheOneLayout(n, column) {\n        var _n__id;\n        n._id = (_n__id = n._id) !== null && _n__id !== void 0 ? _n__id : GridStackEngine._idSeq++;\n        let l = {\n            x: n.x,\n            y: n.y,\n            w: n.w,\n            _id: n._id\n        };\n        if (n.autoPosition || n.x === undefined) {\n            delete l.x;\n            delete l.y;\n            if (n.autoPosition) l.autoPosition = true;\n        }\n        this._layouts = this._layouts || [];\n        this._layouts[column] = this._layouts[column] || [];\n        let index = this.findCacheLayout(n, column);\n        if (index === -1) this._layouts[column].push(l);\n        else this._layouts[column][index] = l;\n        return this;\n    }\n    findCacheLayout(n, column) {\n        var _this__layouts_column, _this__layouts;\n        var _this__layouts_column_findIndex;\n        return (_this__layouts_column_findIndex = (_this__layouts = this._layouts) === null || _this__layouts === void 0 ? void 0 : (_this__layouts_column = _this__layouts[column]) === null || _this__layouts_column === void 0 ? void 0 : _this__layouts_column.findIndex((l)=>l._id === n._id)) !== null && _this__layouts_column_findIndex !== void 0 ? _this__layouts_column_findIndex : -1;\n    }\n    removeNodeFromLayoutCache(n) {\n        if (!this._layouts) {\n            return;\n        }\n        for(let i = 0; i < this._layouts.length; i++){\n            let index = this.findCacheLayout(n, i);\n            if (index !== -1) {\n                this._layouts[i].splice(index, 1);\n            }\n        }\n    }\n    /** called to remove all internal values but the _id */ cleanupNode(node) {\n        for(let prop in node){\n            if (prop[0] === \"_\" && prop !== \"_id\") delete node[prop];\n        }\n        return this;\n    }\n    constructor(opts = {}){\n        this.addedNodes = [];\n        this.removedNodes = [];\n        this.column = opts.column || 12;\n        this.maxRow = opts.maxRow;\n        this._float = opts.float;\n        this.nodes = opts.nodes || [];\n        this.onChange = opts.onChange;\n    }\n}\n/** @internal unique global internal _id counter */ GridStackEngine._idSeq = 0;\n //# sourceMappingURL=gridstack-engine.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLWVuZ2luZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUMrQjtBQUNoQzs7Ozs7Q0FLQyxHQUNELE1BQU1DO0lBVUZDLGNBQXdDO1lBQTVCQyxPQUFBQSxpRUFBTyxNQUFNQyxTQUFBQSxpRUFBUztRQUM5QixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUNDLFNBQVMsS0FBS0YsTUFDckIsT0FBTyxJQUFJO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUdGO1FBQ2pCLElBQUlBLE1BQU07WUFDTixJQUFJLENBQUNHLFVBQVUsR0FBRyxJQUFJLENBQUNDLE1BQU07WUFDN0IsSUFBSSxDQUFDQSxNQUFNLEdBQUcsTUFBTSwrRUFBK0U7WUFDbkcsSUFBSSxDQUFDQyxVQUFVO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLElBQUksb0VBQW9FO1FBQzVGLE9BQ0s7WUFDRCxJQUFJLENBQUNGLE1BQU0sR0FBRyxJQUFJLENBQUNELFVBQVU7WUFDN0IsT0FBTyxJQUFJLENBQUNBLFVBQVU7WUFDdEIsSUFBSUYsUUFDQSxJQUFJLENBQUNNLFVBQVU7WUFDbkIsSUFBSSxDQUFDQyxPQUFPO1FBQ2hCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxnSUFBZ0k7SUFDaElDLGtCQUFrQkMsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFDeEIsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDQyxLQUFLLElBQUksSUFBSSxDQUFDVixTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNDLFVBQVUsS0FBSyxDQUFDLElBQUksQ0FBQ1UsVUFBVSxJQUFLLEVBQUNILEtBQUtJLE9BQU8sSUFBSUosS0FBS0ssU0FBUyxJQUFJSixHQUFHSyxDQUFDLElBQUlOLEtBQUtNLENBQUM7SUFDeEk7SUFDQTtnQ0FDNEIsR0FDNUJDLGVBQWVQLElBQUksRUFBZ0M7WUFBOUJDLEtBQUFBLGlFQUFLRCxNQUFNUSx3REFBU0MsTUFBQUEsaUVBQU0s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QU9BLFNBQVMsT0FDNUIsT0FBT3BNLElBQUksQ0FBQ29NLEtBQUs7UUFDekI7UUFDQSxPQUFPLElBQUk7SUFDZjtJQTc5QkFDLFlBQVl2QyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ25CLElBQUksQ0FBQzVCLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ25CLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQy9GLE1BQU0sR0FBRzhJLEtBQUs5SSxNQUFNLElBQUk7UUFDN0IsSUFBSSxDQUFDMkYsTUFBTSxHQUFHbUQsS0FBS25ELE1BQU07UUFDekIsSUFBSSxDQUFDakgsTUFBTSxHQUFHb0ssS0FBSzVKLEtBQUs7UUFDeEIsSUFBSSxDQUFDNkIsS0FBSyxHQUFHK0gsS0FBSy9ILEtBQUssSUFBSSxFQUFFO1FBQzdCLElBQUksQ0FBQ2lGLFFBQVEsR0FBRzhDLEtBQUs5QyxRQUFRO0lBQ2pDO0FBczlCSjtBQUNBLGlEQUFpRCxHQUNqRDVILGdCQUFnQnNHLE1BQU0sR0FBRztBQUNFLENBQzNCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLWVuZ2luZS5qcz84MjZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZ3JpZHN0YWNrLWVuZ2luZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG4vKipcbiAqIERlZmluZXMgdGhlIEdyaWRTdGFjayBlbmdpbmUgdGhhdCBkb2VzIG1vc3Qgbm8gRE9NIGdyaWQgbWFuaXB1bGF0aW9uLlxuICogU2VlIEdyaWRTdGFjayBtZXRob2RzIGFuZCB2YXJzIGZvciBkZXNjcmlwdGlvbnMuXG4gKlxuICogTk9URTogdmFsdWVzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgZGlyZWN0bHkgLSBjYWxsIHRoZSBtYWluIEdyaWRTdGFjayBBUEkgaW5zdGVhZFxuICovXG5jbGFzcyBHcmlkU3RhY2tFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBvcHRzLmNvbHVtbiB8fCAxMjtcbiAgICAgICAgdGhpcy5tYXhSb3cgPSBvcHRzLm1heFJvdztcbiAgICAgICAgdGhpcy5fZmxvYXQgPSBvcHRzLmZsb2F0O1xuICAgICAgICB0aGlzLm5vZGVzID0gb3B0cy5ub2RlcyB8fCBbXTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9wdHMub25DaGFuZ2U7XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlKGZsYWcgPSB0cnVlLCBkb1BhY2sgPSB0cnVlKSB7XG4gICAgICAgIGlmICghIXRoaXMuYmF0Y2hNb2RlID09PSBmbGFnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuYmF0Y2hNb2RlID0gZmxhZztcbiAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZGbG9hdCA9IHRoaXMuX2Zsb2F0O1xuICAgICAgICAgICAgdGhpcy5fZmxvYXQgPSB0cnVlOyAvLyBsZXQgdGhpbmdzIGdvIGFueXdoZXJlIGZvciBub3cuLi4gd2lsbCByZXN0b3JlIGFuZCBwb3NzaWJseSByZXBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICB0aGlzLmNsZWFuTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUluaXRpYWwoKTsgLy8gc2luY2UgYmVnaW4gdXBkYXRlICh3aGljaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMpIHdvbid0IGRvIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Zsb2F0ID0gdGhpcy5fcHJldkZsb2F0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZGbG9hdDtcbiAgICAgICAgICAgIGlmIChkb1BhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFja05vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gdXNlIGVudGlyZSByb3cgZm9yIGhpdHRpbmcgYXJlYSAod2lsbCB1c2UgYm90dG9tIHJldmVyc2Ugc29ydGVkIGZpcnN0KSBpZiB3ZSBub3QgYWN0aXZlbHkgbW92aW5nIERPV04gYW5kIGRpZG4ndCBhbHJlYWR5IHNraXBcbiAgICBfdXNlRW50aXJlUm93QXJlYShub2RlLCBubikge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmZsb2F0IHx8IHRoaXMuYmF0Y2hNb2RlICYmICF0aGlzLl9wcmV2RmxvYXQpICYmICF0aGlzLl9oYXNMb2NrZWQgJiYgKCFub2RlLl9tb3ZpbmcgfHwgbm9kZS5fc2tpcERvd24gfHwgbm4ueSA8PSBub2RlLnkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGZpeCBjb2xsaXNpb24gb24gZ2l2ZW4gJ25vZGUnLCBnb2luZyB0byBnaXZlbiBuZXcgbG9jYXRpb24gJ25uJywgd2l0aCBvcHRpb25hbCAnY29sbGlkZScgbm9kZSBhbHJlYWR5IGZvdW5kLlxuICAgICAqIHJldHVybiB0cnVlIGlmIHdlIG1vdmVkLiAqL1xuICAgIF9maXhDb2xsaXNpb25zKG5vZGUsIG5uID0gbm9kZSwgY29sbGlkZSwgb3B0ID0ge30pIHtcbiAgICAgICAgdGhpcy5zb3J0Tm9kZXMoLTEpOyAvLyBmcm9tIGxhc3QgdG8gZmlyc3QsIHNvIHJlY3Vyc2l2ZSBjb2xsaXNpb24gbW92ZSBpdGVtcyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgY29sbGlkZSA9IGNvbGxpZGUgfHwgdGhpcy5jb2xsaWRlKG5vZGUsIG5uKTsgLy8gUkVBTCBhcmVhIGNvbGxpZGUgZm9yIHN3YXAgYW5kIHNraXAgaWYgbm9uZS4uLlxuICAgICAgICBpZiAoIWNvbGxpZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHN3YXAgY2hlY2s6IGlmIHdlJ3JlIGFjdGl2ZWx5IG1vdmluZyBpbiBncmF2aXR5IG1vZGUsIHNlZSBpZiB3ZSBjb2xsaWRlIHdpdGggYW4gb2JqZWN0IHRoZSBzYW1lIHNpemVcbiAgICAgICAgaWYgKG5vZGUuX21vdmluZyAmJiAhb3B0Lm5lc3RlZCAmJiAhdGhpcy5mbG9hdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3dhcChub2RlLCBjb2xsaWRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgd2hpbGUoKSBjb2xsaXNpb25zIE1BS0UgU1VSRSB0byBjaGVjayBlbnRpcmUgcm93IHNvIGxhcmdlciBpdGVtcyBkb24ndCBsZWFwIGZyb2cgc21hbGwgb25lcyAocHVzaCB0aGVtIGFsbCBkb3duIHN0YXJ0aW5nIGxhc3QgaW4gZ3JpZClcbiAgICAgICAgbGV0IGFyZWEgPSBubjtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUVudGlyZVJvd0FyZWEobm9kZSwgbm4pKSB7XG4gICAgICAgICAgICBhcmVhID0geyB4OiAwLCB3OiB0aGlzLmNvbHVtbiwgeTogbm4ueSwgaDogbm4uaCB9O1xuICAgICAgICAgICAgY29sbGlkZSA9IHRoaXMuY29sbGlkZShub2RlLCBhcmVhLCBvcHQuc2tpcCk7IC8vIGZvcmNlIG5ldyBoaXRcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV3T3B0ID0geyBuZXN0ZWQ6IHRydWUsIHBhY2s6IGZhbHNlIH07XG4gICAgICAgIHdoaWxlIChjb2xsaWRlID0gY29sbGlkZSB8fCB0aGlzLmNvbGxpZGUobm9kZSwgYXJlYSwgb3B0LnNraXApKSB7IC8vIGNvdWxkIGNvbGxpZGUgd2l0aCBtb3JlIHRoYW4gMSBpdGVtLi4uIHNvIHJlcGVhdCBmb3IgZWFjaFxuICAgICAgICAgICAgbGV0IG1vdmVkO1xuICAgICAgICAgICAgLy8gaWYgY29sbGlkaW5nIHdpdGggYSBsb2NrZWQgaXRlbSBPUiBtb3ZpbmcgZG93biB3aXRoIHRvcCBncmF2aXR5IChhbmQgY29sbGlkZSBjb3VsZCBtb3ZlIHVwKSAtPiBza2lwIHBhc3QgdGhlIGNvbGxpZGUsXG4gICAgICAgICAgICAvLyBidXQgcmVtZW1iZXIgdGhhdCBza2lwIGRvd24gc28gd2Ugb25seSBkbyB0aGlzIG9uY2UgKGFuZCBwdXNoIG90aGVycyBvdGhlcndpc2UpLlxuICAgICAgICAgICAgaWYgKGNvbGxpZGUubG9ja2VkIHx8IG5vZGUuX21vdmluZyAmJiAhbm9kZS5fc2tpcERvd24gJiYgbm4ueSA+IG5vZGUueSAmJiAhdGhpcy5mbG9hdCAmJlxuICAgICAgICAgICAgICAgIC8vIGNhbiB0YWtlIHNwYWNlIHdlIGhhZCwgb3IgYmVmb3JlIHdoZXJlIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAgICAgKCF0aGlzLmNvbGxpZGUoY29sbGlkZSwgeyAuLi5jb2xsaWRlLCB5OiBub2RlLnkgfSwgbm9kZSkgfHwgIXRoaXMuY29sbGlkZShjb2xsaWRlLCB7IC4uLmNvbGxpZGUsIHk6IG5uLnkgLSBjb2xsaWRlLmggfSwgbm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fc2tpcERvd24gPSAobm9kZS5fc2tpcERvd24gfHwgbm4ueSA+IG5vZGUueSk7XG4gICAgICAgICAgICAgICAgbW92ZWQgPSB0aGlzLm1vdmVOb2RlKG5vZGUsIHsgLi4ubm4sIHk6IGNvbGxpZGUueSArIGNvbGxpZGUuaCwgLi4ubmV3T3B0IH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlLmxvY2tlZCAmJiBtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5jb3B5UG9zKG5uLCBub2RlKTsgLy8gbW92aW5nIGFmdGVyIGxvY2sgYmVjb21lIG91ciBuZXcgZGVzaXJlZCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29sbGlkZS5sb2NrZWQgJiYgbW92ZWQgJiYgb3B0LnBhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbW92ZWQgYWZ0ZXIgYW5kIHdpbGwgcGFjazogZG8gaXQgbm93IGFuZCBrZWVwIHRoZSBvcmlnaW5hbCBkcm9wIGxvY2F0aW9uLCBidXQgcGFzdCB0aGUgb2xkIGNvbGxpZGUgdG8gc2VlIHdoYXQgZWxzZSB3ZSBtaWdodCBwdXNoIHdheVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgbm4ueSA9IGNvbGxpZGUueSArIGNvbGxpZGUuaDtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuY29weVBvcyhub2RlLCBubik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpZE1vdmUgPSBkaWRNb3ZlIHx8IG1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBjb2xsaWRlIGRvd24gKmFmdGVyKiB3aGVyZSB3ZSB3aWxsIGJlLCBpZ25vcmluZyB3aGVyZSB3ZSBhcmUgbm93IChkb24ndCBjb2xsaWRlIHdpdGggdXMpXG4gICAgICAgICAgICAgICAgbW92ZWQgPSB0aGlzLm1vdmVOb2RlKGNvbGxpZGUsIHsgLi4uY29sbGlkZSwgeTogbm4ueSArIG5uLmgsIHNraXA6IG5vZGUsIC4uLm5ld09wdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlkTW92ZTtcbiAgICAgICAgICAgIH0gLy8gYnJlYWsgaW5mIGxvb3AgaWYgd2UgY291bGRuJ3QgbW92ZSBhZnRlciBhbGwgKGV4OiBtYXhSb3csIGZpeGVkKVxuICAgICAgICAgICAgY29sbGlkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlkTW92ZTtcbiAgICB9XG4gICAgLyoqIHJldHVybiB0aGUgbm9kZXMgdGhhdCBpbnRlcmNlcHQgdGhlIGdpdmVuIG5vZGUuIE9wdGlvbmFsbHkgYSBkaWZmZXJlbnQgYXJlYSBjYW4gYmUgdXNlZCwgYXMgd2VsbCBhcyBhIHNlY29uZCBub2RlIHRvIHNraXAgKi9cbiAgICBjb2xsaWRlKHNraXAsIGFyZWEgPSBza2lwLCBza2lwMikge1xuICAgICAgICBjb25zdCBza2lwSWQgPSBza2lwLl9pZDtcbiAgICAgICAgY29uc3Qgc2tpcDJJZCA9IHNraXAyPy5faWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLl9pZCAhPT0gc2tpcElkICYmIG4uX2lkICE9PSBza2lwMklkICYmIFV0aWxzLmlzSW50ZXJjZXB0ZWQobiwgYXJlYSkpO1xuICAgIH1cbiAgICBjb2xsaWRlQWxsKHNraXAsIGFyZWEgPSBza2lwLCBza2lwMikge1xuICAgICAgICBjb25zdCBza2lwSWQgPSBza2lwLl9pZDtcbiAgICAgICAgY29uc3Qgc2tpcDJJZCA9IHNraXAyPy5faWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmZpbHRlcihuID0+IG4uX2lkICE9PSBza2lwSWQgJiYgbi5faWQgIT09IHNraXAySWQgJiYgVXRpbHMuaXNJbnRlcmNlcHRlZChuLCBhcmVhKSk7XG4gICAgfVxuICAgIC8qKiBkb2VzIGEgcGl4ZWwgY292ZXJhZ2UgY29sbGlzaW9uIGJhc2VkIG9uIHdoZXJlIHdlIHN0YXJ0ZWQsIHJldHVybmluZyB0aGUgbm9kZSB0aGF0IGhhcyB0aGUgbW9zdCBjb3ZlcmFnZSB0aGF0IGlzID41MCUgbWlkIGxpbmUgKi9cbiAgICBkaXJlY3Rpb25Db2xsaWRlQ292ZXJhZ2Uobm9kZSwgbywgY29sbGlkZXMpIHtcbiAgICAgICAgaWYgKCFvLnJlY3QgfHwgIW5vZGUuX3JlY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCByMCA9IG5vZGUuX3JlY3Q7IC8vIHdoZXJlIHN0YXJ0ZWRcbiAgICAgICAgbGV0IHIgPSB7IC4uLm8ucmVjdCB9OyAvLyB3aGVyZSB3ZSBhcmVcbiAgICAgICAgLy8gdXBkYXRlIGRyYWdnZWQgcmVjdCB0byBzaG93IHdoZXJlIGl0J3MgY29taW5nIGZyb20gKGFib3ZlIG9yIGJlbG93LCBldGMuLi4pXG4gICAgICAgIGlmIChyLnkgPiByMC55KSB7XG4gICAgICAgICAgICByLmggKz0gci55IC0gcjAueTtcbiAgICAgICAgICAgIHIueSA9IHIwLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByLmggKz0gcjAueSAtIHIueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci54ID4gcjAueCkge1xuICAgICAgICAgICAgci53ICs9IHIueCAtIHIwLng7XG4gICAgICAgICAgICByLnggPSByMC54O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgci53ICs9IHIwLnggLSByLng7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbGxpZGU7XG4gICAgICAgIGxldCBvdmVyTWF4ID0gMC41OyAvLyBuZWVkID41MCVcbiAgICAgICAgY29sbGlkZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmIChuLmxvY2tlZCB8fCAhbi5fcmVjdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcjIgPSBuLl9yZWN0OyAvLyBvdmVybGFwcGluZyB0YXJnZXRcbiAgICAgICAgICAgIGxldCB5T3ZlciA9IE51bWJlci5NQVhfVkFMVUUsIHhPdmVyID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHdlIHN0YXJ0ZWQgZnJvbSwgY29tcHV0ZSB0aGUgb3ZlcmxhcCAlIG9mIGNvdmVyYWdlXG4gICAgICAgICAgICAvLyAoZXg6IGZyb20gYWJvdmUvYmVsb3cgd2Ugb25seSBjb21wdXRlIHRoZSBtYXggaG9yaXpvbnRhbCBsaW5lIGNvdmVyYWdlKVxuICAgICAgICAgICAgaWYgKHIwLnkgPCByMi55KSB7IC8vIGZyb20gYWJvdmVcbiAgICAgICAgICAgICAgICB5T3ZlciA9ICgoci55ICsgci5oKSAtIHIyLnkpIC8gcjIuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIwLnkgKyByMC5oID4gcjIueSArIHIyLmgpIHsgLy8gZnJvbSBiZWxvd1xuICAgICAgICAgICAgICAgIHlPdmVyID0gKChyMi55ICsgcjIuaCkgLSByLnkpIC8gcjIuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMC54IDwgcjIueCkgeyAvLyBmcm9tIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgeE92ZXIgPSAoKHIueCArIHIudykgLSByMi54KSAvIHIyLnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyMC54ICsgcjAudyA+IHIyLnggKyByMi53KSB7IC8vIGZyb20gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgeE92ZXIgPSAoKHIyLnggKyByMi53KSAtIHIueCkgLyByMi53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG92ZXIgPSBNYXRoLm1pbih4T3ZlciwgeU92ZXIpO1xuICAgICAgICAgICAgaWYgKG92ZXIgPiBvdmVyTWF4KSB7XG4gICAgICAgICAgICAgICAgb3Zlck1heCA9IG92ZXI7XG4gICAgICAgICAgICAgICAgY29sbGlkZSA9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvLmNvbGxpZGUgPSBjb2xsaWRlOyAvLyBzYXZlIGl0IHNvIHdlIGRvbid0IGhhdmUgdG8gZmluZCBpdCBhZ2FpblxuICAgICAgICByZXR1cm4gY29sbGlkZTtcbiAgICB9XG4gICAgLyoqIGRvZXMgYSBwaXhlbCBjb3ZlcmFnZSByZXR1cm5pbmcgdGhlIG5vZGUgdGhhdCBoYXMgdGhlIG1vc3QgY292ZXJhZ2UgYnkgYXJlYSAqL1xuICAgIC8qXG4gICAgcHJvdGVjdGVkIGNvbGxpZGVDb3ZlcmFnZShyOiBHcmlkU3RhY2tQb3NpdGlvbiwgY29sbGlkZXM6IEdyaWRTdGFja05vZGVbXSk6IHtjb2xsaWRlOiBHcmlkU3RhY2tOb2RlLCBvdmVyOiBudW1iZXJ9IHtcbiAgICAgIGxldCBjb2xsaWRlOiBHcmlkU3RhY2tOb2RlO1xuICAgICAgbGV0IG92ZXJNYXggPSAwO1xuICAgICAgY29sbGlkZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgaWYgKG4ubG9ja2VkIHx8ICFuLl9yZWN0KSByZXR1cm47XG4gICAgICAgIGxldCBvdmVyID0gVXRpbHMuYXJlYUludGVyY2VwdChyLCBuLl9yZWN0KTtcbiAgICAgICAgaWYgKG92ZXIgPiBvdmVyTWF4KSB7XG4gICAgICAgICAgb3Zlck1heCA9IG92ZXI7XG4gICAgICAgICAgY29sbGlkZSA9IG47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtjb2xsaWRlLCBvdmVyOiBvdmVyTWF4fTtcbiAgICB9XG4gICAgKi9cbiAgICAvKiogY2FsbGVkIHRvIGNhY2hlIHRoZSBub2RlcyBwaXhlbCByZWN0YW5nbGVzIHVzZWQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24gZHVyaW5nIGRyYWcgKi9cbiAgICBjYWNoZVJlY3RzKHcsIGgsIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobiA9PiBuLl9yZWN0ID0ge1xuICAgICAgICAgICAgeTogbi55ICogaCArIHRvcCxcbiAgICAgICAgICAgIHg6IG4ueCAqIHcgKyBsZWZ0LFxuICAgICAgICAgICAgdzogbi53ICogdyAtIGxlZnQgLSByaWdodCxcbiAgICAgICAgICAgIGg6IG4uaCAqIGggLSB0b3AgLSBib3R0b21cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogY2FsbGVkIHRvIHBvc3NpYmx5IHN3YXAgYmV0d2VlbiAyIG5vZGVzIChzYW1lIHNpemUgb3IgY29sdW1uLCBub3QgbG9ja2VkLCB0b3VjaGluZyksIHJldHVybmluZyB0cnVlIGlmIHN1Y2Nlc3NmdWwgKi9cbiAgICBzd2FwKGEsIGIpIHtcbiAgICAgICAgaWYgKCFiIHx8IGIubG9ja2VkIHx8ICFhIHx8IGEubG9ja2VkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBfZG9Td2FwKCkge1xuICAgICAgICAgICAgbGV0IHggPSBiLngsIHkgPSBiLnk7XG4gICAgICAgICAgICBiLnggPSBhLng7XG4gICAgICAgICAgICBiLnkgPSBhLnk7IC8vIGIgLT4gYSBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKGEuaCAhPSBiLmgpIHtcbiAgICAgICAgICAgICAgICBhLnggPSB4O1xuICAgICAgICAgICAgICAgIGEueSA9IGIueSArIGIuaDsgLy8gYSAtPiBnb2VzIGFmdGVyIGJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEudyAhPSBiLncpIHtcbiAgICAgICAgICAgICAgICBhLnggPSBiLnggKyBiLnc7XG4gICAgICAgICAgICAgICAgYS55ID0geTsgLy8gYSAtPiBnb2VzIGFmdGVyIGJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEueCA9IHg7XG4gICAgICAgICAgICAgICAgYS55ID0geTsgLy8gYSAtPiBvbGQgYiBwb3NpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS5fZGlydHkgPSBiLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG91Y2hpbmc7IC8vIHJlbWVtYmVyIGlmIHdlIGNhbGxlZCBpdCAodnMgdW5kZWZpbmVkKVxuICAgICAgICAvLyBzYW1lIHNpemUgYW5kIHNhbWUgcm93IG9yIGNvbHVtbiwgYW5kIHRvdWNoaW5nXG4gICAgICAgIGlmIChhLncgPT09IGIudyAmJiBhLmggPT09IGIuaCAmJiAoYS54ID09PSBiLnggfHwgYS55ID09PSBiLnkpICYmICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKVxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgaWYgKHRvdWNoaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjsgLy8gSUZGIHJhbiB0ZXN0IGFuZCBmYWlsLCBiYWlsIG91dFxuICAgICAgICAvLyBjaGVjayBmb3IgdGFraW5nIHNhbWUgY29sdW1ucyAoYnV0IGRpZmZlcmVudCBoZWlnaHQpIGFuZCB0b3VjaGluZ1xuICAgICAgICBpZiAoYS53ID09PSBiLncgJiYgYS54ID09PSBiLnggJiYgKHRvdWNoaW5nIHx8ICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKSkge1xuICAgICAgICAgICAgaWYgKGIueSA8IGEueSkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdDtcbiAgICAgICAgICAgIH0gLy8gc3dhcCBhIDwtPiBiIHZhcnMgc28gYSBpcyBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBjaGVjayBpZiB0YWtpbmcgc2FtZSByb3cgKGJ1dCBkaWZmZXJlbnQgd2lkdGgpIGFuZCB0b3VjaGluZ1xuICAgICAgICBpZiAoYS5oID09PSBiLmggJiYgYS55ID09PSBiLnkgJiYgKHRvdWNoaW5nIHx8ICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKSkge1xuICAgICAgICAgICAgaWYgKGIueCA8IGEueCkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdDtcbiAgICAgICAgICAgIH0gLy8gc3dhcCBhIDwtPiBiIHZhcnMgc28gYSBpcyBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQXJlYUVtcHR5KHgsIHksIHcsIGgpIHtcbiAgICAgICAgbGV0IG5uID0geyB4OiB4IHx8IDAsIHk6IHkgfHwgMCwgdzogdyB8fCAxLCBoOiBoIHx8IDEgfTtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbGxpZGUobm4pO1xuICAgIH1cbiAgICAvKiogcmUtbGF5b3V0IGdyaWQgaXRlbXMgdG8gcmVjbGFpbSBhbnkgZW1wdHkgc3BhY2UgLSBvcHRpb25hbGx5IGtlZXBpbmcgdGhlIHNvcnQgb3JkZXIgZXhhY3RseSB0aGUgc2FtZSAoJ2xpc3QnIG1vZGUpIHZzIHRydWx5IGZpbmRpbmcgYW4gZW1wdHkgc3BhY2VzICovXG4gICAgY29tcGFjdChsYXlvdXQgPSAnY29tcGFjdCcsIGRvU29ydCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChkb1NvcnQpXG4gICAgICAgICAgICB0aGlzLnNvcnROb2RlcygpO1xuICAgICAgICBjb25zdCB3YXNCYXRjaCA9IHRoaXMuYmF0Y2hNb2RlO1xuICAgICAgICBpZiAoIXdhc0JhdGNoKVxuICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpO1xuICAgICAgICBjb25zdCB3YXNDb2x1bW5SZXNpemUgPSB0aGlzLl9pbkNvbHVtblJlc2l6ZTtcbiAgICAgICAgaWYgKCF3YXNDb2x1bW5SZXNpemUpXG4gICAgICAgICAgICB0aGlzLl9pbkNvbHVtblJlc2l6ZSA9IHRydWU7IC8vIGZhc3RlciBhZGROb2RlKClcbiAgICAgICAgbGV0IGNvcHlOb2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTsgLy8gcHJldGVuZCB3ZSBoYXZlIG5vIG5vZGVzIHRvIGNvbmZsaWN0IGxheW91dCB0byBzdGFydCB3aXRoLi4uXG4gICAgICAgIGNvcHlOb2Rlcy5mb3JFYWNoKChuLCBpbmRleCwgbGlzdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFmdGVyO1xuICAgICAgICAgICAgaWYgKCFuLmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIG4uYXV0b1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnbGlzdCcgJiYgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gbGlzdFtpbmRleCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGROb2RlKG4sIGZhbHNlLCBhZnRlcik7IC8vICdmYWxzZScgZm9yIGFkZCBldmVudCB0cmlnZ2VyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdhc0NvbHVtblJlc2l6ZSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbkNvbHVtblJlc2l6ZTtcbiAgICAgICAgaWYgKCF3YXNCYXRjaClcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIGVuYWJsZS9kaXNhYmxlIGZsb2F0aW5nIHdpZGdldHMgKGRlZmF1bHQ6IGBmYWxzZWApIFNlZSBbZXhhbXBsZV0oaHR0cDovL2dyaWRzdGFja2pzLmNvbS9kZW1vL2Zsb2F0Lmh0bWwpICovXG4gICAgc2V0IGZsb2F0KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5fZmxvYXQgPT09IHZhbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZmxvYXQgPSB2YWwgfHwgZmFsc2U7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKS5fbm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGZsb2F0IGdldHRlciBtZXRob2QgKi9cbiAgICBnZXQgZmxvYXQoKSB7IHJldHVybiB0aGlzLl9mbG9hdCB8fCBmYWxzZTsgfVxuICAgIC8qKiBzb3J0IHRoZSBub2RlcyBhcnJheSBmcm9tIGZpcnN0IHRvIGxhc3QsIG9yIHJldmVyc2UuIENhbGxlZCBkdXJpbmcgY29sbGlzaW9uL3BsYWNlbWVudCB0byBmb3JjZSBhbiBvcmRlciAqL1xuICAgIHNvcnROb2RlcyhkaXIgPSAxLCBjb2x1bW4gPSB0aGlzLmNvbHVtbikge1xuICAgICAgICB0aGlzLm5vZGVzID0gVXRpbHMuc29ydCh0aGlzLm5vZGVzLCBkaXIsIGNvbHVtbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byB0b3AgZ3Jhdml0eSBwYWNrIHRoZSBpdGVtcyBiYWNrIE9SIHJldmVydCBiYWNrIHRvIG9yaWdpbmFsIFkgcG9zaXRpb25zIHdoZW4gZmxvYXRpbmcgKi9cbiAgICBfcGFja05vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5iYXRjaE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydE5vZGVzKCk7IC8vIGZpcnN0IHRvIGxhc3RcbiAgICAgICAgaWYgKHRoaXMuZmxvYXQpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgWSBwb3NcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobi5fdXBkYXRpbmcgfHwgbi5fb3JpZyA9PT0gdW5kZWZpbmVkIHx8IG4ueSA9PT0gbi5fb3JpZy55KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IG5ld1kgPSBuLnk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1kgPiBuLl9vcmlnLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1uZXdZO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlkZSA9IHRoaXMuY29sbGlkZShuLCB7IHg6IG4ueCwgeTogbmV3WSwgdzogbi53LCBoOiBuLmggfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi55ID0gbmV3WTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9wIGdyYXZpdHkgcGFja1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKChuLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG4ubG9ja2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4ueSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1kgPSBpID09PSAwID8gMCA6IG4ueSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYW5CZU1vdmVkID0gaSA9PT0gMCB8fCAhdGhpcy5jb2xsaWRlKG4sIHsgeDogbi54LCB5OiBuZXdZLCB3OiBuLncsIGg6IG4uaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5CZU1vdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IG11c3QgYmUgZGlydHkgKGZyb20gbGFzdCBwb3NpdGlvbikgZm9yIEdyaWRTdGFjazo6T25DaGFuZ2UgQ0IgdG8gdXBkYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdGVtcyBiYWNrLiBUaGUgdXNlciAnY2hhbmdlJyBDQiBzaG91bGQgZGV0ZWN0IGNoYW5nZXMgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgcG9zaXRpb24gaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgbi5fZGlydHkgPSAobi55ICE9PSBuZXdZKTtcbiAgICAgICAgICAgICAgICAgICAgbi55ID0gbmV3WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSByYW5kb20gbm9kZSwgbWFrZXMgc3VyZSBpdCdzIGNvb3JkaW5hdGVzL3ZhbHVlcyBhcmUgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZ3JpZFxuICAgICAqIEBwYXJhbSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSByZXNpemluZyBpZiBvdXQgb2YgYm91bmQsIHJlc2l6ZSBkb3duIG9yIG1vdmUgaW50byB0aGUgZ3JpZCB0byBmaXQgP1xuICAgICAqL1xuICAgIHByZXBhcmVOb2RlKG5vZGUsIHJlc2l6aW5nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xuICAgICAgICBub2RlLl9pZCA9IG5vZGUuX2lkID8/IEdyaWRTdGFja0VuZ2luZS5faWRTZXErKztcbiAgICAgICAgLy8gaWYgd2UncmUgbWlzc2luZyBwb3NpdGlvbiwgaGF2ZSB0aGUgZ3JpZCBwb3NpdGlvbiB1cyBhdXRvbWF0aWNhbGx5IChiZWZvcmUgd2Ugc2V0IHRoZW0gdG8gMCwwKVxuICAgICAgICBpZiAobm9kZS54ID09PSB1bmRlZmluZWQgfHwgbm9kZS55ID09PSB1bmRlZmluZWQgfHwgbm9kZS54ID09PSBudWxsIHx8IG5vZGUueSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5hdXRvUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2lnbiBkZWZhdWx0cyBmb3IgbWlzc2luZyByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgbGV0IGRlZmF1bHRzID0geyB4OiAwLCB5OiAwLCB3OiAxLCBoOiAxIH07XG4gICAgICAgIFV0aWxzLmRlZmF1bHRzKG5vZGUsIGRlZmF1bHRzKTtcbiAgICAgICAgaWYgKCFub2RlLmF1dG9Qb3NpdGlvbikge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuYXV0b1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub1Jlc2l6ZSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubm9SZXNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vTW92ZSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubm9Nb3ZlO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzLnNhbml0aXplTWluTWF4KG5vZGUpO1xuICAgICAgICAvLyBjaGVjayBmb3IgTmFOIChpbiBjYXNlIG1lc3NlZCB1cCBzdHJpbmdzIHdlcmUgcGFzc2VkLiBjYW4ndCBkbyBwYXJzZUludCgpIHx8IGRlZmF1bHRzLnggYWJvdmUgYXMgMCBpcyB2YWxpZCAjKVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUueCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9kZS54ID0gTnVtYmVyKG5vZGUueCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLnkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IE51bWJlcihub2RlLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS53ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlLncgPSBOdW1iZXIobm9kZS53KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUuaCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9kZS5oID0gTnVtYmVyKG5vZGUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUueCkpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IGRlZmF1bHRzLng7XG4gICAgICAgICAgICBub2RlLmF1dG9Qb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IGRlZmF1bHRzLnk7XG4gICAgICAgICAgICBub2RlLmF1dG9Qb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUudykpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IGRlZmF1bHRzLnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUuaCkpIHtcbiAgICAgICAgICAgIG5vZGUuaCA9IGRlZmF1bHRzLmg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUJvdW5kRml4KG5vZGUsIHJlc2l6aW5nKTtcbiAgICB9XG4gICAgLyoqIHBhcnQyIG9mIHByZXBhcmluZyBhIG5vZGUgdG8gZml0IGluc2lkZSBvdXIgZ3JpZCAtIGNoZWNrcyBmb3IgeCx5LHcgZnJvbSBncmlkIGRpbWVuc2lvbnMgKi9cbiAgICBub2RlQm91bmRGaXgobm9kZSwgcmVzaXppbmcpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuX29yaWcgfHwgVXRpbHMuY29weVBvcyh7fSwgbm9kZSk7XG4gICAgICAgIGlmIChub2RlLm1heFcpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IE1hdGgubWluKG5vZGUudywgbm9kZS5tYXhXKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5tYXhIKSB7XG4gICAgICAgICAgICBub2RlLmggPSBNYXRoLm1pbihub2RlLmgsIG5vZGUubWF4SCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubWluVyAmJiBub2RlLm1pblcgPD0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIG5vZGUudyA9IE1hdGgubWF4KG5vZGUudywgbm9kZS5taW5XKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5taW5IKSB7XG4gICAgICAgICAgICBub2RlLmggPSBNYXRoLm1heChub2RlLmgsIG5vZGUubWluSCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBsb2FkZWQgYSBsYXJnZXIgdGhhbiBhbGxvd2VkIHdpZGdldCBmb3IgY3VycmVudCAjIG9mIGNvbHVtbnMsXG4gICAgICAgIC8vIHJlbWVtYmVyIGl0J3MgcG9zaXRpb24gJiB3aWR0aCBzbyB3ZSBjYW4gcmVzdG9yZSBiYWNrICgxIC0+IDEyIGNvbHVtbikgIzE2NTUgIzE5ODVcbiAgICAgICAgLy8gSUZGIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGNvbHVtbiByZXNpemluZyFcbiAgICAgICAgY29uc3Qgc2F2ZU9yaWcgPSAobm9kZS54IHx8IDApICsgKG5vZGUudyB8fCAxKSA+IHRoaXMuY29sdW1uO1xuICAgICAgICBpZiAoc2F2ZU9yaWcgJiYgdGhpcy5jb2x1bW4gPCAxMiAmJiAhdGhpcy5faW5Db2x1bW5SZXNpemUgJiYgbm9kZS5faWQgJiYgdGhpcy5maW5kQ2FjaGVMYXlvdXQobm9kZSwgMTIpID09PSAtMSkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSB7IC4uLm5vZGUgfTsgLy8gbmVlZCBfaWQgKyBwb3NpdGlvbnNcbiAgICAgICAgICAgIGlmIChjb3B5LmF1dG9Qb3NpdGlvbiB8fCBjb3B5LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb3B5Lng7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvcHkueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb3B5LnggPSBNYXRoLm1pbigxMSwgY29weS54KTtcbiAgICAgICAgICAgIGNvcHkudyA9IE1hdGgubWluKDEyLCBjb3B5LncgfHwgMSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlT25lTGF5b3V0KGNvcHksIDEyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS53ID4gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIG5vZGUudyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudyA8IDEpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4Um93ICYmIG5vZGUuaCA+IHRoaXMubWF4Um93KSB7XG4gICAgICAgICAgICBub2RlLmggPSB0aGlzLm1heFJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLmggPCAxKSB7XG4gICAgICAgICAgICBub2RlLmggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnggPCAwKSB7XG4gICAgICAgICAgICBub2RlLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnkgPCAwKSB7XG4gICAgICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnggKyBub2RlLncgPiB0aGlzLmNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgbm9kZS53ID0gdGhpcy5jb2x1bW4gLSBub2RlLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSB0aGlzLmNvbHVtbiAtIG5vZGUudztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhSb3cgJiYgbm9kZS55ICsgbm9kZS5oID4gdGhpcy5tYXhSb3cpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemluZykge1xuICAgICAgICAgICAgICAgIG5vZGUuaCA9IHRoaXMubWF4Um93IC0gbm9kZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gdGhpcy5tYXhSb3cgLSBub2RlLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVdGlscy5zYW1lUG9zKG5vZGUsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqIHJldHVybnMgYSBsaXN0IG9mIG1vZGlmaWVkIG5vZGVzIGZyb20gdGhlaXIgb3JpZ2luYWwgdmFsdWVzICovXG4gICAgZ2V0RGlydHlOb2Rlcyh2ZXJpZnkpIHtcbiAgICAgICAgLy8gY29tcGFyZSBvcmlnaW5hbCB4LHksdyxoIGluc3RlYWQgYXMgX2RpcnR5IGNhbiBiZSBhIHRlbXBvcmFyeSBzdGF0ZVxuICAgICAgICBpZiAodmVyaWZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5maWx0ZXIobiA9PiBuLl9kaXJ0eSAmJiAhVXRpbHMuc2FtZVBvcyhuLCBuLl9vcmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuZmlsdGVyKG4gPT4gbi5fZGlydHkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGwgdGhpcyB0byBjYWxsIG9uQ2hhbmdlIGNhbGxiYWNrIHdpdGggZGlydHkgbm9kZXMgc28gRE9NIGNhbiBiZSB1cGRhdGVkICovXG4gICAgX25vdGlmeShyZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hNb2RlIHx8ICF0aGlzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBkaXJ0eU5vZGVzID0gKHJlbW92ZWROb2RlcyB8fCBbXSkuY29uY2F0KHRoaXMuZ2V0RGlydHlOb2RlcygpKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShkaXJ0eU5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVtb3ZlIGRpcnR5IGFuZCBsYXN0IHRyaWVkIGluZm8gKi9cbiAgICBjbGVhbk5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5iYXRjaE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgZGVsZXRlIG4uX2RpcnR5O1xuICAgICAgICAgICAgZGVsZXRlIG4uX2xhc3RUcmllZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byBzYXZlIGluaXRpYWwgcG9zaXRpb24vc2l6ZSB0byB0cmFjayByZWFsIGRpcnR5IHN0YXRlLlxuICAgICAqIE5vdGU6IHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgY2FsbCBjaGFuZ2UgZXZlbnQgKHNvIG5leHQgQVBJIGlzIGNhbiBkZXRlY3QgY2hhbmdlcylcbiAgICAgKiBhcyB3ZWxsIGFzIHJpZ2h0IGJlZm9yZSB3ZSBzdGFydCBtb3ZlL3Jlc2l6ZS9lbnRlciAoc28gd2UgY2FuIHJlc3RvcmUgaXRlbXMgdG8gcHJldiB2YWx1ZXMpICovXG4gICAgc2F2ZUluaXRpYWwoKSB7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIG4uX29yaWcgPSBVdGlscy5jb3B5UG9zKHt9LCBuKTtcbiAgICAgICAgICAgIGRlbGV0ZSBuLl9kaXJ0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2hhc0xvY2tlZCA9IHRoaXMubm9kZXMuc29tZShuID0+IG4ubG9ja2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVzdG9yZSBhbGwgdGhlIG5vZGVzIGJhY2sgdG8gaW5pdGlhbCB2YWx1ZXMgKGNhbGxlZCB3aGVuIHdlIGxlYXZlKSAqL1xuICAgIHJlc3RvcmVJbml0aWFsKCkge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuc2FtZVBvcyhuLCBuLl9vcmlnKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBVdGlscy5jb3B5UG9zKG4sIG4uX29yaWcpO1xuICAgICAgICAgICAgbi5fZGlydHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogZmluZCB0aGUgZmlyc3QgYXZhaWxhYmxlIGVtcHR5IHNwb3QgZm9yIHRoZSBnaXZlbiBub2RlIHdpZHRoL2hlaWdodCwgdXBkYXRpbmcgdGhlIHgseSBhdHRyaWJ1dGVzLiByZXR1cm4gdHJ1ZSBpZiBmb3VuZC5cbiAgICAgKiBvcHRpb25hbGx5IHlvdSBjYW4gcGFzcyB5b3VyIG93biBleGlzdGluZyBub2RlIGxpc3QgYW5kIGNvbHVtbiBjb3VudCwgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIHRoYXQgZW5naW5lIGRhdGEuXG4gICAgICogT3B0aW9uYWxseSBwYXNzIGEgd2lkZ2V0IHRvIHN0YXJ0IHNlYXJjaCBBRlRFUiwgbWVhbmluZyB0aGUgb3JkZXIgd2lsbCByZW1haW4gdGhlIHNhbWUgYnV0IHBvc3NpYmx5IGhhdmUgZW1wdHkgc2xvdHMgd2Ugc2tpcHBlZFxuICAgICAqL1xuICAgIGZpbmRFbXB0eVBvc2l0aW9uKG5vZGUsIG5vZGVMaXN0ID0gdGhpcy5ub2RlcywgY29sdW1uID0gdGhpcy5jb2x1bW4sIGFmdGVyKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGFmdGVyID8gYWZ0ZXIueSAqIGNvbHVtbiArIChhZnRlci54ICsgYWZ0ZXIudykgOiAwO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyAhZm91bmQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHggPSBpICUgY29sdW1uO1xuICAgICAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKGkgLyBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKHggKyBub2RlLncgPiBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBib3ggPSB7IHgsIHksIHc6IG5vZGUudywgaDogbm9kZS5oIH07XG4gICAgICAgICAgICBpZiAoIW5vZGVMaXN0LmZpbmQobiA9PiBVdGlscy5pc0ludGVyY2VwdGVkKGJveCwgbikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUueCAhPT0geCB8fCBub2RlLnkgIT09IHkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnggPSB4O1xuICAgICAgICAgICAgICAgIG5vZGUueSA9IHk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuYXV0b1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKiBjYWxsIHRvIGFkZCB0aGUgZ2l2ZW4gbm9kZSB0byBvdXIgbGlzdCwgZml4aW5nIGNvbGxpc2lvbiBhbmQgcmUtcGFja2luZyAqL1xuICAgIGFkZE5vZGUobm9kZSwgdHJpZ2dlckFkZEV2ZW50ID0gZmFsc2UsIGFmdGVyKSB7XG4gICAgICAgIGxldCBkdXAgPSB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLl9pZCA9PT0gbm9kZS5faWQpO1xuICAgICAgICBpZiAoZHVwKVxuICAgICAgICAgICAgcmV0dXJuIGR1cDsgLy8gcHJldmVudCBpbnNlcnRpbmcgdHdpY2UhIHJldHVybiBpdCBpbnN0ZWFkLlxuICAgICAgICAvLyBza2lwIHByZXBhcmVOb2RlIGlmIHdlJ3JlIGluIG1pZGRsZSBvZiBjb2x1bW4gcmVzaXplIChub3QgbmV3KSBidXQgZG8gY2hlY2sgZm9yIGJvdW5kcyFcbiAgICAgICAgbm9kZSA9IHRoaXMuX2luQ29sdW1uUmVzaXplID8gdGhpcy5ub2RlQm91bmRGaXgobm9kZSkgOiB0aGlzLnByZXBhcmVOb2RlKG5vZGUpO1xuICAgICAgICBkZWxldGUgbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZDtcbiAgICAgICAgZGVsZXRlIG5vZGUuX3JlbW92ZURPTTtcbiAgICAgICAgbGV0IHNraXBDb2xsaXNpb247XG4gICAgICAgIGlmIChub2RlLmF1dG9Qb3NpdGlvbiAmJiB0aGlzLmZpbmRFbXB0eVBvc2l0aW9uKG5vZGUsIHRoaXMubm9kZXMsIHRoaXMuY29sdW1uLCBhZnRlcikpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmF1dG9Qb3NpdGlvbjsgLy8gZm91bmQgb3VyIHNsb3RcbiAgICAgICAgICAgIHNraXBDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKHRyaWdnZXJBZGRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5hZGRlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwQ29sbGlzaW9uKVxuICAgICAgICAgICAgdGhpcy5fZml4Q29sbGlzaW9ucyhub2RlKTtcbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fcGFja05vZGVzKCkuX25vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUsIHJlbW92ZURPTSA9IHRydWUsIHRyaWdnZXJFdmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5faWQgPT09IG5vZGUuX2lkKSkge1xuICAgICAgICAgICAgLy8gVEVTVCBjb25zb2xlLmxvZyhgRXJyb3I6IEdyaWRTdGFja0VuZ2luZS5yZW1vdmVOb2RlKCkgbm9kZS5faWQ9JHtub2RlLl9pZH0gbm90IGZvdW5kIWApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlckV2ZW50KSB7IC8vIHdlIHdhaXQgdW50aWwgZmluYWwgZHJvcCB0byBtYW51YWxseSB0cmFjayByZW1vdmVkIGl0ZW1zIChyYXRoZXIgdGhhbiBkdXJpbmcgZHJhZylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZURPTSlcbiAgICAgICAgICAgIG5vZGUuX3JlbW92ZURPTSA9IHRydWU7IC8vIGxldCBDQiByZW1vdmUgYWN0dWFsIEhUTUwgKHVzZWQgdG8gc2V0IF9pZCB0byBudWxsLCBidXQgdGhlbiB3ZSBsb29zZSBsYXlvdXQgaW5mbylcbiAgICAgICAgLy8gZG9uJ3QgdXNlICdmYXN0ZXInIC5zcGxpY2UoZmluZEluZGV4KCksMSkgaW4gY2FzZSBub2RlIGlzbid0IGluIG91ciBsaXN0LCBvciBpbiBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKG4gPT4gbi5faWQgIT09IG5vZGUuX2lkKTtcbiAgICAgICAgaWYgKCFub2RlLl9pc0Fib3V0VG9SZW1vdmUpXG4gICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKTsgLy8gaWYgZHJhZ2dlZCBvdXQsIG5vIG5lZWQgdG8gcmVsYXlvdXQgYXMgYWxyZWFkeSBkb25lLi4uXG4gICAgICAgIHRoaXMuX25vdGlmeShbbm9kZV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsKHJlbW92ZURPTSA9IHRydWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheW91dHM7XG4gICAgICAgIGlmICghdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmVtb3ZlRE9NICYmIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IG4uX3JlbW92ZURPTSA9IHRydWUpOyAvLyBsZXQgQ0IgcmVtb3ZlIGFjdHVhbCBIVE1MICh1c2VkIHRvIHNldCBfaWQgdG8gbnVsbCwgYnV0IHRoZW4gd2UgbG9vc2UgbGF5b3V0IGluZm8pXG4gICAgICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm90aWZ5KHRoaXMucmVtb3ZlZE5vZGVzKTtcbiAgICB9XG4gICAgLyoqIGNoZWNrcyBpZiBpdGVtIGNhbiBiZSBtb3ZlZCAobGF5b3V0IGNvbnN0cmFpbikgdnMgbW92ZU5vZGUoKSwgcmV0dXJuaW5nIHRydWUgaWYgd2FzIGFibGUgdG8gbW92ZS5cbiAgICAgKiBJbiBtb3JlIGNvbXBsaWNhdGVkIGNhc2VzIChtYXhSb3cpIGl0IHdpbGwgYXR0ZW1wdCBhdCBtb3ZpbmcgdGhlIGl0ZW0gYW5kIGZpeGluZ1xuICAgICAqIG90aGVycyBpbiBhIGNsb25lIGZpcnN0LCB0aGVuIGFwcGx5IHRob3NlIGNoYW5nZXMgaWYgc3RpbGwgd2l0aGluIHNwZWNzLiAqL1xuICAgIG1vdmVOb2RlQ2hlY2sobm9kZSwgbykge1xuICAgICAgICAvLyBpZiAobm9kZS5sb2NrZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5nZWRQb3NDb25zdHJhaW4obm9kZSwgbykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG8ucGFjayA9IHRydWU7XG4gICAgICAgIC8vIHNpbXBsZXIgY2FzZTogbW92ZSBpdGVtIGRpcmVjdGx5Li4uXG4gICAgICAgIGlmICghdGhpcy5tYXhSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVOb2RlKG5vZGUsIG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBsZXggY2FzZTogY3JlYXRlIGEgY2xvbmUgd2l0aCBOTyBtYXhSb3cgKHdpbGwgY2hlY2sgZm9yIG91dCBvZiBib3VuZHMgYXQgdGhlIGVuZClcbiAgICAgICAgbGV0IGNsb25lZE5vZGU7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBHcmlkU3RhY2tFbmdpbmUoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0OiB0aGlzLmZsb2F0LFxuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZSA9IHsgLi4ubiB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubiB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2xvbmVkTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UncmUgY292ZXJpbmcgNTAlIGNvbGxpc2lvbiBhbmQgY291bGQgbW92ZSwgd2hpbGUgc3RpbGwgYmVpbmcgdW5kZXIgbWF4Um93IG9yIGF0IGxlYXN0IG5vdCBtYWtpbmcgaXQgd29yc2VcbiAgICAgICAgLy8gKGNhc2Ugd2hlcmUgd2lkZ2V0IHdhcyBzb21laG93IGFkZGVkIHBhc3Qgb3VyIG1heCAjMjQ0OSlcbiAgICAgICAgbGV0IGNhbk1vdmUgPSBjbG9uZS5tb3ZlTm9kZShjbG9uZWROb2RlLCBvKSAmJiBjbG9uZS5nZXRSb3coKSA8PSBNYXRoLm1heCh0aGlzLmdldFJvdygpLCB0aGlzLm1heFJvdyk7XG4gICAgICAgIC8vIGVsc2UgY2hlY2sgaWYgd2UgY2FuIGZvcmNlIGEgc3dhcCAoZmxvYXQ9dHJ1ZSwgb3IgZGlmZmVyZW50IHNoYXBlcykgb24gbm9uLXJlc2l6ZVxuICAgICAgICBpZiAoIWNhbk1vdmUgJiYgIW8ucmVzaXppbmcgJiYgby5jb2xsaWRlKSB7XG4gICAgICAgICAgICBsZXQgY29sbGlkZSA9IG8uY29sbGlkZS5lbC5ncmlkc3RhY2tOb2RlOyAvLyBmaW5kIHRoZSBzb3VyY2Ugbm9kZSB0aGUgY2xvbmUgY29sbGlkZWQgd2l0aCBhdCA1MCVcbiAgICAgICAgICAgIGlmICh0aGlzLnN3YXAobm9kZSwgY29sbGlkZSkpIHsgLy8gc3dhcHMgYW5kIG1hcmsgZGlydHlcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbk1vdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGlmIGNsb25lIHdhcyBhYmxlIHRvIG1vdmUsIGNvcHkgdGhvc2UgbW9kcyBvdmVyIHRvIHVzIG5vdyBpbnN0ZWFkIG9mIGNhbGxlciB0cnlpbmcgdG8gZG8gdGhpcyBhbGwgb3ZlciFcbiAgICAgICAgLy8gTm90ZTogd2UgY2FuJ3QgdXNlIHRoZSBsaXN0IGRpcmVjdGx5IGFzIGVsZW1lbnRzIGFuZCBvdGhlciBwYXJ0cyBwb2ludCB0byBhY3R1YWwgbm9kZSwgc28gY29weSBjb250ZW50XG4gICAgICAgIGNsb25lLm5vZGVzLmZpbHRlcihuID0+IG4uX2RpcnR5KS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLm5vZGVzLmZpbmQoYSA9PiBhLl9pZCA9PT0gYy5faWQpO1xuICAgICAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFV0aWxzLmNvcHlQb3MobiwgYyk7XG4gICAgICAgICAgICBuLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiByZXR1cm4gdHJ1ZSBpZiBjYW4gZml0IGluIGdyaWQgaGVpZ2h0IGNvbnN0cmFpbiBvbmx5IChhbHdheXMgdHJ1ZSBpZiBubyBtYXhSb3cpICovXG4gICAgd2lsbEl0Rml0KG5vZGUpIHtcbiAgICAgICAgZGVsZXRlIG5vZGUuX3dpbGxGaXRQb3M7XG4gICAgICAgIGlmICghdGhpcy5tYXhSb3cpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY2xvbmUgd2l0aCBOTyBtYXhSb3cgYW5kIGNoZWNrIGlmIHN0aWxsIHdpdGhpbiBzaXplXG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBHcmlkU3RhY2tFbmdpbmUoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0OiB0aGlzLmZsb2F0LFxuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMubWFwKG4gPT4geyByZXR1cm4geyAuLi5uIH07IH0pXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbiA9IHsgLi4ubm9kZSB9OyAvLyBjbG9uZSBub2RlIHNvIHdlIGRvbid0IG1vZCBhbnkgc2V0dGluZ3Mgb24gaXQgYnV0IGhhdmUgZnVsbCBhdXRvUG9zaXRpb24gYW5kIG1pbi9tYXggYXMgd2VsbCEgIzE2ODdcbiAgICAgICAgdGhpcy5jbGVhbnVwTm9kZShuKTtcbiAgICAgICAgZGVsZXRlIG4uZWw7XG4gICAgICAgIGRlbGV0ZSBuLl9pZDtcbiAgICAgICAgZGVsZXRlIG4uY29udGVudDtcbiAgICAgICAgZGVsZXRlIG4uZ3JpZDtcbiAgICAgICAgY2xvbmUuYWRkTm9kZShuKTtcbiAgICAgICAgaWYgKGNsb25lLmdldFJvdygpIDw9IHRoaXMubWF4Um93KSB7XG4gICAgICAgICAgICBub2RlLl93aWxsRml0UG9zID0gVXRpbHMuY29weVBvcyh7fSwgbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiB0cnVlIGlmIHgseSBvciB3LGggYXJlIGRpZmZlcmVudCBhZnRlciBjbGFtcGluZyB0byBtaW4vbWF4ICovXG4gICAgY2hhbmdlZFBvc0NvbnN0cmFpbihub2RlLCBwKSB7XG4gICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB3LGggYXJlIHNldCBmb3IgY2FsbGVyXG4gICAgICAgIHAudyA9IHAudyB8fCBub2RlLnc7XG4gICAgICAgIHAuaCA9IHAuaCB8fCBub2RlLmg7XG4gICAgICAgIGlmIChub2RlLnggIT09IHAueCB8fCBub2RlLnkgIT09IHAueSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBjaGVjayBjb25zdHJhaW5lZCB3LGhcbiAgICAgICAgaWYgKG5vZGUubWF4Vykge1xuICAgICAgICAgICAgcC53ID0gTWF0aC5taW4ocC53LCBub2RlLm1heFcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm1heEgpIHtcbiAgICAgICAgICAgIHAuaCA9IE1hdGgubWluKHAuaCwgbm9kZS5tYXhIKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5taW5XKSB7XG4gICAgICAgICAgICBwLncgPSBNYXRoLm1heChwLncsIG5vZGUubWluVyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubWluSCkge1xuICAgICAgICAgICAgcC5oID0gTWF0aC5tYXgocC5oLCBub2RlLm1pbkgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobm9kZS53ICE9PSBwLncgfHwgbm9kZS5oICE9PSBwLmgpO1xuICAgIH1cbiAgICAvKiogcmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBub2RlIHdhcyBhY3R1YWxseSBtb3ZlZCAoY2hlY2tzIGZvciBuby1vcCBhbmQgbG9ja2VkKSAqL1xuICAgIG1vdmVOb2RlKG5vZGUsIG8pIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IC8qbm9kZS5sb2NrZWQgfHwqLyAhbylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHdhc1VuZGVmaW5lZFBhY2s7XG4gICAgICAgIGlmIChvLnBhY2sgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5iYXRjaE1vZGUpIHtcbiAgICAgICAgICAgIHdhc1VuZGVmaW5lZFBhY2sgPSBvLnBhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcGFzc2VkIGluIHZhbHVlcyBhbmQgY2hlY2sgaWYgd2UncmUgc3RpbGwgY2hhbmdpbmcgb3VyIG5vZGVcbiAgICAgICAgaWYgKHR5cGVvZiBvLnggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLnggPSBub2RlLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLnkgPSBub2RlLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLncgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLncgPSBub2RlLnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLmggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLmggPSBub2RlLmg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc2l6aW5nID0gKG5vZGUudyAhPT0gby53IHx8IG5vZGUuaCAhPT0gby5oKTtcbiAgICAgICAgbGV0IG5uID0gVXRpbHMuY29weVBvcyh7fSwgbm9kZSwgdHJ1ZSk7IC8vIGdldCBtaW4vbWF4IG91dCBmaXJzdCwgdGhlbiBvcHQgcG9zaXRpb25zIG5leHRcbiAgICAgICAgVXRpbHMuY29weVBvcyhubiwgbyk7XG4gICAgICAgIG5uID0gdGhpcy5ub2RlQm91bmRGaXgobm4sIHJlc2l6aW5nKTtcbiAgICAgICAgVXRpbHMuY29weVBvcyhvLCBubik7XG4gICAgICAgIGlmICghby5mb3JjZUNvbGxpZGUgJiYgVXRpbHMuc2FtZVBvcyhub2RlLCBvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHByZXZQb3MgPSBVdGlscy5jb3B5UG9zKHt9LCBub2RlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugd2lsbCBuZWVkIHRvIGZpeCBjb2xsaXNpb24gYXQgb3VyIG5ldyBsb2NhdGlvblxuICAgICAgICBsZXQgY29sbGlkZXMgPSB0aGlzLmNvbGxpZGVBbGwobm9kZSwgbm4sIG8uc2tpcCk7XG4gICAgICAgIGxldCBuZWVkVG9Nb3ZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbGxpZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZURyYWcgPSBub2RlLl9tb3ZpbmcgJiYgIW8ubmVzdGVkO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGNvbGxpZGVkIG92ZXIgNTAlIHN1cmZhY2UgYXJlYSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgbGV0IGNvbGxpZGUgPSBhY3RpdmVEcmFnID8gdGhpcy5kaXJlY3Rpb25Db2xsaWRlQ292ZXJhZ2Uobm9kZSwgbywgY29sbGlkZXMpIDogY29sbGlkZXNbMF07XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBlbmFibGluZyBjcmVhdGlvbiBvZiBzdWItZ3JpZHMgb24gdGhlIGZseSwgc2VlIGlmIHdlJ3JlIGNvdmVyaW5nIDgwJSBvZiBlaXRoZXIgb25lLCBpZiB3ZSBkaWRuJ3QgYWxyZWFkeSBkbyB0aGF0XG4gICAgICAgICAgICBpZiAoYWN0aXZlRHJhZyAmJiBjb2xsaWRlICYmIG5vZGUuZ3JpZD8ub3B0cz8uc3ViR3JpZER5bmFtaWMgJiYgIW5vZGUuZ3JpZC5faXNUZW1wKSB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXIgPSBVdGlscy5hcmVhSW50ZXJjZXB0KG8ucmVjdCwgY29sbGlkZS5fcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IGExID0gVXRpbHMuYXJlYShvLnJlY3QpO1xuICAgICAgICAgICAgICAgIGxldCBhMiA9IFV0aWxzLmFyZWEoY29sbGlkZS5fcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmMgPSBvdmVyIC8gKGExIDwgYTIgPyBhMSA6IGEyKTtcbiAgICAgICAgICAgICAgICBpZiAocGVyYyA+IC44KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGUuZ3JpZC5tYWtlU3ViR3JpZChjb2xsaWRlLmVsLCB1bmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xsaWRlKSB7XG4gICAgICAgICAgICAgICAgbmVlZFRvTW92ZSA9ICF0aGlzLl9maXhDb2xsaXNpb25zKG5vZGUsIG5uLCBjb2xsaWRlLCBvKTsgLy8gY2hlY2sgaWYgYWxyZWFkeSBtb3ZlZC4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZFRvTW92ZSA9IGZhbHNlOyAvLyB3ZSBkaWRuJ3QgY292ZXIgPjUwJSBmb3IgYSBtb3ZlLCBza2lwLi4uXG4gICAgICAgICAgICAgICAgaWYgKHdhc1VuZGVmaW5lZFBhY2spXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvLnBhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IG1vdmUgKHRvIHRoZSBvcmlnaW5hbCBhc2sgdnMgdGhlIGNvbGxpc2lvbiB2ZXJzaW9uIHdoaWNoIG1pZ2h0IGRpZmZlcikgYW5kIHJlcGFjayB0aGluZ3NcbiAgICAgICAgaWYgKG5lZWRUb01vdmUpIHtcbiAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLmNvcHlQb3Mobm9kZSwgbm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLnBhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3BhY2tOb2RlcygpXG4gICAgICAgICAgICAgICAgLl9ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIVV0aWxzLnNhbWVQb3Mobm9kZSwgcHJldlBvcyk7IC8vIHBhY2sgbWlnaHQgaGF2ZSBtb3ZlZCB0aGluZ3MgYmFja1xuICAgIH1cbiAgICBnZXRSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgocm93LCBuKSA9PiBNYXRoLm1heChyb3csIG4ueSArIG4uaCksIDApO1xuICAgIH1cbiAgICBiZWdpblVwZGF0ZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5fdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG5vZGUuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9za2lwRG93bjtcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXRjaE1vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlSW5pdGlhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmRVcGRhdGUoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5fdXBkYXRpbmcpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZGVsZXRlIG4uX3VwZGF0aW5nO1xuICAgICAgICAgICAgZGVsZXRlIG4uX3NraXBEb3duO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogc2F2ZXMgYSBjb3B5IG9mIHRoZSBsYXJnZXN0IGNvbHVtbiBsYXlvdXQgKGVnIDEyIGV2ZW4gd2hlbiByZW5kZXJpbmcgb25lQ29sdW1uTW9kZSkgc28gd2UgZG9uJ3QgbG9vc2Ugb3JpZyBsYXlvdXQsXG4gICAgICogcmV0dXJuaW5nIGEgbGlzdCBvZiB3aWRnZXRzIGZvciBzZXJpYWxpemF0aW9uICovXG4gICAgc2F2ZShzYXZlRWxlbWVudCA9IHRydWUsIHNhdmVDQikge1xuICAgICAgICAvLyB1c2UgdGhlIGhpZ2hlc3QgbGF5b3V0IGZvciBhbnkgc2F2ZWQgaW5mbyBzbyB3ZSBjYW4gaGF2ZSBmdWxsIGRldGFpbCBvbiByZWxvYWQgIzE4NDlcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuX2xheW91dHM/Lmxlbmd0aDtcbiAgICAgICAgbGV0IGxheW91dCA9IGxlbiAmJiB0aGlzLmNvbHVtbiAhPT0gKGxlbiAtIDEpID8gdGhpcy5fbGF5b3V0c1tsZW4gLSAxXSA6IG51bGw7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIHRoaXMuc29ydE5vZGVzKCk7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGxldCB3bCA9IGxheW91dD8uZmluZChsID0+IGwuX2lkID09PSBuLl9pZCk7XG4gICAgICAgICAgICAvLyB1c2UgbGF5b3V0IGluZm8gZmllbGRzIGluc3RlYWQgaWYgc2V0XG4gICAgICAgICAgICBsZXQgdyA9IHsgLi4ubiwgLi4uKHdsIHx8IHt9KSB9O1xuICAgICAgICAgICAgVXRpbHMucmVtb3ZlSW50ZXJuYWxGb3JTYXZlKHcsICFzYXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2F2ZUNCKVxuICAgICAgICAgICAgICAgIHNhdmVDQihuLCB3KTtcbiAgICAgICAgICAgIGxpc3QucHVzaCh3KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB3aGVuZXZlciBhIG5vZGUgaXMgYWRkZWQgb3IgbW92ZWQgLSB1cGRhdGVzIHRoZSBjYWNoZWQgbGF5b3V0cyAqL1xuICAgIGxheW91dHNOb2Rlc0NoYW5nZShub2Rlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2xheW91dHMgfHwgdGhpcy5faW5Db2x1bW5SZXNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gcmVtb3ZlIHNtYWxsZXIgbGF5b3V0cyAtIHdlIHdpbGwgcmUtZ2VuZXJhdGUgdGhvc2Ugb24gdGhlIGZseS4uLiBsYXJnZXIgb25lcyBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICB0aGlzLl9sYXlvdXRzLmZvckVhY2goKGxheW91dCwgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxheW91dCB8fCBjb2x1bW4gPT09IHRoaXMuY29sdW1uKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbHVtbiA8IHRoaXMuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2F2ZSB0aGUgb3JpZ2luYWwgeCx5LHcgKGggaXNuJ3QgY2FjaGVkKSB0byBzZWUgd2hhdCBhY3R1YWxseSBjaGFuZ2VkIHRvIHByb3BhZ2F0ZSBiZXR0ZXIuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhZ2FpbnN0IG91dCBvZiBib3VuZCBzY2FsaW5nL21vdmluZyBhcyB0aGF0IHdpbGwgYmUgZG9uZSB3aGVuIHVzaW5nIHRob3NlIGNhY2hlIHZhbHVlcy4gIzE3ODVcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSBjb2x1bW4gLyB0aGlzLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuX29yaWcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRpZG4ndCBjaGFuZ2UgKG5ld2x5IGFkZGVkID8pXG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gbGF5b3V0LmZpbmQobCA9PiBsLl9pZCA9PT0gbm9kZS5faWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGNhY2hlIGZvciBuZXcgbm9kZXMuIFdpbGwgdXNlIHRob3NlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gWSBjaGFuZ2VkLCBwdXNoIGRvd24gc2FtZSBhbW91bnRcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGV0ZWN0IGRvaW5nIGl0ZW0gJ3N3YXBzJyB3aWxsIGhlbHAgaW5zdGVhZCBvZiBtb3ZlIChlc3BlY2lhbGx5IGluIDEgY29sdW1uIG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnkgPj0gMCAmJiBub2RlLnkgIT09IG5vZGUuX29yaWcueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi55ICs9IChub2RlLnkgLSBub2RlLl9vcmlnLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFggY2hhbmdlZCwgc2NhbGUgZnJvbSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUueCAhPT0gbm9kZS5fb3JpZy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnggPSBNYXRoLnJvdW5kKG5vZGUueCAqIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWR0aCBjaGFuZ2VkLCBzY2FsZSBmcm9tIG5ldyB3aWR0aFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS53ICE9PSBub2RlLl9vcmlnLncpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4udyA9IE1hdGgucm91bmQobm9kZS53ICogcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmhlaWdodCBhbHdheXMgY2FycmllcyBvdmVyIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgQ2FsbGVkIHRvIHNjYWxlIHRoZSB3aWRnZXQgd2lkdGggJiBwb3NpdGlvbiB1cC9kb3duIGJhc2VkIG9uIHRoZSBjb2x1bW4gY2hhbmdlLlxuICAgICAqIE5vdGUgd2Ugc3RvcmUgcHJldmlvdXMgbGF5b3V0cyAoZXNwZWNpYWxseSBvcmlnaW5hbCBvbmVzKSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIGdvXG4gICAgICogZnJvbSBzYXkgMTIgLT4gMSAtPiAxMiBhbmQgZ2V0IGJhY2sgdG8gd2hlcmUgd2Ugd2VyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmV2Q29sdW1uIHByZXZpb3VzIG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogQHBhcmFtIGNvbHVtbiAgbmV3IGNvbHVtbiBudW1iZXJcbiAgICAgKiBAcGFyYW0gbm9kZXMgZGlmZmVyZW50IHNvcnRlZCBsaXN0IChleDogRE9NIG9yZGVyKSBpbnN0ZWFkIG9mIGN1cnJlbnQgbGlzdFxuICAgICAqIEBwYXJhbSBsYXlvdXQgc3BlY2lmeSB0aGUgdHlwZSBvZiByZS1sYXlvdXQgdGhhdCB3aWxsIGhhcHBlbiAocG9zaXRpb24sIHNpemUsIGV0Yy4uLikuXG4gICAgICogTm90ZTogaXRlbXMgd2lsbCBuZXZlciBiZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGNvbHVtbiBib3VuZGFyaWVzLiBkZWZhdWx0IChtb3ZlU2NhbGUpLiBJZ25vcmVkIGZvciAxIGNvbHVtblxuICAgICAqL1xuICAgIGNvbHVtbkNoYW5nZWQocHJldkNvbHVtbiwgY29sdW1uLCBub2RlcywgbGF5b3V0ID0gJ21vdmVTY2FsZScpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVzLmxlbmd0aCB8fCAhY29sdW1uIHx8IHByZXZDb2x1bW4gPT09IGNvbHVtbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBzaW1wbGVyIHNob3J0Y3V0cyBsYXlvdXRzXG4gICAgICAgIGNvbnN0IGRvQ29tcGFjdCA9IGxheW91dCA9PT0gJ2NvbXBhY3QnIHx8IGxheW91dCA9PT0gJ2xpc3QnO1xuICAgICAgICBpZiAoZG9Db21wYWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnROb2RlcygxLCBwcmV2Q29sdW1uKTsgLy8gc29ydCB3aXRoIG9yaWdpbmFsIGxheW91dCBvbmNlIGFuZCBvbmx5IG9uY2UgKG5ldyBjb2x1bW4gd2lsbCBhZmZlY3Qgb3JkZXIgb3RoZXJ3aXNlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIHRoZSBjdXJyZW50IGxheW91dCBpbiBjYXNlIHRoZXkgd2FudCB0byBnbyBiYWNrIChsaWtlIDEyIC0+IDEgLT4gMTIpIGFzIGl0IHJlcXVpcmVzIG9yaWdpbmFsIGRhdGEgSUZGIHdlJ3JlIHNpemluZyBkb3duIChzZWUgYmVsb3cpXG4gICAgICAgIGlmIChjb2x1bW4gPCBwcmV2Q29sdW1uKVxuICAgICAgICAgICAgdGhpcy5jYWNoZUxheW91dCh0aGlzLm5vZGVzLCBwcmV2Q29sdW1uKTtcbiAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpOyAvLyBkbyB0aGlzIEVBUkxZIGFzIGl0IHdpbGwgY2FsbCBzYXZlSW5pdGlhbCgpIHNvIHdlIGNhbiBkZXRlY3Qgd2hlcmUgd2Ugc3RhcnRlZCBmb3IgX2RpcnR5IGFuZCBjb2xsaXNpb25cbiAgICAgICAgbGV0IG5ld05vZGVzID0gW107XG4gICAgICAgIC8vIGlmIHdlJ3JlIGdvaW5nIHRvIDEgY29sdW1uIGFuZCB1c2luZyBET00gb3JkZXIgKGl0ZW0gcGFzc2VkIGluKSByYXRoZXIgdGhhbiBkZWZhdWx0IHNvcnRpbmcsIHRoZW4gZ2VuZXJhdGUgdGhhdCBsYXlvdXRcbiAgICAgICAgbGV0IGRvbU9yZGVyID0gZmFsc2U7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDEgJiYgbm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgZG9tT3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIG4ueCA9IDA7XG4gICAgICAgICAgICAgICAgbi53ID0gMTtcbiAgICAgICAgICAgICAgICBuLnkgPSBNYXRoLm1heChuLnksIHRvcCk7XG4gICAgICAgICAgICAgICAgdG9wID0gbi55ICsgbi5oO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdOb2RlcyA9IG5vZGVzO1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzID0gZG9Db21wYWN0ID8gdGhpcy5ub2RlcyA6IFV0aWxzLnNvcnQodGhpcy5ub2RlcywgLTEsIHByZXZDb2x1bW4pOyAvLyBjdXJyZW50IGNvbHVtbiByZXZlcnNlIHNvcnRpbmcgc28gd2UgY2FuIGluc2VydCBsYXN0IHRvIGZyb250IChsaW1pdCBjb2xsaXNpb24pXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgY2FjaGVkIHByZXZpb3VzIGxheW91dCBJRkYgd2UgYXJlIGdvaW5nIHVwIGluIHNpemUgKHJlc3RvcmUpIG90aGVyd2lzZSBhbHdheXNcbiAgICAgICAgLy8gZ2VuZXJhdGUgbmV4dCBzaXplIGRvd24gZnJvbSB3aGVyZSB3ZSBhcmUgKGxvb2tzIG1vcmUgbmF0dXJhbCBhcyB5b3UgZ3JhZHVhbGx5IHNpemUgZG93bikuXG4gICAgICAgIGlmIChjb2x1bW4gPiBwcmV2Q29sdW1uICYmIHRoaXMuX2xheW91dHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlTm9kZXMgPSB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gfHwgW107XG4gICAgICAgICAgICAvLyAuLi5pZiBub3QsIHN0YXJ0IHdpdGggdGhlIGxhcmdlc3QgbGF5b3V0IChpZiBub3QgYWxyZWFkeSB0aGVyZSkgYXMgZG93bi1zY2FsaW5nIGlzIG1vcmUgYWNjdXJhdGVcbiAgICAgICAgICAgIC8vIGJ5IHByZXRlbmRpbmcgd2UgY2FtZSBmcm9tIHRoYXQgbGFyZ2VyIGNvbHVtbiBieSBhc3NpZ25pbmcgdGhvc2UgdmFsdWVzIGFzIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5fbGF5b3V0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCFjYWNoZU5vZGVzLmxlbmd0aCAmJiBwcmV2Q29sdW1uICE9PSBsYXN0SW5kZXggJiYgdGhpcy5fbGF5b3V0c1tsYXN0SW5kZXhdPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29sdW1uID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dHNbbGFzdEluZGV4XS5mb3JFYWNoKGNhY2hlTm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gbm9kZXMuZmluZChuID0+IG4uX2lkID09PSBjYWNoZU5vZGUuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIGN1cnJlbnQsIHVzZSBjYWNoZSBpbmZvIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb0NvbXBhY3QgJiYgIWNhY2hlTm9kZS5hdXRvUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnggPSBjYWNoZU5vZGUueCA/PyBuLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi55ID0gY2FjaGVOb2RlLnkgPz8gbi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbi53ID0gY2FjaGVOb2RlLncgPz8gbi53O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlTm9kZS54ID09IHVuZGVmaW5lZCB8fCBjYWNoZU5vZGUueSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uYXV0b1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZm91bmQgY2FjaGUgcmUtdXNlIHRob3NlIG5vZGVzIHRoYXQgYXJlIHN0aWxsIGN1cnJlbnRcbiAgICAgICAgICAgIGNhY2hlTm9kZXMuZm9yRWFjaChjYWNoZU5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBqID0gbm9kZXMuZmluZEluZGV4KG4gPT4gbi5faWQgPT09IGNhY2hlTm9kZS5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIGN1cnJlbnQsIHVzZSBjYWNoZSBpbmZvIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLncgPSBjYWNoZU5vZGUudzsgLy8gb25seSB3IGlzIHVzZWQsIGFuZCBkb24ndCB0cmltIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlTm9kZS5hdXRvUG9zaXRpb24gfHwgaXNOYU4oY2FjaGVOb2RlLngpIHx8IGlzTmFOKGNhY2hlTm9kZS55KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kRW1wdHlQb3NpdGlvbihjYWNoZU5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlTm9kZS5hdXRvUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ueCA9IGNhY2hlTm9kZS54ID8/IG4ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ueSA9IGNhY2hlTm9kZS55ID8/IG4ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4udyA9IGNhY2hlTm9kZS53ID8/IG4udztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11Y2ggc2ltcGxlciBsYXlvdXQgdGhhdCBqdXN0IGNvbXBhY3RzXG4gICAgICAgIGlmIChkb0NvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdChsYXlvdXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIC4uLmFuZCBhZGQgYW55IGV4dHJhIG5vbi1jYWNoZWQgb25lc1xuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dChjb2x1bW4sIHByZXZDb2x1bW4sIG5ld05vZGVzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkb21PcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSAoZG9Db21wYWN0IHx8IGxheW91dCA9PT0gJ25vbmUnKSA/IDEgOiBjb2x1bW4gLyBwcmV2Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZSA9IChsYXlvdXQgPT09ICdtb3ZlJyB8fCBsYXlvdXQgPT09ICdtb3ZlU2NhbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlID0gKGxheW91dCA9PT0gJ3NjYWxlJyB8fCBsYXlvdXQgPT09ICdtb3ZlU2NhbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHggKyB3IGNvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGdyaWQsIGJ1dCBhZGROb2RlKCkgYmVsb3cgd2lsbCBoYW5kbGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gKGNvbHVtbiA9PT0gMSA/IDAgOiAobW92ZSA/IE1hdGgucm91bmQobm9kZS54ICogcmF0aW8pIDogTWF0aC5taW4obm9kZS54LCBjb2x1bW4gLSAxKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS53ID0gKChjb2x1bW4gPT09IDEgfHwgcHJldkNvbHVtbiA9PT0gMSkgPyAxIDogc2NhbGUgPyAoTWF0aC5yb3VuZChub2RlLncgKiByYXRpbykgfHwgMSkgOiAoTWF0aC5taW4obm9kZS53LCBjb2x1bW4pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHJlLWxheW91dCB0aGVtIGluIHJldmVyc2Ugb3JkZXIgKHRvIGdldCBjb3JyZWN0IHBsYWNlbWVudClcbiAgICAgICAgICAgIGlmICghZG9tT3JkZXIpXG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMgPSBVdGlscy5zb3J0KG5ld05vZGVzLCAtMSwgY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuX2luQ29sdW1uUmVzaXplID0gdHJ1ZTsgLy8gcHJldmVudCBjYWNoZSB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTsgLy8gcHJldGVuZCB3ZSBoYXZlIG5vIG5vZGVzIHRvIHN0YXJ0IHdpdGggKGFkZCgpIHdpbGwgdXNlIHNhbWUgc3RydWN0dXJlcykgdG8gc2ltcGxpZnkgbGF5b3V0XG4gICAgICAgICAgICBuZXdOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9kZShub2RlLCBmYWxzZSk7IC8vICdmYWxzZScgZm9yIGFkZCBldmVudCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX29yaWc7IC8vIG1ha2Ugc3VyZSB0aGUgY29tbWl0IGRvZXNuJ3QgdHJ5IHRvIHJlc3RvcmUgdGhpbmdzIGJhY2sgdG8gb3JpZ2luYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IGRlbGV0ZSBuLl9vcmlnKTsgLy8gY2xlYXIgX29yaWcgYmVmb3JlIGJhdGNoPWZhbHNlIHNvIGl0IGRvZXNuJ3QgaGFuZGxlIGZsb2F0PXRydWUgcmVzdG9yZVxuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlLCAhZG9Db21wYWN0KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2luQ29sdW1uUmVzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbCB0byBjYWNoZSB0aGUgZ2l2ZW4gbGF5b3V0IGludGVybmFsbHkgdG8gdGhlIGdpdmVuIGxvY2F0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGJhY2sgd2hlbiBjb2x1bW4gY2hhbmdlcyBzaXplXG4gICAgICogQHBhcmFtIG5vZGVzIGxpc3Qgb2Ygbm9kZXNcbiAgICAgKiBAcGFyYW0gY29sdW1uIGNvcnJlc3BvbmRpbmcgY29sdW1uIGluZGV4IHRvIHNhdmUgaXQgdW5kZXJcbiAgICAgKiBAcGFyYW0gY2xlYXIgaWYgdHJ1ZSwgd2lsbCBmb3JjZSBvdGhlciBjYWNoZXMgdG8gYmUgcmVtb3ZlZCAoZGVmYXVsdCBmYWxzZSlcbiAgICAgKi9cbiAgICBjYWNoZUxheW91dChub2RlcywgY29sdW1uLCBjbGVhciA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjb3B5ID0gW107XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG4sIGkpID0+IHtcbiAgICAgICAgICAgIG4uX2lkID0gbi5faWQgPz8gR3JpZFN0YWNrRW5naW5lLl9pZFNlcSsrOyAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBpZCBpbiBjYXNlIHRoaXMgaXMgbmV3IGxheW91dCwgZWxzZSByZS11c2UgaWQgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGNvcHlbaV0gPSB7IHg6IG4ueCwgeTogbi55LCB3OiBuLncsIF9pZDogbi5faWQgfTsgLy8gb25seSB0aGluZyB3ZSBjaGFuZ2UgaXMgeCx5LHcgYW5kIGlkIHRvIGZpbmQgaXQgYmFja1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5b3V0cyA9IGNsZWFyID8gW10gOiB0aGlzLl9sYXlvdXRzIHx8IFtdOyAvLyB1c2UgYXJyYXkgdG8gZmluZCBsYXJnZXIgcXVpY2tcbiAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dID0gY29weTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGwgdG8gY2FjaGUgdGhlIGdpdmVuIG5vZGUgbGF5b3V0IGludGVybmFsbHkgdG8gdGhlIGdpdmVuIGxvY2F0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGJhY2sgd2hlbiBjb2x1bW4gY2hhbmdlcyBzaXplXG4gICAgICogQHBhcmFtIG5vZGUgc2luZ2xlIG5vZGUgdG8gY2FjaGVcbiAgICAgKiBAcGFyYW0gY29sdW1uIGNvcnJlc3BvbmRpbmcgY29sdW1uIGluZGV4IHRvIHNhdmUgaXQgdW5kZXJcbiAgICAgKi9cbiAgICBjYWNoZU9uZUxheW91dChuLCBjb2x1bW4pIHtcbiAgICAgICAgbi5faWQgPSBuLl9pZCA/PyBHcmlkU3RhY2tFbmdpbmUuX2lkU2VxKys7XG4gICAgICAgIGxldCBsID0geyB4OiBuLngsIHk6IG4ueSwgdzogbi53LCBfaWQ6IG4uX2lkIH07XG4gICAgICAgIGlmIChuLmF1dG9Qb3NpdGlvbiB8fCBuLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGwueDtcbiAgICAgICAgICAgIGRlbGV0ZSBsLnk7XG4gICAgICAgICAgICBpZiAobi5hdXRvUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgbC5hdXRvUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dHMgPSB0aGlzLl9sYXlvdXRzIHx8IFtdO1xuICAgICAgICB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gPSB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gfHwgW107XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZmluZENhY2hlTGF5b3V0KG4sIGNvbHVtbik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRzW2NvbHVtbl0ucHVzaChsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dW2luZGV4XSA9IGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5kQ2FjaGVMYXlvdXQobiwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzPy5bY29sdW1uXT8uZmluZEluZGV4KGwgPT4gbC5faWQgPT09IG4uX2lkKSA/PyAtMTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZUZyb21MYXlvdXRDYWNoZShuKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGF5b3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5maW5kQ2FjaGVMYXlvdXQobiwgaSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBjYWxsZWQgdG8gcmVtb3ZlIGFsbCBpbnRlcm5hbCB2YWx1ZXMgYnV0IHRoZSBfaWQgKi9cbiAgICBjbGVhbnVwTm9kZShub2RlKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb3BbMF0gPT09ICdfJyAmJiBwcm9wICE9PSAnX2lkJylcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKiogQGludGVybmFsIHVuaXF1ZSBnbG9iYWwgaW50ZXJuYWwgX2lkIGNvdW50ZXIgKi9cbkdyaWRTdGFja0VuZ2luZS5faWRTZXEgPSAwO1xuZXhwb3J0IHsgR3JpZFN0YWNrRW5naW5lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkc3RhY2stZW5naW5lLmpzLm1hcCJdLCJuYW1lcyI6WyJVdGlscyIsIkdyaWRTdGFja0VuZ2luZSIsImJhdGNoVXBkYXRlIiwiZmxhZyIsImRvUGFjayIsImJhdGNoTW9kZSIsIl9wcmV2RmxvYXQiLCJfZmxvYXQiLCJjbGVhbk5vZGVzIiwic2F2ZUluaXRpYWwiLCJfcGFja05vZGVzIiwiX25vdGlmeSIsIl91c2VFbnRpcmVSb3dBcmVhIiwibm9kZSIsIm5uIiwiZmxvYXQiLCJfaGFzTG9ja2VkIiwiX21vdmluZyIsIl9za2lwRG93biIsInkiLCJfZml4Q29sbGlzaW9ucyIsImNvbGxpZGUiLCJvcHQiLCJzb3J0Tm9kZXMiLCJuZXN0ZWQiLCJzd2FwIiwiYXJlYSIsIngiLCJ3IiwiY29sdW1uIiwiaCIsInNraXAiLCJkaWRNb3ZlIiwibmV3T3B0IiwicGFjayIsIm1vdmVkIiwibG9ja2VkIiwibW92ZU5vZGUiLCJjb3B5UG9zIiwidW5kZWZpbmVkIiwic2tpcDIiLCJza2lwSWQiLCJfaWQiLCJza2lwMklkIiwibm9kZXMiLCJmaW5kIiwibiIsImlzSW50ZXJjZXB0ZWQiLCJjb2xsaWRlQWxsIiwiZmlsdGVyIiwiZGlyZWN0aW9uQ29sbGlkZUNvdmVyYWdlIiwibyIsImNvbGxpZGVzIiwicmVjdCIsIl9yZWN0IiwicjAiLCJyIiwib3Zlck1heCIsImZvckVhY2giLCJyMiIsInlPdmVyIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwieE92ZXIiLCJvdmVyIiwiTWF0aCIsIm1pbiIsImNhY2hlUmVjdHMiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJhIiwiYiIsIl9kb1N3YXAiLCJfZGlydHkiLCJ0b3VjaGluZyIsImlzVG91Y2hpbmciLCJ0IiwiaXNBcmVhRW1wdHkiLCJjb21wYWN0IiwibGF5b3V0IiwiZG9Tb3J0IiwibGVuZ3RoIiwid2FzQmF0Y2giLCJ3YXNDb2x1bW5SZXNpemUiLCJfaW5Db2x1bW5SZXNpemUiLCJjb3B5Tm9kZXMiLCJpbmRleCIsImxpc3QiLCJhZnRlciIsImF1dG9Qb3NpdGlvbiIsImFkZE5vZGUiLCJ2YWwiLCJkaXIiLCJzb3J0IiwiX3VwZGF0aW5nIiwiX29yaWciLCJuZXdZIiwiaSIsImNhbkJlTW92ZWQiLCJwcmVwYXJlTm9kZSIsInJlc2l6aW5nIiwiX2lkU2VxIiwiZGVmYXVsdHMiLCJub1Jlc2l6ZSIsIm5vTW92ZSIsInNhbml0aXplTWluTWF4IiwiaXNOYU4iLCJub2RlQm91bmRGaXgiLCJiZWZvcmUiLCJtYXhXIiwibWF4SCIsIm1pblciLCJtYXgiLCJtaW5IIiwic2F2ZU9yaWciLCJmaW5kQ2FjaGVMYXlvdXQiLCJjb3B5IiwiY2FjaGVPbmVMYXlvdXQiLCJtYXhSb3ciLCJzYW1lUG9zIiwiZ2V0RGlydHlOb2RlcyIsInZlcmlmeSIsInJlbW92ZWROb2RlcyIsIm9uQ2hhbmdlIiwiZGlydHlOb2RlcyIsImNvbmNhdCIsIl9sYXN0VHJpZWQiLCJzb21lIiwicmVzdG9yZUluaXRpYWwiLCJmaW5kRW1wdHlQb3NpdGlvbiIsIm5vZGVMaXN0Iiwic3RhcnQiLCJmb3VuZCIsImZsb29yIiwiYm94IiwidHJpZ2dlckFkZEV2ZW50IiwiZHVwIiwiX3RlbXBvcmFyeVJlbW92ZWQiLCJfcmVtb3ZlRE9NIiwic2tpcENvbGxpc2lvbiIsInB1c2giLCJhZGRlZE5vZGVzIiwicmVtb3ZlTm9kZSIsInJlbW92ZURPTSIsInRyaWdnZXJFdmVudCIsIl9pc0Fib3V0VG9SZW1vdmUiLCJyZW1vdmVBbGwiLCJfbGF5b3V0cyIsIm1vdmVOb2RlQ2hlY2siLCJjaGFuZ2VkUG9zQ29uc3RyYWluIiwiY2xvbmVkTm9kZSIsImNsb25lIiwibWFwIiwiY2FuTW92ZSIsImdldFJvdyIsImVsIiwiZ3JpZHN0YWNrTm9kZSIsImMiLCJ3aWxsSXRGaXQiLCJfd2lsbEZpdFBvcyIsImNsZWFudXBOb2RlIiwiY29udGVudCIsImdyaWQiLCJwIiwid2FzVW5kZWZpbmVkUGFjayIsImZvcmNlQ29sbGlkZSIsInByZXZQb3MiLCJuZWVkVG9Nb3ZlIiwiYWN0aXZlRHJhZyIsIm9wdHMiLCJzdWJHcmlkRHluYW1pYyIsIl9pc1RlbXAiLCJhcmVhSW50ZXJjZXB0IiwiYTEiLCJhMiIsInBlcmMiLCJtYWtlU3ViR3JpZCIsInJlZHVjZSIsInJvdyIsImJlZ2luVXBkYXRlIiwiZW5kVXBkYXRlIiwic2F2ZSIsInNhdmVFbGVtZW50Iiwic2F2ZUNCIiwibGVuIiwid2wiLCJsIiwicmVtb3ZlSW50ZXJuYWxGb3JTYXZlIiwibGF5b3V0c05vZGVzQ2hhbmdlIiwicmF0aW8iLCJyb3VuZCIsImNvbHVtbkNoYW5nZWQiLCJwcmV2Q29sdW1uIiwiZG9Db21wYWN0IiwiY2FjaGVMYXlvdXQiLCJuZXdOb2RlcyIsImRvbU9yZGVyIiwiY2FjaGVOb2RlcyIsImxhc3RJbmRleCIsImNhY2hlTm9kZSIsImoiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJtb3ZlIiwic2NhbGUiLCJjbGVhciIsInJlbW92ZU5vZGVGcm9tTGF5b3V0Q2FjaGUiLCJwcm9wIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/gridstack-engine.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.js":
/*!**************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridStack: function() { return /* binding */ GridStack; }\n/* harmony export */ });\n/* harmony import */ var _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gridstack-engine */ \"./node_modules/gridstack/dist/gridstack-engine.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./node_modules/gridstack/dist/types.js\");\n/* harmony import */ var _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-gridstack */ \"./node_modules/gridstack/dist/dd-gridstack.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _types__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _utils__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _utils__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/*!\n * GridStack 9.4.0\n * https://gridstackjs.com/\n *\n * Copyright (c) 2021-2022 Alain Dumesny\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\n */ \n\n\n/*\n * and include D&D by default\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n */ \n\n\n/** global instance */ const dd = new _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack;\n// export all dependent file as well to make it easier for users to just import the main file\n\n\n\n\n/**\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\n * @example\n * <div class=\"grid-stack\">\n *   <div class=\"grid-stack-item\">\n *     <div class=\"grid-stack-item-content\">Item 1</div>\n *   </div>\n * </div>\n */ class GridStack {\n    /**\n     * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\n     * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\n     * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\n     * @param options grid options (optional)\n     * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\n     *\n     * @example\n     * let grid = GridStack.init();\n     *\n     * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\n     * let grid = document.querySelector('.grid-stack').gridstack;\n     */ static init() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, elOrString = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \".grid-stack\";\n        let el = GridStack.getGridElement(elOrString);\n        if (!el) {\n            if (typeof elOrString === \"string\") {\n                console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n            } else {\n                console.error(\"GridStack.init() no grid element was passed.\");\n            }\n            return null;\n        }\n        if (!el.gridstack) {\n            el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n        }\n        return el.gridstack;\n    }\n    /**\n     * Will initialize a list of elements (given a selector) and return an array of grids.\n     * @param options grid options (optional)\n     * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\n     *\n     * @example\n     * let grids = GridStack.initAll();\n     * grids.forEach(...)\n     */ static initAll() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \".grid-stack\";\n        let grids = [];\n        GridStack.getGridElements(selector).forEach((el)=>{\n            if (!el.gridstack) {\n                el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n            }\n            grids.push(el.gridstack);\n        });\n        if (grids.length === 0) {\n            console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n        }\n        return grids;\n    }\n    /**\n     * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\n     * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\n     * JSON serialized data, including options.\n     * @param parent HTML element parent to the grid\n     * @param opt grids options used to initialize the grid, and list of children\n     */ static addGrid(parent) {\n        let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (!parent) return null;\n        let el = parent;\n        if (el.gridstack) {\n            // already a grid - set option and load data\n            const grid = el.gridstack;\n            if (opt) grid.opts = {\n                ...grid.opts,\n                ...opt\n            };\n            if (opt.children !== undefined) grid.load(opt.children);\n            return grid;\n        }\n        // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n        const parentIsGrid = parent.classList.contains(\"grid-stack\");\n        if (!parentIsGrid || GridStack.addRemoveCB) {\n            if (GridStack.addRemoveCB) {\n                el = GridStack.addRemoveCB(parent, opt, true, true);\n            } else {\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = '<div class=\"grid-stack '.concat(opt.class || \"\", '\"></div>');\n                el = doc.body.children[0];\n                parent.appendChild(el);\n            }\n        }\n        // create grid class and load any children\n        let grid = GridStack.init(opt, el);\n        return grid;\n    }\n    /** call this method to register your engine instead of the default one.\n     * See instead `GridStackOptions.engineClass` if you only need to\n     * replace just one instance.\n     */ static registerEngine(engineClass) {\n        GridStack.engineClass = engineClass;\n    }\n    /** @internal create placeholder DIV as needed */ get placeholder() {\n        if (!this._placeholder) {\n            let placeholderChild = document.createElement(\"div\"); // child so padding match item-content\n            placeholderChild.className = \"placeholder-content\";\n            if (this.opts.placeholderText) {\n                placeholderChild.innerHTML = this.opts.placeholderText;\n            }\n            this._placeholder = document.createElement(\"div\");\n            this._placeholder.classList.add(this.opts.placeholderClass, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n            this.placeholder.appendChild(placeholderChild);\n        }\n        return this._placeholder;\n    }\n    /**\n     * add a new widget and returns it.\n     *\n     * Widget will be always placed even if result height is more than actual grid height.\n     * You need to use `willItFit()` before calling addWidget for additional check.\n     * See also `makeWidget()`.\n     *\n     * @example\n     * let grid = GridStack.init();\n     * grid.addWidget({w: 3, content: 'hello'});\n     * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\n     *\n     * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\n     * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\n     */ addWidget(els, options) {\n        function isGridStackWidget(w) {\n            return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n        }\n        let el;\n        let node;\n        if (typeof els === \"string\") {\n            let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n            doc.body.innerHTML = els;\n            el = doc.body.children[0];\n        } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n            node = options = els;\n            if (node === null || node === void 0 ? void 0 : node.el) {\n                el = node.el; // re-use element stored in the node\n            } else if (GridStack.addRemoveCB) {\n                el = GridStack.addRemoveCB(this.el, options, true, false);\n            } else {\n                let content = (options === null || options === void 0 ? void 0 : options.content) || \"\";\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = '<div class=\"grid-stack-item '.concat(this.opts.itemClass || \"\", '\"><div class=\"grid-stack-item-content\">').concat(content, \"</div></div>\");\n                el = doc.body.children[0];\n            }\n        } else {\n            el = els;\n        }\n        if (!el) return;\n        // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\n        node = el.gridstackNode;\n        if (node && el.parentElement === this.el && this.engine.nodes.find((n)=>n._id === node._id)) return el;\n        // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n        // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n        // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n        let domAttr = this._readAttr(el);\n        options = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(options, domAttr);\n        node = this.engine.prepareNode(options);\n        this._writeAttr(el, options);\n        if (this._insertNotAppend) {\n            this.el.prepend(el);\n        } else {\n            this.el.appendChild(el);\n        }\n        this.makeWidget(el, options);\n        return el;\n    }\n    /**\n     * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\n     * from the parent's subGrid options.\n     * @param el gridItem element to convert\n     * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\n     * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\n     * @returns newly created grid\n     */ makeSubGrid(el, ops, nodeToAdd) {\n        let saveContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n        var _node_subGrid;\n        let node = el.gridstackNode;\n        if (!node) {\n            node = this.makeWidget(el).gridstackNode;\n        }\n        if ((_node_subGrid = node.subGrid) === null || _node_subGrid === void 0 ? void 0 : _node_subGrid.el) return node.subGrid; // already done\n        // find the template subGrid stored on a parent as fallback...\n        let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let grid = this;\n        while(grid && !subGridTemplate){\n            var _grid_opts, _grid_parentGridItem;\n            subGridTemplate = (_grid_opts = grid.opts) === null || _grid_opts === void 0 ? void 0 : _grid_opts.subGridOpts;\n            grid = (_grid_parentGridItem = grid.parentGridItem) === null || _grid_parentGridItem === void 0 ? void 0 : _grid_parentGridItem.grid;\n        }\n        //... and set the create options\n        ops = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep({\n            ...subGridTemplate || {},\n            children: undefined,\n            ...ops || node.subGridOpts\n        });\n        node.subGridOpts = ops;\n        // if column special case it set, remember that flag and set default\n        let autoColumn;\n        if (ops.column === \"auto\") {\n            autoColumn = true;\n            ops.column = Math.max(node.w || 1, (nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd.w) || 1);\n            ops.disableOneColumnMode = true; // driven by parent\n        }\n        // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n        let content = node.el.querySelector(\".grid-stack-item-content\");\n        let newItem;\n        let newItemOpt;\n        if (saveContent) {\n            this._removeDD(node.el); // remove D&D since it's set on content div\n            newItemOpt = {\n                ...node,\n                x: 0,\n                y: 0\n            };\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalForSave(newItemOpt);\n            delete newItemOpt.subGridOpts;\n            if (node.content) {\n                newItemOpt.content = node.content;\n                delete node.content;\n            }\n            if (GridStack.addRemoveCB) {\n                newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\n            } else {\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = '<div class=\"grid-stack-item\"></div>';\n                newItem = doc.body.children[0];\n                newItem.appendChild(content);\n                doc.body.innerHTML = '<div class=\"grid-stack-item-content\"></div>';\n                content = doc.body.children[0];\n                node.el.appendChild(content);\n            }\n            this._prepareDragDropByNode(node); // ... and restore original D&D\n        }\n        // if we're adding an additional item, make the container large enough to have them both\n        if (nodeToAdd) {\n            let w = autoColumn ? ops.column : node.w;\n            let h = node.h + nodeToAdd.h;\n            let style = node.el.style;\n            style.transition = \"none\"; // show up instantly so we don't see scrollbar with nodeToAdd\n            this.update(node.el, {\n                w,\n                h\n            });\n            setTimeout(()=>style.transition = null); // recover animation\n        }\n        let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n        if (nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n        if (autoColumn) subGrid._autoColumn = true;\n        // add the original content back as a child of hte newly created grid\n        if (saveContent) {\n            subGrid.addWidget(newItem, newItemOpt);\n        }\n        // now add any additional node\n        if (nodeToAdd) {\n            if (nodeToAdd._moving) {\n                // create an artificial event even for the just created grid to receive this item\n                window.setTimeout(()=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeToAdd._event, \"mouseenter\", subGrid.el), 0);\n            } else {\n                subGrid.addWidget(node.el, node);\n            }\n        }\n        return subGrid;\n    }\n    /**\n     * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\n     * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\n     */ removeAsSubGrid(nodeThatRemoved) {\n        var _this_parentGridItem;\n        let pGrid = (_this_parentGridItem = this.parentGridItem) === null || _this_parentGridItem === void 0 ? void 0 : _this_parentGridItem.grid;\n        if (!pGrid) return;\n        pGrid.batchUpdate();\n        pGrid.removeWidget(this.parentGridItem.el, true, true);\n        this.engine.nodes.forEach((n)=>{\n            // migrate any children over and offsetting by our location\n            n.x += this.parentGridItem.x;\n            n.y += this.parentGridItem.y;\n            pGrid.addWidget(n.el, n);\n        });\n        pGrid.batchUpdate(false);\n        if (this.parentGridItem) delete this.parentGridItem.subGrid;\n        delete this.parentGridItem;\n        // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n        if (nodeThatRemoved) {\n            window.setTimeout(()=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeThatRemoved._event, \"mouseenter\", pGrid.el), 0);\n        }\n    }\n    /**\n     * saves the current layout returning a list of widgets for serialization which might include any nested grids.\n     * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\n     * be removed.\n     * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\n     * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\n     * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\n     * @returns list of widgets or full grid option, including .children list of widgets\n     */ save() {\n        let saveContent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, saveGridOpt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, saveCB = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : GridStack.saveCB;\n        // return copied GridStackWidget (with optionally .el) we can modify at will...\n        let list = this.engine.save(saveContent, saveCB);\n        // check for HTML content and nested grids\n        list.forEach((n)=>{\n            if (saveContent && n.el && !n.subGrid && !saveCB) {\n                let sub = n.el.querySelector(\".grid-stack-item-content\");\n                n.content = sub ? sub.innerHTML : undefined;\n                if (!n.content) delete n.content;\n            } else {\n                var _n_subGrid;\n                if (!saveContent && !saveCB) {\n                    delete n.content;\n                }\n                // check for nested grid\n                if ((_n_subGrid = n.subGrid) === null || _n_subGrid === void 0 ? void 0 : _n_subGrid.el) {\n                    const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\n                    n.subGridOpts = saveGridOpt ? listOrOpt : {\n                        children: listOrOpt\n                    };\n                    delete n.subGrid;\n                }\n            }\n            delete n.el;\n        });\n        // check if save entire grid options (needed for recursive) + children...\n        if (saveGridOpt) {\n            let o = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(this.opts);\n            // delete default values that will be recreated on launch\n            if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n                o.margin = o.marginTop;\n                delete o.marginTop;\n                delete o.marginRight;\n                delete o.marginBottom;\n                delete o.marginLeft;\n            }\n            if (o.rtl === (this.el.style.direction === \"rtl\")) {\n                o.rtl = \"auto\";\n            }\n            if (this._isAutoCellHeight) {\n                o.cellHeight = \"auto\";\n            }\n            if (this._autoColumn) {\n                o.column = \"auto\";\n                delete o.disableOneColumnMode;\n            }\n            const origShow = o._alwaysShowResizeHandle;\n            delete o._alwaysShowResizeHandle;\n            if (origShow !== undefined) {\n                o.alwaysShowResizeHandle = origShow;\n            } else {\n                delete o.alwaysShowResizeHandle;\n            }\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalAndSame(o, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults);\n            o.children = list;\n            return o;\n        }\n        return list;\n    }\n    /**\n     * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\n     *\n     * @param layout list of widgets definition to update/create\n     * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\n     * the user control of insertion.\n     *\n     * @example\n     * see http://gridstackjs.com/demo/serialization.html\n     */ load(items) {\n        let addRemove = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GridStack.addRemoveCB || true;\n        items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(items); // so we can mod\n        // if passed list has coordinates, use them (insert from end to beginning for conflict resolution) else force widget same order\n        const haveCoord = items.some((w)=>w.x !== undefined || w.y !== undefined);\n        if (haveCoord) items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sort(items, -1, this._prevColumn || this.getColumn());\n        this._insertNotAppend = haveCoord; // if we create in reverse order...\n        // if we're loading a layout into for example 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save\n        // the original wanted layout so we can scale back up correctly #1471\n        if (this._prevColumn && this._prevColumn !== this.opts.column && items.some((n)=>(n.x || 0) + n.w > this.opts.column)) {\n            this._ignoreLayoutsNodeChange = true; // skip layout update\n            this.engine.cacheLayout(items, this._prevColumn, true);\n        }\n        // if given a different callback, temporally set it as global option so creating will use it\n        const prevCB = GridStack.addRemoveCB;\n        if (typeof addRemove === \"function\") GridStack.addRemoveCB = addRemove;\n        let removed = [];\n        this.batchUpdate();\n        // see if any items are missing from new layout and need to be removed first\n        if (addRemove) {\n            let copyNodes = [\n                ...this.engine.nodes\n            ]; // don't loop through array you modify\n            copyNodes.forEach((n)=>{\n                if (!n.id) return;\n                let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id);\n                if (!item) {\n                    if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\n                    removed.push(n); // batch keep track\n                    this.removeWidget(n.el, true, false);\n                }\n            });\n        }\n        // now add/update the widgets - starting with removing items in the new layout we will reposition\n        // to reduce collision and add no-coord ones at next available spot\n        let updateNodes = [];\n        this.engine.nodes = this.engine.nodes.filter((n)=>{\n            if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id)) {\n                updateNodes.push(n);\n                return false;\n            } // remove if found from list\n            return true;\n        });\n        let widthChanged = false;\n        items.forEach((w)=>{\n            let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(updateNodes, w.id);\n            if (item) {\n                var _w_subGridOpts;\n                // if item sizes to content, re-use the exiting height so it's a better guess at the final size 9same if width doesn't change)\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(item)) w.h = item.h;\n                // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\n                if (w.autoPosition || w.x === undefined || w.y === undefined) {\n                    w.w = w.w || item.w;\n                    w.h = w.h || item.h;\n                    this.engine.findEmptyPosition(w);\n                }\n                widthChanged = widthChanged || w.w !== undefined && w.w !== item.w;\n                // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\n                this.engine.nodes.push(item);\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.samePos(item, w)) {\n                    this.moveNode(item, {\n                        ...w,\n                        forceCollide: true\n                    });\n                    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(w, item, true);\n                }\n                this.update(item.el, w);\n                if ((_w_subGridOpts = w.subGridOpts) === null || _w_subGridOpts === void 0 ? void 0 : _w_subGridOpts.children) {\n                    let sub = item.el.querySelector(\".grid-stack\");\n                    if (sub && sub.gridstack) {\n                        sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\n                        this._insertNotAppend = true; // got reset by above call\n                    }\n                }\n            } else if (addRemove) {\n                this.addWidget(w);\n            }\n        });\n        this.engine.removedNodes = removed;\n        this.doContentResize(widthChanged, true); // we only need to wait for animation if we changed any widths\n        this.batchUpdate(false);\n        // after commit, clear that flag\n        delete this._ignoreLayoutsNodeChange;\n        delete this._insertNotAppend;\n        prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\n        return this;\n    }\n    /**\n     * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\n     * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\n     */ batchUpdate() {\n        let flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.engine.batchUpdate(flag);\n        if (!flag) {\n            this._updateContainerHeight();\n            this._triggerRemoveEvent();\n            this._triggerAddEvent();\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * Gets current cell height.\n     */ getCellHeight() {\n        let forcePixel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        if (this.opts.cellHeight && this.opts.cellHeight !== \"auto\" && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === \"px\")) {\n            return this.opts.cellHeight;\n        }\n        // else get first cell height\n        let el = this.el.querySelector(\".\" + this.opts.itemClass);\n        if (el) {\n            let height = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-h\")) || 1; // since we don't write 1 anymore\n            return Math.round(el.offsetHeight / height);\n        }\n        // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n        let rows = parseInt(this.el.getAttribute(\"gs-current-row\"));\n        return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n    }\n    /**\n     * Update current cell height - see `GridStackOptions.cellHeight` for format.\n     * This method rebuilds an internal CSS style sheet.\n     * Note: You can expect performance issues if call this method too often.\n     *\n     * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\n     * if pass 0 the CSS will be generated by the application instead.\n     * @param update (Optional) if false, styles will not be updated\n     *\n     * @example\n     * grid.cellHeight(100); // same as 100px\n     * grid.cellHeight('70px');\n     * grid.cellHeight(grid.cellWidth() * 1.2);\n     */ cellHeight(val) {\n        let update = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        // if not called internally, check if we're changing mode\n        if (update && val !== undefined) {\n            if (this._isAutoCellHeight !== (val === \"auto\")) {\n                this._isAutoCellHeight = val === \"auto\";\n                this._updateResizeEvent();\n            }\n        }\n        if (val === \"initial\" || val === \"auto\") {\n            val = undefined;\n        }\n        // make item content be square\n        if (val === undefined) {\n            let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n            val = this.cellWidth() + marginDiff;\n        }\n        let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(val);\n        if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n            return this;\n        }\n        this.opts.cellHeightUnit = data.unit;\n        this.opts.cellHeight = data.h;\n        this.doContentResize(false, true); // no anim wait, but use attributes since we only change row height\n        if (update) {\n            this._updateStyles(true); // true = force re-create for current # of rows\n        }\n        return this;\n    }\n    /** Gets current cell width. */ cellWidth() {\n        return this._widthOrContainer() / this.getColumn();\n    }\n    /** return our expected width (or parent) for 1 column check */ _widthOrContainer() {\n        // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n        // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n        return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n    }\n    /**\n     * re-layout grid items to reclaim any empty space. Options are:\n     * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\n     * 'compact' might re-order items to fill any empty space\n     *\n     * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\n     */ compact() {\n        let layout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"compact\", doSort = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        this.engine.compact(layout, doSort);\n        this._triggerChangeEvent();\n        return this;\n    }\n    /**\n     * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\n     * as well as cache the original layout so you can revert back to previous positions without loss.\n     * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\n     * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\n     * @param column - Integer > 0 (default 12).\n     * @param layout specify the type of re-layout that will happen (position, size, etc...).\n     * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\n     */ column(column) {\n        let layout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"moveScale\";\n        if (!column || column < 1 || this.opts.column === column) return this;\n        let oldColumn = this.getColumn();\n        // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)\n        // then remember the original columns so we can restore.\n        if (column === 1) {\n            this._prevColumn = oldColumn;\n        } else {\n            delete this._prevColumn;\n        }\n        this.el.classList.remove(\"gs-\" + oldColumn);\n        this.el.classList.add(\"gs-\" + column);\n        this.opts.column = this.engine.column = column;\n        // update the items now - see if the dom order nodes should be passed instead (else default to current list)\n        let domNodes;\n        if (column === 1 && this.opts.oneColumnModeDomSort) {\n            domNodes = [];\n            this.getGridItems().forEach((el)=>{\n                if (el.gridstackNode) {\n                    domNodes.push(el.gridstackNode);\n                }\n            });\n            if (!domNodes.length) {\n                domNodes = undefined;\n            }\n        }\n        this.engine.columnChanged(oldColumn, column, domNodes, layout);\n        if (this._isAutoCellHeight) this.cellHeight();\n        this.doContentResize();\n        // and trigger our event last...\n        this._ignoreLayoutsNodeChange = true; // skip layout update\n        this._triggerChangeEvent();\n        delete this._ignoreLayoutsNodeChange;\n        return this;\n    }\n    /**\n     * get the number of columns in the grid (default 12)\n     */ getColumn() {\n        return this.opts.column;\n    }\n    /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */ getGridItems() {\n        return Array.from(this.el.children).filter((el)=>el.matches(\".\" + this.opts.itemClass) && !el.matches(\".\" + this.opts.placeholderClass));\n    }\n    /**\n     * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\n     * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\n     */ destroy() {\n        let removeDOM = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        if (!this.el) return; // prevent multiple calls\n        this.offAll();\n        this._updateResizeEvent(true);\n        this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n        this.setAnimation(false);\n        if (!removeDOM) {\n            this.removeAll(removeDOM);\n            this.el.classList.remove(this._styleSheetClass);\n            this.el.removeAttribute(\"gs-current-row\");\n        } else {\n            this.el.parentNode.removeChild(this.el);\n        }\n        this._removeStylesheet();\n        if (this.parentGridItem) delete this.parentGridItem.subGrid;\n        delete this.parentGridItem;\n        delete this.opts;\n        delete this._placeholder;\n        delete this.engine;\n        delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n        delete this.el;\n        return this;\n    }\n    /**\n     * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\n     */ float(val) {\n        if (this.opts.float !== val) {\n            this.opts.float = this.engine.float = val;\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * get the current float mode\n     */ getFloat() {\n        return this.engine.float;\n    }\n    /**\n     * Get the position of the cell under a pixel on screen.\n     * @param position the position of the pixel to resolve in\n     * absolute coordinates, as an object with top and left properties\n     * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\n     * Useful when grid is within `position: relative` element\n     *\n     * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\n     */ getCellFromPixel(position) {\n        let useDocRelative = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        let box = this.el.getBoundingClientRect();\n        // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n        let containerPos;\n        if (useDocRelative) {\n            containerPos = {\n                top: box.top + document.documentElement.scrollTop,\n                left: box.left\n            };\n        // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n        } else {\n            containerPos = {\n                top: this.el.offsetTop,\n                left: this.el.offsetLeft\n            };\n        // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n        }\n        let relativeLeft = position.left - containerPos.left;\n        let relativeTop = position.top - containerPos.top;\n        let columnWidth = box.width / this.getColumn();\n        let rowHeight = box.height / parseInt(this.el.getAttribute(\"gs-current-row\"));\n        return {\n            x: Math.floor(relativeLeft / columnWidth),\n            y: Math.floor(relativeTop / rowHeight)\n        };\n    }\n    /** returns the current number of rows, which will be at least `minRow` if set */ getRow() {\n        return Math.max(this.engine.getRow(), this.opts.minRow);\n    }\n    /**\n     * Checks if specified area is empty.\n     * @param x the position x.\n     * @param y the position y.\n     * @param w the width of to check\n     * @param h the height of to check\n     */ isAreaEmpty(x, y, w, h) {\n        return this.engine.isAreaEmpty(x, y, w, h);\n    }\n    /**\n     * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\n     * If you want gridstack to add the elements for you, use `addWidget()` instead.\n     * Makes the given element a widget and returns it.\n     * @param els widget or single selector to convert.\n     * @param options widget definition to use instead of reading attributes or using default sizing values\n     *\n     * @example\n     * let grid = GridStack.init();\n     * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\n     * grid.el.appendChild('<div id=\"2\"></div>');\n     * grid.makeWidget('1');\n     * grid.makeWidget('2', {w:2, content: 'hello'});\n     */ makeWidget(els, options) {\n        let el = GridStack.getElement(els);\n        this._prepareElement(el, true, options);\n        const node = el.gridstackNode;\n        this._updateContainerHeight();\n        this.doContentResize(false, false, node);\n        // see if there is a sub-grid to create\n        if (node.subGridOpts) {\n            this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\n        }\n        // if we're adding an item into 1 column (_prevColumn is set only when going to 1) make sure\n        // we don't override the larger 12 column layout that was already saved. #1985\n        if (this._prevColumn && this.opts.column === 1) {\n            this._ignoreLayoutsNodeChange = true;\n        }\n        this._triggerAddEvent();\n        this._triggerChangeEvent();\n        delete this._ignoreLayoutsNodeChange;\n        return el;\n    }\n    /**\n     * Event handler that extracts our CustomEvent data out automatically for receiving custom\n     * notifications (see doc for supported events)\n     * @param name of the event (see possible values) or list of names space separated\n     * @param callback function called with event and optional second/third param\n     * (see README documentation for each signature).\n     *\n     * @example\n     * grid.on('added', function(e, items) { log('added ', items)} );\n     * or\n     * grid.on('added removed change', function(e, items) { log(e.type, items)} );\n     *\n     * Note: in some cases it is the same as calling native handler and parsing the event.\n     * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\n     *\n     */ on(name, callback) {\n        // check for array of names being passed instead\n        if (name.indexOf(\" \") !== -1) {\n            let names = name.split(\" \");\n            names.forEach((name)=>this.on(name, callback));\n            return this;\n        }\n        if (name === \"change\" || name === \"added\" || name === \"removed\" || name === \"enable\" || name === \"disable\") {\n            // native CustomEvent handlers - cash the generic handlers so we can easily remove\n            let noData = name === \"enable\" || name === \"disable\";\n            if (noData) {\n                this._gsEventHandler[name] = (event)=>callback(event);\n            } else {\n                this._gsEventHandler[name] = (event)=>callback(event, event.detail);\n            }\n            this.el.addEventListener(name, this._gsEventHandler[name]);\n        } else if (name === \"drag\" || name === \"dragstart\" || name === \"dragstop\" || name === \"resizestart\" || name === \"resize\" || name === \"resizestop\" || name === \"dropped\" || name === \"resizecontent\") {\n            // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n            // do same for start event to make it easier...\n            this._gsEventHandler[name] = callback;\n        } else {\n            console.log(\"GridStack.on(\" + name + ') event not supported, but you can still use $(\".grid-stack\").on(...) while jquery-ui is still used internally.');\n        }\n        return this;\n    }\n    /**\n     * unsubscribe from the 'on' event below\n     * @param name of the event (see possible values)\n     */ off(name) {\n        // check for array of names being passed instead\n        if (name.indexOf(\" \") !== -1) {\n            let names = name.split(\" \");\n            names.forEach((name)=>this.off(name));\n            return this;\n        }\n        if (name === \"change\" || name === \"added\" || name === \"removed\" || name === \"enable\" || name === \"disable\") {\n            // remove native CustomEvent handlers\n            if (this._gsEventHandler[name]) {\n                this.el.removeEventListener(name, this._gsEventHandler[name]);\n            }\n        }\n        delete this._gsEventHandler[name];\n        return this;\n    }\n    /** remove all event handlers */ offAll() {\n        Object.keys(this._gsEventHandler).forEach((key)=>this.off(key));\n        return this;\n    }\n    /**\n     * Removes widget from the grid.\n     * @param el  widget or selector to modify\n     * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\n     * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n     */ removeWidget(els) {\n        let removeDOM = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, triggerEvent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        GridStack.getElements(els).forEach((el)=>{\n            if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n            let node = el.gridstackNode;\n            // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n            if (!node) {\n                node = this.engine.nodes.find((n)=>el === n.el);\n            }\n            if (!node) return;\n            if (GridStack.addRemoveCB) {\n                GridStack.addRemoveCB(this.el, node, false, false);\n            }\n            // remove our DOM data (circular link) and drag&drop permanently\n            delete el.gridstackNode;\n            this._removeDD(el);\n            this.engine.removeNode(node, removeDOM, triggerEvent);\n            if (removeDOM && el.parentElement) {\n                el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n            }\n        });\n        if (triggerEvent) {\n            this._triggerRemoveEvent();\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * Removes all widgets from the grid.\n     * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\n     */ removeAll() {\n        let removeDOM = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n        this.engine.nodes.forEach((n)=>{\n            delete n.el.gridstackNode;\n            this._removeDD(n.el);\n        });\n        this.engine.removeAll(removeDOM);\n        this._triggerRemoveEvent();\n        return this;\n    }\n    /**\n     * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\n     * @param doAnimate if true the grid will animate.\n     */ setAnimation(doAnimate) {\n        if (doAnimate) {\n            this.el.classList.add(\"grid-stack-animate\");\n        } else {\n            this.el.classList.remove(\"grid-stack-animate\");\n        }\n        return this;\n    }\n    /**\n     * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\n     * Also toggle the grid-stack-static class.\n     * @param val if true the grid become static.\n     * @param updateClass true (default) if css class gets updated\n     * @param recurse true (default) if sub-grids also get updated\n     */ setStatic(val) {\n        let updateClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, recurse = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (!!this.opts.staticGrid === val) return this;\n        val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\n        this._setupRemoveDrop();\n        this._setupAcceptWidget();\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n); // either delete or init Drag&drop\n            if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n        });\n        if (updateClass) {\n            this._setStaticClass();\n        }\n        return this;\n    }\n    /**\n     * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\n     * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\n     * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\n     */ update(els, opt) {\n        // support legacy call for now ?\n        if (arguments.length > 2) {\n            console.warn(\"gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon\");\n            // eslint-disable-next-line prefer-rest-params\n            let a = arguments, i = 1;\n            opt = {\n                x: a[i++],\n                y: a[i++],\n                w: a[i++],\n                h: a[i++]\n            };\n            return this.update(els, opt);\n        }\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el === null || el === void 0 ? void 0 : el.gridstackNode;\n            if (!n) return;\n            let w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n            delete w.autoPosition;\n            delete w.id;\n            // move/resize widget if anything changed\n            let keys = [\n                \"x\",\n                \"y\",\n                \"w\",\n                \"h\"\n            ];\n            let m;\n            if (keys.some((k)=>w[k] !== undefined && w[k] !== n[k])) {\n                m = {};\n                keys.forEach((k)=>{\n                    m[k] = w[k] !== undefined ? w[k] : n[k];\n                    delete w[k];\n                });\n            }\n            // for a move as well IFF there is any min/max fields set\n            if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n                m = {}; // will use node position but validate values\n            }\n            // check for content changing\n            if (w.content !== undefined) {\n                const itemContent = el.querySelector(\".grid-stack-item-content\");\n                if (itemContent && itemContent.innerHTML !== w.content) {\n                    var _n_subGrid;\n                    itemContent.innerHTML = w.content;\n                    // restore any sub-grid back\n                    if ((_n_subGrid = n.subGrid) === null || _n_subGrid === void 0 ? void 0 : _n_subGrid.el) {\n                        itemContent.appendChild(n.subGrid.el);\n                        if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\n                    }\n                }\n                delete w.content;\n            }\n            // any remaining fields are assigned, but check for dragging changes, resize constrain\n            let changed = false;\n            let ddChanged = false;\n            for(const key in w){\n                if (key[0] !== \"_\" && n[key] !== w[key]) {\n                    n[key] = w[key];\n                    changed = true;\n                    ddChanged = ddChanged || !this.opts.staticGrid && (key === \"noResize\" || key === \"noMove\" || key === \"locked\");\n                }\n            }\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sanitizeMinMax(n);\n            // finally move the widget\n            if (m !== undefined) this.moveNode(n, m);\n            if (changed) {\n                this._writeAttr(el, n);\n            }\n            if (ddChanged) {\n                this._prepareDragDropByNode(n);\n            }\n        });\n        return this;\n    }\n    moveNode(n, m) {\n        this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);\n        this._updateContainerHeight();\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n    }\n    /**\n     * Updates widget height to match the content height to avoid v-scrollbar or dead space.\n     * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\n     * useAttrSize set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\n     */ resizeToContent(el) {\n        let useAttrSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!el) return;\n        el.classList.remove(\"size-to-content-max\");\n        if (!el.clientHeight) return; // 0 when hidden, skip\n        let n = el.gridstackNode;\n        if (!n) return;\n        const grid = n.grid;\n        if (!grid) return;\n        if (el.parentElement !== grid.el) return; // skip if we are not inside a grid\n        const cell = grid.getCellHeight();\n        if (!cell) return;\n        let height = useAttrSize && n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\n        let item;\n        if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\n        if (!item) item = el.querySelector(GridStack.resizeToContentParent);\n        if (!item) return;\n        const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\n        const itemH = useAttrSize && n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\n        let wantedH;\n        if (n.subGrid) {\n            // sub-grid - use their actual row count * their cell height\n            wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight();\n        } else {\n            // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\n            const child = item.firstElementChild;\n            if (!child) {\n                console.log(\"Error: resizeToContent() '\".concat(GridStack.resizeToContentParent, \"'.firstElementChild is null, make sure to have a div like container. Skipping sizing.\"));\n                return;\n            }\n            wantedH = child.getBoundingClientRect().height || itemH;\n        }\n        if (itemH === wantedH) return;\n        height += wantedH - itemH;\n        let h = Math.ceil(height / cell);\n        // check for min/max and special sizing\n        const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent : 0;\n        if (softMax && h > softMax) {\n            h = softMax;\n            el.classList.add(\"size-to-content-max\"); // get v-scroll back\n        }\n        if (n.minH && h < n.minH) h = n.minH;\n        else if (n.maxH && h > n.maxH) h = n.maxH;\n        if (h !== n.h) {\n            grid._ignoreLayoutsNodeChange = true;\n            grid.moveNode(n, {\n                h\n            });\n            delete grid._ignoreLayoutsNodeChange;\n        }\n    }\n    /** call the user resize (so they can do extra work) else our build in version */ resizeToContentCheck(el) {\n        let useAttr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el, useAttr);\n        else this.resizeToContent(el, useAttr);\n    }\n    /**\n     * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\n     * @param value margin value\n     */ margin(value) {\n        let isMultiValue = typeof value === \"string\" && value.split(\" \").length > 1;\n        // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n        if (!isMultiValue) {\n            let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(value);\n            if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n        }\n        // re-use existing margin handling\n        this.opts.margin = value;\n        this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n        this._initMargin();\n        this._updateStyles(true); // true = force re-create\n        return this;\n    }\n    /** returns current margin number value (undefined if 4 sides don't match) */ getMargin() {\n        return this.opts.margin;\n    }\n    /**\n     * Returns true if the height of the grid will be less than the vertical\n     * constraint. Always returns true if grid doesn't have height constraint.\n     * @param node contains x,y,w,h,auto-position options\n     *\n     * @example\n     * if (grid.willItFit(newWidget)) {\n     *   grid.addWidget(newWidget);\n     * } else {\n     *   alert('Not enough free space to place the widget');\n     * }\n     */ willItFit(node) {\n        // support legacy call for now\n        if (arguments.length > 1) {\n            console.warn(\"gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon\");\n            // eslint-disable-next-line prefer-rest-params\n            let a = arguments, i = 0, w = {\n                x: a[i++],\n                y: a[i++],\n                w: a[i++],\n                h: a[i++],\n                autoPosition: a[i++]\n            };\n            return this.willItFit(w);\n        }\n        return this.engine.willItFit(node);\n    }\n    /** @internal */ _triggerChangeEvent() {\n        if (this.engine.batchMode) return this;\n        let elements = this.engine.getDirtyNodes(true); // verify they really changed\n        if (elements && elements.length) {\n            if (!this._ignoreLayoutsNodeChange) {\n                this.engine.layoutsNodesChange(elements);\n            }\n            this._triggerEvent(\"change\", elements);\n        }\n        this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n        return this;\n    }\n    /** @internal */ _triggerAddEvent() {\n        var _this_engine_addedNodes;\n        if (this.engine.batchMode) return this;\n        if ((_this_engine_addedNodes = this.engine.addedNodes) === null || _this_engine_addedNodes === void 0 ? void 0 : _this_engine_addedNodes.length) {\n            if (!this._ignoreLayoutsNodeChange) {\n                this.engine.layoutsNodesChange(this.engine.addedNodes);\n            }\n            // prevent added nodes from also triggering 'change' event (which is called next)\n            this.engine.addedNodes.forEach((n)=>{\n                delete n._dirty;\n            });\n            this._triggerEvent(\"added\", this.engine.addedNodes);\n            this.engine.addedNodes = [];\n        }\n        return this;\n    }\n    /** @internal */ _triggerRemoveEvent() {\n        var _this_engine_removedNodes;\n        if (this.engine.batchMode) return this;\n        if ((_this_engine_removedNodes = this.engine.removedNodes) === null || _this_engine_removedNodes === void 0 ? void 0 : _this_engine_removedNodes.length) {\n            this._triggerEvent(\"removed\", this.engine.removedNodes);\n            this.engine.removedNodes = [];\n        }\n        return this;\n    }\n    /** @internal */ _triggerEvent(type, data) {\n        let event = data ? new CustomEvent(type, {\n            bubbles: false,\n            detail: data\n        }) : new Event(type);\n        this.el.dispatchEvent(event);\n        return this;\n    }\n    /** @internal called to delete the current dynamic style sheet used for our layout */ _removeStylesheet() {\n        if (this._styles) {\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeStylesheet(this._styleSheetClass);\n            delete this._styles;\n        }\n        return this;\n    }\n    /** @internal updated/create the CSS styles for row based layout and initial margin setting */ _updateStyles() {\n        let forceUpdate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, maxH = arguments.length > 1 ? arguments[1] : void 0;\n        // call to delete existing one if we change cellHeight / margin\n        if (forceUpdate) {\n            this._removeStylesheet();\n        }\n        if (!maxH) maxH = this.getRow();\n        this._updateContainerHeight();\n        // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n        if (this.opts.cellHeight === 0) {\n            return this;\n        }\n        let cellHeight = this.opts.cellHeight;\n        let cellHeightUnit = this.opts.cellHeightUnit;\n        let prefix = \".\".concat(this._styleSheetClass, \" > .\").concat(this.opts.itemClass);\n        // create one as needed\n        if (!this._styles) {\n            // insert style to parent (instead of 'head' by default) to support WebComponent\n            let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n            this._styles = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.createStylesheet(this._styleSheetClass, styleLocation, {\n                nonce: this.opts.nonce\n            });\n            if (!this._styles) return this;\n            this._styles._max = 0;\n            // these are done once only\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, prefix, \"height: \".concat(cellHeight).concat(cellHeightUnit));\n            // content margins\n            let top = this.opts.marginTop + this.opts.marginUnit;\n            let bottom = this.opts.marginBottom + this.opts.marginUnit;\n            let right = this.opts.marginRight + this.opts.marginUnit;\n            let left = this.opts.marginLeft + this.opts.marginUnit;\n            let content = \"\".concat(prefix, \" > .grid-stack-item-content\");\n            let placeholder = \".\".concat(this._styleSheetClass, \" > .grid-stack-placeholder > .placeholder-content\");\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, content, \"top: \".concat(top, \"; right: \").concat(right, \"; bottom: \").concat(bottom, \"; left: \").concat(left, \";\"));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, placeholder, \"top: \".concat(top, \"; right: \").concat(right, \"; bottom: \").concat(bottom, \"; left: \").concat(left, \";\"));\n            // resize handles offset (to match margin)\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-ne\"), \"right: \".concat(right));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-e\"), \"right: \".concat(right));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-se\"), \"right: \".concat(right, \"; bottom: \").concat(bottom));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-nw\"), \"left: \".concat(left));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-w\"), \"left: \".concat(left));\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, \" > .ui-resizable-sw\"), \"left: \".concat(left, \"; bottom: \").concat(bottom));\n        }\n        // now update the height specific fields\n        maxH = maxH || this._styles._max;\n        if (maxH > this._styles._max) {\n            let getHeight = (rows)=>cellHeight * rows + cellHeightUnit;\n            for(let i = this._styles._max + 1; i <= maxH; i++){\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, '[gs-y=\"').concat(i, '\"]'), \"top: \".concat(getHeight(i)));\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, \"\".concat(prefix, '[gs-h=\"').concat(i + 1, '\"]'), \"height: \".concat(getHeight(i + 1))); // start at 2\n            }\n            this._styles._max = maxH;\n        }\n        return this;\n    }\n    /** @internal */ _updateContainerHeight() {\n        if (!this.engine || this.engine.batchMode) return this;\n        const parent = this.parentGridItem;\n        let row = this.getRow() + this._extraDragRow; // this checks for minRow already\n        const cellHeight = this.opts.cellHeight;\n        const unit = this.opts.cellHeightUnit;\n        if (!cellHeight) return this;\n        // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\n        if (!parent) {\n            const cssMinHeight = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(getComputedStyle(this.el)[\"minHeight\"]);\n            if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\n                const minRow = Math.floor(cssMinHeight.h / cellHeight);\n                if (row < minRow) {\n                    row = minRow;\n                }\n            }\n        }\n        this.el.setAttribute(\"gs-current-row\", String(row));\n        this.el.style.removeProperty(\"min-height\");\n        this.el.style.removeProperty(\"height\");\n        if (row) {\n            // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\n            this.el.style[parent ? \"minHeight\" : \"height\"] = row * cellHeight + unit;\n        }\n        // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\n        if (parent && !parent.grid.engine.batchMode && _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(parent)) {\n            parent.grid.resizeToContentCheck(parent.el);\n        }\n        return this;\n    }\n    /** @internal */ _prepareElement(el) {\n        let triggerAddEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, node = arguments.length > 2 ? arguments[2] : void 0;\n        el.classList.add(this.opts.itemClass);\n        node = node || this._readAttr(el);\n        el.gridstackNode = node;\n        node.el = el;\n        node.grid = this;\n        let copy = {\n            ...node\n        };\n        node = this.engine.addNode(node, triggerAddEvent);\n        // write node attr back in case there was collision or we have to fix bad values during addNode()\n        if (!_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.same(node, copy)) {\n            this._writeAttr(el, node);\n        }\n        if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(node)) el.classList.add(\"size-to-content\");\n        this._prepareDragDropByNode(node);\n        return this;\n    }\n    /** @internal call to write position x,y,w,h attributes back to element */ _writePosAttr(el, n) {\n        if (n.x !== undefined && n.x !== null) {\n            el.setAttribute(\"gs-x\", String(n.x));\n        }\n        if (n.y !== undefined && n.y !== null) {\n            el.setAttribute(\"gs-y\", String(n.y));\n        }\n        n.w > 1 ? el.setAttribute(\"gs-w\", String(n.w)) : el.removeAttribute(\"gs-w\");\n        n.h > 1 ? el.setAttribute(\"gs-h\", String(n.h)) : el.removeAttribute(\"gs-h\");\n        return this;\n    }\n    /** @internal call to write any default attributes back to element */ _writeAttr(el, node) {\n        if (!node) return this;\n        this._writePosAttr(el, node);\n        let attrs /*: GridStackWidget but strings */  = {\n            autoPosition: \"gs-auto-position\",\n            noResize: \"gs-no-resize\",\n            noMove: \"gs-no-move\",\n            locked: \"gs-locked\",\n            id: \"gs-id\"\n        };\n        for(const key in attrs){\n            if (node[key]) {\n                el.setAttribute(attrs[key], String(node[key]));\n            } else {\n                el.removeAttribute(attrs[key]);\n            }\n        }\n        return this;\n    }\n    /** @internal call to read any default attributes from element */ _readAttr(el) {\n        let clearDefaultAttr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        let n = {};\n        n.x = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-x\"));\n        n.y = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-y\"));\n        n.w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-w\"));\n        n.h = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-h\"));\n        n.autoPosition = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-auto-position\"));\n        n.noResize = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-no-resize\"));\n        n.noMove = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-no-move\"));\n        n.locked = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-locked\"));\n        n.id = el.getAttribute(\"gs-id\");\n        // read but never written out\n        n.maxW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-w\"));\n        n.minW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-w\"));\n        n.maxH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-h\"));\n        n.minH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-h\"));\n        // v8.x optimization to reduce un-needed attr that don't render or are default CSS\n        if (clearDefaultAttr) {\n            if (n.w === 1) el.removeAttribute(\"gs-w\");\n            if (n.h === 1) el.removeAttribute(\"gs-h\");\n            if (n.maxW) el.removeAttribute(\"gs-max-w\");\n            if (n.minW) el.removeAttribute(\"gs-min-w\");\n            if (n.maxH) el.removeAttribute(\"gs-max-h\");\n            if (n.minH) el.removeAttribute(\"gs-min-h\");\n        }\n        // remove any key not found (null or false which is default)\n        for(const key in n){\n            if (!n.hasOwnProperty(key)) return;\n            if (!n[key] && n[key] !== 0) {\n                delete n[key];\n            }\n        }\n        return n;\n    }\n    /** @internal */ _setStaticClass() {\n        let classes = [\n            \"grid-stack-static\"\n        ];\n        if (this.opts.staticGrid) {\n            this.el.classList.add(...classes);\n            this.el.setAttribute(\"gs-static\", \"true\");\n        } else {\n            this.el.classList.remove(...classes);\n            this.el.removeAttribute(\"gs-static\");\n        }\n        return this;\n    }\n    /**\n     * called when we are being resized - check if the one Column Mode needs to be turned on/off\n     * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\n     * or `sizeToContent` gridItem options.\n     */ onResize() {\n        var _this_el;\n        if (!((_this_el = this.el) === null || _this_el === void 0 ? void 0 : _this_el.clientWidth)) return; // return if we're gone or no size yet (will get called again)\n        if (this.prevWidth === this.el.clientWidth) return; // no-op\n        this.prevWidth = this.el.clientWidth;\n        // console.log('onResize ', this.el.clientWidth);\n        this.batchUpdate();\n        // see if we're nested and take our column count from our parent....\n        let columnChanged = false;\n        if (this._autoColumn && this.parentGridItem) {\n            if (this.opts.column !== this.parentGridItem.w) {\n                this.column(this.parentGridItem.w, \"none\");\n                columnChanged = true;\n            }\n        } else {\n            // else check for 1 column in/out behavior\n            let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize || this.opts.column === 1 && !this._prevColumn;\n            if (this.opts.column === 1 !== oneColumn) {\n                // if (this.opts.animate) this.setAnimation(false); // 1 <-> 12 is too radical, turn off animation and we need it for sizeToContent\n                this.column(oneColumn ? 1 : this._prevColumn);\n                // if (this.opts.animate) setTimeout(() => this.setAnimation(true));\n                columnChanged = true;\n            }\n        }\n        // make the cells content square again\n        if (this._isAutoCellHeight) this.cellHeight();\n        // update any nested grids, or items size\n        this.engine.nodes.forEach((n)=>{\n            if (n.subGrid) n.subGrid.onResize();\n        });\n        if (!this._skipInitialResize) this.doContentResize(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\n        delete this._skipInitialResize;\n        this.batchUpdate(false);\n        return this;\n    }\n    doContentResize() {\n        let delay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, useAttr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : undefined;\n        // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\n        // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\n        setTimeout(()=>{\n            if (n) {\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n)) this.resizeToContentCheck(n.el, useAttr);\n            } else if (this.engine.nodes.some((n)=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n))) {\n                const nodes = [\n                    ...this.engine.nodes\n                ]; // in case order changes while resizing one\n                this.batchUpdate();\n                nodes.forEach((n)=>{\n                    if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n)) this.resizeToContentCheck(n.el, useAttr);\n                });\n                this.batchUpdate(false);\n            }\n            // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\n            if (this._gsEventHandler[\"resizecontent\"]) this._gsEventHandler[\"resizecontent\"](null, n ? [\n                n\n            ] : this.engine.nodes);\n        }, delay ? 300 + 10 : 0);\n    }\n    /** add or remove the grid element size event handler */ _updateResizeEvent() {\n        let forceRemove = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)\n        // or supporting new sizeToContent option.\n        const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || !this.opts.disableOneColumnMode || this.engine.nodes.find((n)=>n.sizeToContent));\n        if (!forceRemove && trackSize && !this.resizeObserver) {\n            this._sizeThrottle = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.throttle(()=>this.onResize(), this.opts.cellHeightThrottle);\n            this.resizeObserver = new ResizeObserver(()=>this._sizeThrottle());\n            this.resizeObserver.observe(this.el);\n            this._skipInitialResize = true; // makeWidget will originally have called on startup\n        } else if ((forceRemove || !trackSize) && this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            delete this.resizeObserver;\n            delete this._sizeThrottle;\n        }\n        return this;\n    }\n    /** @internal convert a potential selector into actual element */ static getElement() {\n        let els = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \".grid-stack-item\";\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElement(els);\n    }\n    /** @internal */ static getElements() {\n        let els = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \".grid-stack-item\";\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n    }\n    /** @internal */ static getGridElement(els) {\n        return GridStack.getElement(els);\n    }\n    /** @internal */ static getGridElements(els) {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n    }\n    /** @internal initialize margin top/bottom/left/right and units */ _initMargin() {\n        let data;\n        let margin = 0;\n        // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n        let margins = [];\n        if (typeof this.opts.margin === \"string\") {\n            margins = this.opts.margin.split(\" \");\n        }\n        if (margins.length === 2) {\n            this.opts.marginTop = this.opts.marginBottom = margins[0];\n            this.opts.marginLeft = this.opts.marginRight = margins[1];\n        } else if (margins.length === 4) {\n            this.opts.marginTop = margins[0];\n            this.opts.marginRight = margins[1];\n            this.opts.marginBottom = margins[2];\n            this.opts.marginLeft = margins[3];\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.margin);\n            this.opts.marginUnit = data.unit;\n            margin = this.opts.margin = data.h;\n        }\n        // see if top/bottom/left/right need to be set as well\n        if (this.opts.marginTop === undefined) {\n            this.opts.marginTop = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginTop);\n            this.opts.marginTop = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginBottom === undefined) {\n            this.opts.marginBottom = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginBottom);\n            this.opts.marginBottom = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginRight === undefined) {\n            this.opts.marginRight = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginRight);\n            this.opts.marginRight = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginLeft === undefined) {\n            this.opts.marginLeft = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginLeft);\n            this.opts.marginLeft = data.h;\n            delete this.opts.margin;\n        }\n        this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n        if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n            this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n        }\n        return this;\n    }\n    /* ===========================================================================================\n     * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\n     * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n     * ===========================================================================================\n     */ /** get the global (but static to this code) DD implementation */ static getDD() {\n        return dd;\n    }\n    /**\n     * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\n     * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\n     * is dynamically create and needs to be set later.\n     * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\n     * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\n     * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\n     */ static setupDragIn(dragIn, dragInOptions) {\n        let root = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : document;\n        if ((dragInOptions === null || dragInOptions === void 0 ? void 0 : dragInOptions.pause) !== undefined) {\n            _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = dragInOptions.pause;\n        }\n        dragInOptions = {\n            ..._types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions,\n            ...dragInOptions || {}\n        };\n        let els = typeof dragIn === \"string\" ? _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(dragIn, root) : dragIn;\n        if (els.length) els === null || els === void 0 ? void 0 : els.forEach((el)=>{\n            if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n        });\n    }\n    /**\n     * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\n     * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\n     * @param els widget or selector to modify.\n     * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\n     */ movable(els, val) {\n        if (this.opts.staticGrid) return this; // can't move a static grid!\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el.gridstackNode;\n            if (!n) return;\n            val ? delete n.noMove : n.noMove = true;\n            this._prepareDragDropByNode(n); // init DD if need be, and adjust\n        });\n        return this;\n    }\n    /**\n     * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\n     * @param els  widget or selector to modify\n     * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\n     */ resizable(els, val) {\n        if (this.opts.staticGrid) return this; // can't resize a static grid!\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el.gridstackNode;\n            if (!n) return;\n            val ? delete n.noResize : n.noResize = true;\n            this._prepareDragDropByNode(n); // init DD if need be, and adjust\n        });\n        return this;\n    }\n    /**\n     * Temporarily disables widgets moving/resizing.\n     * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\n     * Note: no-op for static grid\n     * This is a shortcut for:\n     * @example\n     *  grid.enableMove(false);\n     *  grid.enableResize(false);\n     * @param recurse true (default) if sub-grids also get updated\n     */ disable() {\n        let recurse = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        if (this.opts.staticGrid) return;\n        this.enableMove(false, recurse);\n        this.enableResize(false, recurse);\n        this._triggerEvent(\"disable\");\n        return this;\n    }\n    /**\n     * Re-enables widgets moving/resizing - see disable().\n     * Note: no-op for static grid.\n     * This is a shortcut for:\n     * @example\n     *  grid.enableMove(true);\n     *  grid.enableResize(true);\n     * @param recurse true (default) if sub-grids also get updated\n     */ enable() {\n        let recurse = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        if (this.opts.staticGrid) return;\n        this.enableMove(true, recurse);\n        this.enableResize(true, recurse);\n        this._triggerEvent(\"enable\");\n        return this;\n    }\n    /**\n     * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\n     * @param recurse true (default) if sub-grids also get updated\n     */ enableMove(doEnable) {\n        let recurse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (this.opts.staticGrid) return this; // can't move a static grid!\n        doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n);\n            if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n        });\n        return this;\n    }\n    /**\n     * Enables/disables widget resizing. No-op for static grids.\n     * @param recurse true (default) if sub-grids also get updated\n     */ enableResize(doEnable) {\n        let recurse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (this.opts.staticGrid) return this; // can't size a static grid!\n        doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n);\n            if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n        });\n        return this;\n    }\n    /** @internal removes any drag&drop present (called during destroy) */ _removeDD(el) {\n        dd.draggable(el, \"destroy\").resizable(el, \"destroy\");\n        if (el.gridstackNode) {\n            delete el.gridstackNode._initDD; // reset our DD init flag\n        }\n        delete el.ddElement;\n        return this;\n    }\n    /** @internal called to add drag over to support widgets being added externally */ _setupAcceptWidget() {\n        // check if we need to disable things\n        if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n            dd.droppable(this.el, \"destroy\");\n            return this;\n        }\n        // vars shared across all methods\n        let cellHeight, cellWidth;\n        let onDrag = (event, el, helper)=>{\n            let node = el.gridstackNode;\n            if (!node) return;\n            helper = helper || el;\n            let parent = this.el.getBoundingClientRect();\n            let { top, left } = helper.getBoundingClientRect();\n            left -= parent.left;\n            top -= parent.top;\n            let ui = {\n                position: {\n                    top,\n                    left\n                }\n            };\n            if (node._temporaryRemoved) {\n                node.x = Math.max(0, Math.round(left / cellWidth));\n                node.y = Math.max(0, Math.round(top / cellHeight));\n                delete node.autoPosition;\n                this.engine.nodeBoundFix(node);\n                // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n                if (!this.engine.willItFit(node)) {\n                    node.autoPosition = true; // ignore x,y and try for any slot...\n                    if (!this.engine.willItFit(node)) {\n                        dd.off(el, \"drag\"); // stop calling us\n                        return; // full grid or can't grow\n                    }\n                    if (node._willFitPos) {\n                        // use the auto position instead #1687\n                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._willFitPos);\n                        delete node._willFitPos;\n                    }\n                }\n                // re-use the existing node dragging method\n                this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n            } else {\n                // re-use the existing node dragging that does so much of the collision detection\n                this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n            }\n        };\n        dd.droppable(this.el, {\n            accept: (el)=>{\n                let node = el.gridstackNode;\n                // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n                if ((node === null || node === void 0 ? void 0 : node.grid) === this) return true;\n                if (!this.opts.acceptWidgets) return false;\n                // check for accept method or class matching\n                let canAccept = true;\n                if (typeof this.opts.acceptWidgets === \"function\") {\n                    canAccept = this.opts.acceptWidgets(el);\n                } else {\n                    let selector = this.opts.acceptWidgets === true ? \".grid-stack-item\" : this.opts.acceptWidgets;\n                    canAccept = el.matches(selector);\n                }\n                // finally check to make sure we actually have space left #1571\n                if (canAccept && node && this.opts.maxRow) {\n                    let n = {\n                        w: node.w,\n                        h: node.h,\n                        minW: node.minW,\n                        minH: node.minH\n                    }; // only width/height matters and autoPosition\n                    canAccept = this.engine.willItFit(n);\n                }\n                return canAccept;\n            }\n        })/**\n             * entering our grid area\n             */ .on(this.el, \"dropover\", (event, el, helper)=>{\n            // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n            let node = el.gridstackNode;\n            // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n            if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._temporaryRemoved) {\n                // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n                return false; // prevent parent from receiving msg (which may be a grid as well)\n            }\n            // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n            if ((node === null || node === void 0 ? void 0 : node.grid) && node.grid !== this && !node._temporaryRemoved) {\n                // console.log('dropover without leave'); // TEST\n                let otherGrid = node.grid;\n                otherGrid._leave(el, helper);\n            }\n            // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n            cellWidth = this.cellWidth();\n            cellHeight = this.getCellHeight(true);\n            // load any element attributes if we don't have a node\n            if (!node) {\n                node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\n            }\n            if (!node.grid) {\n                node._isExternal = true;\n                el.gridstackNode = node;\n            }\n            // calculate the grid size based on element outer size\n            helper = helper || el;\n            let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n            let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n            // if the item came from another grid, make a copy and save the original info in case we go back there\n            if (node.grid && node.grid !== this) {\n                // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n                // console.log('dropover cloning node'); // TEST\n                if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n                el.gridstackNode = node = {\n                    ...node,\n                    w,\n                    h,\n                    grid: this\n                };\n                delete node.x;\n                delete node.y;\n                this.engine.cleanupNode(node).nodeBoundFix(node);\n                // restore some internal fields we need after clearing them all\n                node._initDD = node._isExternal = node._temporaryRemoved = true; // so it can be inserted onDrag below\n            } else {\n                node.w = w;\n                node.h = h;\n                node._temporaryRemoved = true; // so we can insert it\n            }\n            // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n            this._itemRemoving(node.el, false);\n            dd.on(el, \"drag\", onDrag);\n            // make sure this is called at least once when going fast #1578\n            onDrag(event, el, helper);\n            return false; // prevent parent from receiving msg (which may be a grid as well)\n        })/**\n             * Leaving our grid area...\n             */ .on(this.el, \"dropout\", (event, el, helper)=>{\n            // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n            let node = el.gridstackNode;\n            if (!node) return false;\n            // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n            // so skip this one if we're not the active grid really..\n            if (!node.grid || node.grid === this) {\n                this._leave(el, helper);\n                // if we were created as temporary nested grid, go back to before state\n                if (this._isTemp) {\n                    this.removeAsSubGrid(node);\n                }\n            }\n            return false; // prevent parent from receiving msg (which may be grid as well)\n        })/**\n             * end - releasing the mouse\n             */ .on(this.el, \"drop\", (event, el, helper)=>{\n            var _node_subGrid_el, _node_subGrid;\n            let node = el.gridstackNode;\n            // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n            if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._isExternal) return false;\n            let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n            this.placeholder.remove();\n            // notify previous grid of removal\n            // console.log('drop delete _gridstackNodeOrig') // TEST\n            let origNode = el._gridstackNodeOrig;\n            delete el._gridstackNodeOrig;\n            if (wasAdded && (origNode === null || origNode === void 0 ? void 0 : origNode.grid) && origNode.grid !== this) {\n                let oGrid = origNode.grid;\n                oGrid.engine.removeNodeFromLayoutCache(origNode);\n                oGrid.engine.removedNodes.push(origNode);\n                oGrid._triggerRemoveEvent()._triggerChangeEvent();\n                // if it's an empty sub-grid that got auto-created, nuke it\n                if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n                    oGrid.removeAsSubGrid();\n                }\n            }\n            if (!node) return false;\n            // use existing placeholder node as it's already in our list with drop location\n            if (wasAdded) {\n                this.engine.cleanupNode(node); // removes all internal _xyz values\n                node.grid = this;\n            }\n            dd.off(el, \"drag\");\n            // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n            // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n            if (helper !== el) {\n                helper.remove();\n                el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n                if (wasAdded) {\n                    el = el.cloneNode(true);\n                }\n            } else {\n                el.remove(); // reduce flicker as we change depth here, and size further down\n                this._removeDD(el);\n            }\n            if (!wasAdded) return false;\n            el.gridstackNode = node;\n            node.el = el;\n            let subGrid = (_node_subGrid = node.subGrid) === null || _node_subGrid === void 0 ? void 0 : (_node_subGrid_el = _node_subGrid.el) === null || _node_subGrid_el === void 0 ? void 0 : _node_subGrid_el.gridstack; // set when actual sub-grid present\n            // @ts-ignore\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(el); // @ts-ignore\n            this._writeAttr(el, node);\n            el.classList.add(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n            this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n            if (subGrid) {\n                subGrid.parentGridItem = node;\n                if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n            }\n            this._updateContainerHeight();\n            this.engine.addedNodes.push(node); // @ts-ignore\n            this._triggerAddEvent(); // @ts-ignore\n            this._triggerChangeEvent();\n            this.engine.endUpdate();\n            if (this._gsEventHandler[\"dropped\"]) {\n                this._gsEventHandler[\"dropped\"]({\n                    ...event,\n                    type: \"dropped\"\n                }, origNode && origNode.grid ? origNode : undefined, node);\n            }\n            // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n            window.setTimeout(()=>{\n                // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n                if (node.el && node.el.parentElement) {\n                    this._prepareDragDropByNode(node);\n                } else {\n                    this.engine.removeNode(node);\n                }\n                delete node.grid._isTemp;\n            });\n            return false; // prevent parent from receiving msg (which may be grid as well)\n        });\n        return this;\n    }\n    /** @internal mark item for removal */ _itemRemoving(el, remove) {\n        let node = el ? el.gridstackNode : undefined;\n        if (!node || !node.grid || el.classList.contains(this.opts.removableOptions.decline)) return;\n        remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n        remove ? el.classList.add(\"grid-stack-item-removing\") : el.classList.remove(\"grid-stack-item-removing\");\n    }\n    /** @internal called to setup a trash drop zone if the user specifies it */ _setupRemoveDrop() {\n        if (!this.opts.staticGrid && typeof this.opts.removable === \"string\") {\n            let trashEl = document.querySelector(this.opts.removable);\n            if (!trashEl) return this;\n            // only register ONE drop-over/dropout callback for the 'trash', and it will\n            // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n            // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n            if (!dd.isDroppable(trashEl)) {\n                dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, \"dropover\", (event, el)=>this._itemRemoving(el, true)).on(trashEl, \"dropout\", (event, el)=>this._itemRemoving(el, false));\n            }\n        }\n        return this;\n    }\n    /** @internal prepares the element for drag&drop */ _prepareDragDropByNode(node) {\n        let el = node.el;\n        const noMove = node.noMove || this.opts.disableDrag;\n        const noResize = node.noResize || this.opts.disableResize;\n        // check for disabled grid first\n        if (this.opts.staticGrid || noMove && noResize) {\n            if (node._initDD) {\n                this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n                delete node._initDD;\n            }\n            el.classList.add(\"ui-draggable-disabled\", \"ui-resizable-disabled\"); // add styles one might depend on #1435\n            return this;\n        }\n        if (!node._initDD) {\n            // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n            let cellWidth;\n            let cellHeight;\n            /** called when item starts moving/resizing */ let onStartMoving = (event, ui)=>{\n                // trigger any 'dragstart' / 'resizestart' manually\n                if (this._gsEventHandler[event.type]) {\n                    this._gsEventHandler[event.type](event, event.target);\n                }\n                cellWidth = this.cellWidth();\n                cellHeight = this.getCellHeight(true); // force pixels for calculations\n                this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n            };\n            /** called when item is being dragged/resized */ let dragOrResize = (event, ui)=>{\n                this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n            };\n            /** called when the item stops moving/resizing */ let onEndMoving = (event)=>{\n                this.placeholder.remove();\n                delete node._moving;\n                delete node._event;\n                delete node._lastTried;\n                // if the item has moved to another grid, we're done here\n                let target = event.target;\n                if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n                node.el = target;\n                if (node._isAboutToRemove) {\n                    let grid = el.gridstackNode.grid;\n                    if (grid._gsEventHandler[event.type]) {\n                        grid._gsEventHandler[event.type](event, target);\n                    }\n                    grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\n                    grid.removeWidget(el, true, true);\n                } else {\n                    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(target);\n                    if (node._temporaryRemoved) {\n                        // got removed - restore item back to before dragging position\n                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._orig); // @ts-ignore\n                        this._writePosAttr(target, node);\n                        this.engine.addNode(node);\n                    } else {\n                        // move to new placeholder location\n                        this._writePosAttr(target, node);\n                    }\n                    if (this._gsEventHandler[event.type]) {\n                        this._gsEventHandler[event.type](event, target);\n                    }\n                }\n                // @ts-ignore\n                this._extraDragRow = 0; // @ts-ignore\n                this._updateContainerHeight(); // @ts-ignore\n                this._triggerChangeEvent();\n                this.engine.endUpdate();\n                if (event.type === \"resizestop\") {\n                    if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\n                    this.doContentResize(false, true, node); // no amin wait as will use the actual sized coordinate attr\n                }\n            };\n            dd.draggable(el, {\n                start: onStartMoving,\n                stop: onEndMoving,\n                drag: dragOrResize\n            }).resizable(el, {\n                start: onStartMoving,\n                stop: onEndMoving,\n                resize: dragOrResize\n            });\n            node._initDD = true; // we've set DD support now\n        }\n        // finally fine tune move vs resize by disabling any part...\n        dd.draggable(el, noMove ? \"disable\" : \"enable\").resizable(el, noResize ? \"disable\" : \"enable\");\n        return this;\n    }\n    /** @internal handles actual drag/resize start */ _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n        this.engine.cleanNodes().beginUpdate(node);\n        // @ts-ignore\n        this._writePosAttr(this.placeholder, node);\n        this.el.appendChild(this.placeholder);\n        // console.log('_onStartMoving placeholder') // TEST\n        node.el = this.placeholder;\n        node._lastUiPosition = ui.position;\n        node._prevYPix = ui.position.top;\n        node._moving = event.type === \"dragstart\"; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n        delete node._lastTried;\n        if (event.type === \"dropover\" && node._temporaryRemoved) {\n            // console.log('engine.addNode x=' + node.x); // TEST\n            this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n            node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n        }\n        // set the min/max resize info\n        this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n        if (event.type === \"resizestart\") {\n            dd.resizable(el, \"option\", \"minWidth\", cellWidth * (node.minW || 1)).resizable(el, \"option\", \"minHeight\", cellHeight * (node.minH || 1));\n            if (node.maxW) {\n                dd.resizable(el, \"option\", \"maxWidth\", cellWidth * node.maxW);\n            }\n            if (node.maxH) {\n                dd.resizable(el, \"option\", \"maxHeight\", cellHeight * node.maxH);\n            }\n        }\n    }\n    /** @internal handles actual drag/resize */ _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n        let p = {\n            ...node._orig\n        }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n        let resizing;\n        let mLeft = this.opts.marginLeft, mRight = this.opts.marginRight, mTop = this.opts.marginTop, mBottom = this.opts.marginBottom;\n        // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n        let mHeight = Math.round(cellHeight * 0.1), mWidth = Math.round(cellWidth * 0.1);\n        mLeft = Math.min(mLeft, mWidth);\n        mRight = Math.min(mRight, mWidth);\n        mTop = Math.min(mTop, mHeight);\n        mBottom = Math.min(mBottom, mHeight);\n        if (event.type === \"drag\") {\n            if (node._temporaryRemoved) return; // handled by dropover\n            let distance = ui.position.top - node._prevYPix;\n            node._prevYPix = ui.position.top;\n            if (this.opts.draggable.scroll !== false) {\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollPosition(el, ui.position, distance);\n            }\n            // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n            let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n            let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n            p.x = Math.round(left / cellWidth);\n            p.y = Math.round(top / cellHeight);\n            // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n            let prev = this._extraDragRow;\n            if (this.engine.collide(node, p)) {\n                let row = this.getRow();\n                let extra = Math.max(0, p.y + node.h - row);\n                if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n                    extra = Math.max(0, this.opts.maxRow - row);\n                } // @ts-ignore\n                this._extraDragRow = extra; // @ts-ignore\n            } else this._extraDragRow = 0; // @ts-ignore\n            if (this._extraDragRow !== prev) this._updateContainerHeight();\n            if (node.x === p.x && node.y === p.y) return; // skip same\n        // DON'T skip one we tried as we might have failed because of coverage <50% before\n        // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n        } else if (event.type === \"resize\") {\n            if (p.x < 0) return;\n            // Scrolling page if needed\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollResize(event, el, cellHeight);\n            // get new size\n            p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n            p.h = Math.round((ui.size.height - mTop) / cellHeight);\n            if (node.w === p.w && node.h === p.h) return;\n            if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n            // if we size on left/top side this might move us, so get possible new position as well\n            let left = ui.position.left + mLeft;\n            let top = ui.position.top + mTop;\n            p.x = Math.round(left / cellWidth);\n            p.y = Math.round(top / cellHeight);\n            resizing = true;\n        }\n        node._event = event;\n        node._lastTried = p; // set as last tried (will nuke if we go there)\n        let rect = {\n            x: ui.position.left + mLeft,\n            y: ui.position.top + mTop,\n            w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n            h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n        };\n        if (this.engine.moveNodeCheck(node, {\n            ...p,\n            cellWidth,\n            cellHeight,\n            rect,\n            resizing\n        })) {\n            node._lastUiPosition = ui.position;\n            this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n            delete node._skipDown;\n            if (resizing && node.subGrid) node.subGrid.onResize();\n            this._extraDragRow = 0; // @ts-ignore\n            this._updateContainerHeight();\n            let target = event.target; // @ts-ignore\n            this._writePosAttr(target, node);\n            if (this._gsEventHandler[event.type]) {\n                this._gsEventHandler[event.type](event, target);\n            }\n        }\n    }\n    /** @internal called when item leaving our area by either cursor dropout event\n     * or shape is outside our boundaries. remove it from us, and mark temporary if this was\n     * our item to start with else restore prev node values from prev grid it came from.\n     */ _leave(el, helper) {\n        let node = el.gridstackNode;\n        if (!node) return;\n        dd.off(el, \"drag\"); // no need to track while being outside\n        // this gets called when cursor leaves and shape is outside, so only do this once\n        if (node._temporaryRemoved) return;\n        node._temporaryRemoved = true;\n        this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n        node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n        if (this.opts.removable === true) {\n            // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n            this._itemRemoving(el, true);\n        }\n        // finally if item originally came from another grid, but left us, restore things back to prev info\n        if (el._gridstackNodeOrig) {\n            // console.log('leave delete _gridstackNodeOrig') // TEST\n            el.gridstackNode = el._gridstackNodeOrig;\n            delete el._gridstackNodeOrig;\n        } else if (node._isExternal) {\n            // item came from outside (like a toolbar) so nuke any node info\n            delete node.el;\n            delete el.gridstackNode;\n            // and restore all nodes back to original\n            this.engine.restoreInitial();\n        }\n    }\n    // legacy method removed\n    commit() {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.obsolete)(this, this.batchUpdate(false), \"commit\", \"batchUpdate\", \"5.2\");\n        return this;\n    }\n    /**\n     * Construct a grid item from the given element and options\n     * @param el\n     * @param opts\n     */ constructor(el, opts = {}){\n        var _this_el_parentElement, _this_opts_draggable;\n        /** @internal */ this._gsEventHandler = {};\n        /** @internal extra row added when dragging at the bottom of the grid */ this._extraDragRow = 0;\n        this.el = el; // exposed HTML element to the user\n        opts = opts || {}; // handles null/undefined/0\n        if (!el.classList.contains(\"grid-stack\")) {\n            this.el.classList.add(\"grid-stack\");\n        }\n        // if row property exists, replace minRow and maxRow instead\n        if (opts.row) {\n            opts.minRow = opts.maxRow = opts.row;\n            delete opts.row;\n        }\n        let rowAttr = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-row\"));\n        // flag only valid in sub-grids (handled by parent, not here)\n        if (opts.column === \"auto\") {\n            delete opts.column;\n        }\n        // save original setting so we can restore on save\n        if (opts.alwaysShowResizeHandle !== undefined) {\n            opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n        }\n        // elements DOM attributes override any passed options (like CSS style) - merge the two together\n        let defaults = {\n            ..._utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),\n            column: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-column\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.column,\n            minRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-row\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.minRow,\n            maxRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-row\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.maxRow,\n            staticGrid: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-static\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.staticGrid,\n            draggable: {\n                handle: (opts.handleClass ? \".\" + opts.handleClass : opts.handle ? opts.handle : \"\") || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.draggable.handle\n            },\n            removableOptions: {\n                accept: opts.itemClass || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.accept,\n                decline: _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.decline\n            }\n        };\n        if (el.getAttribute(\"gs-animate\")) {\n            defaults.animate = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-animate\"));\n        }\n        this.opts = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(opts, defaults);\n        opts = null; // make sure we use this.opts instead\n        this._initMargin(); // part of settings defaults...\n        // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n        if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {\n            this._prevColumn = this.getColumn();\n            this.opts.column = 1;\n        }\n        if (this.opts.rtl === \"auto\") {\n            this.opts.rtl = el.style.direction === \"rtl\";\n        }\n        if (this.opts.rtl) {\n            this.el.classList.add(\"grid-stack-rtl\");\n        }\n        // check if we're been nested, and if so update our style and keep pointer around (used during save)\n        const grandParent = (_this_el_parentElement = this.el.parentElement) === null || _this_el_parentElement === void 0 ? void 0 : _this_el_parentElement.parentElement;\n        let parentGridItem = (grandParent === null || grandParent === void 0 ? void 0 : grandParent.classList.contains(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass)) ? grandParent.gridstackNode : undefined;\n        if (parentGridItem) {\n            parentGridItem.subGrid = this;\n            this.parentGridItem = parentGridItem;\n            this.el.classList.add(\"grid-stack-nested\");\n            parentGridItem.el.classList.add(\"grid-stack-sub-grid\");\n        }\n        this._isAutoCellHeight = this.opts.cellHeight === \"auto\";\n        if (this._isAutoCellHeight || this.opts.cellHeight === \"initial\") {\n            // make the cell content square initially (will use resize/column event to keep it square)\n            this.cellHeight(undefined, false);\n        } else {\n            // append unit if any are set\n            if (typeof this.opts.cellHeight == \"number\" && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.cellHeightUnit) {\n                this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;\n                delete this.opts.cellHeightUnit;\n            }\n            this.cellHeight(this.opts.cellHeight, false);\n        }\n        // see if we need to adjust auto-hide\n        if (this.opts.alwaysShowResizeHandle === \"mobile\") {\n            this.opts.alwaysShowResizeHandle = _dd_touch__WEBPACK_IMPORTED_MODULE_4__.isTouch;\n        }\n        this._styleSheetClass = \"gs-id-\" + _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine._idSeq++;\n        this.el.classList.add(this._styleSheetClass);\n        this._setStaticClass();\n        let engineClass = this.opts.engineClass || GridStack.engineClass || _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\n        this.engine = new engineClass({\n            column: this.getColumn(),\n            float: this.opts.float,\n            maxRow: this.opts.maxRow,\n            onChange: (cbNodes)=>{\n                let maxH = 0;\n                this.engine.nodes.forEach((n)=>{\n                    maxH = Math.max(maxH, n.y + n.h);\n                });\n                cbNodes.forEach((n)=>{\n                    let el = n.el;\n                    if (!el) return;\n                    if (n._removeDOM) {\n                        if (el) el.remove();\n                        delete n._removeDOM;\n                    } else {\n                        this._writePosAttr(el, n);\n                    }\n                });\n                this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n            }\n        });\n        if (this.opts.auto) {\n            this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n            this.getGridItems().forEach((el)=>this._prepareElement(el));\n            this.batchUpdate(false);\n        }\n        // load any passed in children as well, which overrides any DOM layout done above\n        if (this.opts.children) {\n            let children = this.opts.children;\n            delete this.opts.children;\n            if (children.length) this.load(children); // don't load empty\n        }\n        this.setAnimation(this.opts.animate);\n        this._updateStyles();\n        this.el.classList.add(\"gs-\" + this.opts.column);\n        // dynamic grids require pausing during drag to detect over to nest vs push\n        if (this.opts.subGridDynamic && !_dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = true;\n        if (((_this_opts_draggable = this.opts.draggable) === null || _this_opts_draggable === void 0 ? void 0 : _this_opts_draggable.pause) !== undefined) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = this.opts.draggable.pause;\n        this._setupRemoveDrop();\n        this._setupAcceptWidget();\n        this._updateResizeEvent();\n    }\n}\n/** parent class for sizing content. defaults to '.grid-stack-item-content' */ GridStack.resizeToContentParent = \".grid-stack-item-content\";\n/** scoping so users can call GridStack.Utils.sort() for example */ GridStack.Utils = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */ GridStack.Engine = _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\nGridStack.GDRev = \"9.4.0\";\n //# sourceMappingURL=gridstack.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDb0Q7QUFDWDtBQUNtQjtBQUM3RDs7Ozs7Q0FLQyxHQUM0QztBQUNSO0FBQ0k7QUFDekMsb0JBQW9CLEdBQ3BCLE1BQU1RLEtBQUssSUFBSUgsc0RBQVdBO0FBQzFCLDZGQUE2RjtBQUNyRTtBQUNBO0FBQ1c7QUFDSjtBQUMvQjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNSTtJQUNGOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE9BQU9DLE9BQStDO1lBQTFDQyxVQUFBQSxpRUFBVSxDQUFDLEdBQUdDLGFBQUFBLGlFQUFhO1FBQ25DLElBQUlDLEtBQUtKLFVBQVVLLGNBQWMsQ0FBQ0Y7UUFDbEMsSUFBSSxDQUFDQyxJQUFJO1lBQ0wsSUFBSSxPQUFPRCxlQUFlLFVBQVU7Z0JBQ2hDRyxRQUFRQyxLQUFLLENBQUMsMERBQTBESixhQUFhLDRDQUNqRjtZQUNSLE9BQ0s7Z0JBQ0RHLFFBQVFDLEtBQUssQ0FBQztZQUNsQjtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0gsR0FBR0ksU0FBUyxFQUFFO1lBQ2ZKLEdBQUdJLFNBQVMsR0FBRyxJQUFJUixVQUFVSSxJQUFJWix5Q0FBS0EsQ0FBQ2lCLFNBQVMsQ0FBQ1A7UUFDckQ7UUFDQSxPQUFPRSxHQUFHSSxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPRSxVQUFnRDtZQUF4Q1IsVUFBQUEsaUVBQVUsQ0FBQyxHQUFHUyxXQUFBQSxpRUFBVztRQUNwQyxJQUFJQyxRQUFRLEVBQUU7UUFDZFosVUFBVWEsZUFBZSxDQUFDRixVQUFVRyxPQUFPLENBQUNWLENBQUFBO1lBQ3hDLElBQUksQ0FBQ0EsR0FBR0ksU0FBUyxFQUFFO2dCQUNmSixHQUFHSSxTQUFTLEdBQUcsSUFBSVIsVUFBVUksSUFBSVoseUNBQUtBLENBQUNpQixTQUFTLENB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Q0FBQ1osS0FBSztRQUNuRCxJQUFJLENBQUM5RyxnQkFBZ0I7UUFDckIsSUFBSSxDQUFDQyxrQkFBa0I7UUFDdkIsSUFBSSxDQUFDbEYsa0JBQWtCO0lBQzNCO0FBcStESjtBQUNBLDRFQUE0RSxHQUM1RTFLLFVBQVVtUixxQkFBcUIsR0FBRztBQUNsQyxpRUFBaUUsR0FDakVuUixVQUFVUixLQUFLLEdBQUdBLHlDQUFLQTtBQUN2QixtRUFBbUUsR0FDbkVRLFVBQVV1YyxNQUFNLEdBQUdoZCw4REFBZUE7QUFDbENTLFVBQVV3YyxLQUFLLEdBQUc7QUFDRyxDQUNyQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2dyaWRzdGFjay5qcz9lY2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogR3JpZFN0YWNrIDkuNC4wXG4gKiBodHRwczovL2dyaWRzdGFja2pzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEtMjAyMiBBbGFpbiBEdW1lc255XG4gKiBzZWUgcm9vdCBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmlkc3RhY2svZ3JpZHN0YWNrLmpzL3RyZWUvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgR3JpZFN0YWNrRW5naW5lIH0gZnJvbSAnLi9ncmlkc3RhY2stZW5naW5lJztcbmltcG9ydCB7IFV0aWxzLCBvYnNvbGV0ZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZ3JpZERlZmF1bHRzLCBkcmFnSW5EZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuLypcbiAqIGFuZCBpbmNsdWRlIEQmRCBieSBkZWZhdWx0XG4gKiBUT0RPOiB3aGlsZSB3ZSBjb3VsZCBnZW5lcmF0ZSBhIGdyaWRzdGFjay1zdGF0aWMuanMgYXQgc21hbGxlciBzaXplIC0gc2F2ZXMgYWJvdXQgMzFrICg0MWsgLT4gNzJrKVxuICogSSBkb24ndCBrbm93IGhvdyB0byBnZW5lcmF0ZSB0aGUgREQgb25seSBjb2RlIGF0IHRoZSByZW1haW5pbmcgMzFrIHRvIGRlbGF5IGxvYWQgYXMgY29kZSBkZXBlbmRzIG9uIEdyaWRzdGFjay50c1xuICogYWxzbyBpdCBjYXVzZWQgbG9hZGluZyBpc3N1ZXMgaW4gcHJvZCAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9pc3N1ZXMvMjAzOVxuICovXG5pbXBvcnQgeyBEREdyaWRTdGFjayB9IGZyb20gJy4vZGQtZ3JpZHN0YWNrJztcbmltcG9ydCB7IGlzVG91Y2ggfSBmcm9tICcuL2RkLXRvdWNoJztcbmltcG9ydCB7IERETWFuYWdlciB9IGZyb20gJy4vZGQtbWFuYWdlcic7XG4vKiogZ2xvYmFsIGluc3RhbmNlICovXG5jb25zdCBkZCA9IG5ldyBEREdyaWRTdGFjaztcbi8vIGV4cG9ydCBhbGwgZGVwZW5kZW50IGZpbGUgYXMgd2VsbCB0byBtYWtlIGl0IGVhc2llciBmb3IgdXNlcnMgdG8ganVzdCBpbXBvcnQgdGhlIG1haW4gZmlsZVxuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vZ3JpZHN0YWNrLWVuZ2luZSc7XG5leHBvcnQgKiBmcm9tICcuL2RkLWdyaWRzdGFjayc7XG4vKipcbiAqIE1haW4gZ3JpZHN0YWNrIGNsYXNzIC0geW91IHdpbGwgbmVlZCB0byBjYWxsIGBHcmlkU3RhY2suaW5pdCgpYCBmaXJzdCB0byBpbml0aWFsaXplIHlvdXIgZ3JpZC5cbiAqIE5vdGU6IHlvdXIgZ3JpZCBlbGVtZW50cyBNVVNUIGhhdmUgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGZvciB0aGUgQ1NTIGxheW91dCB0byB3b3JrOlxuICogQGV4YW1wbGVcbiAqIDxkaXYgY2xhc3M9XCJncmlkLXN0YWNrXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJncmlkLXN0YWNrLWl0ZW1cIj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnRcIj5JdGVtIDE8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqL1xuY2xhc3MgR3JpZFN0YWNrIHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXppbmcgdGhlIEhUTUwgZWxlbWVudCwgb3Igc2VsZWN0b3Igc3RyaW5nLCBpbnRvIGEgZ3JpZCB3aWxsIHJldHVybiB0aGUgZ3JpZC4gQ2FsbGluZyBpdCBhZ2FpbiB3aWxsXG4gICAgICogc2ltcGx5IHJldHVybiB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgKGlnbm9yZSBhbnkgcGFzc2VkIG9wdGlvbnMpLiBUaGVyZSBpcyBhbHNvIGFuIGluaXRBbGwoKSB2ZXJzaW9uIHRoYXQgc3VwcG9ydFxuICAgICAqIG11bHRpcGxlIGdyaWRzIGluaXRpYWxpemF0aW9uIGF0IG9uY2UuIE9yIHlvdSBjYW4gdXNlIGFkZEdyaWQoKSB0byBjcmVhdGUgdGhlIGVudGlyZSBncmlkIGZyb20gSlNPTi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBncmlkIG9wdGlvbnMgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSBlbE9yU3RyaW5nIGVsZW1lbnQgb3IgQ1NTIHNlbGVjdG9yIChmaXJzdCBvbmUgdXNlZCkgdG8gY29udmVydCB0byBhIGdyaWQgKGRlZmF1bHQgdG8gJy5ncmlkLXN0YWNrJyBjbGFzcyBzZWxlY3RvcilcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGdyaWQgPSBHcmlkU3RhY2suaW5pdCgpO1xuICAgICAqXG4gICAgICogTm90ZTogdGhlIEhUTUxFbGVtZW50IChvZiB0eXBlIEdyaWRIVE1MRWxlbWVudCkgd2lsbCBzdG9yZSBhIGBncmlkc3RhY2s6IEdyaWRTdGFja2AgdmFsdWUgdGhhdCBjYW4gYmUgcmV0cmlldmUgbGF0ZXJcbiAgICAgKiBsZXQgZ3JpZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ncmlkLXN0YWNrJykuZ3JpZHN0YWNrO1xuICAgICAqL1xuICAgIHN0YXRpYyBpbml0KG9wdGlvbnMgPSB7fSwgZWxPclN0cmluZyA9ICcuZ3JpZC1zdGFjaycpIHtcbiAgICAgICAgbGV0IGVsID0gR3JpZFN0YWNrLmdldEdyaWRFbGVtZW50KGVsT3JTdHJpbmcpO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignR3JpZFN0YWNrLmluaXRBbGwoKSBubyBncmlkIHdhcyBmb3VuZCB3aXRoIHNlbGVjdG9yIFwiJyArIGVsT3JTdHJpbmcgKyAnXCIgLSBlbGVtZW50IG1pc3Npbmcgb3Igd3Jvbmcgc2VsZWN0b3IgPycgK1xuICAgICAgICAgICAgICAgICAgICAnXFxuTm90ZTogXCIuZ3JpZC1zdGFja1wiIGlzIHJlcXVpcmVkIGZvciBwcm9wZXIgQ1NTIHN0eWxpbmcgYW5kIGRyYWcvZHJvcCwgYW5kIGlzIHRoZSBkZWZhdWx0IHNlbGVjdG9yLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignR3JpZFN0YWNrLmluaXQoKSBubyBncmlkIGVsZW1lbnQgd2FzIHBhc3NlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWwuZ3JpZHN0YWNrKSB7XG4gICAgICAgICAgICBlbC5ncmlkc3RhY2sgPSBuZXcgR3JpZFN0YWNrKGVsLCBVdGlscy5jbG9uZURlZXAob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5ncmlkc3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgaW5pdGlhbGl6ZSBhIGxpc3Qgb2YgZWxlbWVudHMgKGdpdmVuIGEgc2VsZWN0b3IpIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgZ3JpZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZ3JpZCBvcHRpb25zIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgZWxlbWVudHMgc2VsZWN0b3IgdG8gY29udmVydCB0byBncmlkcyAoZGVmYXVsdCB0byAnLmdyaWQtc3RhY2snIGNsYXNzIHNlbGVjdG9yKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgZ3JpZHMgPSBHcmlkU3RhY2suaW5pdEFsbCgpO1xuICAgICAqIGdyaWRzLmZvckVhY2goLi4uKVxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0QWxsKG9wdGlvbnMgPSB7fSwgc2VsZWN0b3IgPSAnLmdyaWQtc3RhY2snKSB7XG4gICAgICAgIGxldCBncmlkcyA9IFtdO1xuICAgICAgICBHcmlkU3RhY2suZ2V0R3JpZEVsZW1lbnRzKHNlbGVjdG9yKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmICghZWwuZ3JpZHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgZWwuZ3JpZHN0YWNrID0gbmV3IEdyaWRTdGFjayhlbCwgVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWRzLnB1c2goZWwuZ3JpZHN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChncmlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dyaWRTdGFjay5pbml0QWxsKCkgbm8gZ3JpZCB3YXMgZm91bmQgd2l0aCBzZWxlY3RvciBcIicgKyBzZWxlY3RvciArICdcIiAtIGVsZW1lbnQgbWlzc2luZyBvciB3cm9uZyBzZWxlY3RvciA/JyArXG4gICAgICAgICAgICAgICAgJ1xcbk5vdGU6IFwiLmdyaWQtc3RhY2tcIiBpcyByZXF1aXJlZCBmb3IgcHJvcGVyIENTUyBzdHlsaW5nIGFuZCBkcmFnL2Ryb3AsIGFuZCBpcyB0aGUgZGVmYXVsdCBzZWxlY3Rvci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JpZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGwgdG8gY3JlYXRlIGEgZ3JpZCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLCBpbmNsdWRpbmcgbG9hZGluZyBhbnkgY2hpbGRyZW4gZnJvbSBKU09OIHN0cnVjdHVyZS4gVGhpcyB3aWxsIGNhbGwgR3JpZFN0YWNrLmluaXQoKSwgdGhlblxuICAgICAqIGdyaWQubG9hZCgpIG9uIGFueSBwYXNzZWQgY2hpbGRyZW4gKHJlY3Vyc2l2ZWx5KS4gR3JlYXQgYWx0ZXJuYXRpdmUgdG8gY2FsbGluZyBpbml0KCkgaWYgeW91IHdhbnQgZW50aXJlIGdyaWQgdG8gY29tZSBmcm9tXG4gICAgICogSlNPTiBzZXJpYWxpemVkIGRhdGEsIGluY2x1ZGluZyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgSFRNTCBlbGVtZW50IHBhcmVudCB0byB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSBvcHQgZ3JpZHMgb3B0aW9ucyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGdyaWQsIGFuZCBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyaWQocGFyZW50LCBvcHQgPSB7fSkge1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZWwgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChlbC5ncmlkc3RhY2spIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBncmlkIC0gc2V0IG9wdGlvbiBhbmQgbG9hZCBkYXRhXG4gICAgICAgICAgICBjb25zdCBncmlkID0gZWwuZ3JpZHN0YWNrO1xuICAgICAgICAgICAgaWYgKG9wdClcbiAgICAgICAgICAgICAgICBncmlkLm9wdHMgPSB7IC4uLmdyaWQub3B0cywgLi4ub3B0IH07XG4gICAgICAgICAgICBpZiAob3B0LmNoaWxkcmVuICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZ3JpZC5sb2FkKG9wdC5jaGlsZHJlbik7XG4gICAgICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWQgZWxlbWVudCwgYnV0IGNoZWNrIGlmIHRoZSBwYXNzZWQgJ3BhcmVudCcgYWxyZWFkeSBoYXMgZ3JpZCBzdHlsaW5nIGFuZCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgICAgIGNvbnN0IHBhcmVudElzR3JpZCA9IHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2dyaWQtc3RhY2snKTtcbiAgICAgICAgaWYgKCFwYXJlbnRJc0dyaWQgfHwgR3JpZFN0YWNrLmFkZFJlbW92ZUNCKSB7XG4gICAgICAgICAgICBpZiAoR3JpZFN0YWNrLmFkZFJlbW92ZUNCKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBHcmlkU3RhY2suYWRkUmVtb3ZlQ0IocGFyZW50LCBvcHQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7IC8vIElFIG5lZWRzIGEgcGFyYW1cbiAgICAgICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImdyaWQtc3RhY2sgJHtvcHQuY2xhc3MgfHwgJyd9XCI+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5ib2R5LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgY2xhc3MgYW5kIGxvYWQgYW55IGNoaWxkcmVuXG4gICAgICAgIGxldCBncmlkID0gR3JpZFN0YWNrLmluaXQob3B0LCBlbCk7XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgIH1cbiAgICAvKiogY2FsbCB0aGlzIG1ldGhvZCB0byByZWdpc3RlciB5b3VyIGVuZ2luZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBTZWUgaW5zdGVhZCBgR3JpZFN0YWNrT3B0aW9ucy5lbmdpbmVDbGFzc2AgaWYgeW91IG9ubHkgbmVlZCB0b1xuICAgICAqIHJlcGxhY2UganVzdCBvbmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyRW5naW5lKGVuZ2luZUNsYXNzKSB7XG4gICAgICAgIEdyaWRTdGFjay5lbmdpbmVDbGFzcyA9IGVuZ2luZUNsYXNzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNyZWF0ZSBwbGFjZWhvbGRlciBESVYgYXMgbmVlZGVkICovXG4gICAgZ2V0IHBsYWNlaG9sZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBjaGlsZCBzbyBwYWRkaW5nIG1hdGNoIGl0ZW0tY29udGVudFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJDaGlsZC5jbGFzc05hbWUgPSAncGxhY2Vob2xkZXItY29udGVudCc7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnBsYWNlaG9sZGVyVGV4dCkge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyQ2hpbGQuaW5uZXJIVE1MID0gdGhpcy5vcHRzLnBsYWNlaG9sZGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5jbGFzc0xpc3QuYWRkKHRoaXMub3B0cy5wbGFjZWhvbGRlckNsYXNzLCBncmlkRGVmYXVsdHMuaXRlbUNsYXNzLCB0aGlzLm9wdHMuaXRlbUNsYXNzKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXJDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBncmlkIGl0ZW0gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBlbFxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdHMgPSB7fSkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2dzRXZlbnRIYW5kbGVyID0ge307XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgZXh0cmEgcm93IGFkZGVkIHdoZW4gZHJhZ2dpbmcgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZ3JpZCAqL1xuICAgICAgICB0aGlzLl9leHRyYURyYWdSb3cgPSAwO1xuICAgICAgICB0aGlzLmVsID0gZWw7IC8vIGV4cG9zZWQgSFRNTCBlbGVtZW50IHRvIHRoZSB1c2VyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBoYW5kbGVzIG51bGwvdW5kZWZpbmVkLzBcbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2dyaWQtc3RhY2snKSkge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdncmlkLXN0YWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcm93IHByb3BlcnR5IGV4aXN0cywgcmVwbGFjZSBtaW5Sb3cgYW5kIG1heFJvdyBpbnN0ZWFkXG4gICAgICAgIGlmIChvcHRzLnJvdykge1xuICAgICAgICAgICAgb3B0cy5taW5Sb3cgPSBvcHRzLm1heFJvdyA9IG9wdHMucm93O1xuICAgICAgICAgICAgZGVsZXRlIG9wdHMucm93O1xuICAgICAgICB9XG4gICAgICAgIGxldCByb3dBdHRyID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1yb3cnKSk7XG4gICAgICAgIC8vIGZsYWcgb25seSB2YWxpZCBpbiBzdWItZ3JpZHMgKGhhbmRsZWQgYnkgcGFyZW50LCBub3QgaGVyZSlcbiAgICAgICAgaWYgKG9wdHMuY29sdW1uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIHNldHRpbmcgc28gd2UgY2FuIHJlc3RvcmUgb24gc2F2ZVxuICAgICAgICBpZiAob3B0cy5hbHdheXNTaG93UmVzaXplSGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdHMuX2Fsd2F5c1Nob3dSZXNpemVIYW5kbGUgPSBvcHRzLmFsd2F5c1Nob3dSZXNpemVIYW5kbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudHMgRE9NIGF0dHJpYnV0ZXMgb3ZlcnJpZGUgYW55IHBhc3NlZCBvcHRpb25zIChsaWtlIENTUyBzdHlsZSkgLSBtZXJnZSB0aGUgdHdvIHRvZ2V0aGVyXG4gICAgICAgIGxldCBkZWZhdWx0cyA9IHsgLi4uVXRpbHMuY2xvbmVEZWVwKGdyaWREZWZhdWx0cyksXG4gICAgICAgICAgICBjb2x1bW46IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MtY29sdW1uJykpIHx8IGdyaWREZWZhdWx0cy5jb2x1bW4sXG4gICAgICAgICAgICBtaW5Sb3c6IHJvd0F0dHIgPyByb3dBdHRyIDogVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1taW4tcm93JykpIHx8IGdyaWREZWZhdWx0cy5taW5Sb3csXG4gICAgICAgICAgICBtYXhSb3c6IHJvd0F0dHIgPyByb3dBdHRyIDogVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1tYXgtcm93JykpIHx8IGdyaWREZWZhdWx0cy5tYXhSb3csXG4gICAgICAgICAgICBzdGF0aWNHcmlkOiBVdGlscy50b0Jvb2woZWwuZ2V0QXR0cmlidXRlKCdncy1zdGF0aWMnKSkgfHwgZ3JpZERlZmF1bHRzLnN0YXRpY0dyaWQsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHtcbiAgICAgICAgICAgICAgICBoYW5kbGU6IChvcHRzLmhhbmRsZUNsYXNzID8gJy4nICsgb3B0cy5oYW5kbGVDbGFzcyA6IChvcHRzLmhhbmRsZSA/IG9wdHMuaGFuZGxlIDogJycpKSB8fCBncmlkRGVmYXVsdHMuZHJhZ2dhYmxlLmhhbmRsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmFibGVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgYWNjZXB0OiBvcHRzLml0ZW1DbGFzcyB8fCBncmlkRGVmYXVsdHMucmVtb3ZhYmxlT3B0aW9ucy5hY2NlcHQsXG4gICAgICAgICAgICAgICAgZGVjbGluZTogZ3JpZERlZmF1bHRzLnJlbW92YWJsZU9wdGlvbnMuZGVjbGluZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZ3MtYW5pbWF0ZScpKSB7IC8vIGRlZmF1bHQgdG8gdHJ1ZSwgYnV0IGlmIHNldCB0byBmYWxzZSB1c2UgdGhhdCBpbnN0ZWFkXG4gICAgICAgICAgICBkZWZhdWx0cy5hbmltYXRlID0gVXRpbHMudG9Cb29sKGVsLmdldEF0dHJpYnV0ZSgnZ3MtYW5pbWF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdHMgPSBVdGlscy5kZWZhdWx0cyhvcHRzLCBkZWZhdWx0cyk7XG4gICAgICAgIG9wdHMgPSBudWxsOyAvLyBtYWtlIHN1cmUgd2UgdXNlIHRoaXMub3B0cyBpbnN0ZWFkXG4gICAgICAgIHRoaXMuX2luaXRNYXJnaW4oKTsgLy8gcGFydCBvZiBzZXR0aW5ncyBkZWZhdWx0cy4uLlxuICAgICAgICAvLyBOb3cgY2hlY2sgaWYgd2UncmUgbG9hZGluZyBpbnRvIDEgY29sdW1uIG1vZGUgRklSU1Qgc28gd2UgZG9uJ3QgZG8gdW4tbmVjZXNzYXJ5IHdvcmsgKGxpa2UgY2VsbEhlaWdodCA9IHdpZHRoIC8gMTIgdGhlbiBnbyAxIGNvbHVtbilcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2x1bW4gIT09IDEgJiYgIXRoaXMub3B0cy5kaXNhYmxlT25lQ29sdW1uTW9kZSAmJiB0aGlzLl93aWR0aE9yQ29udGFpbmVyKCkgPD0gdGhpcy5vcHRzLm9uZUNvbHVtblNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZDb2x1bW4gPSB0aGlzLmdldENvbHVtbigpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLmNvbHVtbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5ydGwgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5vcHRzLnJ0bCA9IChlbC5zdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnJ0bCkge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdncmlkLXN0YWNrLXJ0bCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlJ3JlIGJlZW4gbmVzdGVkLCBhbmQgaWYgc28gdXBkYXRlIG91ciBzdHlsZSBhbmQga2VlcCBwb2ludGVyIGFyb3VuZCAodXNlZCBkdXJpbmcgc2F2ZSlcbiAgICAgICAgY29uc3QgZ3JhbmRQYXJlbnQgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQ/LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBwYXJlbnRHcmlkSXRlbSA9IGdyYW5kUGFyZW50Py5jbGFzc0xpc3QuY29udGFpbnMoZ3JpZERlZmF1bHRzLml0ZW1DbGFzcykgPyBncmFuZFBhcmVudC5ncmlkc3RhY2tOb2RlIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAocGFyZW50R3JpZEl0ZW0pIHtcbiAgICAgICAgICAgIHBhcmVudEdyaWRJdGVtLnN1YkdyaWQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRHcmlkSXRlbSA9IHBhcmVudEdyaWRJdGVtO1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdncmlkLXN0YWNrLW5lc3RlZCcpO1xuICAgICAgICAgICAgcGFyZW50R3JpZEl0ZW0uZWwuY2xhc3NMaXN0LmFkZCgnZ3JpZC1zdGFjay1zdWItZ3JpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzQXV0b0NlbGxIZWlnaHQgPSAodGhpcy5vcHRzLmNlbGxIZWlnaHQgPT09ICdhdXRvJyk7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0IHx8IHRoaXMub3B0cy5jZWxsSGVpZ2h0ID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIGNlbGwgY29udGVudCBzcXVhcmUgaW5pdGlhbGx5ICh3aWxsIHVzZSByZXNpemUvY29sdW1uIGV2ZW50IHRvIGtlZXAgaXQgc3F1YXJlKVxuICAgICAgICAgICAgdGhpcy5jZWxsSGVpZ2h0KHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXBwZW5kIHVuaXQgaWYgYW55IGFyZSBzZXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmNlbGxIZWlnaHQgPT0gJ251bWJlcicgJiYgdGhpcy5vcHRzLmNlbGxIZWlnaHRVbml0ICYmIHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdCAhPT0gZ3JpZERlZmF1bHRzLmNlbGxIZWlnaHRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmNlbGxIZWlnaHQgPSB0aGlzLm9wdHMuY2VsbEhlaWdodCArIHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRzLmNlbGxIZWlnaHRVbml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZWxsSGVpZ2h0KHRoaXMub3B0cy5jZWxsSGVpZ2h0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIGlmIHdlIG5lZWQgdG8gYWRqdXN0IGF1dG8taGlkZVxuICAgICAgICBpZiAodGhpcy5vcHRzLmFsd2F5c1Nob3dSZXNpemVIYW5kbGUgPT09ICdtb2JpbGUnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMuYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSA9IGlzVG91Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3R5bGVTaGVldENsYXNzID0gJ2dzLWlkLScgKyBHcmlkU3RhY2tFbmdpbmUuX2lkU2VxKys7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLl9zdHlsZVNoZWV0Q2xhc3MpO1xuICAgICAgICB0aGlzLl9zZXRTdGF0aWNDbGFzcygpO1xuICAgICAgICBsZXQgZW5naW5lQ2xhc3MgPSB0aGlzLm9wdHMuZW5naW5lQ2xhc3MgfHwgR3JpZFN0YWNrLmVuZ2luZUNsYXNzIHx8IEdyaWRTdGFja0VuZ2luZTtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgZW5naW5lQ2xhc3Moe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmdldENvbHVtbigpLFxuICAgICAgICAgICAgZmxvYXQ6IHRoaXMub3B0cy5mbG9hdCxcbiAgICAgICAgICAgIG1heFJvdzogdGhpcy5vcHRzLm1heFJvdyxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoY2JOb2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtYXhIID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4geyBtYXhIID0gTWF0aC5tYXgobWF4SCwgbi55ICsgbi5oKTsgfSk7XG4gICAgICAgICAgICAgICAgY2JOb2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBuLmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAobi5fcmVtb3ZlRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbi5fcmVtb3ZlRE9NO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVQb3NBdHRyKGVsLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlcyhmYWxzZSwgbWF4SCk7IC8vIGZhbHNlID0gZG9uJ3QgcmVjcmVhdGUsIGp1c3QgYXBwZW5kIGlmIG5lZWQgYmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXV0bykge1xuICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpOyAvLyBwcmV2ZW50IGluIGJldHdlZW4gcmUtbGF5b3V0ICMxNTM1IFRPRE86IHRoaXMgb25seSBzZXQgZmxvYXQ9dHJ1ZSwgbmVlZCB0byBwcmV2ZW50IGNvbGxpc2lvbiBjaGVjay4uLlxuICAgICAgICAgICAgdGhpcy5nZXRHcmlkSXRlbXMoKS5mb3JFYWNoKGVsID0+IHRoaXMuX3ByZXBhcmVFbGVtZW50KGVsKSk7XG4gICAgICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2FkIGFueSBwYXNzZWQgaW4gY2hpbGRyZW4gYXMgd2VsbCwgd2hpY2ggb3ZlcnJpZGVzIGFueSBET00gbGF5b3V0IGRvbmUgYWJvdmVcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5vcHRzLmNoaWxkcmVuO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0cy5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkKGNoaWxkcmVuKTsgLy8gZG9uJ3QgbG9hZCBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uKHRoaXMub3B0cy5hbmltYXRlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGVzKCk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZ3MtJyArIHRoaXMub3B0cy5jb2x1bW4pO1xuICAgICAgICAvLyBkeW5hbWljIGdyaWRzIHJlcXVpcmUgcGF1c2luZyBkdXJpbmcgZHJhZyB0byBkZXRlY3Qgb3ZlciB0byBuZXN0IHZzIHB1c2hcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdWJHcmlkRHluYW1pYyAmJiAhRERNYW5hZ2VyLnBhdXNlRHJhZylcbiAgICAgICAgICAgIERETWFuYWdlci5wYXVzZURyYWcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRyYWdnYWJsZT8ucGF1c2UgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIERETWFuYWdlci5wYXVzZURyYWcgPSB0aGlzLm9wdHMuZHJhZ2dhYmxlLnBhdXNlO1xuICAgICAgICB0aGlzLl9zZXR1cFJlbW92ZURyb3AoKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBY2NlcHRXaWRnZXQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVzaXplRXZlbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IHdpZGdldCBhbmQgcmV0dXJucyBpdC5cbiAgICAgKlxuICAgICAqIFdpZGdldCB3aWxsIGJlIGFsd2F5cyBwbGFjZWQgZXZlbiBpZiByZXN1bHQgaGVpZ2h0IGlzIG1vcmUgdGhhbiBhY3R1YWwgZ3JpZCBoZWlnaHQuXG4gICAgICogWW91IG5lZWQgdG8gdXNlIGB3aWxsSXRGaXQoKWAgYmVmb3JlIGNhbGxpbmcgYWRkV2lkZ2V0IGZvciBhZGRpdGlvbmFsIGNoZWNrLlxuICAgICAqIFNlZSBhbHNvIGBtYWtlV2lkZ2V0KClgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgZ3JpZCA9IEdyaWRTdGFjay5pbml0KCk7XG4gICAgICogZ3JpZC5hZGRXaWRnZXQoe3c6IDMsIGNvbnRlbnQ6ICdoZWxsbyd9KTtcbiAgICAgKiBncmlkLmFkZFdpZGdldCgnPGRpdiBjbGFzcz1cImdyaWQtc3RhY2staXRlbVwiPjxkaXYgY2xhc3M9XCJncmlkLXN0YWNrLWl0ZW0tY29udGVudFwiPmhlbGxvPC9kaXY+PC9kaXY+Jywge3c6IDN9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbCAgR3JpZFN0YWNrV2lkZ2V0ICh3aGljaCBjYW4gaGF2ZSBjb250ZW50IHN0cmluZyBhcyB3ZWxsKSwgaHRtbCBlbGVtZW50LCBvciBzdHJpbmcgZGVmaW5pdGlvbiB0byBhZGRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB3aWRnZXQgcG9zaXRpb24vc2l6ZSBvcHRpb25zIChvcHRpb25hbCwgYW5kIGlnbm9yZSBpZiBmaXJzdCBwYXJhbSBpcyBhbHJlYWR5IG9wdGlvbikgLSBzZWUgR3JpZFN0YWNrV2lkZ2V0XG4gICAgICovXG4gICAgYWRkV2lkZ2V0KGVscywgb3B0aW9ucykge1xuICAgICAgICBmdW5jdGlvbiBpc0dyaWRTdGFja1dpZGdldCh3KSB7XG4gICAgICAgICAgICByZXR1cm4gdy5lbCAhPT0gdW5kZWZpbmVkIHx8IHcueCAhPT0gdW5kZWZpbmVkIHx8IHcueSAhPT0gdW5kZWZpbmVkIHx8IHcudyAhPT0gdW5kZWZpbmVkIHx8IHcuaCAhPT0gdW5kZWZpbmVkIHx8IHcuY29udGVudCAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgZWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGV0IGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7IC8vIElFIG5lZWRzIGEgcGFyYW1cbiAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9IGVscztcbiAgICAgICAgICAgIGVsID0gZG9jLmJvZHkuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzR3JpZFN0YWNrV2lkZ2V0KGVscykpIHtcbiAgICAgICAgICAgIG5vZGUgPSBvcHRpb25zID0gZWxzO1xuICAgICAgICAgICAgaWYgKG5vZGU/LmVsKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBub2RlLmVsOyAvLyByZS11c2UgZWxlbWVudCBzdG9yZWQgaW4gdGhlIG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEdyaWRTdGFjay5hZGRSZW1vdmVDQikge1xuICAgICAgICAgICAgICAgIGVsID0gR3JpZFN0YWNrLmFkZFJlbW92ZUNCKHRoaXMuZWwsIG9wdGlvbnMsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gb3B0aW9ucz8uY29udGVudCB8fCAnJztcbiAgICAgICAgICAgICAgICBsZXQgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTsgLy8gSUUgbmVlZHMgYSBwYXJhbVxuICAgICAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtICR7dGhpcy5vcHRzLml0ZW1DbGFzcyB8fCAnJ31cIj48ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnRcIj4ke2NvbnRlbnR9PC9kaXY+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5ib2R5LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwgPSBlbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gaWYgdGhlIGNhbGxlciBlbmRlZCB1cCBpbml0aWFsaXppbmcgdGhlIHdpZGdldCBpbiBhZGRSZW1vdmVDQiwgb3Igd2Ugc3RhcmVkIHdpdGggb25lIGFscmVhZHksIHNraXAgdGhlIHJlc3RcbiAgICAgICAgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgIGlmIChub2RlICYmIGVsLnBhcmVudEVsZW1lbnQgPT09IHRoaXMuZWwgJiYgdGhpcy5lbmdpbmUubm9kZXMuZmluZChuID0+IG4uX2lkID09PSBub2RlLl9pZCkpXG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIC8vIFRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIHBhc3NlZCBpbiBvcHQgd2l0aCBkZWZhdWx0IGFuZCB2YWxpZCB2YWx1ZXMsIGJ1dCB0aGlzIGJyZWFrIGtub2Nrb3V0IGRlbW9zXG4gICAgICAgIC8vIGFzIHRoZSBhY3R1YWwgdmFsdWUgYXJlIGZpbGxlZCBpbiB3aGVuIF9wcmVwYXJlRWxlbWVudCgpIGNhbGxzIGVsLmdldEF0dHJpYnV0ZSgnZ3MteHl6JykgYmVmb3JlIGFkZGluZyB0aGUgbm9kZS5cbiAgICAgICAgLy8gU28gbWFrZSBzdXJlIHdlIGxvYWQgYW55IERPTSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgaW4gcGFzc2VkIGluIG9wdGlvbnMgKHdoaWNoIG92ZXJyaWRlKVxuICAgICAgICBsZXQgZG9tQXR0ciA9IHRoaXMuX3JlYWRBdHRyKGVsKTtcbiAgICAgICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTsgLy8gbWFrZSBhIGNvcHkgYmVmb3JlIHdlIG1vZGlmeSBpbiBjYXNlIGNhbGxlciByZS11c2VzIGl0XG4gICAgICAgIFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIGRvbUF0dHIpO1xuICAgICAgICBub2RlID0gdGhpcy5lbmdpbmUucHJlcGFyZU5vZGUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3dyaXRlQXR0cihlbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLl9pbnNlcnROb3RBcHBlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZWwucHJlcGVuZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ha2VXaWRnZXQoZWwsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gZXhpc3RpbmcgZ3JpZEl0ZW0gZWxlbWVudCBpbnRvIGEgc3ViLWdyaWQgd2l0aCB0aGUgZ2l2ZW4gKG9wdGlvbmFsKSBvcHRpb25zLCBlbHNlIGluaGVyaXQgdGhlbVxuICAgICAqIGZyb20gdGhlIHBhcmVudCdzIHN1YkdyaWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gZWwgZ3JpZEl0ZW0gZWxlbWVudCB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIG9wcyAob3B0aW9uYWwpIHN1Yi1ncmlkIG9wdGlvbnMsIGVsc2UgZGVmYXVsdCB0byBub2RlLCB0aGVuIHBhcmVudCBzZXR0aW5ncywgZWxzZSBkZWZhdWx0c1xuICAgICAqIEBwYXJhbSBub2RlVG9BZGQgKG9wdGlvbmFsKSBub2RlIHRvIGFkZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBzdWIgZ3JpZCAodXNlZCB3aGVuIGRyYWdnaW5nIG92ZXIgZXhpc3RpbmcgcmVndWxhciBpdGVtKVxuICAgICAqIEByZXR1cm5zIG5ld2x5IGNyZWF0ZWQgZ3JpZFxuICAgICAqL1xuICAgIG1ha2VTdWJHcmlkKGVsLCBvcHMsIG5vZGVUb0FkZCwgc2F2ZUNvbnRlbnQgPSB0cnVlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5tYWtlV2lkZ2V0KGVsKS5ncmlkc3RhY2tOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnN1YkdyaWQ/LmVsKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3ViR3JpZDsgLy8gYWxyZWFkeSBkb25lXG4gICAgICAgIC8vIGZpbmQgdGhlIHRlbXBsYXRlIHN1YkdyaWQgc3RvcmVkIG9uIGEgcGFyZW50IGFzIGZhbGxiYWNrLi4uXG4gICAgICAgIGxldCBzdWJHcmlkVGVtcGxhdGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgZ3JpZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChncmlkICYmICFzdWJHcmlkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHN1YkdyaWRUZW1wbGF0ZSA9IGdyaWQub3B0cz8uc3ViR3JpZE9wdHM7XG4gICAgICAgICAgICBncmlkID0gZ3JpZC5wYXJlbnRHcmlkSXRlbT8uZ3JpZDtcbiAgICAgICAgfVxuICAgICAgICAvLy4uLiBhbmQgc2V0IHRoZSBjcmVhdGUgb3B0aW9uc1xuICAgICAgICBvcHMgPSBVdGlscy5jbG9uZURlZXAoeyAuLi4oc3ViR3JpZFRlbXBsYXRlIHx8IHt9KSwgY2hpbGRyZW46IHVuZGVmaW5lZCwgLi4uKG9wcyB8fCBub2RlLnN1YkdyaWRPcHRzKSB9KTtcbiAgICAgICAgbm9kZS5zdWJHcmlkT3B0cyA9IG9wcztcbiAgICAgICAgLy8gaWYgY29sdW1uIHNwZWNpYWwgY2FzZSBpdCBzZXQsIHJlbWVtYmVyIHRoYXQgZmxhZyBhbmQgc2V0IGRlZmF1bHRcbiAgICAgICAgbGV0IGF1dG9Db2x1bW47XG4gICAgICAgIGlmIChvcHMuY29sdW1uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGF1dG9Db2x1bW4gPSB0cnVlO1xuICAgICAgICAgICAgb3BzLmNvbHVtbiA9IE1hdGgubWF4KG5vZGUudyB8fCAxLCBub2RlVG9BZGQ/LncgfHwgMSk7XG4gICAgICAgICAgICBvcHMuZGlzYWJsZU9uZUNvbHVtbk1vZGUgPSB0cnVlOyAvLyBkcml2ZW4gYnkgcGFyZW50XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgY29udmVydGluZyBhbiBleGlzdGluZyBmdWxsIGl0ZW0sIG1vdmUgb3ZlciB0aGUgY29udGVudCB0byBiZSB0aGUgZmlyc3Qgc3ViIGl0ZW0gaW4gdGhlIG5ldyBncmlkXG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5lbC5xdWVyeVNlbGVjdG9yKCcuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnKTtcbiAgICAgICAgbGV0IG5ld0l0ZW07XG4gICAgICAgIGxldCBuZXdJdGVtT3B0O1xuICAgICAgICBpZiAoc2F2ZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUREKG5vZGUuZWwpOyAvLyByZW1vdmUgRCZEIHNpbmNlIGl0J3Mgc2V0IG9uIGNvbnRlbnQgZGl2XG4gICAgICAgICAgICBuZXdJdGVtT3B0ID0geyAuLi5ub2RlLCB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICBVdGlscy5yZW1vdmVJbnRlcm5hbEZvclNhdmUobmV3SXRlbU9wdCk7XG4gICAgICAgICAgICBkZWxldGUgbmV3SXRlbU9wdC5zdWJHcmlkT3B0cztcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBuZXdJdGVtT3B0LmNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChHcmlkU3RhY2suYWRkUmVtb3ZlQ0IpIHtcbiAgICAgICAgICAgICAgICBuZXdJdGVtID0gR3JpZFN0YWNrLmFkZFJlbW92ZUNCKHRoaXMuZWwsIG5ld0l0ZW1PcHQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpOyAvLyBJRSBuZWVkcyBhIHBhcmFtXG4gICAgICAgICAgICAgICAgZG9jLmJvZHkuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJncmlkLXN0YWNrLWl0ZW1cIj48L2Rpdj5gO1xuICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBkb2MuYm9keS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBuZXdJdGVtLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnRcIj48L2Rpdj5gO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBkb2MuYm9keS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBub2RlLmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG5vZGUpOyAvLyAuLi4gYW5kIHJlc3RvcmUgb3JpZ2luYWwgRCZEXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgYWRkaW5nIGFuIGFkZGl0aW9uYWwgaXRlbSwgbWFrZSB0aGUgY29udGFpbmVyIGxhcmdlIGVub3VnaCB0byBoYXZlIHRoZW0gYm90aFxuICAgICAgICBpZiAobm9kZVRvQWRkKSB7XG4gICAgICAgICAgICBsZXQgdyA9IGF1dG9Db2x1bW4gPyBvcHMuY29sdW1uIDogbm9kZS53O1xuICAgICAgICAgICAgbGV0IGggPSBub2RlLmggKyBub2RlVG9BZGQuaDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IG5vZGUuZWwuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnOyAvLyBzaG93IHVwIGluc3RhbnRseSBzbyB3ZSBkb24ndCBzZWUgc2Nyb2xsYmFyIHdpdGggbm9kZVRvQWRkXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShub2RlLmVsLCB7IHcsIGggfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHN0eWxlLnRyYW5zaXRpb24gPSBudWxsKTsgLy8gcmVjb3ZlciBhbmltYXRpb25cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViR3JpZCA9IG5vZGUuc3ViR3JpZCA9IEdyaWRTdGFjay5hZGRHcmlkKGNvbnRlbnQsIG9wcyk7XG4gICAgICAgIGlmIChub2RlVG9BZGQ/Ll9tb3ZpbmcpXG4gICAgICAgICAgICBzdWJHcmlkLl9pc1RlbXAgPSB0cnVlOyAvLyBwcmV2ZW50IHJlLW5lc3RpbmcgYXMgd2UgYWRkIG92ZXJcbiAgICAgICAgaWYgKGF1dG9Db2x1bW4pXG4gICAgICAgICAgICBzdWJHcmlkLl9hdXRvQ29sdW1uID0gdHJ1ZTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbCBjb250ZW50IGJhY2sgYXMgYSBjaGlsZCBvZiBodGUgbmV3bHkgY3JlYXRlZCBncmlkXG4gICAgICAgIGlmIChzYXZlQ29udGVudCkge1xuICAgICAgICAgICAgc3ViR3JpZC5hZGRXaWRnZXQobmV3SXRlbSwgbmV3SXRlbU9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGFkZCBhbnkgYWRkaXRpb25hbCBub2RlXG4gICAgICAgIGlmIChub2RlVG9BZGQpIHtcbiAgICAgICAgICAgIGlmIChub2RlVG9BZGQuX21vdmluZykge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnRpZmljaWFsIGV2ZW50IGV2ZW4gZm9yIHRoZSBqdXN0IGNyZWF0ZWQgZ3JpZCB0byByZWNlaXZlIHRoaXMgaXRlbVxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IFV0aWxzLnNpbXVsYXRlTW91c2VFdmVudChub2RlVG9BZGQuX2V2ZW50LCAnbW91c2VlbnRlcicsIHN1YkdyaWQuZWwpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YkdyaWQuYWRkV2lkZ2V0KG5vZGUuZWwsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJHcmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiBhbiBpdGVtIHdhcyBjb252ZXJ0ZWQgaW50byBhIG5lc3RlZCBncmlkIHRvIGFjY29tbW9kYXRlIGEgZHJhZ2dlZCBvdmVyIGl0ZW0sIGJ1dCB0aGVuIGl0ZW0gbGVhdmVzIC0gcmV0dXJuIGJhY2tcbiAgICAgKiB0byB0aGUgb3JpZ2luYWwgZ3JpZC1pdGVtLiBBbHNvIGNhbGxlZCB0byByZW1vdmUgZW1wdHkgc3ViLWdyaWRzIHdoZW4gbGFzdCBpdGVtIGlzIGRyYWdnZWQgb3V0IChzaW5jZSByZS1jcmVhdGluZyBpcyBzaW1wbGUpXG4gICAgICovXG4gICAgcmVtb3ZlQXNTdWJHcmlkKG5vZGVUaGF0UmVtb3ZlZCkge1xuICAgICAgICBsZXQgcEdyaWQgPSB0aGlzLnBhcmVudEdyaWRJdGVtPy5ncmlkO1xuICAgICAgICBpZiAoIXBHcmlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwR3JpZC5iYXRjaFVwZGF0ZSgpO1xuICAgICAgICBwR3JpZC5yZW1vdmVXaWRnZXQodGhpcy5wYXJlbnRHcmlkSXRlbS5lbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5naW5lLm5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAvLyBtaWdyYXRlIGFueSBjaGlsZHJlbiBvdmVyIGFuZCBvZmZzZXR0aW5nIGJ5IG91ciBsb2NhdGlvblxuICAgICAgICAgICAgbi54ICs9IHRoaXMucGFyZW50R3JpZEl0ZW0ueDtcbiAgICAgICAgICAgIG4ueSArPSB0aGlzLnBhcmVudEdyaWRJdGVtLnk7XG4gICAgICAgICAgICBwR3JpZC5hZGRXaWRnZXQobi5lbCwgbik7XG4gICAgICAgIH0pO1xuICAgICAgICBwR3JpZC5iYXRjaFVwZGF0ZShmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudEdyaWRJdGVtKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50R3JpZEl0ZW0uc3ViR3JpZDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50R3JpZEl0ZW07XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnRpZmljaWFsIGV2ZW50IGZvciB0aGUgb3JpZ2luYWwgZ3JpZCBub3cgdGhhdCB0aGlzIG9uZSBpcyBnb25lIChnb3QgYSBsZWF2ZSwgYnV0IHdvbid0IGdldCBlbnRlcilcbiAgICAgICAgaWYgKG5vZGVUaGF0UmVtb3ZlZCkge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gVXRpbHMuc2ltdWxhdGVNb3VzZUV2ZW50KG5vZGVUaGF0UmVtb3ZlZC5fZXZlbnQsICdtb3VzZWVudGVyJywgcEdyaWQuZWwpLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBzYXZlcyB0aGUgY3VycmVudCBsYXlvdXQgcmV0dXJuaW5nIGEgbGlzdCBvZiB3aWRnZXRzIGZvciBzZXJpYWxpemF0aW9uIHdoaWNoIG1pZ2h0IGluY2x1ZGUgYW55IG5lc3RlZCBncmlkcy5cbiAgICAgKiBAcGFyYW0gc2F2ZUNvbnRlbnQgaWYgdHJ1ZSAoZGVmYXVsdCkgdGhlIGxhdGVzdCBodG1sIGluc2lkZSAuZ3JpZC1zdGFjay1jb250ZW50IHdpbGwgYmUgc2F2ZWQgdG8gR3JpZFN0YWNrV2lkZ2V0LmNvbnRlbnQgZmllbGQsIGVsc2UgaXQgd2lsbFxuICAgICAqIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHNhdmVHcmlkT3B0IGlmIHRydWUgKGRlZmF1bHQgZmFsc2UpLCBzYXZlIHRoZSBncmlkIG9wdGlvbnMgaXRzZWxmLCBzbyB5b3UgY2FuIGNhbGwgdGhlIG5ldyBHcmlkU3RhY2suYWRkR3JpZCgpXG4gICAgICogdG8gcmVjcmVhdGUgZXZlcnl0aGluZyBmcm9tIHNjcmF0Y2guIEdyaWRTdGFja09wdGlvbnMuY2hpbGRyZW4gd291bGQgdGhlbiBjb250YWluIHRoZSB3aWRnZXQgbGlzdCBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBzYXZlQ0IgY2FsbGJhY2sgZm9yIGVhY2ggbm9kZSAtPiB3aWRnZXQsIHNvIGFwcGxpY2F0aW9uIGNhbiBpbnNlcnQgYWRkaXRpb25hbCBkYXRhIHRvIGJlIHNhdmVkIGludG8gdGhlIHdpZGdldCBkYXRhIHN0cnVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyBsaXN0IG9mIHdpZGdldHMgb3IgZnVsbCBncmlkIG9wdGlvbiwgaW5jbHVkaW5nIC5jaGlsZHJlbiBsaXN0IG9mIHdpZGdldHNcbiAgICAgKi9cbiAgICBzYXZlKHNhdmVDb250ZW50ID0gdHJ1ZSwgc2F2ZUdyaWRPcHQgPSBmYWxzZSwgc2F2ZUNCID0gR3JpZFN0YWNrLnNhdmVDQikge1xuICAgICAgICAvLyByZXR1cm4gY29waWVkIEdyaWRTdGFja1dpZGdldCAod2l0aCBvcHRpb25hbGx5IC5lbCkgd2UgY2FuIG1vZGlmeSBhdCB3aWxsLi4uXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5lbmdpbmUuc2F2ZShzYXZlQ29udGVudCwgc2F2ZUNCKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIEhUTUwgY29udGVudCBhbmQgbmVzdGVkIGdyaWRzXG4gICAgICAgIGxpc3QuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmIChzYXZlQ29udGVudCAmJiBuLmVsICYmICFuLnN1YkdyaWQgJiYgIXNhdmVDQikgeyAvLyBzdWItZ3JpZCBhcmUgc2F2ZWQgZGlmZmVyZW50bHksIG5vdCBwbGFpbiBjb250ZW50XG4gICAgICAgICAgICAgICAgbGV0IHN1YiA9IG4uZWwucXVlcnlTZWxlY3RvcignLmdyaWQtc3RhY2staXRlbS1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgbi5jb250ZW50ID0gc3ViID8gc3ViLmlubmVySFRNTCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoIW4uY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG4uY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2F2ZUNvbnRlbnQgJiYgIXNhdmVDQikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbi5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbmVzdGVkIGdyaWRcbiAgICAgICAgICAgICAgICBpZiAobi5zdWJHcmlkPy5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0T3JPcHQgPSBuLnN1YkdyaWQuc2F2ZShzYXZlQ29udGVudCwgc2F2ZUdyaWRPcHQsIHNhdmVDQik7XG4gICAgICAgICAgICAgICAgICAgIG4uc3ViR3JpZE9wdHMgPSAoc2F2ZUdyaWRPcHQgPyBsaXN0T3JPcHQgOiB7IGNoaWxkcmVuOiBsaXN0T3JPcHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuLnN1YkdyaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG4uZWw7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjaGVjayBpZiBzYXZlIGVudGlyZSBncmlkIG9wdGlvbnMgKG5lZWRlZCBmb3IgcmVjdXJzaXZlKSArIGNoaWxkcmVuLi4uXG4gICAgICAgIGlmIChzYXZlR3JpZE9wdCkge1xuICAgICAgICAgICAgbGV0IG8gPSBVdGlscy5jbG9uZURlZXAodGhpcy5vcHRzKTtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBkZWZhdWx0IHZhbHVlcyB0aGF0IHdpbGwgYmUgcmVjcmVhdGVkIG9uIGxhdW5jaFxuICAgICAgICAgICAgaWYgKG8ubWFyZ2luQm90dG9tID09PSBvLm1hcmdpblRvcCAmJiBvLm1hcmdpblJpZ2h0ID09PSBvLm1hcmdpbkxlZnQgJiYgby5tYXJnaW5Ub3AgPT09IG8ubWFyZ2luUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBvLm1hcmdpbiA9IG8ubWFyZ2luVG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvLm1hcmdpblRvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5tYXJnaW5SaWdodDtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5tYXJnaW5Cb3R0b207XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8ubWFyZ2luTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvLnJ0bCA9PT0gKHRoaXMuZWwuc3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykpIHtcbiAgICAgICAgICAgICAgICBvLnJ0bCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgby5jZWxsSGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2F1dG9Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICBvLmNvbHVtbiA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBkZWxldGUgby5kaXNhYmxlT25lQ29sdW1uTW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yaWdTaG93ID0gby5fYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvLl9hbHdheXNTaG93UmVzaXplSGFuZGxlO1xuICAgICAgICAgICAgaWYgKG9yaWdTaG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvLmFsd2F5c1Nob3dSZXNpemVIYW5kbGUgPSBvcmlnU2hvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvLmFsd2F5c1Nob3dSZXNpemVIYW5kbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVdGlscy5yZW1vdmVJbnRlcm5hbEFuZFNhbWUobywgZ3JpZERlZmF1bHRzKTtcbiAgICAgICAgICAgIG8uY2hpbGRyZW4gPSBsaXN0O1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxvYWQgdGhlIHdpZGdldHMgZnJvbSBhIGxpc3QuIFRoaXMgd2lsbCBjYWxsIHVwZGF0ZSgpIG9uIGVhY2ggKG1hdGNoaW5nIGJ5IGlkKSBvciBhZGQvcmVtb3ZlIHdpZGdldHMgdGhhdCBhcmUgbm90IHRoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheW91dCBsaXN0IG9mIHdpZGdldHMgZGVmaW5pdGlvbiB0byB1cGRhdGUvY3JlYXRlXG4gICAgICogQHBhcmFtIGFkZEFuZFJlbW92ZSBib29sZWFuIChkZWZhdWx0IHRydWUpIG9yIGNhbGxiYWNrIG1ldGhvZCBjYW4gYmUgcGFzc2VkIHRvIGNvbnRyb2wgaWYgYW5kIGhvdyBtaXNzaW5nIHdpZGdldHMgY2FuIGJlIGFkZGVkL3JlbW92ZWQsIGdpdmluZ1xuICAgICAqIHRoZSB1c2VyIGNvbnRyb2wgb2YgaW5zZXJ0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzZWUgaHR0cDovL2dyaWRzdGFja2pzLmNvbS9kZW1vL3NlcmlhbGl6YXRpb24uaHRtbFxuICAgICAqL1xuICAgIGxvYWQoaXRlbXMsIGFkZFJlbW92ZSA9IEdyaWRTdGFjay5hZGRSZW1vdmVDQiB8fCB0cnVlKSB7XG4gICAgICAgIGl0ZW1zID0gVXRpbHMuY2xvbmVEZWVwKGl0ZW1zKTsgLy8gc28gd2UgY2FuIG1vZFxuICAgICAgICAvLyBpZiBwYXNzZWQgbGlzdCBoYXMgY29vcmRpbmF0ZXMsIHVzZSB0aGVtIChpbnNlcnQgZnJvbSBlbmQgdG8gYmVnaW5uaW5nIGZvciBjb25mbGljdCByZXNvbHV0aW9uKSBlbHNlIGZvcmNlIHdpZGdldCBzYW1lIG9yZGVyXG4gICAgICAgIGNvbnN0IGhhdmVDb29yZCA9IGl0ZW1zLnNvbWUodyA9PiB3LnggIT09IHVuZGVmaW5lZCB8fCB3LnkgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChoYXZlQ29vcmQpXG4gICAgICAgICAgICBpdGVtcyA9IFV0aWxzLnNvcnQoaXRlbXMsIC0xLCB0aGlzLl9wcmV2Q29sdW1uIHx8IHRoaXMuZ2V0Q29sdW1uKCkpO1xuICAgICAgICB0aGlzLl9pbnNlcnROb3RBcHBlbmQgPSBoYXZlQ29vcmQ7IC8vIGlmIHdlIGNyZWF0ZSBpbiByZXZlcnNlIG9yZGVyLi4uXG4gICAgICAgIC8vIGlmIHdlJ3JlIGxvYWRpbmcgYSBsYXlvdXQgaW50byBmb3IgZXhhbXBsZSAxIGNvbHVtbiAoX3ByZXZDb2x1bW4gaXMgc2V0IG9ubHkgd2hlbiBnb2luZyB0byAxKSBhbmQgaXRlbXMgZG9uJ3QgZml0LCBtYWtlIHN1cmUgdG8gc2F2ZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgd2FudGVkIGxheW91dCBzbyB3ZSBjYW4gc2NhbGUgYmFjayB1cCBjb3JyZWN0bHkgIzE0NzFcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZDb2x1bW4gJiYgdGhpcy5fcHJldkNvbHVtbiAhPT0gdGhpcy5vcHRzLmNvbHVtbiAmJiBpdGVtcy5zb21lKG4gPT4gKChuLnggfHwgMCkgKyBuLncpID4gdGhpcy5vcHRzLmNvbHVtbikpIHtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlID0gdHJ1ZTsgLy8gc2tpcCBsYXlvdXQgdXBkYXRlXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5jYWNoZUxheW91dChpdGVtcywgdGhpcy5fcHJldkNvbHVtbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZ2l2ZW4gYSBkaWZmZXJlbnQgY2FsbGJhY2ssIHRlbXBvcmFsbHkgc2V0IGl0IGFzIGdsb2JhbCBvcHRpb24gc28gY3JlYXRpbmcgd2lsbCB1c2UgaXRcbiAgICAgICAgY29uc3QgcHJldkNCID0gR3JpZFN0YWNrLmFkZFJlbW92ZUNCO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRSZW1vdmUpID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgR3JpZFN0YWNrLmFkZFJlbW92ZUNCID0gYWRkUmVtb3ZlO1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IFtdO1xuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKCk7XG4gICAgICAgIC8vIHNlZSBpZiBhbnkgaXRlbXMgYXJlIG1pc3NpbmcgZnJvbSBuZXcgbGF5b3V0IGFuZCBuZWVkIHRvIGJlIHJlbW92ZWQgZmlyc3RcbiAgICAgICAgaWYgKGFkZFJlbW92ZSkge1xuICAgICAgICAgICAgbGV0IGNvcHlOb2RlcyA9IFsuLi50aGlzLmVuZ2luZS5ub2Rlc107IC8vIGRvbid0IGxvb3AgdGhyb3VnaCBhcnJheSB5b3UgbW9kaWZ5XG4gICAgICAgICAgICBjb3B5Tm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW4uaWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IFV0aWxzLmZpbmQoaXRlbXMsIG4uaWQpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoR3JpZFN0YWNrLmFkZFJlbW92ZUNCKVxuICAgICAgICAgICAgICAgICAgICAgICAgR3JpZFN0YWNrLmFkZFJlbW92ZUNCKHRoaXMuZWwsIG4sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChuKTsgLy8gYmF0Y2gga2VlcCB0cmFja1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVdpZGdldChuLmVsLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGFkZC91cGRhdGUgdGhlIHdpZGdldHMgLSBzdGFydGluZyB3aXRoIHJlbW92aW5nIGl0ZW1zIGluIHRoZSBuZXcgbGF5b3V0IHdlIHdpbGwgcmVwb3NpdGlvblxuICAgICAgICAvLyB0byByZWR1Y2UgY29sbGlzaW9uIGFuZCBhZGQgbm8tY29vcmQgb25lcyBhdCBuZXh0IGF2YWlsYWJsZSBzcG90XG4gICAgICAgIGxldCB1cGRhdGVOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmVuZ2luZS5ub2RlcyA9IHRoaXMuZW5naW5lLm5vZGVzLmZpbHRlcihuID0+IHtcbiAgICAgICAgICAgIGlmIChVdGlscy5maW5kKGl0ZW1zLCBuLmlkKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzLnB1c2gobik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyByZW1vdmUgaWYgZm91bmQgZnJvbSBsaXN0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB3aWR0aENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCh3ID0+IHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gVXRpbHMuZmluZCh1cGRhdGVOb2Rlcywgdy5pZCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0ZW0gc2l6ZXMgdG8gY29udGVudCwgcmUtdXNlIHRoZSBleGl0aW5nIGhlaWdodCBzbyBpdCdzIGEgYmV0dGVyIGd1ZXNzIGF0IHRoZSBmaW5hbCBzaXplIDlzYW1lIGlmIHdpZHRoIGRvZXNuJ3QgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5zaG91bGRTaXplVG9Db250ZW50KGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICB3LmggPSBpdGVtLmg7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbWlzc2luZyBjb29yZCwgaW4gd2hpY2ggY2FzZSBmaW5kIG5leHQgZW1wdHkgc2xvdCB3aXRoIG5ldyAob3Igb2xkIGlmIG1pc3NpbmcpIHNpemVzXG4gICAgICAgICAgICAgICAgaWYgKHcuYXV0b1Bvc2l0aW9uIHx8IHcueCA9PT0gdW5kZWZpbmVkIHx8IHcueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHcudyA9IHcudyB8fCBpdGVtLnc7XG4gICAgICAgICAgICAgICAgICAgIHcuaCA9IHcuaCB8fCBpdGVtLmg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmZpbmRFbXB0eVBvc2l0aW9uKHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aWR0aENoYW5nZWQgPSB3aWR0aENoYW5nZWQgfHwgKHcudyAhPT0gdW5kZWZpbmVkICYmIHcudyAhPT0gaXRlbS53KTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYmFjayB0byBjdXJyZW50IGxpc3QgQlVUIGZvcmNlIGEgY29sbGlzaW9uIGNoZWNrIGlmIGl0ICdhcHBlYXJzJyB3ZSBkaWRuJ3QgY2hhbmdlIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBvdmVybGFwIG90aGVycyBub3dcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5zYW1lUG9zKGl0ZW0sIHcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZU5vZGUoaXRlbSwgeyAuLi53LCBmb3JjZUNvbGxpZGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmNvcHlQb3ModywgaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGl0ZW0uZWwsIHcpO1xuICAgICAgICAgICAgICAgIGlmICh3LnN1YkdyaWRPcHRzPy5jaGlsZHJlbikgeyAvLyB1cGRhdGUgYW55IHN1YiBncmlkIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YiA9IGl0ZW0uZWwucXVlcnlTZWxlY3RvcignLmdyaWQtc3RhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YiAmJiBzdWIuZ3JpZHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIuZ3JpZHN0YWNrLmxvYWQody5zdWJHcmlkT3B0cy5jaGlsZHJlbik7IC8vIFRPRE86IHN1cHBvcnQgdXBkYXRpbmcgZ3JpZCBvcHRpb25zID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydE5vdEFwcGVuZCA9IHRydWU7IC8vIGdvdCByZXNldCBieSBhYm92ZSBjYWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFdpZGdldCh3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlbW92ZWROb2RlcyA9IHJlbW92ZWQ7XG4gICAgICAgIHRoaXMuZG9Db250ZW50UmVzaXplKHdpZHRoQ2hhbmdlZCwgdHJ1ZSk7IC8vIHdlIG9ubHkgbmVlZCB0byB3YWl0IGZvciBhbmltYXRpb24gaWYgd2UgY2hhbmdlZCBhbnkgd2lkdGhzXG4gICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoZmFsc2UpO1xuICAgICAgICAvLyBhZnRlciBjb21taXQsIGNsZWFyIHRoYXQgZmxhZ1xuICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2U7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pbnNlcnROb3RBcHBlbmQ7XG4gICAgICAgIHByZXZDQiA/IEdyaWRTdGFjay5hZGRSZW1vdmVDQiA9IHByZXZDQiA6IGRlbGV0ZSBHcmlkU3RhY2suYWRkUmVtb3ZlQ0I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1c2UgYmVmb3JlIGNhbGxpbmcgYSBidW5jaCBvZiBgYWRkV2lkZ2V0KClgIHRvIHByZXZlbnQgdW4tbmVjZXNzYXJ5IHJlbGF5b3V0cyBpbiBiZXR3ZWVuIChtb3JlIGVmZmljaWVudClcbiAgICAgKiBhbmQgZ2V0IGEgc2luZ2xlIGV2ZW50IGNhbGxiYWNrLiBZb3Ugd2lsbCBzZWUgbm8gY2hhbmdlcyB1bnRpbCBgYmF0Y2hVcGRhdGUoZmFsc2UpYCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgYmF0Y2hVcGRhdGUoZmxhZyA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuYmF0Y2hVcGRhdGUoZmxhZyk7XG4gICAgICAgIGlmICghZmxhZykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVtb3ZlRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJBZGRFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY3VycmVudCBjZWxsIGhlaWdodC5cbiAgICAgKi9cbiAgICBnZXRDZWxsSGVpZ2h0KGZvcmNlUGl4ZWwgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNlbGxIZWlnaHQgJiYgdGhpcy5vcHRzLmNlbGxIZWlnaHQgIT09ICdhdXRvJyAmJlxuICAgICAgICAgICAgKCFmb3JjZVBpeGVsIHx8ICF0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQgfHwgdGhpcy5vcHRzLmNlbGxIZWlnaHRVbml0ID09PSAncHgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5jZWxsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgZ2V0IGZpcnN0IGNlbGwgaGVpZ2h0XG4gICAgICAgIGxldCBlbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLm9wdHMuaXRlbUNsYXNzKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1oJykpIHx8IDE7IC8vIHNpbmNlIHdlIGRvbid0IHdyaXRlIDEgYW55bW9yZVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGRvIGVudGlyZSBncmlkIGFuZCAjIG9mIHJvd3MgKGJ1dCBkb2Vzbid0IHdvcmsgaWYgbWluLWhlaWdodCBpcyB0aGUgYWN0dWFsIGNvbnN0cmFpbilcbiAgICAgICAgbGV0IHJvd3MgPSBwYXJzZUludCh0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZ3MtY3VycmVudC1yb3cnKSk7XG4gICAgICAgIHJldHVybiByb3dzID8gTWF0aC5yb3VuZCh0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvIHJvd3MpIDogdGhpcy5vcHRzLmNlbGxIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50IGNlbGwgaGVpZ2h0IC0gc2VlIGBHcmlkU3RhY2tPcHRpb25zLmNlbGxIZWlnaHRgIGZvciBmb3JtYXQuXG4gICAgICogVGhpcyBtZXRob2QgcmVidWlsZHMgYW4gaW50ZXJuYWwgQ1NTIHN0eWxlIHNoZWV0LlxuICAgICAqIE5vdGU6IFlvdSBjYW4gZXhwZWN0IHBlcmZvcm1hbmNlIGlzc3VlcyBpZiBjYWxsIHRoaXMgbWV0aG9kIHRvbyBvZnRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgdGhlIGNlbGwgaGVpZ2h0LiBJZiBub3QgcGFzc2VkICh1bmRlZmluZWQpLCBjZWxscyBjb250ZW50IHdpbGwgYmUgbWFkZSBzcXVhcmUgKG1hdGNoIHdpZHRoIG1pbnVzIG1hcmdpbiksXG4gICAgICogaWYgcGFzcyAwIHRoZSBDU1Mgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHVwZGF0ZSAoT3B0aW9uYWwpIGlmIGZhbHNlLCBzdHlsZXMgd2lsbCBub3QgYmUgdXBkYXRlZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBncmlkLmNlbGxIZWlnaHQoMTAwKTsgLy8gc2FtZSBhcyAxMDBweFxuICAgICAqIGdyaWQuY2VsbEhlaWdodCgnNzBweCcpO1xuICAgICAqIGdyaWQuY2VsbEhlaWdodChncmlkLmNlbGxXaWR0aCgpICogMS4yKTtcbiAgICAgKi9cbiAgICBjZWxsSGVpZ2h0KHZhbCwgdXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICAvLyBpZiBub3QgY2FsbGVkIGludGVybmFsbHksIGNoZWNrIGlmIHdlJ3JlIGNoYW5naW5nIG1vZGVcbiAgICAgICAgaWYgKHVwZGF0ZSAmJiB2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQXV0b0NlbGxIZWlnaHQgIT09ICh2YWwgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0ID0gKHZhbCA9PT0gJ2F1dG8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVSZXNpemVFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT09ICdpbml0aWFsJyB8fCB2YWwgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgaXRlbSBjb250ZW50IGJlIHNxdWFyZVxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5EaWZmID0gLXRoaXMub3B0cy5tYXJnaW5SaWdodCAtIHRoaXMub3B0cy5tYXJnaW5MZWZ0XG4gICAgICAgICAgICAgICAgKyB0aGlzLm9wdHMubWFyZ2luVG9wICsgdGhpcy5vcHRzLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2VsbFdpZHRoKCkgKyBtYXJnaW5EaWZmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gVXRpbHMucGFyc2VIZWlnaHQodmFsKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdCA9PT0gZGF0YS51bml0ICYmIHRoaXMub3B0cy5jZWxsSGVpZ2h0ID09PSBkYXRhLmgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdCA9IGRhdGEudW5pdDtcbiAgICAgICAgdGhpcy5vcHRzLmNlbGxIZWlnaHQgPSBkYXRhLmg7XG4gICAgICAgIHRoaXMuZG9Db250ZW50UmVzaXplKGZhbHNlLCB0cnVlKTsgLy8gbm8gYW5pbSB3YWl0LCBidXQgdXNlIGF0dHJpYnV0ZXMgc2luY2Ugd2Ugb25seSBjaGFuZ2Ugcm93IGhlaWdodFxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZXModHJ1ZSk7IC8vIHRydWUgPSBmb3JjZSByZS1jcmVhdGUgZm9yIGN1cnJlbnQgIyBvZiByb3dzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZXRzIGN1cnJlbnQgY2VsbCB3aWR0aC4gKi9cbiAgICBjZWxsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aE9yQ29udGFpbmVyKCkgLyB0aGlzLmdldENvbHVtbigpO1xuICAgIH1cbiAgICAvKiogcmV0dXJuIG91ciBleHBlY3RlZCB3aWR0aCAob3IgcGFyZW50KSBmb3IgMSBjb2x1bW4gY2hlY2sgKi9cbiAgICBfd2lkdGhPckNvbnRhaW5lcigpIHtcbiAgICAgICAgLy8gdXNlIGBvZmZzZXRXaWR0aGAgb3IgYGNsaWVudFdpZHRoYCAobm8gc2Nyb2xsYmFyKSA/XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMDY0MTAxL3VuZGVyc3RhbmRpbmctb2Zmc2V0d2lkdGgtY2xpZW50d2lkdGgtc2Nyb2xsd2lkdGgtYW5kLWhlaWdodC1yZXNwZWN0aXZlbHlcbiAgICAgICAgcmV0dXJuICh0aGlzLmVsLmNsaWVudFdpZHRoIHx8IHRoaXMuZWwucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlLWxheW91dCBncmlkIGl0ZW1zIHRvIHJlY2xhaW0gYW55IGVtcHR5IHNwYWNlLiBPcHRpb25zIGFyZTpcbiAgICAgKiAnbGlzdCcga2VlcCB0aGUgd2lkZ2V0IGxlZnQtPnJpZ2h0IG9yZGVyIHRoZSBzYW1lLCBldmVuIGlmIHRoYXQgbWVhbnMgbGVhdmluZyBhbiBlbXB0eSBzbG90IGlmIHRoaW5ncyBkb24ndCBmaXRcbiAgICAgKiAnY29tcGFjdCcgbWlnaHQgcmUtb3JkZXIgaXRlbXMgdG8gZmlsbCBhbnkgZW1wdHkgc3BhY2VcbiAgICAgKlxuICAgICAqIGRvU29ydCAtICdmYWxzZScgdG8gbGV0IHlvdSBkbyB5b3VyIG93biBzb3J0aW5nIGFoZWFkIGluIGNhc2UgeW91IG5lZWQgdG8gY29udHJvbCBhIGRpZmZlcmVudCBvcmRlci4gKGRlZmF1bHQgdG8gc29ydClcbiAgICAgKi9cbiAgICBjb21wYWN0KGxheW91dCA9ICdjb21wYWN0JywgZG9Tb3J0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuZ2luZS5jb21wYWN0KGxheW91dCwgZG9Tb3J0KTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBncmlkLiBXaWxsIHVwZGF0ZSBleGlzdGluZyB3aWRnZXRzIHRvIGNvbmZvcm0gdG8gbmV3IG51bWJlciBvZiBjb2x1bW5zLFxuICAgICAqIGFzIHdlbGwgYXMgY2FjaGUgdGhlIG9yaWdpbmFsIGxheW91dCBzbyB5b3UgY2FuIHJldmVydCBiYWNrIHRvIHByZXZpb3VzIHBvc2l0aW9ucyB3aXRob3V0IGxvc3MuXG4gICAgICogUmVxdWlyZXMgYGdyaWRzdGFjay1leHRyYS5jc3NgIG9yIGBncmlkc3RhY2stZXh0cmEubWluLmNzc2AgZm9yIFsyLTExXSxcbiAgICAgKiBlbHNlIHlvdSB3aWxsIG5lZWQgdG8gZ2VuZXJhdGUgY29ycmVjdCBDU1MgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcyNjaGFuZ2UtZ3JpZC1jb2x1bW5zKVxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBJbnRlZ2VyID4gMCAoZGVmYXVsdCAxMikuXG4gICAgICogQHBhcmFtIGxheW91dCBzcGVjaWZ5IHRoZSB0eXBlIG9mIHJlLWxheW91dCB0aGF0IHdpbGwgaGFwcGVuIChwb3NpdGlvbiwgc2l6ZSwgZXRjLi4uKS5cbiAgICAgKiBOb3RlOiBpdGVtcyB3aWxsIG5ldmVyIGJlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgY29sdW1uIGJvdW5kYXJpZXMuIGRlZmF1bHQgKCdtb3ZlU2NhbGUnKS4gSWdub3JlZCBmb3IgMSBjb2x1bW5cbiAgICAgKi9cbiAgICBjb2x1bW4oY29sdW1uLCBsYXlvdXQgPSAnbW92ZVNjYWxlJykge1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCBjb2x1bW4gPCAxIHx8IHRoaXMub3B0cy5jb2x1bW4gPT09IGNvbHVtbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgb2xkQ29sdW1uID0gdGhpcy5nZXRDb2x1bW4oKTtcbiAgICAgICAgLy8gaWYgd2UgZ28gaW50byAxIGNvbHVtbiBtb2RlICh3aGljaCBoYXBwZW5zIGlmIHdlJ3JlIHNpemVkIGxlc3MgdGhhbiBtaW5XIHVubGVzcyBkaXNhYmxlT25lQ29sdW1uTW9kZSBpcyBvbilcbiAgICAgICAgLy8gdGhlbiByZW1lbWJlciB0aGUgb3JpZ2luYWwgY29sdW1ucyBzbyB3ZSBjYW4gcmVzdG9yZS5cbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldkNvbHVtbiA9IG9sZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcmV2Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnZ3MtJyArIG9sZENvbHVtbik7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZ3MtJyArIGNvbHVtbik7XG4gICAgICAgIHRoaXMub3B0cy5jb2x1bW4gPSB0aGlzLmVuZ2luZS5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaXRlbXMgbm93IC0gc2VlIGlmIHRoZSBkb20gb3JkZXIgbm9kZXMgc2hvdWxkIGJlIHBhc3NlZCBpbnN0ZWFkIChlbHNlIGRlZmF1bHQgdG8gY3VycmVudCBsaXN0KVxuICAgICAgICBsZXQgZG9tTm9kZXM7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDEgJiYgdGhpcy5vcHRzLm9uZUNvbHVtbk1vZGVEb21Tb3J0KSB7XG4gICAgICAgICAgICBkb21Ob2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5nZXRHcmlkSXRlbXMoKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuZ3JpZHN0YWNrTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2Rlcy5wdXNoKGVsLmdyaWRzdGFja05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkb21Ob2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZ2luZS5jb2x1bW5DaGFuZ2VkKG9sZENvbHVtbiwgY29sdW1uLCBkb21Ob2RlcywgbGF5b3V0KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXV0b0NlbGxIZWlnaHQpXG4gICAgICAgICAgICB0aGlzLmNlbGxIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5kb0NvbnRlbnRSZXNpemUoKTtcbiAgICAgICAgLy8gYW5kIHRyaWdnZXIgb3VyIGV2ZW50IGxhc3QuLi5cbiAgICAgICAgdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2UgPSB0cnVlOyAvLyBza2lwIGxheW91dCB1cGRhdGVcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGdyaWQgKGRlZmF1bHQgMTIpXG4gICAgICovXG4gICAgZ2V0Q29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmNvbHVtbjtcbiAgICB9XG4gICAgLyoqIHJldHVybnMgYW4gYXJyYXkgb2YgZ3JpZCBIVE1MIGVsZW1lbnRzIChubyBwbGFjZWhvbGRlcikgLSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBvdXIgY2hpbGRyZW4gaW4gRE9NIG9yZGVyICovXG4gICAgZ2V0R3JpZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsLmNoaWxkcmVuKVxuICAgICAgICAgICAgLmZpbHRlcigoZWwpID0+IGVsLm1hdGNoZXMoJy4nICsgdGhpcy5vcHRzLml0ZW1DbGFzcykgJiYgIWVsLm1hdGNoZXMoJy4nICsgdGhpcy5vcHRzLnBsYWNlaG9sZGVyQ2xhc3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncmlkIGluc3RhbmNlLiBETyBOT1QgQ0FMTCBhbnkgbWV0aG9kcyBvciBhY2Nlc3MgYW55IHZhcnMgYWZ0ZXIgdGhpcyBhcyBpdCB3aWxsIGZyZWUgdXAgbWVtYmVycy5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlRE9NIGlmIGBmYWxzZWAgZ3JpZCBhbmQgaXRlbXMgSFRNTCBlbGVtZW50cyB3aWxsIG5vdCBiZSByZW1vdmVkIGZyb20gdGhlIERPTSAoT3B0aW9uYWwuIERlZmF1bHQgYHRydWVgKS5cbiAgICAgKi9cbiAgICBkZXN0cm95KHJlbW92ZURPTSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBwcmV2ZW50IG11bHRpcGxlIGNhbGxzXG4gICAgICAgIHRoaXMub2ZmQWxsKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlc2l6ZUV2ZW50KHRydWUpO1xuICAgICAgICB0aGlzLnNldFN0YXRpYyh0cnVlLCBmYWxzZSk7IC8vIHBlcm1hbmVudGx5IHJlbW92ZXMgREQgYnV0IGRvbid0IHNldCBDU1MgY2xhc3MgKHdlJ3JlIGdvaW5nIGF3YXkpXG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uKGZhbHNlKTtcbiAgICAgICAgaWYgKCFyZW1vdmVET00pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKHJlbW92ZURPTSk7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fc3R5bGVTaGVldENsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdncy1jdXJyZW50LXJvdycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0eWxlc2hlZXQoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50R3JpZEl0ZW0pXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnRHcmlkSXRlbS5zdWJHcmlkO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnRHcmlkSXRlbTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0cztcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BsYWNlaG9sZGVyO1xuICAgICAgICBkZWxldGUgdGhpcy5lbmdpbmU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsLmdyaWRzdGFjazsgLy8gcmVtb3ZlIGNpcmN1bGFyIGRlcGVuZGVuY3kgdGhhdCB3b3VsZCBwcmV2ZW50IGEgZnJlZWluZ1xuICAgICAgICBkZWxldGUgdGhpcy5lbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVuYWJsZS9kaXNhYmxlIGZsb2F0aW5nIHdpZGdldHMgKGRlZmF1bHQ6IGBmYWxzZWApIFNlZSBbZXhhbXBsZV0oaHR0cDovL2dyaWRzdGFja2pzLmNvbS9kZW1vL2Zsb2F0Lmh0bWwpXG4gICAgICovXG4gICAgZmxvYXQodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZmxvYXQgIT09IHZhbCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmZsb2F0ID0gdGhpcy5lbmdpbmUuZmxvYXQgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjdXJyZW50IGZsb2F0IG1vZGVcbiAgICAgKi9cbiAgICBnZXRGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmZsb2F0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjZWxsIHVuZGVyIGEgcGl4ZWwgb24gc2NyZWVuLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBpeGVsIHRvIHJlc29sdmUgaW5cbiAgICAgKiBhYnNvbHV0ZSBjb29yZGluYXRlcywgYXMgYW4gb2JqZWN0IHdpdGggdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gdXNlRG9jUmVsYXRpdmUgaWYgdHJ1ZSwgdmFsdWUgd2lsbCBiZSBiYXNlZCBvbiBkb2N1bWVudCBwb3NpdGlvbiB2cyBwYXJlbnQgcG9zaXRpb24gKE9wdGlvbmFsLiBEZWZhdWx0IGZhbHNlKS5cbiAgICAgKiBVc2VmdWwgd2hlbiBncmlkIGlzIHdpdGhpbiBgcG9zaXRpb246IHJlbGF0aXZlYCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYHhgIGFuZCBgeWAgaS5lLiB0aGUgY29sdW1uIGFuZCByb3cgaW4gdGhlIGdyaWQuXG4gICAgICovXG4gICAgZ2V0Q2VsbEZyb21QaXhlbChwb3NpdGlvbiwgdXNlRG9jUmVsYXRpdmUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYm94ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYGdldEJvdW5kaW5nQ2xpZW50UmVjdCBsZWZ0OiAke2JveC5sZWZ0fSB0b3A6ICR7Ym94LnRvcH0gdzogJHtib3gud30gaDogJHtib3guaH1gKVxuICAgICAgICBsZXQgY29udGFpbmVyUG9zO1xuICAgICAgICBpZiAodXNlRG9jUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lclBvcyA9IHsgdG9wOiBib3gudG9wICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgbGVmdDogYm94LmxlZnQgfTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBnZXRDZWxsRnJvbVBpeGVsIHNjcm9sbFRvcDogJHtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfWApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJQb3MgPSB7IHRvcDogdGhpcy5lbC5vZmZzZXRUb3AsIGxlZnQ6IHRoaXMuZWwub2Zmc2V0TGVmdCB9O1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYGdldENlbGxGcm9tUGl4ZWwgb2Zmc2V0VG9wOiAke2NvbnRhaW5lclBvcy5sZWZ0fSBvZmZzZXRMZWZ0OiAke2NvbnRhaW5lclBvcy50b3B9YClcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVsYXRpdmVMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGNvbnRhaW5lclBvcy5sZWZ0O1xuICAgICAgICBsZXQgcmVsYXRpdmVUb3AgPSBwb3NpdGlvbi50b3AgLSBjb250YWluZXJQb3MudG9wO1xuICAgICAgICBsZXQgY29sdW1uV2lkdGggPSAoYm94LndpZHRoIC8gdGhpcy5nZXRDb2x1bW4oKSk7XG4gICAgICAgIGxldCByb3dIZWlnaHQgPSAoYm94LmhlaWdodCAvIHBhcnNlSW50KHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdncy1jdXJyZW50LXJvdycpKSk7XG4gICAgICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3IocmVsYXRpdmVMZWZ0IC8gY29sdW1uV2lkdGgpLCB5OiBNYXRoLmZsb29yKHJlbGF0aXZlVG9wIC8gcm93SGVpZ2h0KSB9O1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2Ygcm93cywgd2hpY2ggd2lsbCBiZSBhdCBsZWFzdCBgbWluUm93YCBpZiBzZXQgKi9cbiAgICBnZXRSb3coKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmVuZ2luZS5nZXRSb3coKSwgdGhpcy5vcHRzLm1pblJvdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgYXJlYSBpcyBlbXB0eS5cbiAgICAgKiBAcGFyYW0geCB0aGUgcG9zaXRpb24geC5cbiAgICAgKiBAcGFyYW0geSB0aGUgcG9zaXRpb24geS5cbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRvIGNoZWNrXG4gICAgICovXG4gICAgaXNBcmVhRW1wdHkoeCwgeSwgdywgaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuaXNBcmVhRW1wdHkoeCwgeSwgdywgaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhZGQgZWxlbWVudHMgdG8geW91ciBncmlkIGJ5IGhhbmQgKG9yIGhhdmUgc29tZSBmcmFtZXdvcmsgY3JlYXRpbmcgRE9NKSwgeW91IGhhdmUgdG8gdGVsbCBncmlkc3RhY2sgYWZ0ZXJ3YXJkcyB0byBtYWtlIHRoZW0gd2lkZ2V0cy5cbiAgICAgKiBJZiB5b3Ugd2FudCBncmlkc3RhY2sgdG8gYWRkIHRoZSBlbGVtZW50cyBmb3IgeW91LCB1c2UgYGFkZFdpZGdldCgpYCBpbnN0ZWFkLlxuICAgICAqIE1ha2VzIHRoZSBnaXZlbiBlbGVtZW50IGEgd2lkZ2V0IGFuZCByZXR1cm5zIGl0LlxuICAgICAqIEBwYXJhbSBlbHMgd2lkZ2V0IG9yIHNpbmdsZSBzZWxlY3RvciB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHdpZGdldCBkZWZpbml0aW9uIHRvIHVzZSBpbnN0ZWFkIG9mIHJlYWRpbmcgYXR0cmlidXRlcyBvciB1c2luZyBkZWZhdWx0IHNpemluZyB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGdyaWQgPSBHcmlkU3RhY2suaW5pdCgpO1xuICAgICAqIGdyaWQuZWwuYXBwZW5kQ2hpbGQoJzxkaXYgaWQ9XCIxXCIgZ3Mtdz1cIjNcIj48L2Rpdj4nKTtcbiAgICAgKiBncmlkLmVsLmFwcGVuZENoaWxkKCc8ZGl2IGlkPVwiMlwiPjwvZGl2PicpO1xuICAgICAqIGdyaWQubWFrZVdpZGdldCgnMScpO1xuICAgICAqIGdyaWQubWFrZVdpZGdldCgnMicsIHt3OjIsIGNvbnRlbnQ6ICdoZWxsbyd9KTtcbiAgICAgKi9cbiAgICBtYWtlV2lkZ2V0KGVscywgb3B0aW9ucykge1xuICAgICAgICBsZXQgZWwgPSBHcmlkU3RhY2suZ2V0RWxlbWVudChlbHMpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRWxlbWVudChlbCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5kb0NvbnRlbnRSZXNpemUoZmFsc2UsIGZhbHNlLCBub2RlKTtcbiAgICAgICAgLy8gc2VlIGlmIHRoZXJlIGlzIGEgc3ViLWdyaWQgdG8gY3JlYXRlXG4gICAgICAgIGlmIChub2RlLnN1YkdyaWRPcHRzKSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VTdWJHcmlkKGVsLCBub2RlLnN1YkdyaWRPcHRzLCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gbm9kZS5zdWJHcmlkIHdpbGwgYmUgdXNlZCBhcyBvcHRpb24gaW4gbWV0aG9kLCBubyBuZWVkIHRvIHBhc3NcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSdyZSBhZGRpbmcgYW4gaXRlbSBpbnRvIDEgY29sdW1uIChfcHJldkNvbHVtbiBpcyBzZXQgb25seSB3aGVuIGdvaW5nIHRvIDEpIG1ha2Ugc3VyZVxuICAgICAgICAvLyB3ZSBkb24ndCBvdmVycmlkZSB0aGUgbGFyZ2VyIDEyIGNvbHVtbiBsYXlvdXQgdGhhdCB3YXMgYWxyZWFkeSBzYXZlZC4gIzE5ODVcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZDb2x1bW4gJiYgdGhpcy5vcHRzLmNvbHVtbiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJBZGRFdmVudCgpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgdGhhdCBleHRyYWN0cyBvdXIgQ3VzdG9tRXZlbnQgZGF0YSBvdXQgYXV0b21hdGljYWxseSBmb3IgcmVjZWl2aW5nIGN1c3RvbVxuICAgICAqIG5vdGlmaWNhdGlvbnMgKHNlZSBkb2MgZm9yIHN1cHBvcnRlZCBldmVudHMpXG4gICAgICogQHBhcmFtIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgcG9zc2libGUgdmFsdWVzKSBvciBsaXN0IG9mIG5hbWVzIHNwYWNlIHNlcGFyYXRlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2l0aCBldmVudCBhbmQgb3B0aW9uYWwgc2Vjb25kL3RoaXJkIHBhcmFtXG4gICAgICogKHNlZSBSRUFETUUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBzaWduYXR1cmUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBncmlkLm9uKCdhZGRlZCcsIGZ1bmN0aW9uKGUsIGl0ZW1zKSB7IGxvZygnYWRkZWQgJywgaXRlbXMpfSApO1xuICAgICAqIG9yXG4gICAgICogZ3JpZC5vbignYWRkZWQgcmVtb3ZlZCBjaGFuZ2UnLCBmdW5jdGlvbihlLCBpdGVtcykgeyBsb2coZS50eXBlLCBpdGVtcyl9ICk7XG4gICAgICpcbiAgICAgKiBOb3RlOiBpbiBzb21lIGNhc2VzIGl0IGlzIHRoZSBzYW1lIGFzIGNhbGxpbmcgbmF0aXZlIGhhbmRsZXIgYW5kIHBhcnNpbmcgdGhlIGV2ZW50LlxuICAgICAqIGdyaWQuZWwuYWRkRXZlbnRMaXN0ZW5lcignYWRkZWQnLCBmdW5jdGlvbihldmVudCkgeyBsb2coJ2FkZGVkICcsIGV2ZW50LmRldGFpbCl9ICk7XG4gICAgICpcbiAgICAgKi9cbiAgICBvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBjaGVjayBmb3IgYXJyYXkgb2YgbmFtZXMgYmVpbmcgcGFzc2VkIGluc3RlYWRcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IG5hbWVzID0gbmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHRoaXMub24obmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnY2hhbmdlJyB8fCBuYW1lID09PSAnYWRkZWQnIHx8IG5hbWUgPT09ICdyZW1vdmVkJyB8fCBuYW1lID09PSAnZW5hYmxlJyB8fCBuYW1lID09PSAnZGlzYWJsZScpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBDdXN0b21FdmVudCBoYW5kbGVycyAtIGNhc2ggdGhlIGdlbmVyaWMgaGFuZGxlcnMgc28gd2UgY2FuIGVhc2lseSByZW1vdmVcbiAgICAgICAgICAgIGxldCBub0RhdGEgPSAobmFtZSA9PT0gJ2VuYWJsZScgfHwgbmFtZSA9PT0gJ2Rpc2FibGUnKTtcbiAgICAgICAgICAgIGlmIChub0RhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlcltuYW1lXSA9IChldmVudCkgPT4gY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbbmFtZV0gPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50LCBldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHRoaXMuX2dzRXZlbnRIYW5kbGVyW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZHJhZycgfHwgbmFtZSA9PT0gJ2RyYWdzdGFydCcgfHwgbmFtZSA9PT0gJ2RyYWdzdG9wJyB8fCBuYW1lID09PSAncmVzaXplc3RhcnQnIHx8IG5hbWUgPT09ICdyZXNpemUnXG4gICAgICAgICAgICB8fCBuYW1lID09PSAncmVzaXplc3RvcCcgfHwgbmFtZSA9PT0gJ2Ryb3BwZWQnIHx8IG5hbWUgPT09ICdyZXNpemVjb250ZW50Jykge1xuICAgICAgICAgICAgLy8gZHJhZyZkcm9wIHN0b3AgZXZlbnRzIE5FRUQgdG8gYmUgY2FsbCB0aGVtIEFGVEVSIHdlIHVwZGF0ZSBub2RlIGF0dHJpYnV0ZXMgc28gaGFuZGxlIHRoZW0gb3Vyc2VsZi5cbiAgICAgICAgICAgIC8vIGRvIHNhbWUgZm9yIHN0YXJ0IGV2ZW50IHRvIG1ha2UgaXQgZWFzaWVyLi4uXG4gICAgICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlcltuYW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dyaWRTdGFjay5vbignICsgbmFtZSArICcpIGV2ZW50IG5vdCBzdXBwb3J0ZWQsIGJ1dCB5b3UgY2FuIHN0aWxsIHVzZSAkKFwiLmdyaWQtc3RhY2tcIikub24oLi4uKSB3aGlsZSBqcXVlcnktdWkgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1bnN1YnNjcmliZSBmcm9tIHRoZSAnb24nIGV2ZW50IGJlbG93XG4gICAgICogQHBhcmFtIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgcG9zc2libGUgdmFsdWVzKVxuICAgICAqL1xuICAgIG9mZihuYW1lKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhcnJheSBvZiBuYW1lcyBiZWluZyBwYXNzZWQgaW5zdGVhZFxuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgbmFtZXMgPSBuYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4gdGhpcy5vZmYobmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdjaGFuZ2UnIHx8IG5hbWUgPT09ICdhZGRlZCcgfHwgbmFtZSA9PT0gJ3JlbW92ZWQnIHx8IG5hbWUgPT09ICdlbmFibGUnIHx8IG5hbWUgPT09ICdkaXNhYmxlJykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG5hdGl2ZSBDdXN0b21FdmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dzRXZlbnRIYW5kbGVyW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHRoaXMuX2dzRXZlbnRIYW5kbGVyW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fZ3NFdmVudEhhbmRsZXJbbmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogcmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyAqL1xuICAgIG9mZkFsbCgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZ3NFdmVudEhhbmRsZXIpLmZvckVhY2goa2V5ID0+IHRoaXMub2ZmKGtleSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB3aWRnZXQgZnJvbSB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0gZWwgIHdpZGdldCBvciBzZWxlY3RvciB0byBtb2RpZnlcbiAgICAgKiBAcGFyYW0gcmVtb3ZlRE9NIGlmIGBmYWxzZWAgRE9NIGVsZW1lbnQgd29uJ3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlIChEZWZhdWx0PyB0cnVlKS5cbiAgICAgKiBAcGFyYW0gdHJpZ2dlckV2ZW50IGlmIGBmYWxzZWAgKHF1aWV0IG1vZGUpIGVsZW1lbnQgd2lsbCBub3QgYmUgYWRkZWQgdG8gcmVtb3ZlZCBsaXN0IGFuZCBubyAncmVtb3ZlZCcgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIChEZWZhdWx0PyB0cnVlKS5cbiAgICAgKi9cbiAgICByZW1vdmVXaWRnZXQoZWxzLCByZW1vdmVET00gPSB0cnVlLCB0cmlnZ2VyRXZlbnQgPSB0cnVlKSB7XG4gICAgICAgIEdyaWRTdGFjay5nZXRFbGVtZW50cyhlbHMpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLnBhcmVudEVsZW1lbnQgJiYgZWwucGFyZW50RWxlbWVudCAhPT0gdGhpcy5lbClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vdCBvdXIgY2hpbGQhXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICAvLyBGb3IgTWV0ZW9yIHN1cHBvcnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmlkc3RhY2svZ3JpZHN0YWNrLmpzL3B1bGwvMjcyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5lbmdpbmUubm9kZXMuZmluZChuID0+IGVsID09PSBuLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoR3JpZFN0YWNrLmFkZFJlbW92ZUNCKSB7XG4gICAgICAgICAgICAgICAgR3JpZFN0YWNrLmFkZFJlbW92ZUNCKHRoaXMuZWwsIG5vZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgb3VyIERPTSBkYXRhIChjaXJjdWxhciBsaW5rKSBhbmQgZHJhZyZkcm9wIHBlcm1hbmVudGx5XG4gICAgICAgICAgICBkZWxldGUgZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUREKGVsKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnJlbW92ZU5vZGUobm9kZSwgcmVtb3ZlRE9NLCB0cmlnZ2VyRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZURPTSAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlKCk7IC8vIGluIGJhdGNoIG1vZGUgZW5naW5lLnJlbW92ZU5vZGUgZG9lc24ndCBjYWxsIGJhY2sgdG8gcmVtb3ZlIERPTVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlbW92ZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgd2lkZ2V0cyBmcm9tIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSByZW1vdmVET00gaWYgYGZhbHNlYCBET00gZWxlbWVudHMgd29uJ3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlIChEZWZhdWx0PyBgdHJ1ZWApLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbChyZW1vdmVET00gPSB0cnVlKSB7XG4gICAgICAgIC8vIGFsd2F5cyByZW1vdmUgb3VyIERPTSBkYXRhIChjaXJjdWxhciBsaW5rKSBiZWZvcmUgbGlzdCBnZXRzIGVtcHRpZWQgYW5kIGRyYWcmZHJvcCBwZXJtYW5lbnRseVxuICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgZGVsZXRlIG4uZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUREKG4uZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmdpbmUucmVtb3ZlQWxsKHJlbW92ZURPTSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZW1vdmVFdmVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBncmlkIGFuaW1hdGlvbiBzdGF0ZS4gIFRvZ2dsZXMgdGhlIGBncmlkLXN0YWNrLWFuaW1hdGVgIGNsYXNzLlxuICAgICAqIEBwYXJhbSBkb0FuaW1hdGUgaWYgdHJ1ZSB0aGUgZ3JpZCB3aWxsIGFuaW1hdGUuXG4gICAgICovXG4gICAgc2V0QW5pbWF0aW9uKGRvQW5pbWF0ZSkge1xuICAgICAgICBpZiAoZG9BbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2dyaWQtc3RhY2stYW5pbWF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdncmlkLXN0YWNrLWFuaW1hdGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBncmlkIHN0YXRpYyBzdGF0ZSwgd2hpY2ggcGVybWFuZW50bHkgcmVtb3Zlcy9hZGQgRHJhZyZEcm9wIHN1cHBvcnQsIHVubGlrZSBkaXNhYmxlKCkvZW5hYmxlKCkgdGhhdCBqdXN0IHR1cm5zIGl0IG9mZi9vbi5cbiAgICAgKiBBbHNvIHRvZ2dsZSB0aGUgZ3JpZC1zdGFjay1zdGF0aWMgY2xhc3MuXG4gICAgICogQHBhcmFtIHZhbCBpZiB0cnVlIHRoZSBncmlkIGJlY29tZSBzdGF0aWMuXG4gICAgICogQHBhcmFtIHVwZGF0ZUNsYXNzIHRydWUgKGRlZmF1bHQpIGlmIGNzcyBjbGFzcyBnZXRzIHVwZGF0ZWRcbiAgICAgKiBAcGFyYW0gcmVjdXJzZSB0cnVlIChkZWZhdWx0KSBpZiBzdWItZ3JpZHMgYWxzbyBnZXQgdXBkYXRlZFxuICAgICAqL1xuICAgIHNldFN0YXRpYyh2YWwsIHVwZGF0ZUNsYXNzID0gdHJ1ZSwgcmVjdXJzZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5vcHRzLnN0YXRpY0dyaWQgPT09IHZhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YWwgPyB0aGlzLm9wdHMuc3RhdGljR3JpZCA9IHRydWUgOiBkZWxldGUgdGhpcy5vcHRzLnN0YXRpY0dyaWQ7XG4gICAgICAgIHRoaXMuX3NldHVwUmVtb3ZlRHJvcCgpO1xuICAgICAgICB0aGlzLl9zZXR1cEFjY2VwdFdpZGdldCgpO1xuICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pOyAvLyBlaXRoZXIgZGVsZXRlIG9yIGluaXQgRHJhZyZkcm9wXG4gICAgICAgICAgICBpZiAobi5zdWJHcmlkICYmIHJlY3Vyc2UpXG4gICAgICAgICAgICAgICAgbi5zdWJHcmlkLnNldFN0YXRpYyh2YWwsIHVwZGF0ZUNsYXNzLCByZWN1cnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGVDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGljQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3aWRnZXQgcG9zaXRpb24vc2l6ZSBhbmQgb3RoZXIgaW5mby4gTm90ZTogaWYgeW91IG5lZWQgdG8gY2FsbCB0aGlzIG9uIGFsbCBub2RlcywgdXNlIGxvYWQoKSBpbnN0ZWFkIHdoaWNoIHdpbGwgdXBkYXRlIHdoYXQgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gZWxzICB3aWRnZXQgb3Igc2VsZWN0b3Igb2Ygb2JqZWN0cyB0byBtb2RpZnkgKG5vdGU6IHNldHRpbmcgdGhlIHNhbWUgeCx5IGZvciBtdWx0aXBsZSBpdGVtcyB3aWxsIGJlIGluZGV0ZXJtaW5pc3RpYyBhbmQgbGlrZWx5IHVud2FudGVkKVxuICAgICAqIEBwYXJhbSBvcHQgbmV3IHdpZGdldCBvcHRpb25zICh4LHksdyxoLCBldGMuLikuIE9ubHkgdGhvc2Ugc2V0IHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUoZWxzLCBvcHQpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBsZWdhY3kgY2FsbCBmb3Igbm93ID9cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay50czogYHVwZGF0ZShlbCwgeCwgeSwgdywgaClgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgdXBkYXRlKGVsLCB7eCwgdywgY29udGVudCwgLi4ufSlgLiBJdCB3aWxsIGJlIHJlbW92ZWQgc29vbicpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgbGV0IGEgPSBhcmd1bWVudHMsIGkgPSAxO1xuICAgICAgICAgICAgb3B0ID0geyB4OiBhW2krK10sIHk6IGFbaSsrXSwgdzogYVtpKytdLCBoOiBhW2krK10gfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShlbHMsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgR3JpZFN0YWNrLmdldEVsZW1lbnRzKGVscykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBsZXQgbiA9IGVsPy5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3ID0gVXRpbHMuY2xvbmVEZWVwKG9wdCk7IC8vIG1ha2UgYSBjb3B5IHdlIGNhbiBtb2RpZnkgaW4gY2FzZSB0aGV5IHJlLXVzZSBpdCBvciBtdWx0aXBsZSBpdGVtc1xuICAgICAgICAgICAgZGVsZXRlIHcuYXV0b1Bvc2l0aW9uO1xuICAgICAgICAgICAgZGVsZXRlIHcuaWQ7XG4gICAgICAgICAgICAvLyBtb3ZlL3Jlc2l6ZSB3aWRnZXQgaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICAgICAgbGV0IGtleXMgPSBbJ3gnLCAneScsICd3JywgJ2gnXTtcbiAgICAgICAgICAgIGxldCBtO1xuICAgICAgICAgICAgaWYgKGtleXMuc29tZShrID0+IHdba10gIT09IHVuZGVmaW5lZCAmJiB3W2tdICE9PSBuW2tdKSkge1xuICAgICAgICAgICAgICAgIG0gPSB7fTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1ba10gPSAod1trXSAhPT0gdW5kZWZpbmVkKSA/IHdba10gOiBuW2tdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd1trXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBhIG1vdmUgYXMgd2VsbCBJRkYgdGhlcmUgaXMgYW55IG1pbi9tYXggZmllbGRzIHNldFxuICAgICAgICAgICAgaWYgKCFtICYmICh3Lm1pblcgfHwgdy5taW5IIHx8IHcubWF4VyB8fCB3Lm1heEgpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHt9OyAvLyB3aWxsIHVzZSBub2RlIHBvc2l0aW9uIGJ1dCB2YWxpZGF0ZSB2YWx1ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjb250ZW50IGNoYW5naW5nXG4gICAgICAgICAgICBpZiAody5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtQ29udGVudCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5ncmlkLXN0YWNrLWl0ZW0tY29udGVudCcpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtQ29udGVudCAmJiBpdGVtQ29udGVudC5pbm5lckhUTUwgIT09IHcuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudC5pbm5lckhUTUwgPSB3LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgYW55IHN1Yi1ncmlkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uc3ViR3JpZD8uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50LmFwcGVuZENoaWxkKG4uc3ViR3JpZC5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW4uc3ViR3JpZC5vcHRzLnN0eWxlSW5IZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uc3ViR3JpZC5fdXBkYXRlU3R5bGVzKHRydWUpOyAvLyBmb3JjZSBjcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdy5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW55IHJlbWFpbmluZyBmaWVsZHMgYXJlIGFzc2lnbmVkLCBidXQgY2hlY2sgZm9yIGRyYWdnaW5nIGNoYW5nZXMsIHJlc2l6ZSBjb25zdHJhaW5cbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nICYmIG5ba2V5XSAhPT0gd1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ba2V5XSA9IHdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRkQ2hhbmdlZCA9IGRkQ2hhbmdlZCB8fCAoIXRoaXMub3B0cy5zdGF0aWNHcmlkICYmIChrZXkgPT09ICdub1Jlc2l6ZScgfHwga2V5ID09PSAnbm9Nb3ZlJyB8fCBrZXkgPT09ICdsb2NrZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVXRpbHMuc2FuaXRpemVNaW5NYXgobik7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IG1vdmUgdGhlIHdpZGdldFxuICAgICAgICAgICAgaWYgKG0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlKG4sIG0pO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHsgLy8gbW92ZSB3aWxsIG9ubHkgdXBkYXRlIHgseSx3LGggc28gdXBkYXRlIHRoZSByZXN0IHRvb1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlQXR0cihlbCwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vdmVOb2RlKG4sIG0pIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xlYW5Ob2RlcygpXG4gICAgICAgICAgICAuYmVnaW5VcGRhdGUobilcbiAgICAgICAgICAgIC5tb3ZlTm9kZShuLCBtKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICB0aGlzLmVuZ2luZS5lbmRVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3aWRnZXQgaGVpZ2h0IHRvIG1hdGNoIHRoZSBjb250ZW50IGhlaWdodCB0byBhdm9pZCB2LXNjcm9sbGJhciBvciBkZWFkIHNwYWNlLlxuICAgICAqIE5vdGU6IHRoaXMgYXNzdW1lcyBvbmx5IDEgY2hpbGQgdW5kZXIgcmVzaXplVG9Db250ZW50UGFyZW50PScuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnIChzaXplZCB0byBncmlkSXRlbSBtaW51cyBwYWRkaW5nKSB0aGF0IGlzIGF0IHRoZSBlbnRpcmUgY29udGVudCBzaXplIHdhbnRlZC5cbiAgICAgKiB1c2VBdHRyU2l6ZSBzZXQgdG8gdHJ1ZSBpZiBHcmlkU3RhY2tOb2RlLmggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBhY3R1YWwgY29udGFpbmVyIGhlaWdodCB3aGVuIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgYW5pbWF0aW9uIHRvIGZpbmlzaCB0byBnZXQgYWN0dWFsIERPTSBoZWlnaHRzXG4gICAgICovXG4gICAgcmVzaXplVG9Db250ZW50KGVsLCB1c2VBdHRyU2l6ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NpemUtdG8tY29udGVudC1tYXgnKTtcbiAgICAgICAgaWYgKCFlbC5jbGllbnRIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm47IC8vIDAgd2hlbiBoaWRkZW4sIHNraXBcbiAgICAgICAgbGV0IG4gPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGdyaWQgPSBuLmdyaWQ7XG4gICAgICAgIGlmICghZ3JpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVsLnBhcmVudEVsZW1lbnQgIT09IGdyaWQuZWwpXG4gICAgICAgICAgICByZXR1cm47IC8vIHNraXAgaWYgd2UgYXJlIG5vdCBpbnNpZGUgYSBncmlkXG4gICAgICAgIGNvbnN0IGNlbGwgPSBncmlkLmdldENlbGxIZWlnaHQoKTtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdXNlQXR0clNpemUgJiYgbi5oID8gbi5oICogY2VsbCA6IGVsLmNsaWVudEhlaWdodDsgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHNlZW0gdG8gZmxpY2tlciBiYWNrIGFuZCBmb3J0aFxuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKG4ucmVzaXplVG9Db250ZW50UGFyZW50KVxuICAgICAgICAgICAgaXRlbSA9IGVsLnF1ZXJ5U2VsZWN0b3Iobi5yZXNpemVUb0NvbnRlbnRQYXJlbnQpO1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICBpdGVtID0gZWwucXVlcnlTZWxlY3RvcihHcmlkU3RhY2sucmVzaXplVG9Db250ZW50UGFyZW50KTtcbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gZWwuY2xpZW50SGVpZ2h0IC0gaXRlbS5jbGllbnRIZWlnaHQ7IC8vIGZ1bGwgLSBhdmFpbGFibGUgaGVpZ2h0IHRvIG91ciBjaGlsZCAobWludXMgYm9yZGVyLCBwYWRkaW5nLi4uKVxuICAgICAgICBjb25zdCBpdGVtSCA9IHVzZUF0dHJTaXplICYmIG4uaCA/IG4uaCAqIGNlbGwgLSBwYWRkaW5nIDogaXRlbS5jbGllbnRIZWlnaHQ7IC8vIGNhbGN1bGF0ZWQgdG8gd2hhdCBjZWxsSGVpZ2h0IGlzIG9yIHdpbGwgYmVjb21lIChyYXRoZXIgdGhhbiBhY3R1YWwgdG8gcHJldmVudCB3YWl0aW5nIGZvciBhbmltYXRpb24gdG8gZmluaXNoKVxuICAgICAgICBsZXQgd2FudGVkSDtcbiAgICAgICAgaWYgKG4uc3ViR3JpZCkge1xuICAgICAgICAgICAgLy8gc3ViLWdyaWQgLSB1c2UgdGhlaXIgYWN0dWFsIHJvdyBjb3VudCAqIHRoZWlyIGNlbGwgaGVpZ2h0XG4gICAgICAgICAgICB3YW50ZWRIID0gbi5zdWJHcmlkLmdldFJvdygpICogbi5zdWJHcmlkLmdldENlbGxIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGNsaWVudEhlaWdodCAmIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGlzIHVuZGVmaW5lZCBmb3IgdGV4dCBhbmQgb3RoZXIgbGVhZiBub2Rlcy4gdXNlIDxkaXY+IGNvbnRhaW5lciFcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gaXRlbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3I6IHJlc2l6ZVRvQ29udGVudCgpICcke0dyaWRTdGFjay5yZXNpemVUb0NvbnRlbnRQYXJlbnR9Jy5maXJzdEVsZW1lbnRDaGlsZCBpcyBudWxsLCBtYWtlIHN1cmUgdG8gaGF2ZSBhIGRpdiBsaWtlIGNvbnRhaW5lci4gU2tpcHBpbmcgc2l6aW5nLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbnRlZEggPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgaXRlbUg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1IID09PSB3YW50ZWRIKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoZWlnaHQgKz0gd2FudGVkSCAtIGl0ZW1IO1xuICAgICAgICBsZXQgaCA9IE1hdGguY2VpbChoZWlnaHQgLyBjZWxsKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pbi9tYXggYW5kIHNwZWNpYWwgc2l6aW5nXG4gICAgICAgIGNvbnN0IHNvZnRNYXggPSBOdW1iZXIuaXNJbnRlZ2VyKG4uc2l6ZVRvQ29udGVudCkgPyBuLnNpemVUb0NvbnRlbnQgOiAwO1xuICAgICAgICBpZiAoc29mdE1heCAmJiBoID4gc29mdE1heCkge1xuICAgICAgICAgICAgaCA9IHNvZnRNYXg7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzaXplLXRvLWNvbnRlbnQtbWF4Jyk7IC8vIGdldCB2LXNjcm9sbCBiYWNrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4ubWluSCAmJiBoIDwgbi5taW5IKVxuICAgICAgICAgICAgaCA9IG4ubWluSDtcbiAgICAgICAgZWxzZSBpZiAobi5tYXhIICYmIGggPiBuLm1heEgpXG4gICAgICAgICAgICBoID0gbi5tYXhIO1xuICAgICAgICBpZiAoaCAhPT0gbi5oKSB7XG4gICAgICAgICAgICBncmlkLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBncmlkLm1vdmVOb2RlKG4sIHsgaCB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBncmlkLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogY2FsbCB0aGUgdXNlciByZXNpemUgKHNvIHRoZXkgY2FuIGRvIGV4dHJhIHdvcmspIGVsc2Ugb3VyIGJ1aWxkIGluIHZlcnNpb24gKi9cbiAgICByZXNpemVUb0NvbnRlbnRDaGVjayhlbCwgdXNlQXR0ciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChHcmlkU3RhY2sucmVzaXplVG9Db250ZW50Q0IpXG4gICAgICAgICAgICBHcmlkU3RhY2sucmVzaXplVG9Db250ZW50Q0IoZWwsIHVzZUF0dHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRvQ29udGVudChlbCwgdXNlQXR0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG1hcmdpbnMgd2hpY2ggd2lsbCBzZXQgYWxsIDQgc2lkZXMgYXQgb25jZSAtIHNlZSBgR3JpZFN0YWNrT3B0aW9ucy5tYXJnaW5gIGZvciBmb3JtYXQgb3B0aW9ucyAoQ1NTIHN0cmluZyBmb3JtYXQgb2YgMSwyLDQgdmFsdWVzIG9yIHNpbmdsZSBudW1iZXIpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBtYXJnaW4gdmFsdWVcbiAgICAgKi9cbiAgICBtYXJnaW4odmFsdWUpIHtcbiAgICAgICAgbGV0IGlzTXVsdGlWYWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnNwbGl0KCcgJykubGVuZ3RoID4gMSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBza2lwIHJlLWNyZWF0aW5nIG91ciBDU1MgZmlsZS4uLiB3b24ndCBjaGVjayBpZiBtdWx0aSB2YWx1ZXMgKHRvbyBtdWNoIGhhc3NsZSlcbiAgICAgICAgaWYgKCFpc011bHRpVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gVXRpbHMucGFyc2VIZWlnaHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5tYXJnaW5Vbml0ID09PSBkYXRhLnVuaXQgJiYgdGhpcy5vcHRzLm1hcmdpbiA9PT0gZGF0YS5oKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS11c2UgZXhpc3RpbmcgbWFyZ2luIGhhbmRsaW5nXG4gICAgICAgIHRoaXMub3B0cy5tYXJnaW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vcHRzLm1hcmdpblRvcCA9IHRoaXMub3B0cy5tYXJnaW5Cb3R0b20gPSB0aGlzLm9wdHMubWFyZ2luTGVmdCA9IHRoaXMub3B0cy5tYXJnaW5SaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5pdE1hcmdpbigpO1xuICAgICAgICB0aGlzLl91cGRhdGVTdHlsZXModHJ1ZSk7IC8vIHRydWUgPSBmb3JjZSByZS1jcmVhdGVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiByZXR1cm5zIGN1cnJlbnQgbWFyZ2luIG51bWJlciB2YWx1ZSAodW5kZWZpbmVkIGlmIDQgc2lkZXMgZG9uJ3QgbWF0Y2gpICovXG4gICAgZ2V0TWFyZ2luKCkgeyByZXR1cm4gdGhpcy5vcHRzLm1hcmdpbjsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaGVpZ2h0IG9mIHRoZSBncmlkIHdpbGwgYmUgbGVzcyB0aGFuIHRoZSB2ZXJ0aWNhbFxuICAgICAqIGNvbnN0cmFpbnQuIEFsd2F5cyByZXR1cm5zIHRydWUgaWYgZ3JpZCBkb2Vzbid0IGhhdmUgaGVpZ2h0IGNvbnN0cmFpbnQuXG4gICAgICogQHBhcmFtIG5vZGUgY29udGFpbnMgeCx5LHcsaCxhdXRvLXBvc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKGdyaWQud2lsbEl0Rml0KG5ld1dpZGdldCkpIHtcbiAgICAgKiAgIGdyaWQuYWRkV2lkZ2V0KG5ld1dpZGdldCk7XG4gICAgICogfSBlbHNlIHtcbiAgICAgKiAgIGFsZXJ0KCdOb3QgZW5vdWdoIGZyZWUgc3BhY2UgdG8gcGxhY2UgdGhlIHdpZGdldCcpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB3aWxsSXRGaXQobm9kZSkge1xuICAgICAgICAvLyBzdXBwb3J0IGxlZ2FjeSBjYWxsIGZvciBub3dcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay50czogYHdpbGxJdEZpdCh4LHksdyxoLGF1dG9Qb3NpdGlvbilgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgd2lsbEl0Rml0KHt4LCB5LC4uLn0pYC4gSXQgd2lsbCBiZSByZW1vdmVkIHNvb24nKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIGxldCBhID0gYXJndW1lbnRzLCBpID0gMCwgdyA9IHsgeDogYVtpKytdLCB5OiBhW2krK10sIHc6IGFbaSsrXSwgaDogYVtpKytdLCBhdXRvUG9zaXRpb246IGFbaSsrXSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lsbEl0Rml0KHcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS53aWxsSXRGaXQobm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckNoYW5nZUV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUuYmF0Y2hNb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IHRoaXMuZW5naW5lLmdldERpcnR5Tm9kZXModHJ1ZSk7IC8vIHZlcmlmeSB0aGV5IHJlYWxseSBjaGFuZ2VkXG4gICAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5sYXlvdXRzTm9kZXNDaGFuZ2UoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmdpbmUuc2F2ZUluaXRpYWwoKTsgLy8gd2UgY2FsbGVkLCBub3cgcmVzZXQgaW5pdGlhbCB2YWx1ZXMgJiBkaXJ0eSBmbGFnc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQWRkRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZ2luZS5iYXRjaE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLmFkZGVkTm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmxheW91dHNOb2Rlc0NoYW5nZSh0aGlzLmVuZ2luZS5hZGRlZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXZlbnQgYWRkZWQgbm9kZXMgZnJvbSBhbHNvIHRyaWdnZXJpbmcgJ2NoYW5nZScgZXZlbnQgKHdoaWNoIGlzIGNhbGxlZCBuZXh0KVxuICAgICAgICAgICAgdGhpcy5lbmdpbmUuYWRkZWROb2Rlcy5mb3JFYWNoKG4gPT4geyBkZWxldGUgbi5fZGlydHk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdhZGRlZCcsIHRoaXMuZW5naW5lLmFkZGVkTm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXJSZW1vdmVFdmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLmJhdGNoTW9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlZE5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgncmVtb3ZlZCcsIHRoaXMuZW5naW5lLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyRXZlbnQodHlwZSwgZGF0YSkge1xuICAgICAgICBsZXQgZXZlbnQgPSBkYXRhID8gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHsgYnViYmxlczogZmFsc2UsIGRldGFpbDogZGF0YSB9KSA6IG5ldyBFdmVudCh0eXBlKTtcbiAgICAgICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBkeW5hbWljIHN0eWxlIHNoZWV0IHVzZWQgZm9yIG91ciBsYXlvdXQgKi9cbiAgICBfcmVtb3ZlU3R5bGVzaGVldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgVXRpbHMucmVtb3ZlU3R5bGVzaGVldCh0aGlzLl9zdHlsZVNoZWV0Q2xhc3MpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0eWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCB1cGRhdGVkL2NyZWF0ZSB0aGUgQ1NTIHN0eWxlcyBmb3Igcm93IGJhc2VkIGxheW91dCBhbmQgaW5pdGlhbCBtYXJnaW4gc2V0dGluZyAqL1xuICAgIF91cGRhdGVTdHlsZXMoZm9yY2VVcGRhdGUgPSBmYWxzZSwgbWF4SCkge1xuICAgICAgICAvLyBjYWxsIHRvIGRlbGV0ZSBleGlzdGluZyBvbmUgaWYgd2UgY2hhbmdlIGNlbGxIZWlnaHQgLyBtYXJnaW5cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdHlsZXNoZWV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXhIKVxuICAgICAgICAgICAgbWF4SCA9IHRoaXMuZ2V0Um93KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICAvLyBpZiB1c2VyIGlzIHRlbGxpbmcgdXMgdGhleSB3aWxsIGhhbmRsZSB0aGUgQ1NTIHRoZW1zZWx2ZXMgYnkgc2V0dGluZyBoZWlnaHRzIHRvIDAuIERvIHdlIG5lZWQgdGhpcyBvcHRzIHJlYWxseSA/P1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNlbGxIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjZWxsSGVpZ2h0ID0gdGhpcy5vcHRzLmNlbGxIZWlnaHQ7XG4gICAgICAgIGxldCBjZWxsSGVpZ2h0VW5pdCA9IHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdDtcbiAgICAgICAgbGV0IHByZWZpeCA9IGAuJHt0aGlzLl9zdHlsZVNoZWV0Q2xhc3N9ID4gLiR7dGhpcy5vcHRzLml0ZW1DbGFzc31gO1xuICAgICAgICAvLyBjcmVhdGUgb25lIGFzIG5lZWRlZFxuICAgICAgICBpZiAoIXRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IHN0eWxlIHRvIHBhcmVudCAoaW5zdGVhZCBvZiAnaGVhZCcgYnkgZGVmYXVsdCkgdG8gc3VwcG9ydCBXZWJDb21wb25lbnRcbiAgICAgICAgICAgIGxldCBzdHlsZUxvY2F0aW9uID0gdGhpcy5vcHRzLnN0eWxlSW5IZWFkID8gdW5kZWZpbmVkIDogdGhpcy5lbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gVXRpbHMuY3JlYXRlU3R5bGVzaGVldCh0aGlzLl9zdHlsZVNoZWV0Q2xhc3MsIHN0eWxlTG9jYXRpb24sIHtcbiAgICAgICAgICAgICAgICBub25jZTogdGhpcy5vcHRzLm5vbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0eWxlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5fbWF4ID0gMDtcbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb25lIG9uY2Ugb25seVxuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIHByZWZpeCwgYGhlaWdodDogJHtjZWxsSGVpZ2h0fSR7Y2VsbEhlaWdodFVuaXR9YCk7XG4gICAgICAgICAgICAvLyBjb250ZW50IG1hcmdpbnNcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm9wdHMubWFyZ2luVG9wICsgdGhpcy5vcHRzLm1hcmdpblVuaXQ7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5vcHRzLm1hcmdpbkJvdHRvbSArIHRoaXMub3B0cy5tYXJnaW5Vbml0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5vcHRzLm1hcmdpblJpZ2h0ICsgdGhpcy5vcHRzLm1hcmdpblVuaXQ7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMub3B0cy5tYXJnaW5MZWZ0ICsgdGhpcy5vcHRzLm1hcmdpblVuaXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGAke3ByZWZpeH0gPiAuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnRgO1xuICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0gYC4ke3RoaXMuX3N0eWxlU2hlZXRDbGFzc30gPiAuZ3JpZC1zdGFjay1wbGFjZWhvbGRlciA+IC5wbGFjZWhvbGRlci1jb250ZW50YDtcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBjb250ZW50LCBgdG9wOiAke3RvcH07IHJpZ2h0OiAke3JpZ2h0fTsgYm90dG9tOiAke2JvdHRvbX07IGxlZnQ6ICR7bGVmdH07YCk7XG4gICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgcGxhY2Vob2xkZXIsIGB0b3A6ICR7dG9wfTsgcmlnaHQ6ICR7cmlnaHR9OyBib3R0b206ICR7Ym90dG9tfTsgbGVmdDogJHtsZWZ0fTtgKTtcbiAgICAgICAgICAgIC8vIHJlc2l6ZSBoYW5kbGVzIG9mZnNldCAodG8gbWF0Y2ggbWFyZ2luKVxuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIGAke3ByZWZpeH0gPiAudWktcmVzaXphYmxlLW5lYCwgYHJpZ2h0OiAke3JpZ2h0fWApO1xuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIGAke3ByZWZpeH0gPiAudWktcmVzaXphYmxlLWVgLCBgcmlnaHQ6ICR7cmlnaHR9YCk7XG4gICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgYCR7cHJlZml4fSA+IC51aS1yZXNpemFibGUtc2VgLCBgcmlnaHQ6ICR7cmlnaHR9OyBib3R0b206ICR7Ym90dG9tfWApO1xuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIGAke3ByZWZpeH0gPiAudWktcmVzaXphYmxlLW53YCwgYGxlZnQ6ICR7bGVmdH1gKTtcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9ID4gLnVpLXJlc2l6YWJsZS13YCwgYGxlZnQ6ICR7bGVmdH1gKTtcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9ID4gLnVpLXJlc2l6YWJsZS1zd2AsIGBsZWZ0OiAke2xlZnR9OyBib3R0b206ICR7Ym90dG9tfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyB1cGRhdGUgdGhlIGhlaWdodCBzcGVjaWZpYyBmaWVsZHNcbiAgICAgICAgbWF4SCA9IG1heEggfHwgdGhpcy5fc3R5bGVzLl9tYXg7XG4gICAgICAgIGlmIChtYXhIID4gdGhpcy5fc3R5bGVzLl9tYXgpIHtcbiAgICAgICAgICAgIGxldCBnZXRIZWlnaHQgPSAocm93cykgPT4gKGNlbGxIZWlnaHQgKiByb3dzKSArIGNlbGxIZWlnaHRVbml0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3N0eWxlcy5fbWF4ICsgMTsgaSA8PSBtYXhIOyBpKyspIHsgLy8gc3RhcnQgYXQgMVxuICAgICAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9W2dzLXk9XCIke2l9XCJdYCwgYHRvcDogJHtnZXRIZWlnaHQoaSl9YCk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIGAke3ByZWZpeH1bZ3MtaD1cIiR7aSArIDF9XCJdYCwgYGhlaWdodDogJHtnZXRIZWlnaHQoaSArIDEpfWApOyAvLyBzdGFydCBhdCAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMuX21heCA9IG1heEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlQ29udGFpbmVySGVpZ2h0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmJhdGNoTW9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudEdyaWRJdGVtO1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRSb3coKSArIHRoaXMuX2V4dHJhRHJhZ1JvdzsgLy8gdGhpcyBjaGVja3MgZm9yIG1pblJvdyBhbHJlYWR5XG4gICAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSB0aGlzLm9wdHMuY2VsbEhlaWdodDtcbiAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdDtcbiAgICAgICAgaWYgKCFjZWxsSGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjc3MgbWluIGhlaWdodCAobm9uIG5lc3RlZCBncmlkKS4gVE9ETzogc3VwcG9ydCBtaXNtYXRjaCwgc2F5OiBtaW4gJSB3aGlsZSB1bml0IGlzIHB4LlxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgY3NzTWluSGVpZ2h0ID0gVXRpbHMucGFyc2VIZWlnaHQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKVsnbWluSGVpZ2h0J10pO1xuICAgICAgICAgICAgaWYgKGNzc01pbkhlaWdodC5oID4gMCAmJiBjc3NNaW5IZWlnaHQudW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pblJvdyA9IE1hdGguZmxvb3IoY3NzTWluSGVpZ2h0LmggLyBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAocm93IDwgbWluUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IG1pblJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2dzLWN1cnJlbnQtcm93JywgU3RyaW5nKHJvdykpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtaW4taGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICAvLyBuZXN0ZWQgZ3JpZHMgaGF2ZSAnaW5zZXJ0OjAnIHRvIGZpbGwgdGhlIHNwYWNlIG9mIHBhcmVudCBieSBkZWZhdWx0LCBidXQgd2UgbWF5IGJlIHRhbGxlciBzbyB1c2UgbWluLWhlaWdodCBmb3IgcG9zc2libGUgc2Nyb2xsYmFyc1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZVtwYXJlbnQgPyAnbWluSGVpZ2h0JyA6ICdoZWlnaHQnXSA9IHJvdyAqIGNlbGxIZWlnaHQgKyB1bml0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIGEgbmVzdGVkIGdyaWQgaW5zaWRlIGFuIHNpemVUb0NvbnRlbnQgaXRlbSwgdGVsbCBpdCB0byByZXNpemUgaXRzZWxmIHRvb1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuZ3JpZC5lbmdpbmUuYmF0Y2hNb2RlICYmIFV0aWxzLnNob3VsZFNpemVUb0NvbnRlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50LmdyaWQucmVzaXplVG9Db250ZW50Q2hlY2socGFyZW50LmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wcmVwYXJlRWxlbWVudChlbCwgdHJpZ2dlckFkZEV2ZW50ID0gZmFsc2UsIG5vZGUpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdHMuaXRlbUNsYXNzKTtcbiAgICAgICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5fcmVhZEF0dHIoZWwpO1xuICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gbm9kZTtcbiAgICAgICAgbm9kZS5lbCA9IGVsO1xuICAgICAgICBub2RlLmdyaWQgPSB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHsgLi4ubm9kZSB9O1xuICAgICAgICBub2RlID0gdGhpcy5lbmdpbmUuYWRkTm9kZShub2RlLCB0cmlnZ2VyQWRkRXZlbnQpO1xuICAgICAgICAvLyB3cml0ZSBub2RlIGF0dHIgYmFjayBpbiBjYXNlIHRoZXJlIHdhcyBjb2xsaXNpb24gb3Igd2UgaGF2ZSB0byBmaXggYmFkIHZhbHVlcyBkdXJpbmcgYWRkTm9kZSgpXG4gICAgICAgIGlmICghVXRpbHMuc2FtZShub2RlLCBjb3B5KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVBdHRyKGVsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuc2hvdWxkU2l6ZVRvQ29udGVudChub2RlKSlcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3NpemUtdG8tY29udGVudCcpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGwgdG8gd3JpdGUgcG9zaXRpb24geCx5LHcsaCBhdHRyaWJ1dGVzIGJhY2sgdG8gZWxlbWVudCAqL1xuICAgIF93cml0ZVBvc0F0dHIoZWwsIG4pIHtcbiAgICAgICAgaWYgKG4ueCAhPT0gdW5kZWZpbmVkICYmIG4ueCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdncy14JywgU3RyaW5nKG4ueCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLnkgIT09IHVuZGVmaW5lZCAmJiBuLnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZ3MteScsIFN0cmluZyhuLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBuLncgPiAxID8gZWwuc2V0QXR0cmlidXRlKCdncy13JywgU3RyaW5nKG4udykpIDogZWwucmVtb3ZlQXR0cmlidXRlKCdncy13Jyk7XG4gICAgICAgIG4uaCA+IDEgPyBlbC5zZXRBdHRyaWJ1dGUoJ2dzLWgnLCBTdHJpbmcobi5oKSkgOiBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2dzLWgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbCB0byB3cml0ZSBhbnkgZGVmYXVsdCBhdHRyaWJ1dGVzIGJhY2sgdG8gZWxlbWVudCAqL1xuICAgIF93cml0ZUF0dHIoZWwsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuX3dyaXRlUG9zQXR0cihlbCwgbm9kZSk7XG4gICAgICAgIGxldCBhdHRycyAvKjogR3JpZFN0YWNrV2lkZ2V0IGJ1dCBzdHJpbmdzICovID0ge1xuICAgICAgICAgICAgYXV0b1Bvc2l0aW9uOiAnZ3MtYXV0by1wb3NpdGlvbicsXG4gICAgICAgICAgICBub1Jlc2l6ZTogJ2dzLW5vLXJlc2l6ZScsXG4gICAgICAgICAgICBub01vdmU6ICdncy1uby1tb3ZlJyxcbiAgICAgICAgICAgIGxvY2tlZDogJ2dzLWxvY2tlZCcsXG4gICAgICAgICAgICBpZDogJ2dzLWlkJyxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChub2RlW2tleV0pIHsgLy8gMCBpcyB2YWxpZCBmb3IgeCx5IG9ubHkgYnV0IGRvbmUgYWJvdmUgYWxyZWFkeSBhbmQgbm90IGluIGxpc3QgYW55d2F5XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJzW2tleV0sIFN0cmluZyhub2RlW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsIHRvIHJlYWQgYW55IGRlZmF1bHQgYXR0cmlidXRlcyBmcm9tIGVsZW1lbnQgKi9cbiAgICBfcmVhZEF0dHIoZWwsIGNsZWFyRGVmYXVsdEF0dHIgPSB0cnVlKSB7XG4gICAgICAgIGxldCBuID0ge307XG4gICAgICAgIG4ueCA9IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MteCcpKTtcbiAgICAgICAgbi55ID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy15JykpO1xuICAgICAgICBuLncgPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLXcnKSk7XG4gICAgICAgIG4uaCA9IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MtaCcpKTtcbiAgICAgICAgbi5hdXRvUG9zaXRpb24gPSBVdGlscy50b0Jvb2woZWwuZ2V0QXR0cmlidXRlKCdncy1hdXRvLXBvc2l0aW9uJykpO1xuICAgICAgICBuLm5vUmVzaXplID0gVXRpbHMudG9Cb29sKGVsLmdldEF0dHJpYnV0ZSgnZ3Mtbm8tcmVzaXplJykpO1xuICAgICAgICBuLm5vTW92ZSA9IFV0aWxzLnRvQm9vbChlbC5nZXRBdHRyaWJ1dGUoJ2dzLW5vLW1vdmUnKSk7XG4gICAgICAgIG4ubG9ja2VkID0gVXRpbHMudG9Cb29sKGVsLmdldEF0dHJpYnV0ZSgnZ3MtbG9ja2VkJykpO1xuICAgICAgICBuLmlkID0gZWwuZ2V0QXR0cmlidXRlKCdncy1pZCcpO1xuICAgICAgICAvLyByZWFkIGJ1dCBuZXZlciB3cml0dGVuIG91dFxuICAgICAgICBuLm1heFcgPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLW1heC13JykpO1xuICAgICAgICBuLm1pblcgPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLW1pbi13JykpO1xuICAgICAgICBuLm1heEggPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLW1heC1oJykpO1xuICAgICAgICBuLm1pbkggPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLW1pbi1oJykpO1xuICAgICAgICAvLyB2OC54IG9wdGltaXphdGlvbiB0byByZWR1Y2UgdW4tbmVlZGVkIGF0dHIgdGhhdCBkb24ndCByZW5kZXIgb3IgYXJlIGRlZmF1bHQgQ1NTXG4gICAgICAgIGlmIChjbGVhckRlZmF1bHRBdHRyKSB7XG4gICAgICAgICAgICBpZiAobi53ID09PSAxKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtdycpO1xuICAgICAgICAgICAgaWYgKG4uaCA9PT0gMSlcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2dzLWgnKTtcbiAgICAgICAgICAgIGlmIChuLm1heFcpXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdncy1tYXgtdycpO1xuICAgICAgICAgICAgaWYgKG4ubWluVylcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2dzLW1pbi13Jyk7XG4gICAgICAgICAgICBpZiAobi5tYXhIKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtbWF4LWgnKTtcbiAgICAgICAgICAgIGlmIChuLm1pbkgpXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdncy1taW4taCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBhbnkga2V5IG5vdCBmb3VuZCAobnVsbCBvciBmYWxzZSB3aGljaCBpcyBkZWZhdWx0KVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICBpZiAoIW4uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIW5ba2V5XSAmJiBuW2tleV0gIT09IDApIHsgLy8gMCBjYW4gYmUgdmFsaWQgdmFsdWUgKHgseSBvbmx5IHJlYWxseSlcbiAgICAgICAgICAgICAgICBkZWxldGUgbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldFN0YXRpY0NsYXNzKCkge1xuICAgICAgICBsZXQgY2xhc3NlcyA9IFsnZ3JpZC1zdGFjay1zdGF0aWMnXTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gICAgICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZ3Mtc3RhdGljJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdncy1zdGF0aWMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gd2UgYXJlIGJlaW5nIHJlc2l6ZWQgLSBjaGVjayBpZiB0aGUgb25lIENvbHVtbiBNb2RlIG5lZWRzIHRvIGJlIHR1cm5lZCBvbi9vZmZcbiAgICAgKiBhbmQgcmVtZW1iZXIgdGhlIHByZXYgY29sdW1ucyB3ZSB1c2VkLCBvciBnZXQgb3VyIGNvdW50IGZyb20gcGFyZW50LCBhcyB3ZWxsIGFzIGNoZWNrIGZvciBjZWxsSGVpZ2h0PT09J2F1dG8nIChzcXVhcmUpXG4gICAgICogb3IgYHNpemVUb0NvbnRlbnRgIGdyaWRJdGVtIG9wdGlvbnMuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbD8uY2xpZW50V2lkdGgpXG4gICAgICAgICAgICByZXR1cm47IC8vIHJldHVybiBpZiB3ZSdyZSBnb25lIG9yIG5vIHNpemUgeWV0ICh3aWxsIGdldCBjYWxsZWQgYWdhaW4pXG4gICAgICAgIGlmICh0aGlzLnByZXZXaWR0aCA9PT0gdGhpcy5lbC5jbGllbnRXaWR0aClcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm8tb3BcbiAgICAgICAgdGhpcy5wcmV2V2lkdGggPSB0aGlzLmVsLmNsaWVudFdpZHRoO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnb25SZXNpemUgJywgdGhpcy5lbC5jbGllbnRXaWR0aCk7XG4gICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoKTtcbiAgICAgICAgLy8gc2VlIGlmIHdlJ3JlIG5lc3RlZCBhbmQgdGFrZSBvdXIgY29sdW1uIGNvdW50IGZyb20gb3VyIHBhcmVudC4uLi5cbiAgICAgICAgbGV0IGNvbHVtbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9Db2x1bW4gJiYgdGhpcy5wYXJlbnRHcmlkSXRlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jb2x1bW4gIT09IHRoaXMucGFyZW50R3JpZEl0ZW0udykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uKHRoaXMucGFyZW50R3JpZEl0ZW0udywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UgY2hlY2sgZm9yIDEgY29sdW1uIGluL291dCBiZWhhdmlvclxuICAgICAgICAgICAgbGV0IG9uZUNvbHVtbiA9ICF0aGlzLm9wdHMuZGlzYWJsZU9uZUNvbHVtbk1vZGUgJiYgdGhpcy5lbC5jbGllbnRXaWR0aCA8PSB0aGlzLm9wdHMub25lQ29sdW1uU2l6ZSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLm9wdHMuY29sdW1uID09PSAxICYmICF0aGlzLl9wcmV2Q29sdW1uKTtcbiAgICAgICAgICAgIGlmICgodGhpcy5vcHRzLmNvbHVtbiA9PT0gMSkgIT09IG9uZUNvbHVtbikge1xuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdHMuYW5pbWF0ZSkgdGhpcy5zZXRBbmltYXRpb24oZmFsc2UpOyAvLyAxIDwtPiAxMiBpcyB0b28gcmFkaWNhbCwgdHVybiBvZmYgYW5pbWF0aW9uIGFuZCB3ZSBuZWVkIGl0IGZvciBzaXplVG9Db250ZW50XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ob25lQ29sdW1uID8gMSA6IHRoaXMuX3ByZXZDb2x1bW4pO1xuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdHMuYW5pbWF0ZSkgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldEFuaW1hdGlvbih0cnVlKSk7XG4gICAgICAgICAgICAgICAgY29sdW1uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgY2VsbHMgY29udGVudCBzcXVhcmUgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuX2lzQXV0b0NlbGxIZWlnaHQpXG4gICAgICAgICAgICB0aGlzLmNlbGxIZWlnaHQoKTtcbiAgICAgICAgLy8gdXBkYXRlIGFueSBuZXN0ZWQgZ3JpZHMsIG9yIGl0ZW1zIHNpemVcbiAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmIChuLnN1YkdyaWQpXG4gICAgICAgICAgICAgICAgbi5zdWJHcmlkLm9uUmVzaXplKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuX3NraXBJbml0aWFsUmVzaXplKVxuICAgICAgICAgICAgdGhpcy5kb0NvbnRlbnRSZXNpemUoY29sdW1uQ2hhbmdlZCk7IC8vIHdhaXQgZm9yIGFuaW0gb2YgY29sdW1uIGNoYW5nZWQgKERPTSByZWZsb3cgYmVmb3JlIHdlIGNhbiBzaXplIGNvcnJlY3RseSlcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NraXBJbml0aWFsUmVzaXplO1xuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRvQ29udGVudFJlc2l6ZShkZWxheSA9IHRydWUsIHVzZUF0dHIgPSBmYWxzZSwgbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1cGRhdGUgYW55IGdyaWRJdGVtIGhlaWdodCB3aXRoIHNpemVUb0NvbnRlbnQsIGJ1dCB3YWl0IGZvciBET00gJGFuaW1hdGlvbl9zcGVlZCB0byBzZXR0bGUgaWYgd2UgY2hhbmdlZCBjb2x1bW4gY291bnRcbiAgICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSB3YXkgdG8ga25vdyB3aGF0IHRoZSBmaW5hbCAocG9zdCBhbmltYXRpb24pIHNpemUgb2YgdGhlIGNvbnRlbnQgd2lsbCBiZSBzbyB3ZSBjYW4gYW5pbWF0ZSB0aGUgY29sdW1uIHdpZHRoIGFuZCBoZWlnaHQgdG9nZXRoZXIgcmF0aGVyIHRoYW4gc2VxdWVudGlhbGx5ID9cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5zaG91bGRTaXplVG9Db250ZW50KG4pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRvQ29udGVudENoZWNrKG4uZWwsIHVzZUF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbmdpbmUubm9kZXMuc29tZShuID0+IFV0aWxzLnNob3VsZFNpemVUb0NvbnRlbnQobikpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBbLi4udGhpcy5lbmdpbmUubm9kZXNdOyAvLyBpbiBjYXNlIG9yZGVyIGNoYW5nZXMgd2hpbGUgcmVzaXppbmcgb25lXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlscy5zaG91bGRTaXplVG9Db250ZW50KG4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUb0NvbnRlbnRDaGVjayhuLmVsLCB1c2VBdHRyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgdGhpcyByZWdhcmRsZXNzIG9mIHNob3VsZFNpemVUb0NvbnRlbnQgYmVjYXVzZSB3aWRnZXQgbWlnaHQgbmVlZCB0byBzdHJldGNoIHRvIHRha2UgYXZhaWxhYmxlIHNwYWNlIGFmdGVyIGEgcmVzaXplXG4gICAgICAgICAgICBpZiAodGhpcy5fZ3NFdmVudEhhbmRsZXJbJ3Jlc2l6ZWNvbnRlbnQnXSlcbiAgICAgICAgICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlclsncmVzaXplY29udGVudCddKG51bGwsIG4gPyBbbl0gOiB0aGlzLmVuZ2luZS5ub2Rlcyk7XG4gICAgICAgIH0sIGRlbGF5ID8gMzAwICsgMTAgOiAwKTtcbiAgICB9XG4gICAgLyoqIGFkZCBvciByZW1vdmUgdGhlIGdyaWQgZWxlbWVudCBzaXplIGV2ZW50IGhhbmRsZXIgKi9cbiAgICBfdXBkYXRlUmVzaXplRXZlbnQoZm9yY2VSZW1vdmUgPSBmYWxzZSkge1xuICAgICAgICAvLyBvbmx5IGFkZCBldmVudCBpZiB3ZSdyZSBub3QgbmVzdGVkIChwYXJlbnQgd2lsbCBjYWxsIHVzKSBhbmQgd2UncmUgYXV0byBzaXppbmcgY2VsbHMgb3Igc3VwcG9ydGluZyBvbmVDb2x1bW4gKGkuZS4gZG9pbmcgd29yaylcbiAgICAgICAgLy8gb3Igc3VwcG9ydGluZyBuZXcgc2l6ZVRvQ29udGVudCBvcHRpb24uXG4gICAgICAgIGNvbnN0IHRyYWNrU2l6ZSA9ICF0aGlzLnBhcmVudEdyaWRJdGVtICYmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0IHx8IHRoaXMub3B0cy5zaXplVG9Db250ZW50IHx8ICF0aGlzLm9wdHMuZGlzYWJsZU9uZUNvbHVtbk1vZGVcbiAgICAgICAgICAgIHx8IHRoaXMuZW5naW5lLm5vZGVzLmZpbmQobiA9PiBuLnNpemVUb0NvbnRlbnQpKTtcbiAgICAgICAgaWYgKCFmb3JjZVJlbW92ZSAmJiB0cmFja1NpemUgJiYgIXRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemVUaHJvdHRsZSA9IFV0aWxzLnRocm90dGxlKCgpID0+IHRoaXMub25SZXNpemUoKSwgdGhpcy5vcHRzLmNlbGxIZWlnaHRUaHJvdHRsZSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMuX3NpemVUaHJvdHRsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuX3NraXBJbml0aWFsUmVzaXplID0gdHJ1ZTsgLy8gbWFrZVdpZGdldCB3aWxsIG9yaWdpbmFsbHkgaGF2ZSBjYWxsZWQgb24gc3RhcnR1cFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChmb3JjZVJlbW92ZSB8fCAhdHJhY2tTaXplKSAmJiB0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc2l6ZU9ic2VydmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NpemVUaHJvdHRsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjb252ZXJ0IGEgcG90ZW50aWFsIHNlbGVjdG9yIGludG8gYWN0dWFsIGVsZW1lbnQgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudChlbHMgPSAnLmdyaWQtc3RhY2staXRlbScpIHsgcmV0dXJuIFV0aWxzLmdldEVsZW1lbnQoZWxzKTsgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudHMoZWxzID0gJy5ncmlkLXN0YWNrLWl0ZW0nKSB7IHJldHVybiBVdGlscy5nZXRFbGVtZW50cyhlbHMpOyB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBnZXRHcmlkRWxlbWVudChlbHMpIHsgcmV0dXJuIEdyaWRTdGFjay5nZXRFbGVtZW50KGVscyk7IH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGdldEdyaWRFbGVtZW50cyhlbHMpIHsgcmV0dXJuIFV0aWxzLmdldEVsZW1lbnRzKGVscyk7IH1cbiAgICAvKiogQGludGVybmFsIGluaXRpYWxpemUgbWFyZ2luIHRvcC9ib3R0b20vbGVmdC9yaWdodCBhbmQgdW5pdHMgKi9cbiAgICBfaW5pdE1hcmdpbigpIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBtYXJnaW4gPSAwO1xuICAgICAgICAvLyBzdXBwb3J0IHBhc3NpbmcgbXVsdGlwbGUgdmFsdWVzIGxpa2UgQ1NTIChleDogJzVweCAxMHB4IDAgMjBweCcpXG4gICAgICAgIGxldCBtYXJnaW5zID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcmdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1hcmdpbnMgPSB0aGlzLm9wdHMubWFyZ2luLnNwbGl0KCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmdpbnMubGVuZ3RoID09PSAyKSB7IC8vIHRvcC9ib3QsIGxlZnQvcmlnaHQgbGlrZSBDU1NcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Ub3AgPSB0aGlzLm9wdHMubWFyZ2luQm90dG9tID0gbWFyZ2luc1swXTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5MZWZ0ID0gdGhpcy5vcHRzLm1hcmdpblJpZ2h0ID0gbWFyZ2luc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJnaW5zLmxlbmd0aCA9PT0gNCkgeyAvLyBDbG9ja3dpc2UgbGlrZSBDU1NcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Ub3AgPSBtYXJnaW5zWzBdO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpblJpZ2h0ID0gbWFyZ2luc1sxXTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Cb3R0b20gPSBtYXJnaW5zWzJdO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpbkxlZnQgPSBtYXJnaW5zWzNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHRoaXMub3B0cy5tYXJnaW4pO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpblVuaXQgPSBkYXRhLnVuaXQ7XG4gICAgICAgICAgICBtYXJnaW4gPSB0aGlzLm9wdHMubWFyZ2luID0gZGF0YS5oO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0b3AvYm90dG9tL2xlZnQvcmlnaHQgbmVlZCB0byBiZSBzZXQgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy5vcHRzLm1hcmdpblRvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luVG9wID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHRoaXMub3B0cy5tYXJnaW5Ub3ApO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpblRvcCA9IGRhdGEuaDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdHMubWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMubWFyZ2luQm90dG9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Cb3R0b20gPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gVXRpbHMucGFyc2VIZWlnaHQodGhpcy5vcHRzLm1hcmdpbkJvdHRvbSk7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luQm90dG9tID0gZGF0YS5oO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0cy5tYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5tYXJnaW5SaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luUmlnaHQgPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gVXRpbHMucGFyc2VIZWlnaHQodGhpcy5vcHRzLm1hcmdpblJpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5SaWdodCA9IGRhdGEuaDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdHMubWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMubWFyZ2luTGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luTGVmdCA9IG1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBVdGlscy5wYXJzZUhlaWdodCh0aGlzLm9wdHMubWFyZ2luTGVmdCk7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luTGVmdCA9IGRhdGEuaDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdHMubWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0cy5tYXJnaW5Vbml0ID0gZGF0YS51bml0OyAvLyBpbiBjYXNlIHNpZGUgd2VyZSBzcGVsbGVkIG91dCwgdXNlIHRob3NlIHVuaXRzIGluc3RlYWQuLi5cbiAgICAgICAgaWYgKHRoaXMub3B0cy5tYXJnaW5Ub3AgPT09IHRoaXMub3B0cy5tYXJnaW5Cb3R0b20gJiYgdGhpcy5vcHRzLm1hcmdpbkxlZnQgPT09IHRoaXMub3B0cy5tYXJnaW5SaWdodCAmJiB0aGlzLm9wdHMubWFyZ2luVG9wID09PSB0aGlzLm9wdHMubWFyZ2luUmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW4gPSB0aGlzLm9wdHMubWFyZ2luVG9wOyAvLyBtYWtlcyBpdCBlYXNpZXIgdG8gY2hlY2sgZm9yIG5vLW9wcyBpbiBzZXRNYXJnaW4oKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogZHJhZyZkcm9wIG1ldGhvZHMgdGhhdCB1c2VkIHRvIGJlIHN0dWJiZWQgb3V0IGFuZCBpbXBsZW1lbnRlZCBpbiBkZC1ncmlkc3RhY2sudHNcbiAgICAgKiBidXQgY2F1c2VkIGxvYWRpbmcgaXNzdWVzIGluIHByb2QgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyaWRzdGFjay9ncmlkc3RhY2suanMvaXNzdWVzLzIwMzlcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICovXG4gICAgLyoqIGdldCB0aGUgZ2xvYmFsIChidXQgc3RhdGljIHRvIHRoaXMgY29kZSkgREQgaW1wbGVtZW50YXRpb24gKi9cbiAgICBzdGF0aWMgZ2V0REQoKSB7XG4gICAgICAgIHJldHVybiBkZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbCB0byBzZXR1cCBkcmFnZ2luZyBpbiBmcm9tIHRoZSBvdXRzaWRlIChzYXkgdG9vbGJhciksIGJ5IHNwZWNpZnlpbmcgdGhlIGNsYXNzIHNlbGVjdGlvbiBhbmQgb3B0aW9ucy5cbiAgICAgKiBDYWxsZWQgZHVyaW5nIEdyaWRTdGFjay5pbml0KCkgYXMgb3B0aW9ucywgYnV0IGNhbiBhbHNvIGJlIGNhbGxlZCBkaXJlY3RseSAobGFzdCBwYXJhbSBhcmUgdXNlZCkgaW4gY2FzZSB0aGUgdG9vbGJhclxuICAgICAqIGlzIGR5bmFtaWNhbGx5IGNyZWF0ZSBhbmQgbmVlZHMgdG8gYmUgc2V0IGxhdGVyLlxuICAgICAqIEBwYXJhbSBkcmFnSW4gc3RyaW5nIHNlbGVjdG9yIChleDogJy5zaWRlYmFyIC5ncmlkLXN0YWNrLWl0ZW0nKSBvciBsaXN0IG9mIGRvbSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSBkcmFnSW5PcHRpb25zIG9wdGlvbnMgLSBzZWUgREREcmFnSW5PcHQuIChkZWZhdWx0OiB7aGFuZGxlOiAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JywgYXBwZW5kVG86ICdib2R5J31cbiAgICAgKiBAcGFyYW0gcm9vdCBvcHRpb25hbCByb290IHdoaWNoIGRlZmF1bHRzIHRvIGRvY3VtZW50IChmb3Igc2hhZG93IGRvbSBwYXMgdGhlIHBhcmVudCBIVE1MRG9jdW1lbnQpXG4gICAgICovXG4gICAgc3RhdGljIHNldHVwRHJhZ0luKGRyYWdJbiwgZHJhZ0luT3B0aW9ucywgcm9vdCA9IGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChkcmFnSW5PcHRpb25zPy5wYXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBERE1hbmFnZXIucGF1c2VEcmFnID0gZHJhZ0luT3B0aW9ucy5wYXVzZTtcbiAgICAgICAgfVxuICAgICAgICBkcmFnSW5PcHRpb25zID0geyAuLi5kcmFnSW5EZWZhdWx0T3B0aW9ucywgLi4uKGRyYWdJbk9wdGlvbnMgfHwge30pIH07XG4gICAgICAgIGxldCBlbHMgPSAodHlwZW9mIGRyYWdJbiA9PT0gJ3N0cmluZycpID8gVXRpbHMuZ2V0RWxlbWVudHMoZHJhZ0luLCByb290KSA6IGRyYWdJbjtcbiAgICAgICAgaWYgKGVscy5sZW5ndGgpXG4gICAgICAgICAgICBlbHM/LmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGQuaXNEcmFnZ2FibGUoZWwpKVxuICAgICAgICAgICAgICAgICAgICBkZC5kcmFnSW4oZWwsIGRyYWdJbk9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvRGlzYWJsZXMgZHJhZ2dpbmcgYnkgdGhlIHVzZXIgb2Ygc3BlY2lmaWMgZ3JpZCBlbGVtZW50LiBJZiB5b3Ugd2FudCBhbGwgaXRlbXMsIGFuZCBoYXZlIGl0IGFmZmVjdCBmdXR1cmUgaXRlbXMsIHVzZSBlbmFibGVNb3ZlKCkgaW5zdGVhZC4gTm8tb3AgZm9yIHN0YXRpYyBncmlkcy5cbiAgICAgKiBJRiB5b3UgYXJlIGxvb2tpbmcgdG8gcHJldmVudCBhbiBpdGVtIGZyb20gbW92aW5nIChkdWUgdG8gYmVpbmcgcHVzaGVkIGFyb3VuZCBieSBhbm90aGVyIGR1cmluZyBjb2xsaXNpb24pIHVzZSBsb2NrZWQgcHJvcGVydHkgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gZWxzIHdpZGdldCBvciBzZWxlY3RvciB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHZhbCBpZiB0cnVlIHdpZGdldCB3aWxsIGJlIGRyYWdnYWJsZSwgYXNzdW1pbmcgdGhlIHBhcmVudCBncmlkIGlzbid0IG5vTW92ZSBvciBzdGF0aWMuXG4gICAgICovXG4gICAgbW92YWJsZShlbHMsIHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3QgbW92ZSBhIHN0YXRpYyBncmlkIVxuICAgICAgICBHcmlkU3RhY2suZ2V0RWxlbWVudHMoZWxzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGxldCBuID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIGlmICghbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YWwgPyBkZWxldGUgbi5ub01vdmUgOiBuLm5vTW92ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobik7IC8vIGluaXQgREQgaWYgbmVlZCBiZSwgYW5kIGFkanVzdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvRGlzYWJsZXMgdXNlciByZXNpemluZyBvZiBzcGVjaWZpYyBncmlkIGVsZW1lbnQuIElmIHlvdSB3YW50IGFsbCBpdGVtcywgYW5kIGhhdmUgaXQgYWZmZWN0IGZ1dHVyZSBpdGVtcywgdXNlIGVuYWJsZVJlc2l6ZSgpIGluc3RlYWQuIE5vLW9wIGZvciBzdGF0aWMgZ3JpZHMuXG4gICAgICogQHBhcmFtIGVscyAgd2lkZ2V0IG9yIHNlbGVjdG9yIHRvIG1vZGlmeVxuICAgICAqIEBwYXJhbSB2YWwgIGlmIHRydWUgd2lkZ2V0IHdpbGwgYmUgcmVzaXphYmxlLCBhc3N1bWluZyB0aGUgcGFyZW50IGdyaWQgaXNuJ3Qgbm9SZXNpemUgb3Igc3RhdGljLlxuICAgICAqL1xuICAgIHJlc2l6YWJsZShlbHMsIHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3QgcmVzaXplIGEgc3RhdGljIGdyaWQhXG4gICAgICAgIEdyaWRTdGFjay5nZXRFbGVtZW50cyhlbHMpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgbGV0IG4gPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhbCA/IGRlbGV0ZSBuLm5vUmVzaXplIDogbi5ub1Jlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobik7IC8vIGluaXQgREQgaWYgbmVlZCBiZSwgYW5kIGFkanVzdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IGRpc2FibGVzIHdpZGdldHMgbW92aW5nL3Jlc2l6aW5nLlxuICAgICAqIElmIHlvdSB3YW50IGEgbW9yZSBwZXJtYW5lbnQgd2F5ICh3aGljaCBmcmVlemVzIHVwIHJlc291cmNlcykgdXNlIGBzZXRTdGF0aWModHJ1ZSlgIGluc3RlYWQuXG4gICAgICogTm90ZTogbm8tb3AgZm9yIHN0YXRpYyBncmlkXG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvcjpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBncmlkLmVuYWJsZU1vdmUoZmFsc2UpO1xuICAgICAqICBncmlkLmVuYWJsZVJlc2l6ZShmYWxzZSk7XG4gICAgICogQHBhcmFtIHJlY3Vyc2UgdHJ1ZSAoZGVmYXVsdCkgaWYgc3ViLWdyaWRzIGFsc28gZ2V0IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBkaXNhYmxlKHJlY3Vyc2UgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuc3RhdGljR3JpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lbmFibGVNb3ZlKGZhbHNlLCByZWN1cnNlKTtcbiAgICAgICAgdGhpcy5lbmFibGVSZXNpemUoZmFsc2UsIHJlY3Vyc2UpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ2Rpc2FibGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLWVuYWJsZXMgd2lkZ2V0cyBtb3ZpbmcvcmVzaXppbmcgLSBzZWUgZGlzYWJsZSgpLlxuICAgICAqIE5vdGU6IG5vLW9wIGZvciBzdGF0aWMgZ3JpZC5cbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yOlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGdyaWQuZW5hYmxlTW92ZSh0cnVlKTtcbiAgICAgKiAgZ3JpZC5lbmFibGVSZXNpemUodHJ1ZSk7XG4gICAgICogQHBhcmFtIHJlY3Vyc2UgdHJ1ZSAoZGVmYXVsdCkgaWYgc3ViLWdyaWRzIGFsc28gZ2V0IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBlbmFibGUocmVjdXJzZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVuYWJsZU1vdmUodHJ1ZSwgcmVjdXJzZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlUmVzaXplKHRydWUsIHJlY3Vyc2UpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ2VuYWJsZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcy9kaXNhYmxlcyB3aWRnZXQgbW92aW5nLiBOby1vcCBmb3Igc3RhdGljIGdyaWRzLCBhbmQgbG9jYWxseSBkZWZpbmVkIGl0ZW1zIHN0aWxsIG92ZXJydWxlXG4gICAgICogQHBhcmFtIHJlY3Vyc2UgdHJ1ZSAoZGVmYXVsdCkgaWYgc3ViLWdyaWRzIGFsc28gZ2V0IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBlbmFibGVNb3ZlKGRvRW5hYmxlLCByZWN1cnNlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3QgbW92ZSBhIHN0YXRpYyBncmlkIVxuICAgICAgICBkb0VuYWJsZSA/IGRlbGV0ZSB0aGlzLm9wdHMuZGlzYWJsZURyYWcgOiB0aGlzLm9wdHMuZGlzYWJsZURyYWcgPSB0cnVlOyAvLyBGSVJTVCBiZWZvcmUgd2UgdXBkYXRlIGNoaWxkcmVuIGFzIGdyaWQgb3ZlcnJpZGVzICMxNjU4XG4gICAgICAgIHRoaXMuZW5naW5lLm5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobik7XG4gICAgICAgICAgICBpZiAobi5zdWJHcmlkICYmIHJlY3Vyc2UpXG4gICAgICAgICAgICAgICAgbi5zdWJHcmlkLmVuYWJsZU1vdmUoZG9FbmFibGUsIHJlY3Vyc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgd2lkZ2V0IHJlc2l6aW5nLiBOby1vcCBmb3Igc3RhdGljIGdyaWRzLlxuICAgICAqIEBwYXJhbSByZWN1cnNlIHRydWUgKGRlZmF1bHQpIGlmIHN1Yi1ncmlkcyBhbHNvIGdldCB1cGRhdGVkXG4gICAgICovXG4gICAgZW5hYmxlUmVzaXplKGRvRW5hYmxlLCByZWN1cnNlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3Qgc2l6ZSBhIHN0YXRpYyBncmlkIVxuICAgICAgICBkb0VuYWJsZSA/IGRlbGV0ZSB0aGlzLm9wdHMuZGlzYWJsZVJlc2l6ZSA6IHRoaXMub3B0cy5kaXNhYmxlUmVzaXplID0gdHJ1ZTsgLy8gRklSU1QgYmVmb3JlIHdlIHVwZGF0ZSBjaGlsZHJlbiBhcyBncmlkIG92ZXJyaWRlcyAjMTY1OFxuICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pO1xuICAgICAgICAgICAgaWYgKG4uc3ViR3JpZCAmJiByZWN1cnNlKVxuICAgICAgICAgICAgICAgIG4uc3ViR3JpZC5lbmFibGVSZXNpemUoZG9FbmFibGUsIHJlY3Vyc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVtb3ZlcyBhbnkgZHJhZyZkcm9wIHByZXNlbnQgKGNhbGxlZCBkdXJpbmcgZGVzdHJveSkgKi9cbiAgICBfcmVtb3ZlREQoZWwpIHtcbiAgICAgICAgZGQuZHJhZ2dhYmxlKGVsLCAnZGVzdHJveScpLnJlc2l6YWJsZShlbCwgJ2Rlc3Ryb3knKTtcbiAgICAgICAgaWYgKGVsLmdyaWRzdGFja05vZGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5ncmlkc3RhY2tOb2RlLl9pbml0REQ7IC8vIHJlc2V0IG91ciBERCBpbml0IGZsYWdcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZWwuZGRFbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsZWQgdG8gYWRkIGRyYWcgb3ZlciB0byBzdXBwb3J0IHdpZGdldHMgYmVpbmcgYWRkZWQgZXh0ZXJuYWxseSAqL1xuICAgIF9zZXR1cEFjY2VwdFdpZGdldCgpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkaXNhYmxlIHRoaW5nc1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQgfHwgKCF0aGlzLm9wdHMuYWNjZXB0V2lkZ2V0cyAmJiAhdGhpcy5vcHRzLnJlbW92YWJsZSkpIHtcbiAgICAgICAgICAgIGRkLmRyb3BwYWJsZSh0aGlzLmVsLCAnZGVzdHJveScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFycyBzaGFyZWQgYWNyb3NzIGFsbCBtZXRob2RzXG4gICAgICAgIGxldCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGg7XG4gICAgICAgIGxldCBvbkRyYWcgPSAoZXZlbnQsIGVsLCBoZWxwZXIpID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoZWxwZXIgPSBoZWxwZXIgfHwgZWw7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxldCB7IHRvcCwgbGVmdCB9ID0gaGVscGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGVmdCAtPSBwYXJlbnQubGVmdDtcbiAgICAgICAgICAgIHRvcCAtPSBwYXJlbnQudG9wO1xuICAgICAgICAgICAgbGV0IHVpID0geyBwb3NpdGlvbjogeyB0b3AsIGxlZnQgfSB9O1xuICAgICAgICAgICAgaWYgKG5vZGUuX3RlbXBvcmFyeVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGxlZnQgLyBjZWxsV2lkdGgpKTtcbiAgICAgICAgICAgICAgICBub2RlLnkgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRvcCAvIGNlbGxIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5hdXRvUG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUubm9kZUJvdW5kRml4KG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFjY2VwdCAqaW5pdGlhbCogbG9jYXRpb24gaWYgZG9lc24ndCBmaXQgIzE0MTkgKGxvY2tlZCBkcm9wIHJlZ2lvbiwgb3IgY2FuJ3QgZ3JvdyksIGJ1dCBtYXliZSB0cnkgaWYgaXQgd2lsbCBnbyBzb21ld2hlcmVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5naW5lLndpbGxJdEZpdChub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmF1dG9Qb3NpdGlvbiA9IHRydWU7IC8vIGlnbm9yZSB4LHkgYW5kIHRyeSBmb3IgYW55IHNsb3QuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuZ2luZS53aWxsSXRGaXQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLm9mZihlbCwgJ2RyYWcnKTsgLy8gc3RvcCBjYWxsaW5nIHVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGZ1bGwgZ3JpZCBvciBjYW4ndCBncm93XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuX3dpbGxGaXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgYXV0byBwb3NpdGlvbiBpbnN0ZWFkICMxNjg3XG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5jb3B5UG9zKG5vZGUsIG5vZGUuX3dpbGxGaXRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX3dpbGxGaXRQb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmUtdXNlIHRoZSBleGlzdGluZyBub2RlIGRyYWdnaW5nIG1ldGhvZFxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRNb3ZpbmcoaGVscGVyLCBldmVudCwgdWksIG5vZGUsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZS11c2UgdGhlIGV4aXN0aW5nIG5vZGUgZHJhZ2dpbmcgdGhhdCBkb2VzIHNvIG11Y2ggb2YgdGhlIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnT3JSZXNpemUoaGVscGVyLCBldmVudCwgdWksIG5vZGUsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRkLmRyb3BwYWJsZSh0aGlzLmVsLCB7XG4gICAgICAgICAgICBhY2NlcHQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgYWNjZXB0IGRyb3AgdG8gdHJ1ZSBvbiBvdXJzZWxmICh3aGljaCB3ZSBpZ25vcmUpIHNvIHdlIGRvbid0IGdldCBcImNhbid0IGRyb3BcIiBpY29uIGluIEhUTUw1IG1vZGUgd2hpbGUgbW92aW5nXG4gICAgICAgICAgICAgICAgaWYgKG5vZGU/LmdyaWQgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLmFjY2VwdFdpZGdldHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgYWNjZXB0IG1ldGhvZCBvciBjbGFzcyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgIGxldCBjYW5BY2NlcHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmFjY2VwdFdpZGdldHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuQWNjZXB0ID0gdGhpcy5vcHRzLmFjY2VwdFdpZGdldHMoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gKHRoaXMub3B0cy5hY2NlcHRXaWRnZXRzID09PSB0cnVlID8gJy5ncmlkLXN0YWNrLWl0ZW0nIDogdGhpcy5vcHRzLmFjY2VwdFdpZGdldHMpO1xuICAgICAgICAgICAgICAgICAgICBjYW5BY2NlcHQgPSBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmluYWxseSBjaGVjayB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBzcGFjZSBsZWZ0ICMxNTcxXG4gICAgICAgICAgICAgICAgaWYgKGNhbkFjY2VwdCAmJiBub2RlICYmIHRoaXMub3B0cy5tYXhSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSB7IHc6IG5vZGUudywgaDogbm9kZS5oLCBtaW5XOiBub2RlLm1pblcsIG1pbkg6IG5vZGUubWluSCB9OyAvLyBvbmx5IHdpZHRoL2hlaWdodCBtYXR0ZXJzIGFuZCBhdXRvUG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY2FuQWNjZXB0ID0gdGhpcy5lbmdpbmUud2lsbEl0Rml0KG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuQWNjZXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBlbnRlcmluZyBvdXIgZ3JpZCBhcmVhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC5vbih0aGlzLmVsLCAnZHJvcG92ZXInLCAoZXZlbnQsIGVsLCBoZWxwZXIpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBvdmVyICR7dGhpcy5lbC5ncmlkc3RhY2sub3B0cy5pZH0gJHtjb3VudCsrfWApOyAvLyBURVNUXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZHJvcCBlbnRlciBvbiBvdXJzZWxmICh1bmxlc3Mgd2UgdGVtcG9yYXJpbHkgcmVtb3ZlZCkgd2hpY2ggaGFwcGVucyBvbiBhIHNpbXBsZSBkcmFnIG9mIG91ciBpdGVtXG4gICAgICAgICAgICBpZiAobm9kZT8uZ3JpZCA9PT0gdGhpcyAmJiAhbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBub2RlLl9hZGRlZDsgLy8gcmVzZXQgdGhpcyB0byB0cmFjayBwbGFjZWhvbGRlciBhZ2FpbiBpbiBjYXNlIHdlIHdlcmUgb3ZlciBvdGhlciBncmlkICMxNDg0IChkcm9wb3V0IGRvZXNuJ3QgYWx3YXlzIGNsZWFyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBwYXJlbnQgZnJvbSByZWNlaXZpbmcgbXNnICh3aGljaCBtYXkgYmUgYSBncmlkIGFzIHdlbGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXggIzE1Nzggd2hlbiBkcmFnZ2luZyBmYXN0LCB3ZSBtYXkgbm90IGdldCBhIGxlYXZlIG9uIHRoZSBwcmV2aW91cyBncmlkIHNvIGZvcmNlIG9uZSBub3dcbiAgICAgICAgICAgIGlmIChub2RlPy5ncmlkICYmIG5vZGUuZ3JpZCAhPT0gdGhpcyAmJiAhbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcm9wb3ZlciB3aXRob3V0IGxlYXZlJyk7IC8vIFRFU1RcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJHcmlkID0gbm9kZS5ncmlkO1xuICAgICAgICAgICAgICAgIG90aGVyR3JpZC5fbGVhdmUoZWwsIGhlbHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWNoZSBjZWxsIGRpbWVuc2lvbnMgKHdoaWNoIGRvbid0IGNoYW5nZSksIHBvc2l0aW9uIGNhbiBhbmltYXRlIGlmIHdlIHJlbW92ZWQgYW4gaXRlbSBpbiBvdGhlckdyaWQgdGhhdCBhZmZlY3RzIHVzLi4uXG4gICAgICAgICAgICBjZWxsV2lkdGggPSB0aGlzLmNlbGxXaWR0aCgpO1xuICAgICAgICAgICAgY2VsbEhlaWdodCA9IHRoaXMuZ2V0Q2VsbEhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgIC8vIGxvYWQgYW55IGVsZW1lbnQgYXR0cmlidXRlcyBpZiB3ZSBkb24ndCBoYXZlIGEgbm9kZVxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuX3JlYWRBdHRyKGVsLCBmYWxzZSk7IC8vIGRvbid0IHdpcGUgZXh0ZXJuYWwgKGUuZy4gZHJhZyB0b29sYmFyKSBhdHRyICMyMzU0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUuZ3JpZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX2lzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsLmdyaWRzdGFja05vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBncmlkIHNpemUgYmFzZWQgb24gZWxlbWVudCBvdXRlciBzaXplXG4gICAgICAgICAgICBoZWxwZXIgPSBoZWxwZXIgfHwgZWw7XG4gICAgICAgICAgICBsZXQgdyA9IG5vZGUudyB8fCBNYXRoLnJvdW5kKGhlbHBlci5vZmZzZXRXaWR0aCAvIGNlbGxXaWR0aCkgfHwgMTtcbiAgICAgICAgICAgIGxldCBoID0gbm9kZS5oIHx8IE1hdGgucm91bmQoaGVscGVyLm9mZnNldEhlaWdodCAvIGNlbGxIZWlnaHQpIHx8IDE7XG4gICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBjYW1lIGZyb20gYW5vdGhlciBncmlkLCBtYWtlIGEgY29weSBhbmQgc2F2ZSB0aGUgb3JpZ2luYWwgaW5mbyBpbiBjYXNlIHdlIGdvIGJhY2sgdGhlcmVcbiAgICAgICAgICAgIGlmIChub2RlLmdyaWQgJiYgbm9kZS5ncmlkICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgbm9kZSBvcmlnaW5hbCB2YWx1ZXMgKG1pbi9tYXgvaWQvZXRjLi4uKSBidXQgb3ZlcnJpZGUgd2lkdGgvaGVpZ2h0L290aGVyIGZsYWdzIHdoaWNoIGFyZSB0aGlzIGdyaWQgc3BlY2lmaWNcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZHJvcG92ZXIgY2xvbmluZyBub2RlJyk7IC8vIFRFU1RcbiAgICAgICAgICAgICAgICBpZiAoIWVsLl9ncmlkc3RhY2tOb2RlT3JpZylcbiAgICAgICAgICAgICAgICAgICAgZWwuX2dyaWRzdGFja05vZGVPcmlnID0gbm9kZTsgLy8gc2hvdWxkbid0IGhhdmUgbXVsdGlwbGUgbmVzdGVkIVxuICAgICAgICAgICAgICAgIGVsLmdyaWRzdGFja05vZGUgPSBub2RlID0geyAuLi5ub2RlLCB3LCBoLCBncmlkOiB0aGlzIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUueDtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS55O1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmNsZWFudXBOb2RlKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5ub2RlQm91bmRGaXgobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzb21lIGludGVybmFsIGZpZWxkcyB3ZSBuZWVkIGFmdGVyIGNsZWFyaW5nIHRoZW0gYWxsXG4gICAgICAgICAgICAgICAgbm9kZS5faW5pdEREID1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5faXNFeHRlcm5hbCA9IC8vIERPTSBuZWVkcyB0byBiZSByZS1wYXJlbnRlZCBvbiBhIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX3RlbXBvcmFyeVJlbW92ZWQgPSB0cnVlOyAvLyBzbyBpdCBjYW4gYmUgaW5zZXJ0ZWQgb25EcmFnIGJlbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLncgPSB3O1xuICAgICAgICAgICAgICAgIG5vZGUuaCA9IGg7XG4gICAgICAgICAgICAgICAgbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZCA9IHRydWU7IC8vIHNvIHdlIGNhbiBpbnNlcnQgaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGFueSBtYXJrZWQgZm9yIGNvbXBsZXRlIHJlbW92YWwgKE5vdGU6IGRvbid0IGNoZWNrIF9pc0Fib3V0VG9SZW1vdmUgYXMgdGhhdCBpcyBjbGVhcmVkIGFib3ZlIC0ganVzdCBkbyBpdClcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1SZW1vdmluZyhub2RlLmVsLCBmYWxzZSk7XG4gICAgICAgICAgICBkZC5vbihlbCwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoaXMgaXMgY2FsbGVkIGF0IGxlYXN0IG9uY2Ugd2hlbiBnb2luZyBmYXN0ICMxNTc4XG4gICAgICAgICAgICBvbkRyYWcoZXZlbnQsIGVsLCBoZWxwZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwcmV2ZW50IHBhcmVudCBmcm9tIHJlY2VpdmluZyBtc2cgKHdoaWNoIG1heSBiZSBhIGdyaWQgYXMgd2VsbClcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVhdmluZyBvdXIgZ3JpZCBhcmVhLi4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC5vbih0aGlzLmVsLCAnZHJvcG91dCcsIChldmVudCwgZWwsIGhlbHBlcikgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYG91dCAke3RoaXMuZWwuZ3JpZHN0YWNrLm9wdHMuaWR9ICR7Y291bnQrK31gKTsgLy8gVEVTVFxuICAgICAgICAgICAgbGV0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIGZpeCAjMTU3OCB3aGVuIGRyYWdnaW5nIGZhc3QsIHdlIG1pZ2h0IGdldCBsZWF2ZSBhZnRlciBvdGhlciBncmlkIGdldHMgZW50ZXIgKHdoaWNoIGNhbGxzIHVzIHRvIGNsZWFuKVxuICAgICAgICAgICAgLy8gc28gc2tpcCB0aGlzIG9uZSBpZiB3ZSdyZSBub3QgdGhlIGFjdGl2ZSBncmlkIHJlYWxseS4uXG4gICAgICAgICAgICBpZiAoIW5vZGUuZ3JpZCB8fCBub2RlLmdyaWQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWF2ZShlbCwgaGVscGVyKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSB3ZXJlIGNyZWF0ZWQgYXMgdGVtcG9yYXJ5IG5lc3RlZCBncmlkLCBnbyBiYWNrIHRvIGJlZm9yZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBc1N1YkdyaWQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwcmV2ZW50IHBhcmVudCBmcm9tIHJlY2VpdmluZyBtc2cgKHdoaWNoIG1heSBiZSBncmlkIGFzIHdlbGwpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGVuZCAtIHJlbGVhc2luZyB0aGUgbW91c2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLm9uKHRoaXMuZWwsICdkcm9wJywgKGV2ZW50LCBlbCwgaGVscGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZHJvcCBvbiBvdXJzZWxmIGZyb20gb3Vyc2VsZiB0aGF0IGRpZG4ndCBjb21lIGZyb20gdGhlIG91dHNpZGUgLSBkcmFnZW5kIHdpbGwgaGFuZGxlIHRoZSBzaW1wbGUgbW92ZSBpbnN0ZWFkXG4gICAgICAgICAgICBpZiAobm9kZT8uZ3JpZCA9PT0gdGhpcyAmJiAhbm9kZS5faXNFeHRlcm5hbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgd2FzQWRkZWQgPSAhIXRoaXMucGxhY2Vob2xkZXIucGFyZW50RWxlbWVudDsgLy8gc2tpcCBpdGVtcyBub3QgYWN0dWFsbHkgYWRkZWQgdG8gdXMgYmVjYXVzZSBvZiBjb25zdHJhaW5zLCBidXQgZG8gY2xlYW51cCAjMTQxOVxuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIG5vdGlmeSBwcmV2aW91cyBncmlkIG9mIHJlbW92YWxcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcm9wIGRlbGV0ZSBfZ3JpZHN0YWNrTm9kZU9yaWcnKSAvLyBURVNUXG4gICAgICAgICAgICBsZXQgb3JpZ05vZGUgPSBlbC5fZ3JpZHN0YWNrTm9kZU9yaWc7XG4gICAgICAgICAgICBkZWxldGUgZWwuX2dyaWRzdGFja05vZGVPcmlnO1xuICAgICAgICAgICAgaWYgKHdhc0FkZGVkICYmIG9yaWdOb2RlPy5ncmlkICYmIG9yaWdOb2RlLmdyaWQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgb0dyaWQgPSBvcmlnTm9kZS5ncmlkO1xuICAgICAgICAgICAgICAgIG9HcmlkLmVuZ2luZS5yZW1vdmVOb2RlRnJvbUxheW91dENhY2hlKG9yaWdOb2RlKTtcbiAgICAgICAgICAgICAgICBvR3JpZC5lbmdpbmUucmVtb3ZlZE5vZGVzLnB1c2gob3JpZ05vZGUpO1xuICAgICAgICAgICAgICAgIG9HcmlkLl90cmlnZ2VyUmVtb3ZlRXZlbnQoKS5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBlbXB0eSBzdWItZ3JpZCB0aGF0IGdvdCBhdXRvLWNyZWF0ZWQsIG51a2UgaXRcbiAgICAgICAgICAgICAgICBpZiAob0dyaWQucGFyZW50R3JpZEl0ZW0gJiYgIW9HcmlkLmVuZ2luZS5ub2Rlcy5sZW5ndGggJiYgb0dyaWQub3B0cy5zdWJHcmlkRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICBvR3JpZC5yZW1vdmVBc1N1YkdyaWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gdXNlIGV4aXN0aW5nIHBsYWNlaG9sZGVyIG5vZGUgYXMgaXQncyBhbHJlYWR5IGluIG91ciBsaXN0IHdpdGggZHJvcCBsb2NhdGlvblxuICAgICAgICAgICAgaWYgKHdhc0FkZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2xlYW51cE5vZGUobm9kZSk7IC8vIHJlbW92ZXMgYWxsIGludGVybmFsIF94eXogdmFsdWVzXG4gICAgICAgICAgICAgICAgbm9kZS5ncmlkID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRkLm9mZihlbCwgJ2RyYWcnKTtcbiAgICAgICAgICAgIC8vIGlmIHdlIG1hZGUgYSBjb3B5ICgnaGVscGVyJyB3aGljaCBpcyB0ZW1wKSBvZiB0aGUgb3JpZ2luYWwgbm9kZSB0aGVuIGluc2VydCBhIGNvcHksIGVsc2Ugd2UgbW92ZSB0aGUgb3JpZ2luYWwgbm9kZSAoIzExMDIpXG4gICAgICAgICAgICAvLyBhcyB0aGUgaGVscGVyIHdpbGwgYmUgbnVrZWQgYnkganF1ZXJ5LXVpIG90aGVyd2lzZS4gVE9ETzogdXBkYXRlIG9sZCBjb2RlIHBhdGhcbiAgICAgICAgICAgIGlmIChoZWxwZXIgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsLmdyaWRzdGFja05vZGUgPSBvcmlnTm9kZTsgLy8gb3JpZ2luYWwgaXRlbSAobGVmdCBiZWhpbmQpIGlzIHJlLXN0b3JlZCB0byBwcmUgZHJhZ2dpbmcgYXMgdGhlIG5vZGUgbm93IGhhcyBkcm9wIGluZm9cbiAgICAgICAgICAgICAgICBpZiAod2FzQWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlKCk7IC8vIHJlZHVjZSBmbGlja2VyIGFzIHdlIGNoYW5nZSBkZXB0aCBoZXJlLCBhbmQgc2l6ZSBmdXJ0aGVyIGRvd25cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVERChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdhc0FkZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGVsLmdyaWRzdGFja05vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5lbCA9IGVsO1xuICAgICAgICAgICAgbGV0IHN1YkdyaWQgPSBub2RlLnN1YkdyaWQ/LmVsPy5ncmlkc3RhY2s7IC8vIHNldCB3aGVuIGFjdHVhbCBzdWItZ3JpZCBwcmVzZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBVdGlscy5jb3B5UG9zKG5vZGUsIHRoaXMuX3JlYWRBdHRyKHRoaXMucGxhY2Vob2xkZXIpKTsgLy8gcGxhY2Vob2xkZXIgdmFsdWVzIGFzIG1vdmluZyBWRVJZIGZhc3QgY2FuIHRocm93IHRoaW5ncyBvZmYgIzE1NzhcbiAgICAgICAgICAgIFV0aWxzLnJlbW92ZVBvc2l0aW9uaW5nU3R5bGVzKGVsKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fd3JpdGVBdHRyKGVsLCBub2RlKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoZ3JpZERlZmF1bHRzLml0ZW1DbGFzcywgdGhpcy5vcHRzLml0ZW1DbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTsgLy8gQHRzLWlnbm9yZSAvLyBUT0RPOiBub3cgd291bGQgYmUgaWRlYWwgdGltZSB0byBfcmVtb3ZlSGVscGVyU3R5bGUoKSBvdmVycmlkaW5nIGZsb2F0aW5nIHN0eWxlcyAobmF0aXZlIG9ubHkpXG4gICAgICAgICAgICBpZiAoc3ViR3JpZCkge1xuICAgICAgICAgICAgICAgIHN1YkdyaWQucGFyZW50R3JpZEl0ZW0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmICghc3ViR3JpZC5vcHRzLnN0eWxlSW5IZWFkKVxuICAgICAgICAgICAgICAgICAgICBzdWJHcmlkLl91cGRhdGVTdHlsZXModHJ1ZSk7IC8vIHJlLWNyZWF0ZSBzdWItZ3JpZCBzdHlsZXMgbm93IHRoYXQgd2UndmUgbW92ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuYWRkZWROb2Rlcy5wdXNoKG5vZGUpOyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQWRkRXZlbnQoKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5lbmRVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nc0V2ZW50SGFuZGxlclsnZHJvcHBlZCddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbJ2Ryb3BwZWQnXSh7IC4uLmV2ZW50LCB0eXBlOiAnZHJvcHBlZCcgfSwgb3JpZ05vZGUgJiYgb3JpZ05vZGUuZ3JpZCA/IG9yaWdOb2RlIDogdW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdhaXQgdGlsbCB3ZSByZXR1cm4gb3V0IG9mIHRoZSBkcmFnIGNhbGxiYWNrIHRvIHNldCB0aGUgbmV3IGRyYWcmcmVzaXplIGhhbmRsZXIgb3IgdGhleSBtYXkgZ2V0IG1lc3NlZCB1cFxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElGRiB3ZSBhcmUgc3RpbGwgdGhlcmUgKHNvbWUgYXBwbGljYXRpb24gd2lsbCB1c2UgYXMgcGxhY2Vob2xkZXIgYW5kIGluc2VydCB0aGVpciByZWFsIHdpZGdldCBpbnN0ZWFkIGFuZCBiZXR0ZXIgY2FsbCBtYWtlV2lkZ2V0KCkpXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZWwgJiYgbm9kZS5lbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmdyaWQuX2lzVGVtcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwcmV2ZW50IHBhcmVudCBmcm9tIHJlY2VpdmluZyBtc2cgKHdoaWNoIG1heSBiZSBncmlkIGFzIHdlbGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBtYXJrIGl0ZW0gZm9yIHJlbW92YWwgKi9cbiAgICBfaXRlbVJlbW92aW5nKGVsLCByZW1vdmUpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBlbCA/IGVsLmdyaWRzdGFja05vZGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5ncmlkIHx8IGVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdHMucmVtb3ZhYmxlT3B0aW9ucy5kZWNsaW5lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVtb3ZlID8gbm9kZS5faXNBYm91dFRvUmVtb3ZlID0gdHJ1ZSA6IGRlbGV0ZSBub2RlLl9pc0Fib3V0VG9SZW1vdmU7XG4gICAgICAgIHJlbW92ZSA/IGVsLmNsYXNzTGlzdC5hZGQoJ2dyaWQtc3RhY2staXRlbS1yZW1vdmluZycpIDogZWwuY2xhc3NMaXN0LnJlbW92ZSgnZ3JpZC1zdGFjay1pdGVtLXJlbW92aW5nJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHRvIHNldHVwIGEgdHJhc2ggZHJvcCB6b25lIGlmIHRoZSB1c2VyIHNwZWNpZmllcyBpdCAqL1xuICAgIF9zZXR1cFJlbW92ZURyb3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLnN0YXRpY0dyaWQgJiYgdHlwZW9mIHRoaXMub3B0cy5yZW1vdmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgdHJhc2hFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRzLnJlbW92YWJsZSk7XG4gICAgICAgICAgICBpZiAoIXRyYXNoRWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIE9ORSBkcm9wLW92ZXIvZHJvcG91dCBjYWxsYmFjayBmb3IgdGhlICd0cmFzaCcsIGFuZCBpdCB3aWxsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhc3NlZCBpbiBpdGVtIGFuZCBwYXJlbnQgZ3JpZCBiZWNhdXNlIHRoZSAndHJhc2gnIGlzIGEgc2hhcmVkIHJlc291cmNlIGFueXdheSxcbiAgICAgICAgICAgIC8vIGFuZCBOYXRpdmUgREQgb25seSBoYXMgMSBldmVudCBDQiAoaGF2aW5nIGEgbGlzdCBhbmQgdGVjaG5pY2FsbHkgYSBwZXIgZ3JpZCByZW1vdmFibGVPcHRpb25zIGNvbXBsaWNhdGVzIHRoaW5ncyBncmVhdGx5KVxuICAgICAgICAgICAgaWYgKCFkZC5pc0Ryb3BwYWJsZSh0cmFzaEVsKSkge1xuICAgICAgICAgICAgICAgIGRkLmRyb3BwYWJsZSh0cmFzaEVsLCB0aGlzLm9wdHMucmVtb3ZhYmxlT3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLm9uKHRyYXNoRWwsICdkcm9wb3ZlcicsIChldmVudCwgZWwpID0+IHRoaXMuX2l0ZW1SZW1vdmluZyhlbCwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgICAgIC5vbih0cmFzaEVsLCAnZHJvcG91dCcsIChldmVudCwgZWwpID0+IHRoaXMuX2l0ZW1SZW1vdmluZyhlbCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBwcmVwYXJlcyB0aGUgZWxlbWVudCBmb3IgZHJhZyZkcm9wICovXG4gICAgX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCBlbCA9IG5vZGUuZWw7XG4gICAgICAgIGNvbnN0IG5vTW92ZSA9IG5vZGUubm9Nb3ZlIHx8IHRoaXMub3B0cy5kaXNhYmxlRHJhZztcbiAgICAgICAgY29uc3Qgbm9SZXNpemUgPSBub2RlLm5vUmVzaXplIHx8IHRoaXMub3B0cy5kaXNhYmxlUmVzaXplO1xuICAgICAgICAvLyBjaGVjayBmb3IgZGlzYWJsZWQgZ3JpZCBmaXJzdFxuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQgfHwgKG5vTW92ZSAmJiBub1Jlc2l6ZSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLl9pbml0REQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVERChlbCk7IC8vIG51a2VzIGV2ZXJ5dGhpbmcgaW5zdGVhZCBvZiBqdXN0IGRpc2FibGUsIHdpbGwgYWRkIHNvbWUgc3R5bGVzIGJhY2sgbmV4dFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9pbml0REQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd1aS1kcmFnZ2FibGUtZGlzYWJsZWQnLCAndWktcmVzaXphYmxlLWRpc2FibGVkJyk7IC8vIGFkZCBzdHlsZXMgb25lIG1pZ2h0IGRlcGVuZCBvbiAjMTQzNVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLl9pbml0REQpIHtcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlcyB1c2VkL2Nhc2hlZCBiZXR3ZWVuIHRoZSAzIHN0YXJ0L21vdmUvZW5kIG1ldGhvZHMsIGluIGFkZGl0aW9uIHRvIG5vZGUgcGFzc2VkIGFib3ZlXG4gICAgICAgICAgICBsZXQgY2VsbFdpZHRoO1xuICAgICAgICAgICAgbGV0IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICAvKiogY2FsbGVkIHdoZW4gaXRlbSBzdGFydHMgbW92aW5nL3Jlc2l6aW5nICovXG4gICAgICAgICAgICBsZXQgb25TdGFydE1vdmluZyA9IChldmVudCwgdWkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGFueSAnZHJhZ3N0YXJ0JyAvICdyZXNpemVzdGFydCcgbWFudWFsbHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ3NFdmVudEhhbmRsZXJbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbZXZlbnQudHlwZV0oZXZlbnQsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCA9IHRoaXMuY2VsbFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCA9IHRoaXMuZ2V0Q2VsbEhlaWdodCh0cnVlKTsgLy8gZm9yY2UgcGl4ZWxzIGZvciBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0TW92aW5nKGVsLCBldmVudCwgdWksIG5vZGUsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqIGNhbGxlZCB3aGVuIGl0ZW0gaXMgYmVpbmcgZHJhZ2dlZC9yZXNpemVkICovXG4gICAgICAgICAgICBsZXQgZHJhZ09yUmVzaXplID0gKGV2ZW50LCB1aSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdPclJlc2l6ZShlbCwgZXZlbnQsIHVpLCBub2RlLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBjYWxsZWQgd2hlbiB0aGUgaXRlbSBzdG9wcyBtb3ZpbmcvcmVzaXppbmcgKi9cbiAgICAgICAgICAgIGxldCBvbkVuZE1vdmluZyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX21vdmluZztcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5fZXZlbnQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX2xhc3RUcmllZDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBoYXMgbW92ZWQgdG8gYW5vdGhlciBncmlkLCB3ZSdyZSBkb25lIGhlcmVcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmdyaWRzdGFja05vZGUgfHwgdGFyZ2V0LmdyaWRzdGFja05vZGUuZ3JpZCAhPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5vZGUuZWwgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX2lzQWJvdXRUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JpZCA9IGVsLmdyaWRzdGFja05vZGUuZ3JpZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQuX2dzRXZlbnRIYW5kbGVyW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXShldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmlkLmVuZ2luZS5ub2Rlcy5wdXNoKG5vZGUpOyAvLyB0ZW1wIGFkZCBpdCBiYWNrIHNvIHdlIGNhbiBwcm9wZXIgcmVtb3ZlIGl0IG5leHRcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5yZW1vdmVXaWRnZXQoZWwsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMucmVtb3ZlUG9zaXRpb25pbmdTdHlsZXModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuX3RlbXBvcmFyeVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvdCByZW1vdmVkIC0gcmVzdG9yZSBpdGVtIGJhY2sgdG8gYmVmb3JlIGRyYWdnaW5nIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5jb3B5UG9zKG5vZGUsIG5vZGUuX29yaWcpOyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVBvc0F0dHIodGFyZ2V0LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmFkZE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIG5ldyBwbGFjZWhvbGRlciBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVQb3NBdHRyKHRhcmdldCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dzRXZlbnRIYW5kbGVyW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXShldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0cmFEcmFnUm93ID0gMDsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpOyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUuZW5kVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdyZXNpemVzdG9wJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihub2RlLnNpemVUb0NvbnRlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zaXplVG9Db250ZW50ID0gbm9kZS5oOyAvLyBuZXcgc29mdCBsaW1pdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvQ29udGVudFJlc2l6ZShmYWxzZSwgdHJ1ZSwgbm9kZSk7IC8vIG5vIGFtaW4gd2FpdCBhcyB3aWxsIHVzZSB0aGUgYWN0dWFsIHNpemVkIGNvb3JkaW5hdGUgYXR0clxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZC5kcmFnZ2FibGUoZWwsIHtcbiAgICAgICAgICAgICAgICBzdGFydDogb25TdGFydE1vdmluZyxcbiAgICAgICAgICAgICAgICBzdG9wOiBvbkVuZE1vdmluZyxcbiAgICAgICAgICAgICAgICBkcmFnOiBkcmFnT3JSZXNpemVcbiAgICAgICAgICAgIH0pLnJlc2l6YWJsZShlbCwge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBvblN0YXJ0TW92aW5nLFxuICAgICAgICAgICAgICAgIHN0b3A6IG9uRW5kTW92aW5nLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogZHJhZ09yUmVzaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUuX2luaXRERCA9IHRydWU7IC8vIHdlJ3ZlIHNldCBERCBzdXBwb3J0IG5vd1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmFsbHkgZmluZSB0dW5lIG1vdmUgdnMgcmVzaXplIGJ5IGRpc2FibGluZyBhbnkgcGFydC4uLlxuICAgICAgICBkZC5kcmFnZ2FibGUoZWwsIG5vTW92ZSA/ICdkaXNhYmxlJyA6ICdlbmFibGUnKVxuICAgICAgICAgICAgLnJlc2l6YWJsZShlbCwgbm9SZXNpemUgPyAnZGlzYWJsZScgOiAnZW5hYmxlJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGhhbmRsZXMgYWN0dWFsIGRyYWcvcmVzaXplIHN0YXJ0ICovXG4gICAgX29uU3RhcnRNb3ZpbmcoZWwsIGV2ZW50LCB1aSwgbm9kZSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsZWFuTm9kZXMoKVxuICAgICAgICAgICAgLmJlZ2luVXBkYXRlKG5vZGUpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuX3dyaXRlUG9zQXR0cih0aGlzLnBsYWNlaG9sZGVyLCBub2RlKTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19vblN0YXJ0TW92aW5nIHBsYWNlaG9sZGVyJykgLy8gVEVTVFxuICAgICAgICBub2RlLmVsID0gdGhpcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgbm9kZS5fbGFzdFVpUG9zaXRpb24gPSB1aS5wb3NpdGlvbjtcbiAgICAgICAgbm9kZS5fcHJldllQaXggPSB1aS5wb3NpdGlvbi50b3A7XG4gICAgICAgIG5vZGUuX21vdmluZyA9IChldmVudC50eXBlID09PSAnZHJhZ3N0YXJ0Jyk7IC8vICdkcm9wb3ZlcicgYXJlIG5vdCBpbml0aWFsbHkgbW92aW5nIHNvIHRoZXkgY2FuIGdvIGV4YWN0bHkgd2hlcmUgdGhleSBlbnRlciAod2lsbCBwdXNoIHN0dWZmIG91dCBvZiB0aGUgd2F5KVxuICAgICAgICBkZWxldGUgbm9kZS5fbGFzdFRyaWVkO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2Ryb3BvdmVyJyAmJiBub2RlLl90ZW1wb3JhcnlSZW1vdmVkKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZW5naW5lLmFkZE5vZGUgeD0nICsgbm9kZS54KTsgLy8gVEVTVFxuICAgICAgICAgICAgdGhpcy5lbmdpbmUuYWRkTm9kZShub2RlKTsgLy8gd2lsbCBhZGQsIGZpeCBjb2xsaXNpb25zLCB1cGRhdGUgYXR0ciBhbmQgY2xlYXIgX3RlbXBvcmFyeVJlbW92ZWRcbiAgICAgICAgICAgIG5vZGUuX21vdmluZyA9IHRydWU7IC8vIEFGVEVSLCBtYXJrIGFzIG1vdmluZyBvYmplY3QgKHdhbnRlZCBmaXggbG9jYXRpb24gYmVmb3JlKVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgbWluL21heCByZXNpemUgaW5mb1xuICAgICAgICB0aGlzLmVuZ2luZS5jYWNoZVJlY3RzKGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgdGhpcy5vcHRzLm1hcmdpblRvcCwgdGhpcy5vcHRzLm1hcmdpblJpZ2h0LCB0aGlzLm9wdHMubWFyZ2luQm90dG9tLCB0aGlzLm9wdHMubWFyZ2luTGVmdCk7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAncmVzaXplc3RhcnQnKSB7XG4gICAgICAgICAgICBkZC5yZXNpemFibGUoZWwsICdvcHRpb24nLCAnbWluV2lkdGgnLCBjZWxsV2lkdGggKiAobm9kZS5taW5XIHx8IDEpKVxuICAgICAgICAgICAgICAgIC5yZXNpemFibGUoZWwsICdvcHRpb24nLCAnbWluSGVpZ2h0JywgY2VsbEhlaWdodCAqIChub2RlLm1pbkggfHwgMSkpO1xuICAgICAgICAgICAgaWYgKG5vZGUubWF4Vykge1xuICAgICAgICAgICAgICAgIGRkLnJlc2l6YWJsZShlbCwgJ29wdGlvbicsICdtYXhXaWR0aCcsIGNlbGxXaWR0aCAqIG5vZGUubWF4Vyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5tYXhIKSB7XG4gICAgICAgICAgICAgICAgZGQucmVzaXphYmxlKGVsLCAnb3B0aW9uJywgJ21heEhlaWdodCcsIGNlbGxIZWlnaHQgKiBub2RlLm1heEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgaGFuZGxlcyBhY3R1YWwgZHJhZy9yZXNpemUgKi9cbiAgICBfZHJhZ09yUmVzaXplKGVsLCBldmVudCwgdWksIG5vZGUsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCkge1xuICAgICAgICBsZXQgcCA9IHsgLi4ubm9kZS5fb3JpZyB9OyAvLyBjb3VsZCBiZSB1bmRlZmluZWQgKF9pc0V4dGVybmFsKSB3aGljaCBpcyBvayAoZHJhZyBvbmx5IHNldCB4LHkgYW5kIHcsaCB3aWxsIGRlZmF1bHQgdG8gbm9kZSB2YWx1ZSlcbiAgICAgICAgbGV0IHJlc2l6aW5nO1xuICAgICAgICBsZXQgbUxlZnQgPSB0aGlzLm9wdHMubWFyZ2luTGVmdCwgbVJpZ2h0ID0gdGhpcy5vcHRzLm1hcmdpblJpZ2h0LCBtVG9wID0gdGhpcy5vcHRzLm1hcmdpblRvcCwgbUJvdHRvbSA9IHRoaXMub3B0cy5tYXJnaW5Cb3R0b207XG4gICAgICAgIC8vIGlmIG1hcmdpbnMgKHdoaWNoIGFyZSB1c2VkIHRvIHBhc3MgbWlkIHBvaW50IGJ5KSBhcmUgbGFyZ2UgcmVsYXRpdmUgdG8gY2VsbCBoZWlnaHQvd2lkdGgsIHJlZHVjZSB0aGVtIGRvd24gIzE4NTVcbiAgICAgICAgbGV0IG1IZWlnaHQgPSBNYXRoLnJvdW5kKGNlbGxIZWlnaHQgKiAwLjEpLCBtV2lkdGggPSBNYXRoLnJvdW5kKGNlbGxXaWR0aCAqIDAuMSk7XG4gICAgICAgIG1MZWZ0ID0gTWF0aC5taW4obUxlZnQsIG1XaWR0aCk7XG4gICAgICAgIG1SaWdodCA9IE1hdGgubWluKG1SaWdodCwgbVdpZHRoKTtcbiAgICAgICAgbVRvcCA9IE1hdGgubWluKG1Ub3AsIG1IZWlnaHQpO1xuICAgICAgICBtQm90dG9tID0gTWF0aC5taW4obUJvdHRvbSwgbUhlaWdodCk7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnZHJhZycpIHtcbiAgICAgICAgICAgIGlmIChub2RlLl90ZW1wb3JhcnlSZW1vdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gaGFuZGxlZCBieSBkcm9wb3ZlclxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gdWkucG9zaXRpb24udG9wIC0gbm9kZS5fcHJldllQaXg7XG4gICAgICAgICAgICBub2RlLl9wcmV2WVBpeCA9IHVpLnBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuZHJhZ2dhYmxlLnNjcm9sbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBVdGlscy51cGRhdGVTY3JvbGxQb3NpdGlvbihlbCwgdWkucG9zaXRpb24sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdldCBuZXcgcG9zaXRpb24gdGFraW5nIGludG8gYWNjb3VudCB0aGUgbWFyZ2luIGluIHRoZSBkaXJlY3Rpb24gd2UgYXJlIG1vdmluZyEgKG5lZWQgdG8gcGFzcyBtaWQgcG9pbnQgYnkgbWFyZ2luKVxuICAgICAgICAgICAgbGV0IGxlZnQgPSB1aS5wb3NpdGlvbi5sZWZ0ICsgKHVpLnBvc2l0aW9uLmxlZnQgPiBub2RlLl9sYXN0VWlQb3NpdGlvbi5sZWZ0ID8gLW1SaWdodCA6IG1MZWZ0KTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB1aS5wb3NpdGlvbi50b3AgKyAodWkucG9zaXRpb24udG9wID4gbm9kZS5fbGFzdFVpUG9zaXRpb24udG9wID8gLW1Cb3R0b20gOiBtVG9wKTtcbiAgICAgICAgICAgIHAueCA9IE1hdGgucm91bmQobGVmdCAvIGNlbGxXaWR0aCk7XG4gICAgICAgICAgICBwLnkgPSBNYXRoLnJvdW5kKHRvcCAvIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZS8vIGlmIHdlJ3JlIGF0IHRoZSBib3R0b20gaGl0dGluZyBzb21ldGhpbmcgZWxzZSwgZ3JvdyB0aGUgZ3JpZCBzbyBjdXJzb3IgZG9lc24ndCBsZWF2ZSB3aGVuIHRyeWluZyB0byBwbGFjZSBiZWxvdyBvdGhlcnNcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5fZXh0cmFEcmFnUm93O1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLmNvbGxpZGUobm9kZSwgcCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRSb3coKTtcbiAgICAgICAgICAgICAgICBsZXQgZXh0cmEgPSBNYXRoLm1heCgwLCAocC55ICsgbm9kZS5oKSAtIHJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5tYXhSb3cgJiYgcm93ICsgZXh0cmEgPiB0aGlzLm9wdHMubWF4Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhID0gTWF0aC5tYXgoMCwgdGhpcy5vcHRzLm1heFJvdyAtIHJvdyk7XG4gICAgICAgICAgICAgICAgfSAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0cmFEcmFnUm93ID0gZXh0cmE7IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRyYURyYWdSb3cgPSAwOyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAodGhpcy5fZXh0cmFEcmFnUm93ICE9PSBwcmV2KVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKG5vZGUueCA9PT0gcC54ICYmIG5vZGUueSA9PT0gcC55KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gc2tpcCBzYW1lXG4gICAgICAgICAgICAvLyBET04nVCBza2lwIG9uZSB3ZSB0cmllZCBhcyB3ZSBtaWdodCBoYXZlIGZhaWxlZCBiZWNhdXNlIG9mIGNvdmVyYWdlIDw1MCUgYmVmb3JlXG4gICAgICAgICAgICAvLyBpZiAobm9kZS5fbGFzdFRyaWVkICYmIG5vZGUuX2xhc3RUcmllZC54ID09PSB4ICYmIG5vZGUuX2xhc3RUcmllZC55ID09PSB5KSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIGlmIChwLnggPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFNjcm9sbGluZyBwYWdlIGlmIG5lZWRlZFxuICAgICAgICAgICAgVXRpbHMudXBkYXRlU2Nyb2xsUmVzaXplKGV2ZW50LCBlbCwgY2VsbEhlaWdodCk7XG4gICAgICAgICAgICAvLyBnZXQgbmV3IHNpemVcbiAgICAgICAgICAgIHAudyA9IE1hdGgucm91bmQoKHVpLnNpemUud2lkdGggLSBtTGVmdCkgLyBjZWxsV2lkdGgpO1xuICAgICAgICAgICAgcC5oID0gTWF0aC5yb3VuZCgodWkuc2l6ZS5oZWlnaHQgLSBtVG9wKSAvIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKG5vZGUudyA9PT0gcC53ICYmIG5vZGUuaCA9PT0gcC5oKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChub2RlLl9sYXN0VHJpZWQgJiYgbm9kZS5fbGFzdFRyaWVkLncgPT09IHAudyAmJiBub2RlLl9sYXN0VHJpZWQuaCA9PT0gcC5oKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gc2tpcCBvbmUgd2UgdHJpZWQgKGJ1dCBmYWlsZWQpXG4gICAgICAgICAgICAvLyBpZiB3ZSBzaXplIG9uIGxlZnQvdG9wIHNpZGUgdGhpcyBtaWdodCBtb3ZlIHVzLCBzbyBnZXQgcG9zc2libGUgbmV3IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdWkucG9zaXRpb24ubGVmdCArIG1MZWZ0O1xuICAgICAgICAgICAgbGV0IHRvcCA9IHVpLnBvc2l0aW9uLnRvcCArIG1Ub3A7XG4gICAgICAgICAgICBwLnggPSBNYXRoLnJvdW5kKGxlZnQgLyBjZWxsV2lkdGgpO1xuICAgICAgICAgICAgcC55ID0gTWF0aC5yb3VuZCh0b3AgLyBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIHJlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLl9ldmVudCA9IGV2ZW50O1xuICAgICAgICBub2RlLl9sYXN0VHJpZWQgPSBwOyAvLyBzZXQgYXMgbGFzdCB0cmllZCAod2lsbCBudWtlIGlmIHdlIGdvIHRoZXJlKVxuICAgICAgICBsZXQgcmVjdCA9IHtcbiAgICAgICAgICAgIHg6IHVpLnBvc2l0aW9uLmxlZnQgKyBtTGVmdCxcbiAgICAgICAgICAgIHk6IHVpLnBvc2l0aW9uLnRvcCArIG1Ub3AsXG4gICAgICAgICAgICB3OiAodWkuc2l6ZSA/IHVpLnNpemUud2lkdGggOiBub2RlLncgKiBjZWxsV2lkdGgpIC0gbUxlZnQgLSBtUmlnaHQsXG4gICAgICAgICAgICBoOiAodWkuc2l6ZSA/IHVpLnNpemUuaGVpZ2h0IDogbm9kZS5oICogY2VsbEhlaWdodCkgLSBtVG9wIC0gbUJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUubW92ZU5vZGVDaGVjayhub2RlLCB7IC4uLnAsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcmVjdCwgcmVzaXppbmcgfSkpIHtcbiAgICAgICAgICAgIG5vZGUuX2xhc3RVaVBvc2l0aW9uID0gdWkucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5jYWNoZVJlY3RzKGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgbVRvcCwgbVJpZ2h0LCBtQm90dG9tLCBtTGVmdCk7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fc2tpcERvd247XG4gICAgICAgICAgICBpZiAocmVzaXppbmcgJiYgbm9kZS5zdWJHcmlkKVxuICAgICAgICAgICAgICAgIG5vZGUuc3ViR3JpZC5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFEcmFnUm93ID0gMDsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl93cml0ZVBvc0F0dHIodGFyZ2V0LCBub2RlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dzRXZlbnRIYW5kbGVyW2V2ZW50LnR5cGVdKGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHdoZW4gaXRlbSBsZWF2aW5nIG91ciBhcmVhIGJ5IGVpdGhlciBjdXJzb3IgZHJvcG91dCBldmVudFxuICAgICAqIG9yIHNoYXBlIGlzIG91dHNpZGUgb3VyIGJvdW5kYXJpZXMuIHJlbW92ZSBpdCBmcm9tIHVzLCBhbmQgbWFyayB0ZW1wb3JhcnkgaWYgdGhpcyB3YXNcbiAgICAgKiBvdXIgaXRlbSB0byBzdGFydCB3aXRoIGVsc2UgcmVzdG9yZSBwcmV2IG5vZGUgdmFsdWVzIGZyb20gcHJldiBncmlkIGl0IGNhbWUgZnJvbS5cbiAgICAgKi9cbiAgICBfbGVhdmUoZWwsIGhlbHBlcikge1xuICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGQub2ZmKGVsLCAnZHJhZycpOyAvLyBubyBuZWVkIHRvIHRyYWNrIHdoaWxlIGJlaW5nIG91dHNpZGVcbiAgICAgICAgLy8gdGhpcyBnZXRzIGNhbGxlZCB3aGVuIGN1cnNvciBsZWF2ZXMgYW5kIHNoYXBlIGlzIG91dHNpZGUsIHNvIG9ubHkgZG8gdGhpcyBvbmNlXG4gICAgICAgIGlmIChub2RlLl90ZW1wb3JhcnlSZW1vdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBub2RlLl90ZW1wb3JhcnlSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbmdpbmUucmVtb3ZlTm9kZShub2RlKTsgLy8gcmVtb3ZlIHBsYWNlaG9sZGVyIGFzIHdlbGwsIG90aGVyd2lzZSBpdCdzIGEgc2lnbiBub2RlIGlzIG5vdCBpbiBvdXIgbGlzdCwgd2hpY2ggaXMgYSBiaWdnZXIgaXNzdWVcbiAgICAgICAgbm9kZS5lbCA9IG5vZGUuX2lzRXh0ZXJuYWwgJiYgaGVscGVyID8gaGVscGVyIDogZWw7IC8vIHBvaW50IGJhY2sgdG8gcmVhbCBpdGVtIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgaWYgKHRoaXMub3B0cy5yZW1vdmFibGUgPT09IHRydWUpIHsgLy8gYm9vbGVhbiB2cyBhIGNsYXNzIHN0cmluZ1xuICAgICAgICAgICAgLy8gaXRlbSBsZWF2aW5nIHVzIGFuZCB3ZSBhcmUgc3VwcG9zZWQgdG8gcmVtb3ZlIG9uIGxlYXZlIChubyBuZWVkIHRvIGRyYWcgb250byB0cmFzaCkgbWFyayBpdCBzb1xuICAgICAgICAgICAgdGhpcy5faXRlbVJlbW92aW5nKGVsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbGx5IGlmIGl0ZW0gb3JpZ2luYWxseSBjYW1lIGZyb20gYW5vdGhlciBncmlkLCBidXQgbGVmdCB1cywgcmVzdG9yZSB0aGluZ3MgYmFjayB0byBwcmV2IGluZm9cbiAgICAgICAgaWYgKGVsLl9ncmlkc3RhY2tOb2RlT3JpZykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xlYXZlIGRlbGV0ZSBfZ3JpZHN0YWNrTm9kZU9yaWcnKSAvLyBURVNUXG4gICAgICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gZWwuX2dyaWRzdGFja05vZGVPcmlnO1xuICAgICAgICAgICAgZGVsZXRlIGVsLl9ncmlkc3RhY2tOb2RlT3JpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLl9pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAvLyBpdGVtIGNhbWUgZnJvbSBvdXRzaWRlIChsaWtlIGEgdG9vbGJhcikgc28gbnVrZSBhbnkgbm9kZSBpbmZvXG4gICAgICAgICAgICBkZWxldGUgbm9kZS5lbDtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgLy8gYW5kIHJlc3RvcmUgYWxsIG5vZGVzIGJhY2sgdG8gb3JpZ2luYWxcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnJlc3RvcmVJbml0aWFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVnYWN5IG1ldGhvZCByZW1vdmVkXG4gICAgY29tbWl0KCkgeyBvYnNvbGV0ZSh0aGlzLCB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlKSwgJ2NvbW1pdCcsICdiYXRjaFVwZGF0ZScsICc1LjInKTsgcmV0dXJuIHRoaXM7IH1cbn1cbi8qKiBwYXJlbnQgY2xhc3MgZm9yIHNpemluZyBjb250ZW50LiBkZWZhdWx0cyB0byAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JyAqL1xuR3JpZFN0YWNrLnJlc2l6ZVRvQ29udGVudFBhcmVudCA9ICcuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnO1xuLyoqIHNjb3Bpbmcgc28gdXNlcnMgY2FuIGNhbGwgR3JpZFN0YWNrLlV0aWxzLnNvcnQoKSBmb3IgZXhhbXBsZSAqL1xuR3JpZFN0YWNrLlV0aWxzID0gVXRpbHM7XG4vKiogc2NvcGluZyBzbyB1c2VycyBjYW4gY2FsbCBuZXcgR3JpZFN0YWNrLkVuZ2luZSgxMikgZm9yIGV4YW1wbGUgKi9cbkdyaWRTdGFjay5FbmdpbmUgPSBHcmlkU3RhY2tFbmdpbmU7XG5HcmlkU3RhY2suR0RSZXYgPSAnOS40LjAnO1xuZXhwb3J0IHsgR3JpZFN0YWNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkc3RhY2suanMubWFwIl0sIm5hbWVzIjpbIkdyaWRTdGFja0VuZ2luZSIsIlV0aWxzIiwib2Jzb2xldGUiLCJncmlkRGVmYXVsdHMiLCJkcmFnSW5EZWZhdWx0T3B0aW9ucyIsIkRER3JpZFN0YWNrIiwiaXNUb3VjaCIsIkRETWFuYWdlciIsImRkIiwiR3JpZFN0YWNrIiwiaW5pdCIsIm9wdGlvbnMiLCJlbE9yU3RyaW5nIiwiZWwiLCJnZXRHcmlkRWxlbWVudCIsImNvbnNvbGUiLCJlcnJvciIsImdyaWRzdGFjayIsImNsb25lRGVlcCIsImluaXRBbGwiLCJzZWxlY3RvciIsImdyaWRzIiwiZ2V0R3JpZEVsZW1lbnRzIiwiZm9yRWFjaCIsInB1c2giLCJsZW5ndGgiLCJhZGRHcmlkIiwicGFyZW50Iiwib3B0IiwiZ3JpZCIsIm9wdHMiLCJjaGlsZHJlbiIsInVuZGVmaW5lZCIsImxvYWQiLCJwYXJlbnRJc0dyaWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImFkZFJlbW92ZUNCIiwiZG9jIiwiZG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImJvZHkiLCJpbm5lckhUTUwiLCJjbGFzcyIsImFwcGVuZENoaWxkIiwicmVnaXN0ZXJFbmdpbmUiLCJlbmdpbmVDbGFzcyIsInBsYWNlaG9sZGVyIiwiX3BsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJwbGFjZWhvbGRlclRleHQiLCJhZGQiLCJwbGFjZWhvbGRlckNsYXNzIiwiaXRlbUNsYXNzIiwiYWRkV2lkZ2V0IiwiZWxzIiwiaXNHcmlkU3RhY2tXaWRnZXQiLCJ3IiwieCIsInkiLCJoIiwiY29udGVudCIsIm5vZGUiLCJhcmd1bWVudHMiLCJncmlkc3RhY2tOb2RlIiwicGFyZW50RWxlbWVudCIsImVuZ2luZSIsIm5vZGVzIiwiZmluZCIsIm4iLCJfaWQiLCJkb21BdHRyIiwiX3JlYWRBdHRyIiwiZGVmYXVsdHMiLCJwcmVwYXJlTm9kZSIsIl93cml0ZUF0dHIiLCJfaW5zZXJ0Tm90QXBwZW5kIiwicHJlcGVuZCIsIm1ha2VXaWRnZXQiLCJtYWtlU3ViR3JpZCIsIm9wcyIsIm5vZGVUb0FkZCIsInNhdmVDb250ZW50Iiwic3ViR3JpZCIsInN1YkdyaWRUZW1wbGF0ZSIsInN1YkdyaWRPcHRzIiwicGFyZW50R3JpZEl0ZW0iLCJhdXRvQ29sdW1uIiwiY29sdW1uIiwiTWF0aCIsIm1heCIsImRpc2FibGVPbmVDb2x1bW5Nb2RlIiwicXVlcnlTZWxlY3RvciIsIm5ld0l0ZW0iLCJuZXdJdGVtT3B0IiwiX3JlbW92ZUREIiwicmVtb3ZlSW50ZXJuYWxGb3JTYXZlIiwiX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZSIsInN0eWxlIiwidHJhbnNpdGlvbiIsInVwZGF0ZSIsInNldFRpbWVvdXQiLCJfbW92aW5nIiwiX2lzVGVtcCIsIl9hdXRvQ29sdW1uIiwid2luZG93Iiwic2ltdWxhdGVNb3VzZUV2ZW50IiwiX2V2ZW50IiwicmVtb3ZlQXNTdWJHcmlkIiwibm9kZVRoYXRSZW1vdmVkIiwicEdyaWQiLCJiYXRjaFVwZGF0ZSIsInJlbW92ZVdpZGdldCIsInNhdmUiLCJzYXZlR3JpZE9wdCIsInNhdmVDQiIsImxpc3QiLCJzdWIiLCJsaXN0T3JPcHQiLCJvIiwibWFyZ2luQm90dG9tIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5MZWZ0IiwibWFyZ2luIiwicnRsIiwiZGlyZWN0aW9uIiwiX2lzQXV0b0NlbGxIZWlnaHQiLCJjZWxsSGVpZ2h0Iiwib3JpZ1Nob3ciLCJfYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSIsImFsd2F5c1Nob3dSZXNpemVIYW5kbGUiLCJyZW1vdmVJbnRlcm5hbEFuZFNhbWUiLCJpdGVtcyIsImFkZFJlbW92ZSIsImhhdmVDb29yZCIsInNvbWUiLCJzb3J0IiwiX3ByZXZDb2x1bW4iLCJnZXRDb2x1bW4iLCJfaWdub3JlTGF5b3V0c05vZGVDaGFuZ2UiLCJjYWNoZUxheW91dCIsInByZXZDQiIsInJlbW92ZWQiLCJjb3B5Tm9kZXMiLCJpZCIsIml0ZW0iLCJ1cGRhdGVOb2RlcyIsImZpbHRlciIsIndpZHRoQ2hhbmdlZCIsInNob3VsZFNpemVUb0NvbnRlbnQiLCJhdXRvUG9zaXRpb24iLCJmaW5kRW1wdHlQb3NpdGlvbiIsInNhbWVQb3MiLCJtb3ZlTm9kZSIsImZvcmNlQ29sbGlkZSIsImNvcHlQb3MiLCJyZW1vdmVkTm9kZXMiLCJkb0NvbnRlbnRSZXNpemUiLCJmbGFnIiwiX3VwZGF0ZUNvbnRhaW5lckhlaWdodCIsIl90cmlnZ2VyUmVtb3ZlRXZlbnQiLCJfdHJpZ2dlckFkZEV2ZW50IiwiX3RyaWdnZXJDaGFuZ2VFdmVudCIsImdldENlbGxIZWlnaHQiLCJmb3JjZVBpeGVsIiwiY2VsbEhlaWdodFVuaXQiLCJoZWlnaHQiLCJ0b051bWJlciIsImdldEF0dHJpYnV0ZSIsInJvdW5kIiwib2Zmc2V0SGVpZ2h0Iiwicm93cyIsInBhcnNlSW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidmFsIiwiX3VwZGF0ZVJlc2l6ZUV2ZW50IiwibWFyZ2luRGlmZiIsImNlbGxXaWR0aCIsImRhdGEiLCJwYXJzZUhlaWdodCIsInVuaXQiLCJfdXBkYXRlU3R5bGVzIiwiX3dpZHRoT3JDb250YWluZXIiLCJjbGllbnRXaWR0aCIsImlubmVyV2lkdGgiLCJjb21wYWN0IiwibGF5b3V0IiwiZG9Tb3J0Iiwib2xkQ29sdW1uIiwicmVtb3ZlIiwiZG9tTm9kZXMiLCJvbmVDb2x1bW5Nb2RlRG9tU29ydCIsImdldEdyaWRJdGVtcyIsImNvbHVtbkNoYW5nZWQiLCJBcnJheSIsImZyb20iLCJtYXRjaGVzIiwiZGVzdHJveSIsInJlbW92ZURPTSIsIm9mZkFsbCIsInNldFN0YXRpYyIsInNldEFuaW1hdGlvbiIsInJlbW92ZUFsbCIsIl9zdHlsZVNoZWV0Q2xhc3MiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJfcmVtb3ZlU3R5bGVzaGVldCIsImZsb2F0IiwiZ2V0RmxvYXQiLCJnZXRDZWxsRnJvbVBpeGVsIiwicG9zaXRpb24iLCJ1c2VEb2NSZWxhdGl2ZSIsImJveCIsImNvbnRhaW5lclBvcyIsInRvcCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbFRvcCIsImxlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwicmVsYXRpdmVMZWZ0IiwicmVsYXRpdmVUb3AiLCJjb2x1bW5XaWR0aCIsIndpZHRoIiwicm93SGVpZ2h0IiwiZmxvb3IiLCJnZXRSb3ciLCJtaW5Sb3ciLCJpc0FyZWFFbXB0eSIsImdldEVsZW1lbnQiLCJfcHJlcGFyZUVsZW1lbnQiLCJvbiIsIm5hbWUiLCJjYWxsYmFjayIsImluZGV4T2YiLCJuYW1lcyIsInNwbGl0Iiwibm9EYXRhIiwiX2dzRXZlbnRIYW5kbGVyIiwiZXZlbnQiLCJkZXRhaWwiLCJhZGRFdmVudExpc3RlbmVyIiwibG9nIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJ0cmlnZ2VyRXZlbnQiLCJnZXRFbGVtZW50cyIsInJlbW92ZU5vZGUiLCJkb0FuaW1hdGUiLCJ1cGRhdGVDbGFzcyIsInJlY3Vyc2UiLCJzdGF0aWNHcmlkIiwiX3NldHVwUmVtb3ZlRHJvcCIsIl9zZXR1cEFjY2VwdFdpZGdldCIsIl9zZXRTdGF0aWNDbGFzcyIsIndhcm4iLCJhIiwiaSIsIm0iLCJrIiwibWluVyIsIm1pbkgiLCJtYXhXIiwibWF4SCIsIml0ZW1Db250ZW50Iiwic3R5bGVJbkhlYWQiLCJjaGFuZ2VkIiwiZGRDaGFuZ2VkIiwic2FuaXRpemVNaW5NYXgiLCJjbGVhbk5vZGVzIiwiYmVnaW5VcGRhdGUiLCJlbmRVcGRhdGUiLCJyZXNpemVUb0NvbnRlbnQiLCJ1c2VBdHRyU2l6ZSIsImNsaWVudEhlaWdodCIsImNlbGwiLCJyZXNpemVUb0NvbnRlbnRQYXJlbnQiLCJwYWRkaW5nIiwiaXRlbUgiLCJ3YW50ZWRIIiwiY2hpbGQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImNlaWwiLCJzb2Z0TWF4IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic2l6ZVRvQ29udGVudCIsInJlc2l6ZVRvQ29udGVudENoZWNrIiwidXNlQXR0ciIsInJlc2l6ZVRvQ29udGVudENCIiwidmFsdWUiLCJpc011bHRpVmFsdWUiLCJtYXJnaW5Vbml0IiwiX2luaXRNYXJnaW4iLCJnZXRNYXJnaW4iLCJ3aWxsSXRGaXQiLCJiYXRjaE1vZGUiLCJlbGVtZW50cyIsImdldERpcnR5Tm9kZXMiLCJsYXlvdXRzTm9kZXNDaGFuZ2UiLCJfdHJpZ2dlckV2ZW50Iiwic2F2ZUluaXRpYWwiLCJhZGRlZE5vZGVzIiwiX2RpcnR5IiwidHlwZSIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsIkV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIl9zdHlsZXMiLCJyZW1vdmVTdHlsZXNoZWV0IiwiZm9yY2VVcGRhdGUiLCJwcmVmaXgiLCJzdHlsZUxvY2F0aW9uIiwiY3JlYXRlU3R5bGVzaGVldCIsIm5vbmNlIiwiX21heCIsImFkZENTU1J1bGUiLCJib3R0b20iLCJyaWdodCIsImdldEhlaWdodCIsInJvdyIsIl9leHRyYURyYWdSb3ciLCJjc3NNaW5IZWlnaHQiLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0QXR0cmlidXRlIiwiU3RyaW5nIiwicmVtb3ZlUHJvcGVydHkiLCJ0cmlnZ2VyQWRkRXZlbnQiLCJjb3B5IiwiYWRkTm9kZSIsInNhbWUiLCJfd3JpdGVQb3NBdHRyIiwiYXR0cnMiLCJub1Jlc2l6ZSIsIm5vTW92ZSIsImxvY2tlZCIsImNsZWFyRGVmYXVsdEF0dHIiLCJ0b0Jvb2wiLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzZXMiLCJvblJlc2l6ZSIsInByZXZXaWR0aCIsIm9uZUNvbHVtbiIsIm9uZUNvbHVtblNpemUiLCJfc2tpcEluaXRpYWxSZXNpemUiLCJkZWxheSIsImZvcmNlUmVtb3ZlIiwidHJhY2tTaXplIiwicmVzaXplT2JzZXJ2ZXIiLCJfc2l6ZVRocm90dGxlIiwidGhyb3R0bGUiLCJjZWxsSGVpZ2h0VGhyb3R0bGUiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwibWFyZ2lucyIsImdldEREIiwic2V0dXBEcmFnSW4iLCJkcmFnSW4iLCJkcmFnSW5PcHRpb25zIiwicm9vdCIsInBhdXNlIiwicGF1c2VEcmFnIiwiaXNEcmFnZ2FibGUiLCJtb3ZhYmxlIiwicmVzaXphYmxlIiwiZGlzYWJsZSIsImVuYWJsZU1vdmUiLCJlbmFibGVSZXNpemUiLCJlbmFibGUiLCJkb0VuYWJsZSIsImRpc2FibGVEcmFnIiwiZGlzYWJsZVJlc2l6ZSIsImRyYWdnYWJsZSIsIl9pbml0REQiLCJkZEVsZW1lbnQiLCJhY2NlcHRXaWRnZXRzIiwicmVtb3ZhYmxlIiwiZHJvcHBhYmxlIiwib25EcmFnIiwiaGVscGVyIiwidWkiLCJfdGVtcG9yYXJ5UmVtb3ZlZCIsIm5vZGVCb3VuZEZpeCIsIl93aWxsRml0UG9zIiwiX29uU3RhcnRNb3ZpbmciLCJfZHJhZ09yUmVzaXplIiwiYWNjZXB0IiwiY2FuQWNjZXB0IiwibWF4Um93Iiwib3RoZXJHcmlkIiwiX2xlYXZlIiwiX2lzRXh0ZXJuYWwiLCJvZmZzZXRXaWR0aCIsIl9ncmlkc3RhY2tOb2RlT3JpZyIsImNsZWFudXBOb2RlIiwiX2l0ZW1SZW1vdmluZyIsIndhc0FkZGVkIiwib3JpZ05vZGUiLCJvR3JpZCIsInJlbW92ZU5vZGVGcm9tTGF5b3V0Q2FjaGUiLCJzdWJHcmlkRHluYW1pYyIsImNsb25lTm9kZSIsInJlbW92ZVBvc2l0aW9uaW5nU3R5bGVzIiwicmVtb3ZhYmxlT3B0aW9ucyIsImRlY2xpbmUiLCJfaXNBYm91dFRvUmVtb3ZlIiwidHJhc2hFbCIsImlzRHJvcHBhYmxlIiwib25TdGFydE1vdmluZyIsInRhcmdldCIsImRyYWdPclJlc2l6ZSIsIm9uRW5kTW92aW5nIiwiX2xhc3RUcmllZCIsIl9vcmlnIiwic3RhcnQiLCJzdG9wIiwiZHJhZyIsInJlc2l6ZSIsIl9sYXN0VWlQb3NpdGlvbiIsIl9wcmV2WVBpeCIsImNhY2hlUmVjdHMiLCJwIiwicmVzaXppbmciLCJtTGVmdCIsIm1SaWdodCIsIm1Ub3AiLCJtQm90dG9tIiwibUhlaWdodCIsIm1XaWR0aCIsIm1pbiIsImRpc3RhbmNlIiwic2Nyb2xsIiwidXBkYXRlU2Nyb2xsUG9zaXRpb24iLCJwcmV2IiwiY29sbGlkZSIsImV4dHJhIiwidXBkYXRlU2Nyb2xsUmVzaXplIiwic2l6ZSIsInJlY3QiLCJtb3ZlTm9kZUNoZWNrIiwiX3NraXBEb3duIiwicmVzdG9yZUluaXRpYWwiLCJjb21taXQiLCJjb25zdHJ1Y3RvciIsInJvd0F0dHIiLCJoYW5kbGUiLCJoYW5kbGVDbGFzcyIsImFuaW1hdGUiLCJncmFuZFBhcmVudCIsIl9pZFNlcSIsIm9uQ2hhbmdlIiwiY2JOb2RlcyIsIl9yZW1vdmVET00iLCJhdXRvIiwiRW5naW5lIiwiR0RSZXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/gridstack.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/types.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/types.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dragInDefaultOptions: function() { return /* binding */ dragInDefaultOptions; },\n/* harmony export */   gridDefaults: function() { return /* binding */ gridDefaults; }\n/* harmony export */ });\n/**\n * types.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ // default values for grid options - used during init and when saving out\nconst gridDefaults = {\n    alwaysShowResizeHandle: \"mobile\",\n    animate: true,\n    auto: true,\n    cellHeight: \"auto\",\n    cellHeightThrottle: 100,\n    cellHeightUnit: \"px\",\n    column: 12,\n    draggable: {\n        handle: \".grid-stack-item-content\",\n        appendTo: \"body\",\n        scroll: true\n    },\n    handle: \".grid-stack-item-content\",\n    itemClass: \"grid-stack-item\",\n    margin: 10,\n    marginUnit: \"px\",\n    maxRow: 0,\n    minRow: 0,\n    oneColumnSize: 768,\n    placeholderClass: \"grid-stack-placeholder\",\n    placeholderText: \"\",\n    removableOptions: {\n        accept: \"grid-stack-item\",\n        decline: \"grid-stack-non-removable\"\n    },\n    resizable: {\n        handles: \"se\"\n    },\n    rtl: \"auto\"\n};\n/** default dragIn options */ const dragInDefaultOptions = {\n    handle: \".grid-stack-item-content\",\n    appendTo: \"body\"\n}; //# sourceMappingURL=types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FDRCx5RUFBeUU7QUFDbEUsTUFBTUEsZUFBZTtJQUN4QkMsd0JBQXdCO0lBQ3hCQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsWUFBWTtJQUNaQyxvQkFBb0I7SUFDcEJDLGdCQUFnQjtJQUNoQkMsUUFBUTtJQUNSQyxXQUFXO1FBQUVDLFFBQVE7UUFBNEJDLFVBQVU7UUFBUUMsUUFBUTtJQUFLO0lBQ2hGRixRQUFRO0lBQ1JHLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7UUFBRUMsUUFBUTtRQUFtQkMsU0FBUztJQUEyQjtJQUNuRkMsV0FBVztRQUFFQyxTQUFTO0lBQUs7SUFDM0JDLEtBQUs7QUFZVCxFQUFFO0FBQ0YsMkJBQTJCLEdBQ3BCLE1BQU1DLHVCQUF1QjtJQUNoQ2pCLFFBQVE7SUFDUkMsVUFBVTtBQUdkLEVBQUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L3R5cGVzLmpzP2ZjZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0eXBlcy50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG4vLyBkZWZhdWx0IHZhbHVlcyBmb3IgZ3JpZCBvcHRpb25zIC0gdXNlZCBkdXJpbmcgaW5pdCBhbmQgd2hlbiBzYXZpbmcgb3V0XG5leHBvcnQgY29uc3QgZ3JpZERlZmF1bHRzID0ge1xuICAgIGFsd2F5c1Nob3dSZXNpemVIYW5kbGU6ICdtb2JpbGUnLFxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgYXV0bzogdHJ1ZSxcbiAgICBjZWxsSGVpZ2h0OiAnYXV0bycsXG4gICAgY2VsbEhlaWdodFRocm90dGxlOiAxMDAsXG4gICAgY2VsbEhlaWdodFVuaXQ6ICdweCcsXG4gICAgY29sdW1uOiAxMixcbiAgICBkcmFnZ2FibGU6IHsgaGFuZGxlOiAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JywgYXBwZW5kVG86ICdib2R5Jywgc2Nyb2xsOiB0cnVlIH0sXG4gICAgaGFuZGxlOiAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JyxcbiAgICBpdGVtQ2xhc3M6ICdncmlkLXN0YWNrLWl0ZW0nLFxuICAgIG1hcmdpbjogMTAsXG4gICAgbWFyZ2luVW5pdDogJ3B4JyxcbiAgICBtYXhSb3c6IDAsXG4gICAgbWluUm93OiAwLFxuICAgIG9uZUNvbHVtblNpemU6IDc2OCxcbiAgICBwbGFjZWhvbGRlckNsYXNzOiAnZ3JpZC1zdGFjay1wbGFjZWhvbGRlcicsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiAnJyxcbiAgICByZW1vdmFibGVPcHRpb25zOiB7IGFjY2VwdDogJ2dyaWQtc3RhY2staXRlbScsIGRlY2xpbmU6ICdncmlkLXN0YWNrLW5vbi1yZW1vdmFibGUnIH0sXG4gICAgcmVzaXphYmxlOiB7IGhhbmRsZXM6ICdzZScgfSxcbiAgICBydGw6ICdhdXRvJyxcbiAgICAvLyAqKioqIHNhbWUgYXMgbm90IGJlaW5nIHNldCAqKioqXG4gICAgLy8gZGlzYWJsZURyYWc6IGZhbHNlLFxuICAgIC8vIGRpc2FibGVPbmVDb2x1bW5Nb2RlOiBmYWxzZSxcbiAgICAvLyBkaXNhYmxlUmVzaXplOiBmYWxzZSxcbiAgICAvLyBmbG9hdDogZmFsc2UsXG4gICAgLy8gaGFuZGxlQ2xhc3M6IG51bGwsXG4gICAgLy8gb25lQ29sdW1uTW9kZURvbVNvcnQ6IGZhbHNlLFxuICAgIC8vIHJlbW92YWJsZTogZmFsc2UsXG4gICAgLy8gc3RhdGljR3JpZDogZmFsc2UsXG4gICAgLy8gc3R5bGVJbkhlYWQ6IGZhbHNlLFxuICAgIC8vcmVtb3ZhYmxlXG59O1xuLyoqIGRlZmF1bHQgZHJhZ0luIG9wdGlvbnMgKi9cbmV4cG9ydCBjb25zdCBkcmFnSW5EZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBoYW5kbGU6ICcuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnLFxuICAgIGFwcGVuZFRvOiAnYm9keScsXG4gICAgLy8gcmV2ZXJ0OiAnaW52YWxpZCcsXG4gICAgLy8gc2Nyb2xsOiBmYWxzZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiZ3JpZERlZmF1bHRzIiwiYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSIsImFuaW1hdGUiLCJhdXRvIiwiY2VsbEhlaWdodCIsImNlbGxIZWlnaHRUaHJvdHRsZSIsImNlbGxIZWlnaHRVbml0IiwiY29sdW1uIiwiZHJhZ2dhYmxlIiwiaGFuZGxlIiwiYXBwZW5kVG8iLCJzY3JvbGwiLCJpdGVtQ2xhc3MiLCJtYXJnaW4iLCJtYXJnaW5Vbml0IiwibWF4Um93IiwibWluUm93Iiwib25lQ29sdW1uU2l6ZSIsInBsYWNlaG9sZGVyQ2xhc3MiLCJwbGFjZWhvbGRlclRleHQiLCJyZW1vdmFibGVPcHRpb25zIiwiYWNjZXB0IiwiZGVjbGluZSIsInJlc2l6YWJsZSIsImhhbmRsZXMiLCJydGwiLCJkcmFnSW5EZWZhdWx0T3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/types.js\n"));

/***/ }),

/***/ "./node_modules/gridstack/dist/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/utils.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: function() { return /* binding */ Utils; },\n/* harmony export */   obsolete: function() { return /* binding */ obsolete; },\n/* harmony export */   obsoleteAttr: function() { return /* binding */ obsoleteAttr; },\n/* harmony export */   obsoleteOpts: function() { return /* binding */ obsoleteOpts; },\n/* harmony export */   obsoleteOptsDel: function() { return /* binding */ obsoleteOptsDel; }\n/* harmony export */ });\n/**\n * utils.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ /** checks for obsolete method names */ // eslint-disable-next-line\nfunction obsolete(self, f, oldName, newName, rev) {\n    let wrapper = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        console.warn(\"gridstack.js: Function `\" + oldName + \"` is deprecated in \" + rev + \" and has been replaced \" + \"with `\" + newName + \"`. It will be **removed** in a future release\");\n        return f.apply(self, args);\n    };\n    wrapper.prototype = f.prototype;\n    return wrapper;\n}\n/** checks for obsolete grid options (can be used for any fields, but msg is about options) */ function obsoleteOpts(opts, oldName, newName, rev) {\n    if (opts[oldName] !== undefined) {\n        opts[newName] = opts[oldName];\n        console.warn(\"gridstack.js: Option `\" + oldName + \"` is deprecated in \" + rev + \" and has been replaced with `\" + newName + \"`. It will be **removed** in a future release\");\n    }\n}\n/** checks for obsolete grid options which are gone */ function obsoleteOptsDel(opts, oldName, rev, info) {\n    if (opts[oldName] !== undefined) {\n        console.warn(\"gridstack.js: Option `\" + oldName + \"` is deprecated in \" + rev + info);\n    }\n}\n/** checks for obsolete Jquery element attributes */ function obsoleteAttr(el, oldName, newName, rev) {\n    let oldAttr = el.getAttribute(oldName);\n    if (oldAttr !== null) {\n        el.setAttribute(newName, oldAttr);\n        console.warn(\"gridstack.js: attribute `\" + oldName + \"`=\" + oldAttr + \" is deprecated on this object in \" + rev + \" and has been replaced with `\" + newName + \"`. It will be **removed** in a future release\");\n    }\n}\n/**\n * Utility methods\n */ class Utils {\n    /** convert a potential selector into actual list of html elements. optional root which defaults to document (for shadow dom) */ static getElements(els) {\n        let root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document;\n        if (typeof els === \"string\") {\n            const doc = \"getElementById\" in root ? root : undefined;\n            // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors\n            // so if we start with a number, assume it's an id and just return that one item...\n            // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562\n            if (doc && !isNaN(+els[0])) {\n                const el = doc.getElementById(els);\n                return el ? [\n                    el\n                ] : [];\n            }\n            let list = root.querySelectorAll(els);\n            if (!list.length && els[0] !== \".\" && els[0] !== \"#\") {\n                list = root.querySelectorAll(\".\" + els);\n                if (!list.length) {\n                    list = root.querySelectorAll(\"#\" + els);\n                }\n            }\n            return Array.from(list);\n        }\n        return [\n            els\n        ];\n    }\n    /** convert a potential selector into actual single element. optional root which defaults to document (for shadow dom) */ static getElement(els) {\n        let root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document;\n        if (typeof els === \"string\") {\n            const doc = \"getElementById\" in root ? root : undefined;\n            if (!els.length) return null;\n            if (doc && els[0] === \"#\") {\n                return doc.getElementById(els.substring(1));\n            }\n            if (els[0] === \"#\" || els[0] === \".\" || els[0] === \"[\") {\n                return root.querySelector(els);\n            }\n            // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS\n            if (doc && !isNaN(+els[0])) {\n                return doc.getElementById(els);\n            }\n            // finally try string, then id, then class\n            let el = root.querySelector(els);\n            if (doc && !el) {\n                el = doc.getElementById(els);\n            }\n            if (!el) {\n                el = root.querySelector(\".\" + els);\n            }\n            return el;\n        }\n        return els;\n    }\n    /** true if we should resize to content */ static shouldSizeToContent(n) {\n        return (n === null || n === void 0 ? void 0 : n.grid) && (!!n.sizeToContent || n.grid.opts.sizeToContent && n.sizeToContent !== false);\n    }\n    /** returns true if a and b overlap */ static isIntercepted(a, b) {\n        return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);\n    }\n    /** returns true if a and b touch edges or corners */ static isTouching(a, b) {\n        return Utils.isIntercepted(a, {\n            x: b.x - 0.5,\n            y: b.y - 0.5,\n            w: b.w + 1,\n            h: b.h + 1\n        });\n    }\n    /** returns the area a and b overlap */ static areaIntercept(a, b) {\n        let x0 = a.x > b.x ? a.x : b.x;\n        let x1 = a.x + a.w < b.x + b.w ? a.x + a.w : b.x + b.w;\n        if (x1 <= x0) return 0; // no overlap\n        let y0 = a.y > b.y ? a.y : b.y;\n        let y1 = a.y + a.h < b.y + b.h ? a.y + a.h : b.y + b.h;\n        if (y1 <= y0) return 0; // no overlap\n        return (x1 - x0) * (y1 - y0);\n    }\n    /** returns the area */ static area(a) {\n        return a.w * a.h;\n    }\n    /**\n     * Sorts array of nodes\n     * @param nodes array to sort\n     * @param dir 1 for asc, -1 for desc (optional)\n     * @param width width of the grid. If undefined the width will be calculated automatically (optional).\n     **/ static sort(nodes) {\n        let dir = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, column = arguments.length > 2 ? arguments[2] : void 0;\n        column = column || nodes.reduce((col, n)=>Math.max(n.x + n.w, col), 0) || 12;\n        if (dir === -1) return nodes.sort((a, b)=>{\n            var _b_x, _b_y, _a_x, _a_y;\n            return ((_b_x = b.x) !== null && _b_x !== void 0 ? _b_x : 1000) + ((_b_y = b.y) !== null && _b_y !== void 0 ? _b_y : 1000) * column - (((_a_x = a.x) !== null && _a_x !== void 0 ? _a_x : 1000) + ((_a_y = a.y) !== null && _a_y !== void 0 ? _a_y : 1000) * column);\n        });\n        else return nodes.sort((b, a)=>{\n            var _b_x, _b_y, _a_x, _a_y;\n            return ((_b_x = b.x) !== null && _b_x !== void 0 ? _b_x : 1000) + ((_b_y = b.y) !== null && _b_y !== void 0 ? _b_y : 1000) * column - (((_a_x = a.x) !== null && _a_x !== void 0 ? _a_x : 1000) + ((_a_y = a.y) !== null && _a_y !== void 0 ? _a_y : 1000) * column);\n        });\n    }\n    /** find an item by id */ static find(nodes, id) {\n        return id ? nodes.find((n)=>n.id === id) : undefined;\n    }\n    /**\n     * creates a style sheet with style id under given parent\n     * @param id will set the 'gs-style-id' attribute to that id\n     * @param parent to insert the stylesheet as first child,\n     * if none supplied it will be appended to the document head instead.\n     */ static createStylesheet(id, parent, options) {\n        let style = document.createElement(\"style\");\n        const nonce = options === null || options === void 0 ? void 0 : options.nonce;\n        if (nonce) style.nonce = nonce;\n        style.setAttribute(\"type\", \"text/css\");\n        style.setAttribute(\"gs-style-id\", id);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (style.styleSheet) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            style.styleSheet.cssText = \"\";\n        } else {\n            style.appendChild(document.createTextNode(\"\")); // WebKit hack\n        }\n        if (!parent) {\n            // default to head\n            parent = document.getElementsByTagName(\"head\")[0];\n            parent.appendChild(style);\n        } else {\n            parent.insertBefore(style, parent.firstChild);\n        }\n        return style.sheet;\n    }\n    /** removed the given stylesheet id */ static removeStylesheet(id) {\n        let el = document.querySelector(\"STYLE[gs-style-id=\" + id + \"]\");\n        if (el && el.parentNode) el.remove();\n    }\n    /** inserts a CSS rule */ static addCSSRule(sheet, selector, rules) {\n        if (typeof sheet.addRule === \"function\") {\n            sheet.addRule(selector, rules);\n        } else if (typeof sheet.insertRule === \"function\") {\n            sheet.insertRule(\"\".concat(selector, \"{\").concat(rules, \"}\"));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static toBool(v) {\n        if (typeof v === \"boolean\") {\n            return v;\n        }\n        if (typeof v === \"string\") {\n            v = v.toLowerCase();\n            return !(v === \"\" || v === \"no\" || v === \"false\" || v === \"0\");\n        }\n        return Boolean(v);\n    }\n    static toNumber(value) {\n        return value === null || value.length === 0 ? undefined : Number(value);\n    }\n    static parseHeight(val) {\n        let h;\n        let unit = \"px\";\n        if (typeof val === \"string\") {\n            if (val === \"auto\") h = 0;\n            else {\n                let match = val.match(/^(-[0-9]+\\.[0-9]+|[0-9]*\\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);\n                if (!match) {\n                    throw new Error(\"Invalid height\");\n                }\n                unit = match[2] || \"px\";\n                h = parseFloat(match[1]);\n            }\n        } else {\n            h = val;\n        }\n        return {\n            h,\n            unit\n        };\n    }\n    /** copies unset fields in target to use the given default sources values */ // eslint-disable-next-line\n    static defaults(target) {\n        for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            sources[_key - 1] = arguments[_key];\n        }\n        sources.forEach((source)=>{\n            for(const key in source){\n                if (!source.hasOwnProperty(key)) return;\n                if (target[key] === null || target[key] === undefined) {\n                    target[key] = source[key];\n                } else if (typeof source[key] === \"object\" && typeof target[key] === \"object\") {\n                    // property is an object, recursively add it's field over... #1373\n                    this.defaults(target[key], source[key]);\n                }\n            }\n        });\n        return target;\n    }\n    /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */ static same(a, b) {\n        if (typeof a !== \"object\") return a == b;\n        if (typeof a !== typeof b) return false;\n        // else we have object, check just 1 level deep for being same things...\n        if (Object.keys(a).length !== Object.keys(b).length) return false;\n        for(const key in a){\n            if (a[key] !== b[key]) return false;\n        }\n        return true;\n    }\n    /** copies over b size & position (GridStackPosition), and optionally min/max as well */ static copyPos(a, b) {\n        let doMinMax = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (b.x !== undefined) a.x = b.x;\n        if (b.y !== undefined) a.y = b.y;\n        if (b.w !== undefined) a.w = b.w;\n        if (b.h !== undefined) a.h = b.h;\n        if (doMinMax) {\n            if (b.minW) a.minW = b.minW;\n            if (b.minH) a.minH = b.minH;\n            if (b.maxW) a.maxW = b.maxW;\n            if (b.maxH) a.maxH = b.maxH;\n        }\n        return a;\n    }\n    /** true if a and b has same size & position */ static samePos(a, b) {\n        return a && b && a.x === b.x && a.y === b.y && (a.w || 1) === (b.w || 1) && (a.h || 1) === (b.h || 1);\n    }\n    /** given a node, makes sure it's min/max are valid */ static sanitizeMinMax(node) {\n        // remove 0, undefine, null\n        if (!node.minW) {\n            delete node.minW;\n        }\n        if (!node.minH) {\n            delete node.minH;\n        }\n        if (!node.maxW) {\n            delete node.maxW;\n        }\n        if (!node.maxH) {\n            delete node.maxH;\n        }\n    }\n    /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */ static removeInternalAndSame(a, b) {\n        if (typeof a !== \"object\" || typeof b !== \"object\") return;\n        for(let key in a){\n            let val = a[key];\n            if (key[0] === \"_\" || val === b[key]) {\n                delete a[key];\n            } else if (val && typeof val === \"object\" && b[key] !== undefined) {\n                for(let i in val){\n                    if (val[i] === b[key][i] || i[0] === \"_\") {\n                        delete val[i];\n                    }\n                }\n                if (!Object.keys(val).length) {\n                    delete a[key];\n                }\n            }\n        }\n    }\n    /** removes internal fields '_' and default values for saving */ static removeInternalForSave(n) {\n        let removeEl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        for(let key in n){\n            if (key[0] === \"_\" || n[key] === null || n[key] === undefined) delete n[key];\n        }\n        delete n.grid;\n        if (removeEl) delete n.el;\n        // delete default values (will be re-created on read)\n        if (!n.autoPosition) delete n.autoPosition;\n        if (!n.noResize) delete n.noResize;\n        if (!n.noMove) delete n.noMove;\n        if (!n.locked) delete n.locked;\n        if (n.w === 1 || n.w === n.minW) delete n.w;\n        if (n.h === 1 || n.h === n.minH) delete n.h;\n    }\n    /** return the closest parent (or itself) matching the given class */ // static closestUpByClass(el: HTMLElement, name: string): HTMLElement {\n    //   while (el) {\n    //     if (el.classList.contains(name)) return el;\n    //     el = el.parentElement\n    //   }\n    //   return null;\n    // }\n    /** delay calling the given function for given delay, preventing new calls from happening while waiting */ static throttle(func, delay) {\n        let isWaiting = false;\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            if (!isWaiting) {\n                isWaiting = true;\n                setTimeout(()=>{\n                    func(...args);\n                    isWaiting = false;\n                }, delay);\n            }\n        };\n    }\n    static removePositioningStyles(el) {\n        let style = el.style;\n        if (style.position) {\n            style.removeProperty(\"position\");\n        }\n        if (style.left) {\n            style.removeProperty(\"left\");\n        }\n        if (style.top) {\n            style.removeProperty(\"top\");\n        }\n        if (style.width) {\n            style.removeProperty(\"width\");\n        }\n        if (style.height) {\n            style.removeProperty(\"height\");\n        }\n    }\n    /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */ static getScrollElement(el) {\n        if (!el) return document.scrollingElement || document.documentElement; // IE support\n        const style = getComputedStyle(el);\n        const overflowRegex = /(auto|scroll)/;\n        if (overflowRegex.test(style.overflow + style.overflowY)) {\n            return el;\n        } else {\n            return this.getScrollElement(el.parentElement);\n        }\n    }\n    /** @internal */ static updateScrollPosition(el, position, distance) {\n        // is widget in view?\n        let rect = el.getBoundingClientRect();\n        let innerHeightOrClientHeight = window.innerHeight || document.documentElement.clientHeight;\n        if (rect.top < 0 || rect.bottom > innerHeightOrClientHeight) {\n            // set scrollTop of first parent that scrolls\n            // if parent is larger than el, set as low as possible\n            // to get entire widget on screen\n            let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;\n            let offsetDiffUp = rect.top;\n            let scrollEl = this.getScrollElement(el);\n            if (scrollEl !== null) {\n                let prevScroll = scrollEl.scrollTop;\n                if (rect.top < 0 && distance < 0) {\n                    // moving up\n                    if (el.offsetHeight > innerHeightOrClientHeight) {\n                        scrollEl.scrollTop += distance;\n                    } else {\n                        scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;\n                    }\n                } else if (distance > 0) {\n                    // moving down\n                    if (el.offsetHeight > innerHeightOrClientHeight) {\n                        scrollEl.scrollTop += distance;\n                    } else {\n                        scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;\n                    }\n                }\n                // move widget y by amount scrolled\n                position.top += scrollEl.scrollTop - prevScroll;\n            }\n        }\n    }\n    /**\n     * @internal Function used to scroll the page.\n     *\n     * @param event `MouseEvent` that triggers the resize\n     * @param el `HTMLElement` that's being resized\n     * @param distance Distance from the V edges to start scrolling\n     */ static updateScrollResize(event, el, distance) {\n        const scrollEl = this.getScrollElement(el);\n        const height = scrollEl.clientHeight;\n        // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top\n        // #1745 Special situation if scrollEl is document 'html': here browser spec states that\n        // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;\n        // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.\n        const offsetTop = scrollEl === this.getScrollElement() ? 0 : scrollEl.getBoundingClientRect().top;\n        const pointerPosY = event.clientY - offsetTop;\n        const top = pointerPosY < distance;\n        const bottom = pointerPosY > height - distance;\n        if (top) {\n            // This also can be done with a timeout to keep scrolling while the mouse is\n            // in the scrolling zone. (will have smoother behavior)\n            scrollEl.scrollBy({\n                behavior: \"smooth\",\n                top: pointerPosY - distance\n            });\n        } else if (bottom) {\n            scrollEl.scrollBy({\n                behavior: \"smooth\",\n                top: distance - (height - pointerPosY)\n            });\n        }\n    }\n    /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */ static clone(obj) {\n        if (obj === null || obj === undefined || typeof obj !== \"object\") {\n            return obj;\n        }\n        // return Object.assign({}, obj);\n        if (obj instanceof Array) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return [\n                ...obj\n            ];\n        }\n        return {\n            ...obj\n        };\n    }\n    /**\n     * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.\n     * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.\n     */ static cloneDeep(obj) {\n        // list of fields we will skip during cloneDeep (nested objects, other internal)\n        const skipFields = [\n            \"parentGrid\",\n            \"el\",\n            \"grid\",\n            \"subGrid\",\n            \"engine\"\n        ];\n        // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?\n        const ret = Utils.clone(obj);\n        for(const key in ret){\n            // NOTE: we don't support function/circular dependencies so skip those properties for now...\n            if (ret.hasOwnProperty(key) && typeof ret[key] === \"object\" && key.substring(0, 2) !== \"__\" && !skipFields.find((k)=>k === key)) {\n                ret[key] = Utils.cloneDeep(obj[key]);\n            }\n        }\n        return ret;\n    }\n    /** deep clone the given HTML node, removing teh unique id field */ static cloneNode(el) {\n        const node = el.cloneNode(true);\n        node.removeAttribute(\"id\");\n        return node;\n    }\n    static appendTo(el, parent) {\n        let parentNode;\n        if (typeof parent === \"string\") {\n            parentNode = Utils.getElement(parent);\n        } else {\n            parentNode = parent;\n        }\n        if (parentNode) {\n            parentNode.appendChild(el);\n        }\n    }\n    // public static setPositionRelative(el: HTMLElement): void {\n    //   if (!(/^(?:r|a|f)/).test(getComputedStyle(el).position)) {\n    //     el.style.position = \"relative\";\n    //   }\n    // }\n    static addElStyles(el, styles) {\n        if (styles instanceof Object) {\n            for(const s in styles){\n                if (styles.hasOwnProperty(s)) {\n                    if (Array.isArray(styles[s])) {\n                        // support fallback value\n                        styles[s].forEach((val)=>{\n                            el.style[s] = val;\n                        });\n                    } else {\n                        el.style[s] = styles[s];\n                    }\n                }\n            }\n        }\n    }\n    static initEvent(e, info) {\n        const evt = {\n            type: info.type\n        };\n        const obj = {\n            button: 0,\n            which: 0,\n            buttons: 1,\n            bubbles: true,\n            cancelable: true,\n            target: info.target ? info.target : e.target\n        };\n        // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n        if (e.dataTransfer) {\n            evt[\"dataTransfer\"] = e.dataTransfer; // workaround 'readonly' field.\n        }\n        [\n            \"altKey\",\n            \"ctrlKey\",\n            \"metaKey\",\n            \"shiftKey\"\n        ].forEach((p)=>evt[p] = e[p]); // keys\n        [\n            \"pageX\",\n            \"pageY\",\n            \"clientX\",\n            \"clientY\",\n            \"screenX\",\n            \"screenY\"\n        ].forEach((p)=>evt[p] = e[p]); // point info\n        return {\n            ...evt,\n            ...obj\n        };\n    }\n    /** copies the MouseEvent properties and sends it as another event to the given target */ static simulateMouseEvent(e, simulatedType, target) {\n        const simulatedEvent = document.createEvent(\"MouseEvents\");\n        simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, e.target // relatedTarget\n        );\n        (target || e.target).dispatchEvent(simulatedEvent);\n    }\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxxQ0FBcUMsR0FDckMsMkJBQTJCO0FBQ3BCLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsQ0FBQyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUNuRCxJQUFJQyxVQUFVO3lDQUFJQztZQUFBQTs7UUFDZEMsUUFBUUMsSUFBSSxDQUFDLDZCQUE2Qk4sVUFBVSx3QkFBd0JFLE1BQU0sNEJBQzlFLFdBQVdELFVBQVU7UUFDekIsT0FBT0YsRUFBRVEsS0FBSyxDQUFDVCxNQUFNTTtJQUN6QjtJQUNBRCxRQUFRSyxTQUFTLEdBQUdULEVBQUVTLFNBQVM7SUFDL0IsT0FBT0w7QUFDWDtBQUNBLDRGQUE0RixHQUNyRixTQUFTTSxhQUFhQyxJQUFJLEVBQUVWLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3BELElBQUlRLElBQUksQ0FBQ1YsUUFBUSxLQUFLVyxXQUFXO1FBQzdCRCxJQUFJLENBQUNULFFBQVEsR0FBR1MsSUFBSSxDQUFDVixRQUFRO1FBQzdCSyxRQUFRQyxJQUFJLENBQUMsMkJBQTJCTixVQUFVLHdCQUF3QkUsTUFBTSxrQ0FDNUVELFVBQVU7SUFDbEI7QUFDSjtBQUNBLG9EQUFvRCxHQUM3QyxTQUFTVyxnQkFBZ0JGLElBQUksRUFBRVYsT0FBTyxFQUFFRSxHQUFHLEVBQUVXLElBQUk7SUFDcEQsSUFBSUgsSUFBSSxDQUFDVixRQUFRLEtBQUtXLFdBQVc7UUFDN0JOLFFBQVFDLElBQUksQ0FBQywyQkFBMkJOLFVBQVUsd0JBQXdCRSxNQUFNVztJQUNwRjtBQUNKO0FBQ0Esa0RBQWtELEdBQzNDLFNBQVNDLGFBQWFDLEVBQUUsRUFBRWYsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDbEQsSUFBSWMsVUFBVUQsR0FBR0UsWUFBWSxDQUFDakI7SUFDOUIsSUFBSWdCLFlBQVksTUFBTTtRQUNsQkQsR0FBR0csWUFBWSxDQUFDakIsU0FBU2U7UUFDekJYLFFBQVFDLElBQUksQ0FBQyw4QkFBOEJOLFVBQVUsT0FBT2dCLFVBQVUsc0NBQXNDZCxNQUFNLGtDQUM5R0QsVUFBVTtJQUNsQjtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxNQUFNa0I7SUFDVCw4SEFBOEgsR0FDOUgsT0FBT0MsWUFBWUMsR0FBRyxFQUFtQjtZQUFqQkMsT0FBQUEsaUVBQU9DO1FBQzNCLElBQUksT0FBT0YsUUFBUSxVQUFVO1lBQ3pCLE1BQU1HLE1BQU0sb0JBQXFCRixPQUFRQSxPQUFPWDtZQUNoRCx3R0FBd0c7WUFDeEcsbUZBQW1GO1lBQ25GLG9GQUFvRjtZQUNwRixJQUFJYSxPQUFPLENBQUNDLE1BQU0sQ0FBQ0osR0FBRyxDQUFDLEVBQUUsR0FBRztnQkFDeEIsTUFBTU4sS0FBS1MsSUFBSUUsY0FBYyxDQUFDTDtnQkFDOUIsT0FBT04sS0FBSztvQkFBQ0E7aUJBQUcsR0FBRyxFQUFFO1lBQ3pCO1lBQ0EsSUFBSVksT0FBT0wsS0FBS00sZ0JBQWdCLENBQUNQO1lBQ2pDLElBQUksQ0FBQ00sS0FBS0UsTUFBTSxJQUFJUixHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSztnQkFDbERNLE9BQU9MLEtBQUtNLGdCQUFnQixDQUFDLE1BQU1QO2dCQUNuQyxJQUFJLENBQUNNLEtBQUtFLE1BQU0sRUFBRTtvQkFDZEYsT0FBT0wsS0FBS00sZ0JBQWdCLENBQUMsTUFBTVA7Z0JBQ3ZDO1lBQ0o7WUFDQSxPQUFPUyxNQUFNQyxJQUFJLENBQUNKO1FBQ3RCO1FBQ0EsT0FBTztZQUFDTjtTQUFJO0lBQ2hCO0lBQ0EsdUhBQXVILEdBQ3ZILE9BQU9XLFdBQVdYLEdBQUcsRUFBbUI7WUFBakJDLE9BQUFBLGlFQUFPQztRQUMxQixJQUFJLE9BQU9GLFFBQVEsVUFBVTtZQUN6QixNQUFNRyxNQUFNLG9CQUFxQkYsT0FBUUEsT0FBT1g7WUFDaEQsSUFBSSxDQUFDVSxJQUFJUSxNQUFNLEVBQ1gsT0FBTztZQUNYLElBQUlMLE9BQU9ILEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSztnQkFDdkIsT0FBT0csSUFBSUUsY0FBYyxDQUFDTCxJQUFJWSxTQUFTLENBQUM7WUFDNUM7WUFDQSxJQUFJWixHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLO2dCQUNwRCxPQUFPQyxLQUFLWSxhQUFhLENBQUNiO1lBQzlCO1lBQ0EsNkdBQTZHO1lBQzdHLElBQUlHLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDSixHQUFHLENBQUMsRUFBRSxHQUFHO2dCQUN4QixPQUFPRyxJQUFJRSxjQUFjLENBQUNMO1lBQzlCO1lBQ0EsMENBQTBDO1lBQzFDLElBQUlOLEtBQUtPLEtBQUtZLGFBQWEsQ0FBQ2I7WUFDNUIsSUFBSUcsT0FBTyxDQUFDVCxJQUFJO2dCQUNaQSxLQUFLUyxJQUFJRSxjQUFjLENBQUNMO1lBQzVCO1lBQ0EsSUFBSSxDQUFDTixJQUFJO2dCQUNMQSxLQUFLTyxLQUFLWSxhQUFhLENBQUMsTUFBTWI7WUFDbEM7WUFDQSxPQUFPTjtRQUNYO1FBQ0EsT0FBT007SUFDWDtJQUNBLHdDQUF3QyxHQUN4QyxPQUFPYyxvQkFBb0JDLENBQUMsRUFBRTtRQUMxQixPQUFPQSxDQUFBQSxjQUFBQSx3QkFBQUEsRUFBR0MsSUFBSSxLQUFLLEVBQUMsQ0FBQ0QsRUFBRUUsYUFBYSxJQUFLRixFQUFFQyxJQUFJLENBQUMzQixJQUFJLENBQUM0QixhQUFhLElBQUlGLEVBQUVFLGFBQWEsS0FBSyxLQUFLO0lBQ25HO0lBQ0Esb0NBQW9DLEdBQ3BDLE9BQU9DLGNBQWNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sQ0FBRUQsQ0FBQUEsRUFBRUUsQ0FBQyxJQUFJRCxFQUFFQyxDQUFDLEdBQUdELEVBQUVFLENBQUMsSUFBSUgsRUFBRUUsQ0FBQyxHQUFHRixFQUFFRyxDQUFDLElBQUlGLEVBQUVDLENBQUMsSUFBSUYsRUFBRUksQ0FBQyxHQUFHSixFQUFFSyxDQUFDLElBQUlKLEVBQUVHLENBQUMsSUFBSUosRUFBRUksQ0FBQyxJQUFJSCxFQUFFRyxDQUFDLEdBQUdILEVBQUVJLENBQUM7SUFDekY7SUFDQSxtREFBbUQsR0FDbkQsT0FBT0MsV0FBV04sQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDcEIsT0FBT3RCLE1BQU1vQixhQUFhLENBQUNDLEdBQUc7WUFBRUksR0FBR0gsRUFBRUcsQ0FBQyxHQUFHO1lBQUtGLEdBQUdELEVBQUVDLENBQUMsR0FBRztZQUFLRyxHQUFHSixFQUFFSSxDQUFDLEdBQUc7WUFBR0YsR0FBR0YsRUFBRUUsQ0FBQyxHQUFHO1FBQUU7SUFDdkY7SUFDQSxxQ0FBcUMsR0FDckMsT0FBT0ksY0FBY1AsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDdkIsSUFBSU8sS0FBSyxFQUFHSixDQUFDLEdBQUdILEVBQUVHLENBQUMsR0FBSUosRUFBRUksQ0FBQyxHQUFHSCxFQUFFRyxDQUFDO1FBQ2hDLElBQUlLLEtBQUssRUFBR0wsQ0FBQyxHQUFHSixFQUFFSyxDQUFDLEdBQUdKLEVBQUVHLENBQUMsR0FBR0gsRUFBRUksQ0FBQyxHQUFJTCxFQUFFSSxDQUFDLEdBQUdKLEVBQUVLLENBQUMsR0FBR0osRUFBRUcsQ0FBQyxHQUFHSCxFQUFFSSxDQUFDO1FBQ3hELElBQUlJLE1BQU1ELElBQ04sT0FBTyxHQUFHLGFBQWE7UUFDM0IsSUFBSUUsS0FBSyxFQUFHUixDQUFDLEdBQUdELEVBQUVDLENBQUMsR0FBSUYsRUFBRUUsQ0FBQyxHQUFHRCxFQUFFQyxDQUFDO1FBQ2hDLElBQUlTLEtBQUssRUFBR1QsQ0FBQyxHQUFHRixFQUFFRyxDQUFDLEdBQUdGLEVBQUVDLENBQUMsR0FBR0QsRUFBRUUsQ0FBQyxHQUFJSCxFQUFFRSxDQUFDLEdBQUdGLEVBQUVHLENBQUMsR0FBR0YsRUFBRUMsQ0FBQyxHQUFHRCxFQUFFRSxDQUFDO1FBQ3hELElBQUlRLE1BQU1ELElBQ04sT0FBTyxHQUFHLGFBQWE7UUFDM0IsT0FBTyxDQUFDRCxLQUFLRCxFQUFDLElBQU1HLENBQUFBLEtBQUtELEVBQUM7SUFDOUI7SUFDQSxxQkFBcUIsR0FDckIsT0FBT0UsS0FBS1osQ0FBQyxFQUFFO1FBQ1gsT0FBT0EsRUFBRUssQ0FBQyxHQUFHTCxFQUFFRyxDQUFDO0lBQ3BCO0lBQ0E7Ozs7O01BS0UsR0FDRixPQUFPVSxLQUFLQyxLQUFLLEVBQW1CO1lBQWpCQyxNQUFBQSxpRUFBTSxHQUFHQztRQUN4QkEsU0FBU0EsVUFBVUYsTUFBTUcsTUFBTSxDQUFDLENBQUNDLEtBQUt0QixJQUFNdUIsS0FBS0MsR0FBRyxDQUFDeEIsRUFBRVEsQ0FBQyxHQUFHUixFQUFFUyxDQUFDLEVBQUVhLE1BQU0sTUFBTTtRQUM1RSxJQUFJSCxRQUFRLENBQUMsR0FDVCxPQUFPRCxNQUFNRCxJQUFJLENBQUMsQ0FBQ2IsR0FBR0M7Z0JBQVFBLE1BQWdCQSxNQUEyQkQsTUFBZ0JBO21CQUE3RCxDQUFFQyxDQUFBQSxPQUFBQSxFQUFFRyxDQUFDLGNBQUhILGtCQUFBQSxPQUFPLElBQUcsSUFBSyxDQUFDQSxDQUFBQSxPQUFBQSxFQUFFQyxDQUFDLGNBQUhELGtCQUFBQSxPQUFPLElBQUcsSUFBS2UsU0FBVyxFQUFDaEIsQ0FBQUEsT0FBQUEsRUFBRUksQ0FBQyxjQUFISixrQkFBQUEsT0FBTyxJQUFHLElBQUssQ0FBQ0EsQ0FBQUEsT0FBQUEsRUFBRUUsQ0FBQyxjQUFIRixrQkFBQUEsT0FBTyxJQUFHLElBQUtnQixNQUFLO1FBQUM7YUFFOUcsT0FBT0YsTUFBTUQsSUFBSSxDQUFDLENBQUNaLEdBQUdEO2dCQUFRQyxNQUFnQkEsTUFBMkJELE1BQWdCQTttQkFBN0QsQ0FBRUMsQ0FBQUEsT0FBQUEsRUFBRUcsQ0FBQyxjQUFISCxrQkFBQUEsT0FBTyxJQUFHLElBQUssQ0FBQ0EsQ0FBQUEsT0FBQUEsRUFBRUMsQ0FBQyxjQUFIRCxrQkFBQUEsT0FBTyxJQUFHLElBQUtlLFNBQVcsRUFBQ2hCLENBQUFBLE9BQUFBLEVBQUVJLENBQUMsY0FBSEosa0JBQUFBLE9BQU8sSUFBRyxJQUFLLENBQUNBLENBQUFBLE9BQUFBLEVBQUVFLENBQUMsY0FBSEYsa0JBQUFBLE9BQU8sSUFBRyxJQUFLZ0IsTUFBSztRQUFDO0lBQ3RIO0lBQ0EsdUJBQXVCLEdBQ3ZCLE9BQU9LLEtBQUtQLEtBQUssRUFBRVEsRUFBRSxFQUFFO1FBQ25CLE9BQU9BLEtBQUtSLE1BQU1PLElBQUksQ0FBQ3pCLENBQUFBLElBQUtBLEVBQUUwQixFQUFFLEtBQUtBLE1BQU1uRDtJQUMvQztJQUNBOzs7OztLQUtDLEdBQ0QsT0FBT29ELGlCQUFpQkQsRUFBRSxFQUFFRSxNQUFNLEVBQUVDLE9BQU8sRUFBRTtRQUN6QyxJQUFJQyxRQUFRM0MsU0FBUzRDLGFBQWEsQ0FBQztRQUNuQyxNQUFNQyxRQUFRSCxvQkFBQUEsOEJBQUFBLFFBQVNHLEtBQUs7UUFDNUIsSUFBSUEsT0FDQUYsTUFBTUUsS0FBSyxHQUFHQTtRQUNsQkYsTUFBTWhELFlBQVksQ0FBQyxRQUFRO1FBQzNCZ0QsTUFBTWhELFlBQVksQ0FBQyxlQUFlNEM7UUFDbEMsOERBQThEO1FBQzlELElBQUlJLE1BQU1HLFVBQVUsRUFBRTtZQUNsQiw4REFBOEQ7WUFDOURILE1BQU1HLFVBQVUsQ0FBQ0MsT0FBTyxHQUFHO1FBQy9CLE9BQ0s7WUFDREosTUFBTUssV0FBVyxDQUFDaEQsU0FBU2lELGNBQWMsQ0FBQyxNQUFNLGNBQWM7UUFDbEU7UUFDQSxJQUFJLENBQUNSLFFBQVE7WUFDVCxrQkFBa0I7WUFDbEJBLFNBQVN6QyxTQUFTa0Qsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakRULE9BQU9PLFdBQVcsQ0FBQ0w7UUFDdkIsT0FDSztZQUNERixPQUFPVSxZQUFZLENBQUNSLE9BQU9GLE9BQU9XLFVBQVU7UUFDaEQ7UUFDQSxPQUFPVCxNQUFNVSxLQUFLO0lBQ3RCO0lBQ0Esb0NBQW9DLEdBQ3BDLE9BQU9DLGlCQUFpQmYsRUFBRSxFQUFFO1FBQ3hCLElBQUkvQyxLQUFLUSxTQUFTVyxhQUFhLENBQUMsdUJBQXVCNEIsS0FBSztRQUM1RCxJQUFJL0MsTUFBTUEsR0FBRytELFVBQVUsRUFDbkIvRCxHQUFHZ0UsTUFBTTtJQUNqQjtJQUNBLHVCQUF1QixHQUN2QixPQUFPQyxXQUFXSixLQUFLLEVBQUVLLFFBQVEsRUFBRUMsS0FBSyxFQUFFO1FBQ3RDLElBQUksT0FBT04sTUFBTU8sT0FBTyxLQUFLLFlBQVk7WUFDckNQLE1BQU1PLE9BQU8sQ0FBQ0YsVUFBVUM7UUFDNUIsT0FDSyxJQUFJLE9BQU9OLE1BQU1RLFVBQVUsS0FBSyxZQUFZO1lBQzdDUixNQUFNUSxVQUFVLENBQUMsR0FBZUYsT0FBWkQsVUFBUyxLQUFTLE9BQU5DLE9BQU07UUFDMUM7SUFDSjtJQUNBLDhEQUE4RDtJQUM5RCxPQUFPRyxPQUFPQyxDQUFDLEVBQUU7UUFDYixJQUFJLE9BQU9BLE1BQU0sV0FBVztZQUN4QixPQUFPQTtRQUNYO1FBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7WUFDdkJBLElBQUlBLEVBQUVDLFdBQVc7WUFDakIsT0FBTyxDQUFFRCxDQUFBQSxNQUFNLE1BQU1BLE1BQU0sUUFBUUEsTUFBTSxXQUFXQSxNQUFNLEdBQUU7UUFDaEU7UUFDQSxPQUFPRSxRQUFRRjtJQUNuQjtJQUNBLE9BQU9HLFNBQVNDLEtBQUssRUFBRTtRQUNuQixPQUFPLFVBQVcsUUFBUUEsTUFBTTdELE1BQU0sS0FBSyxJQUFLbEIsWUFBWWdGLE9BQU9EO0lBQ3ZFO0lBQ0EsT0FBT0UsWUFBWUMsR0FBRyxFQUFFO1FBQ3BCLElBQUlsRDtRQUNKLElBQUltRCxPQUFPO1FBQ1gsSUFBSSxPQUFPRCxRQUFRLFVBQVU7WUFDekIsSUFBSUEsUUFBUSxRQUNSbEQsSUFBSTtpQkFDSDtnQkFDRCxJQUFJb0QsUUFBUUYsSUFBSUUsS0FBSyxDQUFDO2dCQUN0QixJQUFJLENBQUNBLE9BQU87b0JBQ1IsTUFBTSxJQUFJQyxNQUFNO2dCQUNwQjtnQkFDQUYsT0FBT0MsS0FBSyxDQUFDLEVBQUUsSUFBSTtnQkFDbkJwRCxJQUFJc0QsV0FBV0YsS0FBSyxDQUFDLEVBQUU7WUFDM0I7UUFDSixPQUNLO1lBQ0RwRCxJQUFJa0Q7UUFDUjtRQUNBLE9BQU87WUFBRWxEO1lBQUdtRDtRQUFLO0lBQ3JCO0lBQ0EsMEVBQTBFLEdBQzFFLDJCQUEyQjtJQUMzQixPQUFPSSxTQUFTQyxNQUFNLEVBQWM7UUFBWjtZQUFHQyxRQUFILDJCQUFVO1FBQUQ7UUFDN0JBLFFBQVFDLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDWixJQUFLLE1BQU1DLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUksQ0FBQ0EsT0FBT0UsY0FBYyxDQUFDRCxNQUN2QjtnQkFDSixJQUFJSixNQUFNLENBQUNJLElBQUksS0FBSyxRQUFRSixNQUFNLENBQUNJLElBQUksS0FBSzVGLFdBQVc7b0JBQ25Ed0YsTUFBTSxDQUFDSSxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDN0IsT0FDSyxJQUFJLE9BQU9ELE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFlBQVksT0FBT0osTUFBTSxDQUFDSSxJQUFJLEtBQUssVUFBVTtvQkFDekUsa0VBQWtFO29CQUNsRSxJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSSxJQUFJLEVBQUVELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDMUM7WUFDSjtRQUNKO1FBQ0EsT0FBT0o7SUFDWDtJQUNBLHFJQUFxSSxHQUNySSxPQUFPTSxLQUFLakUsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDZCxJQUFJLE9BQU9ELE1BQU0sVUFDYixPQUFPQSxLQUFLQztRQUNoQixJQUFJLE9BQU9ELE1BQU0sT0FBT0MsR0FDcEIsT0FBTztRQUNYLHdFQUF3RTtRQUN4RSxJQUFJaUUsT0FBT0MsSUFBSSxDQUFDbkUsR0FBR1gsTUFBTSxLQUFLNkUsT0FBT0MsSUFBSSxDQUFDbEUsR0FBR1osTUFBTSxFQUMvQyxPQUFPO1FBQ1gsSUFBSyxNQUFNMEUsT0FBTy9ELEVBQUc7WUFDakIsSUFBSUEsQ0FBQyxDQUFDK0QsSUFBSSxLQUFLOUQsQ0FBQyxDQUFDOEQsSUFBSSxFQUNqQixPQUFPO1FBQ2Y7UUFDQSxPQUFPO0lBQ1g7SUFDQSxzRkFBc0YsR0FDdEYsT0FBT0ssUUFBUXBFLENBQUMsRUFBRUMsQ0FBQyxFQUFvQjtZQUFsQm9FLFdBQUFBLGlFQUFXO1FBQzVCLElBQUlwRSxFQUFFRyxDQUFDLEtBQUtqQyxXQUNSNkIsRUFBRUksQ0FBQyxHQUFHSCxFQUFFRyxDQUFDO1FBQ2IsSUFBSUgsRUFBRUMsQ0FBQyxLQUFLL0IsV0FDUjZCLEVBQUVFLENBQUMsR0FBR0QsRUFBRUMsQ0FBQztRQUNiLElBQUlELEVBQUVJLENBQUMsS0FBS2xDLFdBQ1I2QixFQUFFSyxDQUFDLEdBQUdKLEVBQUVJLENBQUM7UUFDYixJQUFJSixFQUFFRSxDQUFDLEtBQUtoQyxXQUNSNkIsRUFBRUcsQ0FBQyxHQUFHRixFQUFFRSxDQUFDO1FBQ2IsSUFBSWtFLFVBQVU7WUFDVixJQUFJcEUsRUFBRXFFLElBQUksRUFDTnRFLEVBQUVzRSxJQUFJLEdBQUdyRSxFQUFFcUUsSUFBSTtZQUNuQixJQUFJckUsRUFBRXNFLElBQUksRUFDTnZFLEVBQUV1RSxJQUFJLEdBQUd0RSxFQUFFc0UsSUFBSTtZQUNuQixJQUFJdEUsRUFBRXVFLElBQUksRUFDTnhFLEVBQUV3RSxJQUFJLEdBQUd2RSxFQUFFdUUsSUFBSTtZQUNuQixJQUFJdkUsRUFBRXdFLElBQUksRUFDTnpFLEVBQUV5RSxJQUFJLEdBQUd4RSxFQUFFd0UsSUFBSTtRQUN2QjtRQUNBLE9BQU96RTtJQUNYO0lBQ0EsNkNBQTZDLEdBQzdDLE9BQU8wRSxRQUFRMUUsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDakIsT0FBT0QsS0FBS0MsS0FBS0QsRUFBRUksQ0FBQyxLQUFLSCxFQUFFRyxDQUFDLElBQUlKLEVBQUVFLENBQUMsS0FBS0QsRUFBRUMsQ0FBQyxJQUFJLENBQUNGLEVBQUVLLENBQUMsSUFBSSxPQUFRSixDQUFBQSxFQUFFSSxDQUFDLElBQUksTUFBTSxDQUFDTCxFQUFFRyxDQUFDLElBQUksT0FBUUYsQ0FBQUEsRUFBRUUsQ0FBQyxJQUFJO0lBQ3ZHO0lBQ0Esb0RBQW9ELEdBQ3BELE9BQU93RSxlQUFlQyxJQUFJLEVBQUU7UUFDeEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0EsS0FBS04sSUFBSSxFQUFFO1lBQ1osT0FBT00sS0FBS04sSUFBSTtRQUNwQjtRQUNBLElBQUksQ0FBQ00sS0FBS0wsSUFBSSxFQUFFO1lBQ1osT0FBT0ssS0FBS0wsSUFBSTtRQUNwQjtRQUNBLElBQUksQ0FBQ0ssS0FBS0osSUFBSSxFQUFFO1lBQ1osT0FBT0ksS0FBS0osSUFBSTtRQUNwQjtRQUNBLElBQUksQ0FBQ0ksS0FBS0gsSUFBSSxFQUFFO1lBQ1osT0FBT0csS0FBS0gsSUFBSTtRQUNwQjtJQUNKO0lBQ0EsaUhBQWlILEdBQ2pILE9BQU9JLHNCQUFzQjdFLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQy9CLElBQUksT0FBT0QsTUFBTSxZQUFZLE9BQU9DLE1BQU0sVUFDdEM7UUFDSixJQUFLLElBQUk4RCxPQUFPL0QsRUFBRztZQUNmLElBQUlxRCxNQUFNckQsQ0FBQyxDQUFDK0QsSUFBSTtZQUNoQixJQUFJQSxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9WLFFBQVFwRCxDQUFDLENBQUM4RCxJQUFJLEVBQUU7Z0JBQ2xDLE9BQU8vRCxDQUFDLENBQUMrRCxJQUFJO1lBQ2pCLE9BQ0ssSUFBSVYsT0FBTyxPQUFPQSxRQUFRLFlBQVlwRCxDQUFDLENBQUM4RCxJQUFJLEtBQUs1RixXQUFXO2dCQUM3RCxJQUFLLElBQUkyRyxLQUFLekIsSUFBSztvQkFDZixJQUFJQSxHQUFHLENBQUN5QixFQUFFLEtBQUs3RSxDQUFDLENBQUM4RCxJQUFJLENBQUNlLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLO3dCQUN0QyxPQUFPekIsR0FBRyxDQUFDeUIsRUFBRTtvQkFDakI7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDWixPQUFPQyxJQUFJLENBQUNkLEtBQUtoRSxNQUFNLEVBQUU7b0JBQzFCLE9BQU9XLENBQUMsQ0FBQytELElBQUk7Z0JBQ2pCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsOERBQThELEdBQzlELE9BQU9nQixzQkFBc0JuRixDQUFDLEVBQW1CO1lBQWpCb0YsV0FBQUEsaUVBQVc7UUFDdkMsSUFBSyxJQUFJakIsT0FBT25FLEVBQUc7WUFDZixJQUFJbUUsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPbkUsQ0FBQyxDQUFDbUUsSUFBSSxLQUFLLFFBQVFuRSxDQUFDLENBQUNtRSxJQUFJLEtBQUs1RixXQUNoRCxPQUFPeUIsQ0FBQyxDQUFDbUUsSUFBSTtRQUNyQjtRQUNBLE9BQU9uRSxFQUFFQyxJQUFJO1FBQ2IsSUFBSW1GLFVBQ0EsT0FBT3BGLEVBQUVyQixFQUFFO1FBQ2YscURBQXFEO1FBQ3JELElBQUksQ0FBQ3FCLEVBQUVxRixZQUFZLEVBQ2YsT0FBT3JGLEVBQUVxRixZQUFZO1FBQ3pCLElBQUksQ0FBQ3JGLEVBQUVzRixRQUFRLEVBQ1gsT0FBT3RGLEVBQUVzRixRQUFRO1FBQ3JCLElBQUksQ0FBQ3RGLEVBQUV1RixNQUFNLEVBQ1QsT0FBT3ZGLEVBQUV1RixNQUFNO1FBQ25CLElBQUksQ0FBQ3ZGLEVBQUV3RixNQUFNLEVBQ1QsT0FBT3hGLEVBQUV3RixNQUFNO1FBQ25CLElBQUl4RixFQUFFUyxDQUFDLEtBQUssS0FBS1QsRUFBRVMsQ0FBQyxLQUFLVCxFQUFFMEUsSUFBSSxFQUMzQixPQUFPMUUsRUFBRVMsQ0FBQztRQUNkLElBQUlULEVBQUVPLENBQUMsS0FBSyxLQUFLUCxFQUFFTyxDQUFDLEtBQUtQLEVBQUUyRSxJQUFJLEVBQzNCLE9BQU8zRSxFQUFFTyxDQUFDO0lBQ2xCO0lBQ0EsbUVBQW1FLEdBQ25FLHdFQUF3RTtJQUN4RSxpQkFBaUI7SUFDakIsa0RBQWtEO0lBQ2xELDRCQUE0QjtJQUM1QixNQUFNO0lBQ04saUJBQWlCO0lBQ2pCLElBQUk7SUFDSix3R0FBd0csR0FDeEcsT0FBT2tGLFNBQVNDLElBQUksRUFBRUMsS0FBSyxFQUFFO1FBQ3pCLElBQUlDLFlBQVk7UUFDaEIsT0FBTzs2Q0FBSTVIO2dCQUFBQTs7WUFDUCxJQUFJLENBQUM0SCxXQUFXO2dCQUNaQSxZQUFZO2dCQUNaQyxXQUFXO29CQUFRSCxRQUFRMUg7b0JBQU80SCxZQUFZO2dCQUFPLEdBQUdEO1lBQzVEO1FBQ0o7SUFDSjtJQUNBLE9BQU9HLHdCQUF3Qm5ILEVBQUUsRUFBRTtRQUMvQixJQUFJbUQsUUFBUW5ELEdBQUdtRCxLQUFLO1FBQ3BCLElBQUlBLE1BQU1pRSxRQUFRLEVBQUU7WUFDaEJqRSxNQUFNa0UsY0FBYyxDQUFDO1FBQ3pCO1FBQ0EsSUFBSWxFLE1BQU1tRSxJQUFJLEVBQUU7WUFDWm5FLE1BQU1rRSxjQUFjLENBQUM7UUFDekI7UUFDQSxJQUFJbEUsTUFBTW9FLEdBQUcsRUFBRTtZQUNYcEUsTUFBTWtFLGNBQWMsQ0FBQztRQUN6QjtRQUNBLElBQUlsRSxNQUFNcUUsS0FBSyxFQUFFO1lBQ2JyRSxNQUFNa0UsY0FBYyxDQUFDO1FBQ3pCO1FBQ0EsSUFBSWxFLE1BQU1zRSxNQUFNLEVBQUU7WUFDZHRFLE1BQU1rRSxjQUFjLENBQUM7UUFDekI7SUFDSjtJQUNBLHVJQUF1SSxHQUN2SSxPQUFPSyxpQkFBaUIxSCxFQUFFLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxJQUNELE9BQU9RLFNBQVNtSCxnQkFBZ0IsSUFBSW5ILFNBQVNvSCxlQUFlLEVBQUUsYUFBYTtRQUMvRSxNQUFNekUsUUFBUTBFLGlCQUFpQjdIO1FBQy9CLE1BQU04SCxnQkFBZ0I7UUFDdEIsSUFBSUEsY0FBY0MsSUFBSSxDQUFDNUUsTUFBTTZFLFFBQVEsR0FBRzdFLE1BQU04RSxTQUFTLEdBQUc7WUFDdEQsT0FBT2pJO1FBQ1gsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDMEgsZ0JBQWdCLENBQUMxSCxHQUFHa0ksYUFBYTtRQUNqRDtJQUNKO0lBQ0EsY0FBYyxHQUNkLE9BQU9DLHFCQUFxQm5JLEVBQUUsRUFBRW9ILFFBQVEsRUFBRWdCLFFBQVEsRUFBRTtRQUNoRCxxQkFBcUI7UUFDckIsSUFBSUMsT0FBT3JJLEdBQUdzSSxxQkFBcUI7UUFDbkMsSUFBSUMsNEJBQTZCQyxPQUFPQyxXQUFXLElBQUlqSSxTQUFTb0gsZUFBZSxDQUFDYyxZQUFZO1FBQzVGLElBQUlMLEtBQUtkLEdBQUcsR0FBRyxLQUNYYyxLQUFLTSxNQUFNLEdBQUdKLDJCQUEyQjtZQUN6Qyw2Q0FBNkM7WUFDN0Msc0RBQXNEO1lBQ3RELGlDQUFpQztZQUNqQyxJQUFJSyxpQkFBaUJQLEtBQUtNLE1BQU0sR0FBR0o7WUFDbkMsSUFBSU0sZUFBZVIsS0FBS2QsR0FBRztZQUMzQixJQUFJdUIsV0FBVyxJQUFJLENBQUNwQixnQkFBZ0IsQ0FBQzFIO1lBQ3JDLElBQUk4SSxhQUFhLE1BQU07Z0JBQ25CLElBQUlDLGFBQWFELFNBQVNFLFNBQVM7Z0JBQ25DLElBQUlYLEtBQUtkLEdBQUcsR0FBRyxLQUFLYSxXQUFXLEdBQUc7b0JBQzlCLFlBQVk7b0JBQ1osSUFBSXBJLEdBQUdpSixZQUFZLEdBQUdWLDJCQUEyQjt3QkFDN0NPLFNBQVNFLFNBQVMsSUFBSVo7b0JBQzFCLE9BQ0s7d0JBQ0RVLFNBQVNFLFNBQVMsSUFBSXBHLEtBQUtzRyxHQUFHLENBQUNMLGdCQUFnQmpHLEtBQUtzRyxHQUFHLENBQUNkLFlBQVlBLFdBQVdTO29CQUNuRjtnQkFDSixPQUNLLElBQUlULFdBQVcsR0FBRztvQkFDbkIsY0FBYztvQkFDZCxJQUFJcEksR0FBR2lKLFlBQVksR0FBR1YsMkJBQTJCO3dCQUM3Q08sU0FBU0UsU0FBUyxJQUFJWjtvQkFDMUIsT0FDSzt3QkFDRFUsU0FBU0UsU0FBUyxJQUFJSixpQkFBaUJSLFdBQVdBLFdBQVdRO29CQUNqRTtnQkFDSjtnQkFDQSxtQ0FBbUM7Z0JBQ25DeEIsU0FBU0csR0FBRyxJQUFJdUIsU0FBU0UsU0FBUyxHQUFHRDtZQUN6QztRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRCxPQUFPSSxtQkFBbUJDLEtBQUssRUFBRXBKLEVBQUUsRUFBRW9JLFFBQVEsRUFBRTtRQUMzQyxNQUFNVSxXQUFXLElBQUksQ0FBQ3BCLGdCQUFnQixDQUFDMUg7UUFDdkMsTUFBTXlILFNBQVNxQixTQUFTSixZQUFZO1FBQ3BDLDZIQUE2SDtRQUM3SCx3RkFBd0Y7UUFDeEYsZ0dBQWdHO1FBQ2hHLHlHQUF5RztRQUN6RyxNQUFNVyxZQUFZLGFBQWMsSUFBSSxDQUFDM0IsZ0JBQWdCLEtBQU0sSUFBSW9CLFNBQVNSLHFCQUFxQixHQUFHZixHQUFHO1FBQ25HLE1BQU0rQixjQUFjRixNQUFNRyxPQUFPLEdBQUdGO1FBQ3BDLE1BQU05QixNQUFNK0IsY0FBY2xCO1FBQzFCLE1BQU1PLFNBQVNXLGNBQWM3QixTQUFTVztRQUN0QyxJQUFJYixLQUFLO1lBQ0wsNEVBQTRFO1lBQzVFLHVEQUF1RDtZQUN2RHVCLFNBQVNVLFFBQVEsQ0FBQztnQkFBRUMsVUFBVTtnQkFBVWxDLEtBQUsrQixjQUFjbEI7WUFBUztRQUN4RSxPQUNLLElBQUlPLFFBQVE7WUFDYkcsU0FBU1UsUUFBUSxDQUFDO2dCQUFFQyxVQUFVO2dCQUFVbEMsS0FBS2EsV0FBWVgsQ0FBQUEsU0FBUzZCLFdBQVU7WUFBRztRQUNuRjtJQUNKO0lBQ0EsNEdBQTRHLEdBQzVHLE9BQU9JLE1BQU1DLEdBQUcsRUFBRTtRQUNkLElBQUlBLFFBQVEsUUFBUUEsUUFBUS9KLGFBQWEsT0FBUStKLFFBQVMsVUFBVTtZQUNoRSxPQUFPQTtRQUNYO1FBQ0EsaUNBQWlDO1FBQ2pDLElBQUlBLGVBQWU1SSxPQUFPO1lBQ3RCLDhEQUE4RDtZQUM5RCxPQUFPO21CQUFJNEk7YUFBSTtRQUNuQjtRQUNBLE9BQU87WUFBRSxHQUFHQSxHQUFHO1FBQUM7SUFDcEI7SUFDQTs7O0tBR0MsR0FDRCxPQUFPQyxVQUFVRCxHQUFHLEVBQUU7UUFDbEIsZ0ZBQWdGO1FBQ2hGLE1BQU1FLGFBQWE7WUFBQztZQUFjO1lBQU07WUFBUTtZQUFXO1NBQVM7UUFDcEUsNkVBQTZFO1FBQzdFLE1BQU1DLE1BQU0xSixNQUFNc0osS0FBSyxDQUFDQztRQUN4QixJQUFLLE1BQU1uRSxPQUFPc0UsSUFBSztZQUNuQiw0RkFBNEY7WUFDNUYsSUFBSUEsSUFBSXJFLGNBQWMsQ0FBQ0QsUUFBUSxPQUFRc0UsR0FBRyxDQUFDdEUsSUFBSSxLQUFNLFlBQVlBLElBQUl0RSxTQUFTLENBQUMsR0FBRyxPQUFPLFFBQVEsQ0FBQzJJLFdBQVcvRyxJQUFJLENBQUNpSCxDQUFBQSxJQUFLQSxNQUFNdkUsTUFBTTtnQkFDL0hzRSxHQUFHLENBQUN0RSxJQUFJLEdBQUdwRixNQUFNd0osU0FBUyxDQUFDRCxHQUFHLENBQUNuRSxJQUFJO1lBQ3ZDO1FBQ0o7UUFDQSxPQUFPc0U7SUFDWDtJQUNBLGlFQUFpRSxHQUNqRSxPQUFPRSxVQUFVaEssRUFBRSxFQUFFO1FBQ2pCLE1BQU1xRyxPQUFPckcsR0FBR2dLLFNBQVMsQ0FBQztRQUMxQjNELEtBQUs0RCxlQUFlLENBQUM7UUFDckIsT0FBTzVEO0lBQ1g7SUFDQSxPQUFPNkQsU0FBU2xLLEVBQUUsRUFBRWlELE1BQU0sRUFBRTtRQUN4QixJQUFJYztRQUNKLElBQUksT0FBT2QsV0FBVyxVQUFVO1lBQzVCYyxhQUFhM0QsTUFBTWEsVUFBVSxDQUFDZ0M7UUFDbEMsT0FDSztZQUNEYyxhQUFhZDtRQUNqQjtRQUNBLElBQUljLFlBQVk7WUFDWkEsV0FBV1AsV0FBVyxDQUFDeEQ7UUFDM0I7SUFDSjtJQUNBLDZEQUE2RDtJQUM3RCwrREFBK0Q7SUFDL0Qsc0NBQXNDO0lBQ3RDLE1BQU07SUFDTixJQUFJO0lBQ0osT0FBT21LLFlBQVluSyxFQUFFLEVBQUVvSyxNQUFNLEVBQUU7UUFDM0IsSUFBSUEsa0JBQWtCekUsUUFBUTtZQUMxQixJQUFLLE1BQU0wRSxLQUFLRCxPQUFRO2dCQUNwQixJQUFJQSxPQUFPM0UsY0FBYyxDQUFDNEUsSUFBSTtvQkFDMUIsSUFBSXRKLE1BQU11SixPQUFPLENBQUNGLE1BQU0sQ0FBQ0MsRUFBRSxHQUFHO3dCQUMxQix5QkFBeUI7d0JBQ3pCRCxNQUFNLENBQUNDLEVBQUUsQ0FBQy9FLE9BQU8sQ0FBQ1IsQ0FBQUE7NEJBQ2Q5RSxHQUFHbUQsS0FBSyxDQUFDa0gsRUFBRSxHQUFHdkY7d0JBQ2xCO29CQUNKLE9BQ0s7d0JBQ0Q5RSxHQUFHbUQsS0FBSyxDQUFDa0gsRUFBRSxHQUFHRCxNQUFNLENBQUNDLEVBQUU7b0JBQzNCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT0UsVUFBVUMsQ0FBQyxFQUFFMUssSUFBSSxFQUFFO1FBQ3RCLE1BQU0ySyxNQUFNO1lBQUVDLE1BQU01SyxLQUFLNEssSUFBSTtRQUFDO1FBQzlCLE1BQU1mLE1BQU07WUFDUmdCLFFBQVE7WUFDUkMsT0FBTztZQUNQQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVEMsWUFBWTtZQUNaM0YsUUFBUXRGLEtBQUtzRixNQUFNLEdBQUd0RixLQUFLc0YsTUFBTSxHQUFHb0YsRUFBRXBGLE1BQU07UUFDaEQ7UUFDQSx3RUFBd0U7UUFDeEUsSUFBSW9GLEVBQUVRLFlBQVksRUFBRTtZQUNoQlAsR0FBRyxDQUFDLGVBQWUsR0FBR0QsRUFBRVEsWUFBWSxFQUFFLCtCQUErQjtRQUN6RTtRQUNBO1lBQUM7WUFBVTtZQUFXO1lBQVc7U0FBVyxDQUFDMUYsT0FBTyxDQUFDMkYsQ0FBQUEsSUFBS1IsR0FBRyxDQUFDUSxFQUFFLEdBQUdULENBQUMsQ0FBQ1MsRUFBRSxHQUFHLE9BQU87UUFDakY7WUFBQztZQUFTO1lBQVM7WUFBVztZQUFXO1lBQVc7U0FBVSxDQUFDM0YsT0FBTyxDQUFDMkYsQ0FBQUEsSUFBS1IsR0FBRyxDQUFDUSxFQUFFLEdBQUdULENBQUMsQ0FBQ1MsRUFBRSxHQUFHLGFBQWE7UUFDekcsT0FBTztZQUFFLEdBQUdSLEdBQUc7WUFBRSxHQUFHZCxHQUFHO1FBQUM7SUFDNUI7SUFDQSx1RkFBdUYsR0FDdkYsT0FBT3VCLG1CQUFtQlYsQ0FBQyxFQUFFVyxhQUFhLEVBQUUvRixNQUFNLEVBQUU7UUFDaEQsTUFBTWdHLGlCQUFpQjVLLFNBQVM2SyxXQUFXLENBQUM7UUFDNUNELGVBQWVFLGNBQWMsQ0FBQ0gsZUFDOUIsTUFDQSxNQUNBM0MsUUFDQSxHQUNBZ0MsRUFBRWUsT0FBTyxFQUNUZixFQUFFZ0IsT0FBTyxFQUNUaEIsRUFBRWlCLE9BQU8sRUFDVGpCLEVBQUVqQixPQUFPLEVBQ1RpQixFQUFFa0IsT0FBTyxFQUNUbEIsRUFBRW1CLE1BQU0sRUFDUm5CLEVBQUVvQixRQUFRLEVBQ1ZwQixFQUFFcUIsT0FBTyxFQUNULEdBQ0FyQixFQUFFcEYsTUFBTSxDQUFDLGdCQUFnQjs7UUFFeEJBLENBQUFBLFVBQVVvRixFQUFFcEYsTUFBTSxFQUFFMEcsYUFBYSxDQUFDVjtJQUN2QztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC91dGlscy5qcz9mOTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdXRpbHMudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuLyoqIGNoZWNrcyBmb3Igb2Jzb2xldGUgbWV0aG9kIG5hbWVzICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZShzZWxmLCBmLCBvbGROYW1lLCBuZXdOYW1lLCByZXYpIHtcbiAgICBsZXQgd3JhcHBlciA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ3JpZHN0YWNrLmpzOiBGdW5jdGlvbiBgJyArIG9sZE5hbWUgKyAnYCBpcyBkZXByZWNhdGVkIGluICcgKyByZXYgKyAnIGFuZCBoYXMgYmVlbiByZXBsYWNlZCAnICtcbiAgICAgICAgICAgICd3aXRoIGAnICsgbmV3TmFtZSArICdgLiBJdCB3aWxsIGJlICoqcmVtb3ZlZCoqIGluIGEgZnV0dXJlIHJlbGVhc2UnKTtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfTtcbiAgICB3cmFwcGVyLnByb3RvdHlwZSA9IGYucHJvdG90eXBlO1xuICAgIHJldHVybiB3cmFwcGVyO1xufVxuLyoqIGNoZWNrcyBmb3Igb2Jzb2xldGUgZ3JpZCBvcHRpb25zIChjYW4gYmUgdXNlZCBmb3IgYW55IGZpZWxkcywgYnV0IG1zZyBpcyBhYm91dCBvcHRpb25zKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic29sZXRlT3B0cyhvcHRzLCBvbGROYW1lLCBuZXdOYW1lLCByZXYpIHtcbiAgICBpZiAob3B0c1tvbGROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHNbbmV3TmFtZV0gPSBvcHRzW29sZE5hbWVdO1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay5qczogT3B0aW9uIGAnICsgb2xkTmFtZSArICdgIGlzIGRlcHJlY2F0ZWQgaW4gJyArIHJldiArICcgYW5kIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYCcgK1xuICAgICAgICAgICAgbmV3TmFtZSArICdgLiBJdCB3aWxsIGJlICoqcmVtb3ZlZCoqIGluIGEgZnV0dXJlIHJlbGVhc2UnKTtcbiAgICB9XG59XG4vKiogY2hlY2tzIGZvciBvYnNvbGV0ZSBncmlkIG9wdGlvbnMgd2hpY2ggYXJlIGdvbmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZU9wdHNEZWwob3B0cywgb2xkTmFtZSwgcmV2LCBpbmZvKSB7XG4gICAgaWYgKG9wdHNbb2xkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay5qczogT3B0aW9uIGAnICsgb2xkTmFtZSArICdgIGlzIGRlcHJlY2F0ZWQgaW4gJyArIHJldiArIGluZm8pO1xuICAgIH1cbn1cbi8qKiBjaGVja3MgZm9yIG9ic29sZXRlIEpxdWVyeSBlbGVtZW50IGF0dHJpYnV0ZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZUF0dHIoZWwsIG9sZE5hbWUsIG5ld05hbWUsIHJldikge1xuICAgIGxldCBvbGRBdHRyID0gZWwuZ2V0QXR0cmlidXRlKG9sZE5hbWUpO1xuICAgIGlmIChvbGRBdHRyICE9PSBudWxsKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuZXdOYW1lLCBvbGRBdHRyKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdncmlkc3RhY2suanM6IGF0dHJpYnV0ZSBgJyArIG9sZE5hbWUgKyAnYD0nICsgb2xkQXR0ciArICcgaXMgZGVwcmVjYXRlZCBvbiB0aGlzIG9iamVjdCBpbiAnICsgcmV2ICsgJyBhbmQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBgJyArXG4gICAgICAgICAgICBuZXdOYW1lICsgJ2AuIEl0IHdpbGwgYmUgKipyZW1vdmVkKiogaW4gYSBmdXR1cmUgcmVsZWFzZScpO1xuICAgIH1cbn1cbi8qKlxuICogVXRpbGl0eSBtZXRob2RzXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gICAgLyoqIGNvbnZlcnQgYSBwb3RlbnRpYWwgc2VsZWN0b3IgaW50byBhY3R1YWwgbGlzdCBvZiBodG1sIGVsZW1lbnRzLiBvcHRpb25hbCByb290IHdoaWNoIGRlZmF1bHRzIHRvIGRvY3VtZW50IChmb3Igc2hhZG93IGRvbSkgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudHMoZWxzLCByb290ID0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSAoJ2dldEVsZW1lbnRCeUlkJyBpbiByb290KSA/IHJvb3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBOb3RlOiB2ZXJ5IGNvbW1vbiBmb3IgcGVvcGxlIHVzZSB0byBpZD0nMSwyLDMnIHdoaWNoIGlzIG9ubHkgbGVnYWwgYXMgSFRNTDUgaWQsIGJ1dCBub3QgQ1NTIHNlbGVjdG9yc1xuICAgICAgICAgICAgLy8gc28gaWYgd2Ugc3RhcnQgd2l0aCBhIG51bWJlciwgYXNzdW1lIGl0J3MgYW4gaWQgYW5kIGp1c3QgcmV0dXJuIHRoYXQgb25lIGl0ZW0uLi5cbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9pc3N1ZXMvMjIzNCNpc3N1ZWNvbW1lbnQtMTUyMzc5NjU2MlxuICAgICAgICAgICAgaWYgKGRvYyAmJiAhaXNOYU4oK2Vsc1swXSkpIHsgLy8gc3RhcnQgd2l0aCBkaWdpdFxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZG9jLmdldEVsZW1lbnRCeUlkKGVscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsID8gW2VsXSA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpc3QgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoZWxzKTtcbiAgICAgICAgICAgIGlmICghbGlzdC5sZW5ndGggJiYgZWxzWzBdICE9PSAnLicgJiYgZWxzWzBdICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIGVscyk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcjJyArIGVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtlbHNdO1xuICAgIH1cbiAgICAvKiogY29udmVydCBhIHBvdGVudGlhbCBzZWxlY3RvciBpbnRvIGFjdHVhbCBzaW5nbGUgZWxlbWVudC4gb3B0aW9uYWwgcm9vdCB3aGljaCBkZWZhdWx0cyB0byBkb2N1bWVudCAoZm9yIHNoYWRvdyBkb20pICovXG4gICAgc3RhdGljIGdldEVsZW1lbnQoZWxzLCByb290ID0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSAoJ2dldEVsZW1lbnRCeUlkJyBpbiByb290KSA/IHJvb3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWVscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZG9jICYmIGVsc1swXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5nZXRFbGVtZW50QnlJZChlbHMuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbHNbMF0gPT09ICcjJyB8fCBlbHNbMF0gPT09ICcuJyB8fCBlbHNbMF0gPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LnF1ZXJ5U2VsZWN0b3IoZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIHN0YXJ0IHdpdGggYSBkaWdpdCwgYXNzdW1lIGl0J3MgYW4gaWQgKGVycm9yIGNhbGxpbmcgcXVlcnlTZWxlY3RvcignIzEnKSkgYXMgY2xhc3MgYXJlIG5vdCB2YWxpZCBDU1NcbiAgICAgICAgICAgIGlmIChkb2MgJiYgIWlzTmFOKCtlbHNbMF0pKSB7IC8vIHN0YXJ0IHdpdGggZGlnaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmdldEVsZW1lbnRCeUlkKGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHRyeSBzdHJpbmcsIHRoZW4gaWQsIHRoZW4gY2xhc3NcbiAgICAgICAgICAgIGxldCBlbCA9IHJvb3QucXVlcnlTZWxlY3RvcihlbHMpO1xuICAgICAgICAgICAgaWYgKGRvYyAmJiAhZWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChlbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIGVsID0gcm9vdC5xdWVyeVNlbGVjdG9yKCcuJyArIGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgd2Ugc2hvdWxkIHJlc2l6ZSB0byBjb250ZW50ICovXG4gICAgc3RhdGljIHNob3VsZFNpemVUb0NvbnRlbnQobikge1xuICAgICAgICByZXR1cm4gbj8uZ3JpZCAmJiAoISFuLnNpemVUb0NvbnRlbnQgfHwgKG4uZ3JpZC5vcHRzLnNpemVUb0NvbnRlbnQgJiYgbi5zaXplVG9Db250ZW50ICE9PSBmYWxzZSkpO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0cnVlIGlmIGEgYW5kIGIgb3ZlcmxhcCAqL1xuICAgIHN0YXRpYyBpc0ludGVyY2VwdGVkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICEoYS55ID49IGIueSArIGIuaCB8fCBhLnkgKyBhLmggPD0gYi55IHx8IGEueCArIGEudyA8PSBiLnggfHwgYS54ID49IGIueCArIGIudyk7XG4gICAgfVxuICAgIC8qKiByZXR1cm5zIHRydWUgaWYgYSBhbmQgYiB0b3VjaCBlZGdlcyBvciBjb3JuZXJzICovXG4gICAgc3RhdGljIGlzVG91Y2hpbmcoYSwgYikge1xuICAgICAgICByZXR1cm4gVXRpbHMuaXNJbnRlcmNlcHRlZChhLCB7IHg6IGIueCAtIDAuNSwgeTogYi55IC0gMC41LCB3OiBiLncgKyAxLCBoOiBiLmggKyAxIH0pO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0aGUgYXJlYSBhIGFuZCBiIG92ZXJsYXAgKi9cbiAgICBzdGF0aWMgYXJlYUludGVyY2VwdChhLCBiKSB7XG4gICAgICAgIGxldCB4MCA9IChhLnggPiBiLngpID8gYS54IDogYi54O1xuICAgICAgICBsZXQgeDEgPSAoYS54ICsgYS53IDwgYi54ICsgYi53KSA/IGEueCArIGEudyA6IGIueCArIGIudztcbiAgICAgICAgaWYgKHgxIDw9IHgwKVxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIG5vIG92ZXJsYXBcbiAgICAgICAgbGV0IHkwID0gKGEueSA+IGIueSkgPyBhLnkgOiBiLnk7XG4gICAgICAgIGxldCB5MSA9IChhLnkgKyBhLmggPCBiLnkgKyBiLmgpID8gYS55ICsgYS5oIDogYi55ICsgYi5oO1xuICAgICAgICBpZiAoeTEgPD0geTApXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gbm8gb3ZlcmxhcFxuICAgICAgICByZXR1cm4gKHgxIC0geDApICogKHkxIC0geTApO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0aGUgYXJlYSAqL1xuICAgIHN0YXRpYyBhcmVhKGEpIHtcbiAgICAgICAgcmV0dXJuIGEudyAqIGEuaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydHMgYXJyYXkgb2Ygbm9kZXNcbiAgICAgKiBAcGFyYW0gbm9kZXMgYXJyYXkgdG8gc29ydFxuICAgICAqIEBwYXJhbSBkaXIgMSBmb3IgYXNjLCAtMSBmb3IgZGVzYyAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHRoZSBncmlkLiBJZiB1bmRlZmluZWQgdGhlIHdpZHRoIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IChvcHRpb25hbCkuXG4gICAgICoqL1xuICAgIHN0YXRpYyBzb3J0KG5vZGVzLCBkaXIgPSAxLCBjb2x1bW4pIHtcbiAgICAgICAgY29sdW1uID0gY29sdW1uIHx8IG5vZGVzLnJlZHVjZSgoY29sLCBuKSA9PiBNYXRoLm1heChuLnggKyBuLncsIGNvbCksIDApIHx8IDEyO1xuICAgICAgICBpZiAoZGlyID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zb3J0KChhLCBiKSA9PiAoKGIueCA/PyAxMDAwKSArIChiLnkgPz8gMTAwMCkgKiBjb2x1bW4pIC0gKChhLnggPz8gMTAwMCkgKyAoYS55ID8/IDEwMDApICogY29sdW1uKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zb3J0KChiLCBhKSA9PiAoKGIueCA/PyAxMDAwKSArIChiLnkgPz8gMTAwMCkgKiBjb2x1bW4pIC0gKChhLnggPz8gMTAwMCkgKyAoYS55ID8/IDEwMDApICogY29sdW1uKSk7XG4gICAgfVxuICAgIC8qKiBmaW5kIGFuIGl0ZW0gYnkgaWQgKi9cbiAgICBzdGF0aWMgZmluZChub2RlcywgaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID8gbm9kZXMuZmluZChuID0+IG4uaWQgPT09IGlkKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIHN0eWxlIHNoZWV0IHdpdGggc3R5bGUgaWQgdW5kZXIgZ2l2ZW4gcGFyZW50XG4gICAgICogQHBhcmFtIGlkIHdpbGwgc2V0IHRoZSAnZ3Mtc3R5bGUtaWQnIGF0dHJpYnV0ZSB0byB0aGF0IGlkXG4gICAgICogQHBhcmFtIHBhcmVudCB0byBpbnNlcnQgdGhlIHN0eWxlc2hlZXQgYXMgZmlyc3QgY2hpbGQsXG4gICAgICogaWYgbm9uZSBzdXBwbGllZCBpdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkIGluc3RlYWQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlc2hlZXQoaWQsIHBhcmVudCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBjb25zdCBub25jZSA9IG9wdGlvbnM/Lm5vbmNlO1xuICAgICAgICBpZiAobm9uY2UpXG4gICAgICAgICAgICBzdHlsZS5ub25jZSA9IG5vbmNlO1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdncy1zdHlsZS1pZCcsIGlkKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHsgLy8gVE9ETzogb25seSBDU1NJbXBvcnRSdWxlIGhhdmUgdGhhdCBhbmQgZGlmZmVyZW50IGJlYXN0ID8/XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpOyAvLyBXZWJLaXQgaGFja1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGhlYWRcbiAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZS5zaGVldDtcbiAgICB9XG4gICAgLyoqIHJlbW92ZWQgdGhlIGdpdmVuIHN0eWxlc2hlZXQgaWQgKi9cbiAgICBzdGF0aWMgcmVtb3ZlU3R5bGVzaGVldChpZCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdTVFlMRVtncy1zdHlsZS1pZD0nICsgaWQgKyAnXScpO1xuICAgICAgICBpZiAoZWwgJiYgZWwucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvKiogaW5zZXJ0cyBhIENTUyBydWxlICovXG4gICAgc3RhdGljIGFkZENTU1J1bGUoc2hlZXQsIHNlbGVjdG9yLCBydWxlcykge1xuICAgICAgICBpZiAodHlwZW9mIHNoZWV0LmFkZFJ1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHJ1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2hlZXQuaW5zZXJ0UnVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShgJHtzZWxlY3Rvcn17JHtydWxlc319YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgdG9Cb29sKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHYgPSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gISh2ID09PSAnJyB8fCB2ID09PSAnbm8nIHx8IHYgPT09ICdmYWxzZScgfHwgdiA9PT0gJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbih2KTtcbiAgICB9XG4gICAgc3RhdGljIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSA/IHVuZGVmaW5lZCA6IE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUhlaWdodCh2YWwpIHtcbiAgICAgICAgbGV0IGg7XG4gICAgICAgIGxldCB1bml0ID0gJ3B4JztcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB2YWwubWF0Y2goL14oLVswLTldK1xcLlswLTldK3xbMC05XSpcXC5bMC05XSt8LVswLTldK3xbMC05XSspKHB4fGVtfHJlbXx2aHx2d3wlKT8kLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXQgPSBtYXRjaFsyXSB8fCAncHgnO1xuICAgICAgICAgICAgICAgIGggPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaCwgdW5pdCB9O1xuICAgIH1cbiAgICAvKiogY29waWVzIHVuc2V0IGZpZWxkcyBpbiB0YXJnZXQgdG8gdXNlIHRoZSBnaXZlbiBkZWZhdWx0IHNvdXJjZXMgdmFsdWVzICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3RhdGljIGRlZmF1bHRzKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IG51bGwgfHwgdGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgYW4gb2JqZWN0LCByZWN1cnNpdmVseSBhZGQgaXQncyBmaWVsZCBvdmVyLi4uICMxMzczXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKiogZ2l2ZW4gMiBvYmplY3RzIHJldHVybiB0cnVlIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMuIENoZWNrcyBmb3IgT2JqZWN0IHt9IGhhdmluZyBzYW1lIGZpZWxkcyBhbmQgdmFsdWVzIChqdXN0IDEgbGV2ZWwgZG93bikgKi9cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiO1xuICAgICAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBlbHNlIHdlIGhhdmUgb2JqZWN0LCBjaGVjayBqdXN0IDEgbGV2ZWwgZGVlcCBmb3IgYmVpbmcgc2FtZSB0aGluZ3MuLi5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogY29waWVzIG92ZXIgYiBzaXplICYgcG9zaXRpb24gKEdyaWRTdGFja1Bvc2l0aW9uKSwgYW5kIG9wdGlvbmFsbHkgbWluL21heCBhcyB3ZWxsICovXG4gICAgc3RhdGljIGNvcHlQb3MoYSwgYiwgZG9NaW5NYXggPSBmYWxzZSkge1xuICAgICAgICBpZiAoYi54ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhLnggPSBiLng7XG4gICAgICAgIGlmIChiLnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGEueSA9IGIueTtcbiAgICAgICAgaWYgKGIudyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYS53ID0gYi53O1xuICAgICAgICBpZiAoYi5oICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhLmggPSBiLmg7XG4gICAgICAgIGlmIChkb01pbk1heCkge1xuICAgICAgICAgICAgaWYgKGIubWluVylcbiAgICAgICAgICAgICAgICBhLm1pblcgPSBiLm1pblc7XG4gICAgICAgICAgICBpZiAoYi5taW5IKVxuICAgICAgICAgICAgICAgIGEubWluSCA9IGIubWluSDtcbiAgICAgICAgICAgIGlmIChiLm1heFcpXG4gICAgICAgICAgICAgICAgYS5tYXhXID0gYi5tYXhXO1xuICAgICAgICAgICAgaWYgKGIubWF4SClcbiAgICAgICAgICAgICAgICBhLm1heEggPSBiLm1heEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIC8qKiB0cnVlIGlmIGEgYW5kIGIgaGFzIHNhbWUgc2l6ZSAmIHBvc2l0aW9uICovXG4gICAgc3RhdGljIHNhbWVQb3MoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAmJiBiICYmIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIChhLncgfHwgMSkgPT09IChiLncgfHwgMSkgJiYgKGEuaCB8fCAxKSA9PT0gKGIuaCB8fCAxKTtcbiAgICB9XG4gICAgLyoqIGdpdmVuIGEgbm9kZSwgbWFrZXMgc3VyZSBpdCdzIG1pbi9tYXggYXJlIHZhbGlkICovXG4gICAgc3RhdGljIHNhbml0aXplTWluTWF4KG5vZGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIDAsIHVuZGVmaW5lLCBudWxsXG4gICAgICAgIGlmICghbm9kZS5taW5XKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5taW5XO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5taW5IKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5taW5IO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5tYXhXKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5tYXhXO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5tYXhIKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5tYXhIO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiByZW1vdmVzIGZpZWxkIGZyb20gdGhlIGZpcnN0IG9iamVjdCBpZiBzYW1lIGFzIHRoZSBzZWNvbmQgb2JqZWN0cyAobGlrZSBkaWZmaW5nKSBhbmQgaW50ZXJuYWwgJ18nIGZvciBzYXZpbmcgKi9cbiAgICBzdGF0aWMgcmVtb3ZlSW50ZXJuYWxBbmRTYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gYVtrZXldO1xuICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gJ18nIHx8IHZhbCA9PT0gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBiW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxbaV0gPT09IGJba2V5XVtpXSB8fCBpWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogcmVtb3ZlcyBpbnRlcm5hbCBmaWVsZHMgJ18nIGFuZCBkZWZhdWx0IHZhbHVlcyBmb3Igc2F2aW5nICovXG4gICAgc3RhdGljIHJlbW92ZUludGVybmFsRm9yU2F2ZShuLCByZW1vdmVFbCA9IHRydWUpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG4pIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gPT09ICdfJyB8fCBuW2tleV0gPT09IG51bGwgfHwgbltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbi5ncmlkO1xuICAgICAgICBpZiAocmVtb3ZlRWwpXG4gICAgICAgICAgICBkZWxldGUgbi5lbDtcbiAgICAgICAgLy8gZGVsZXRlIGRlZmF1bHQgdmFsdWVzICh3aWxsIGJlIHJlLWNyZWF0ZWQgb24gcmVhZClcbiAgICAgICAgaWYgKCFuLmF1dG9Qb3NpdGlvbilcbiAgICAgICAgICAgIGRlbGV0ZSBuLmF1dG9Qb3NpdGlvbjtcbiAgICAgICAgaWYgKCFuLm5vUmVzaXplKVxuICAgICAgICAgICAgZGVsZXRlIG4ubm9SZXNpemU7XG4gICAgICAgIGlmICghbi5ub01vdmUpXG4gICAgICAgICAgICBkZWxldGUgbi5ub01vdmU7XG4gICAgICAgIGlmICghbi5sb2NrZWQpXG4gICAgICAgICAgICBkZWxldGUgbi5sb2NrZWQ7XG4gICAgICAgIGlmIChuLncgPT09IDEgfHwgbi53ID09PSBuLm1pblcpXG4gICAgICAgICAgICBkZWxldGUgbi53O1xuICAgICAgICBpZiAobi5oID09PSAxIHx8IG4uaCA9PT0gbi5taW5IKVxuICAgICAgICAgICAgZGVsZXRlIG4uaDtcbiAgICB9XG4gICAgLyoqIHJldHVybiB0aGUgY2xvc2VzdCBwYXJlbnQgKG9yIGl0c2VsZikgbWF0Y2hpbmcgdGhlIGdpdmVuIGNsYXNzICovXG4gICAgLy8gc3RhdGljIGNsb3Nlc3RVcEJ5Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gICAgLy8gICB3aGlsZSAoZWwpIHtcbiAgICAvLyAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgcmV0dXJuIGVsO1xuICAgIC8vICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnRcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvKiogZGVsYXkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGdpdmVuIGRlbGF5LCBwcmV2ZW50aW5nIG5ldyBjYWxscyBmcm9tIGhhcHBlbmluZyB3aGlsZSB3YWl0aW5nICovXG4gICAgc3RhdGljIHRocm90dGxlKGZ1bmMsIGRlbGF5KSB7XG4gICAgICAgIGxldCBpc1dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzV2FpdGluZykge1xuICAgICAgICAgICAgICAgIGlzV2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGZ1bmMoLi4uYXJncyk7IGlzV2FpdGluZyA9IGZhbHNlOyB9LCBkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZW1vdmVQb3NpdGlvbmluZ1N0eWxlcyhlbCkge1xuICAgICAgICBsZXQgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9zaXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUubGVmdCkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUudG9wKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgndG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLndpZHRoKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgnd2lkdGgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCByZXR1cm5zIHRoZSBwYXNzZWQgZWxlbWVudCBpZiBzY3JvbGxhYmxlLCBlbHNlIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IHdpbGwsIHVwIHRvIHRoZSBlbnRpcmUgZG9jdW1lbnQgc2Nyb2xsaW5nIGVsZW1lbnQgKi9cbiAgICBzdGF0aWMgZ2V0U2Nyb2xsRWxlbWVudChlbCkge1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyAvLyBJRSBzdXBwb3J0XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZ2V4LnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxFbGVtZW50KGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgdXBkYXRlU2Nyb2xsUG9zaXRpb24oZWwsIHBvc2l0aW9uLCBkaXN0YW5jZSkge1xuICAgICAgICAvLyBpcyB3aWRnZXQgaW4gdmlldz9cbiAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQgPSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICBpZiAocmVjdC50b3AgPCAwIHx8XG4gICAgICAgICAgICByZWN0LmJvdHRvbSA+IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNldCBzY3JvbGxUb3Agb2YgZmlyc3QgcGFyZW50IHRoYXQgc2Nyb2xsc1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGlzIGxhcmdlciB0aGFuIGVsLCBzZXQgYXMgbG93IGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyB0byBnZXQgZW50aXJlIHdpZGdldCBvbiBzY3JlZW5cbiAgICAgICAgICAgIGxldCBvZmZzZXREaWZmRG93biA9IHJlY3QuYm90dG9tIC0gaW5uZXJIZWlnaHRPckNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGxldCBvZmZzZXREaWZmVXAgPSByZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBzY3JvbGxFbCA9IHRoaXMuZ2V0U2Nyb2xsRWxlbWVudChlbCk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsRWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldlNjcm9sbCA9IHNjcm9sbEVsLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCAwICYmIGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZpbmcgdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm9mZnNldEhlaWdodCA+IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCArPSBNYXRoLmFicyhvZmZzZXREaWZmVXApID4gTWF0aC5hYnMoZGlzdGFuY2UpID8gZGlzdGFuY2UgOiBvZmZzZXREaWZmVXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmluZyBkb3duXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5vZmZzZXRIZWlnaHQgPiBpbm5lckhlaWdodE9yQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgKz0gb2Zmc2V0RGlmZkRvd24gPiBkaXN0YW5jZSA/IGRpc3RhbmNlIDogb2Zmc2V0RGlmZkRvd247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB3aWRnZXQgeSBieSBhbW91bnQgc2Nyb2xsZWRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gc2Nyb2xsRWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgRnVuY3Rpb24gdXNlZCB0byBzY3JvbGwgdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgYE1vdXNlRXZlbnRgIHRoYXQgdHJpZ2dlcnMgdGhlIHJlc2l6ZVxuICAgICAqIEBwYXJhbSBlbCBgSFRNTEVsZW1lbnRgIHRoYXQncyBiZWluZyByZXNpemVkXG4gICAgICogQHBhcmFtIGRpc3RhbmNlIERpc3RhbmNlIGZyb20gdGhlIFYgZWRnZXMgdG8gc3RhcnQgc2Nyb2xsaW5nXG4gICAgICovXG4gICAgc3RhdGljIHVwZGF0ZVNjcm9sbFJlc2l6ZShldmVudCwgZWwsIGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbEVsID0gdGhpcy5nZXRTY3JvbGxFbGVtZW50KGVsKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAvLyAjMTcyNyBldmVudC5jbGllbnRZIGlzIHJlbGF0aXZlIHRvIHZpZXdwb3J0LCBzbyBtdXN0IGNvbXBhcmUgdGhpcyBhZ2FpbnN0IHBvc2l0aW9uIG9mIHNjcm9sbEVsIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAvLyAjMTc0NSBTcGVjaWFsIHNpdHVhdGlvbiBpZiBzY3JvbGxFbCBpcyBkb2N1bWVudCAnaHRtbCc6IGhlcmUgYnJvd3NlciBzcGVjIHN0YXRlcyB0aGF0XG4gICAgICAgIC8vIGNsaWVudEhlaWdodCBpcyBoZWlnaHQgb2Ygdmlld3BvcnQsIGJ1dCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBpcyByZWN0YW5nbGUgb2YgaHRtbCBlbGVtZW50O1xuICAgICAgICAvLyB0aGlzIGRpc2NyZXBhbmN5IGFyaXNlcyBiZWNhdXNlIGluIHJlYWxpdHkgc2Nyb2xsYmFyIGlzIGF0dGFjaGVkIHRvIHZpZXdwb3J0LCBub3QgaHRtbCBlbGVtZW50IGl0c2VsZi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKHNjcm9sbEVsID09PSB0aGlzLmdldFNjcm9sbEVsZW1lbnQoKSkgPyAwIDogc2Nyb2xsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBjb25zdCBwb2ludGVyUG9zWSA9IGV2ZW50LmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIGNvbnN0IHRvcCA9IHBvaW50ZXJQb3NZIDwgZGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHBvaW50ZXJQb3NZID4gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBjYW4gYmUgZG9uZSB3aXRoIGEgdGltZW91dCB0byBrZWVwIHNjcm9sbGluZyB3aGlsZSB0aGUgbW91c2UgaXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBzY3JvbGxpbmcgem9uZS4gKHdpbGwgaGF2ZSBzbW9vdGhlciBiZWhhdmlvcilcbiAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbEJ5KHsgYmVoYXZpb3I6ICdzbW9vdGgnLCB0b3A6IHBvaW50ZXJQb3NZIC0gZGlzdGFuY2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm90dG9tKSB7XG4gICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxCeSh7IGJlaGF2aW9yOiAnc21vb3RoJywgdG9wOiBkaXN0YW5jZSAtIChoZWlnaHQgLSBwb2ludGVyUG9zWSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIHNpbmdsZSBsZXZlbCBjbG9uZSwgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHNhbWUgdG9wIGZpZWxkcy4gVGhpcyB3aWxsIHNoYXJlIHN1YiBvYmplY3RzIGFuZCBhcnJheXMgKi9cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIChvYmopICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIFsuLi5vYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLm9iaiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgY2xvbmUgdmVyc2lvbiB0aGF0IHJldHVybnMgYSBmdWxsIGNvcHksIGNoZWNraW5nIGZvciBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzIE9OTFkuXG4gICAgICogTm90ZTogdGhpcyB3aWxsIHVzZSBhcy1pcyBhbnkga2V5IHN0YXJ0aW5nIHdpdGggZG91YmxlIF9fIChhbmQgbm90IGNvcHkgaW5zaWRlKSBzb21lIGxpYiBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvbmVEZWVwKG9iaikge1xuICAgICAgICAvLyBsaXN0IG9mIGZpZWxkcyB3ZSB3aWxsIHNraXAgZHVyaW5nIGNsb25lRGVlcCAobmVzdGVkIG9iamVjdHMsIG90aGVyIGludGVybmFsKVxuICAgICAgICBjb25zdCBza2lwRmllbGRzID0gWydwYXJlbnRHcmlkJywgJ2VsJywgJ2dyaWQnLCAnc3ViR3JpZCcsICdlbmdpbmUnXTtcbiAgICAgICAgLy8gcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIGRhdGUgZm9ybWF0ID9cbiAgICAgICAgY29uc3QgcmV0ID0gVXRpbHMuY2xvbmUob2JqKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmV0KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCBzdXBwb3J0IGZ1bmN0aW9uL2NpcmN1bGFyIGRlcGVuZGVuY2llcyBzbyBza2lwIHRob3NlIHByb3BlcnRpZXMgZm9yIG5vdy4uLlxuICAgICAgICAgICAgaWYgKHJldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiAocmV0W2tleV0pID09PSAnb2JqZWN0JyAmJiBrZXkuc3Vic3RyaW5nKDAsIDIpICE9PSAnX18nICYmICFza2lwRmllbGRzLmZpbmQoayA9PiBrID09PSBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBVdGlscy5jbG9uZURlZXAob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKiBkZWVwIGNsb25lIHRoZSBnaXZlbiBIVE1MIG5vZGUsIHJlbW92aW5nIHRlaCB1bmlxdWUgaWQgZmllbGQgKi9cbiAgICBzdGF0aWMgY2xvbmVOb2RlKGVsKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgc3RhdGljIGFwcGVuZFRvKGVsLCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IHBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IFV0aWxzLmdldEVsZW1lbnQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHB1YmxpYyBzdGF0aWMgc2V0UG9zaXRpb25SZWxhdGl2ZShlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyAgIGlmICghKC9eKD86cnxhfGYpLykudGVzdChnZXRDb21wdXRlZFN0eWxlKGVsKS5wb3NpdGlvbikpIHtcbiAgICAvLyAgICAgZWwuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIHN0YXRpYyBhZGRFbFN0eWxlcyhlbCwgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlc1tzXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgZmFsbGJhY2sgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzXS5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGVbc10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlW3NdID0gc3R5bGVzW3NdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpbml0RXZlbnQoZSwgaW5mbykge1xuICAgICAgICBjb25zdCBldnQgPSB7IHR5cGU6IGluZm8udHlwZSB9O1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICB3aGljaDogMCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IDEsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHRhcmdldDogaW5mby50YXJnZXQgPyBpbmZvLnRhcmdldCA6IGUudGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRvbid0IGNoZWNrIGZvciBgaW5zdGFuY2VvZiBEcmFnRXZlbnRgIGFzIFNhZmFyaSB1c2UgTW91c2VFdmVudCAjMTU0MFxuICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGV2dFsnZGF0YVRyYW5zZmVyJ10gPSBlLmRhdGFUcmFuc2ZlcjsgLy8gd29ya2Fyb3VuZCAncmVhZG9ubHknIGZpZWxkLlxuICAgICAgICB9XG4gICAgICAgIFsnYWx0S2V5JywgJ2N0cmxLZXknLCAnbWV0YUtleScsICdzaGlmdEtleSddLmZvckVhY2gocCA9PiBldnRbcF0gPSBlW3BdKTsgLy8ga2V5c1xuICAgICAgICBbJ3BhZ2VYJywgJ3BhZ2VZJywgJ2NsaWVudFgnLCAnY2xpZW50WScsICdzY3JlZW5YJywgJ3NjcmVlblknXS5mb3JFYWNoKHAgPT4gZXZ0W3BdID0gZVtwXSk7IC8vIHBvaW50IGluZm9cbiAgICAgICAgcmV0dXJuIHsgLi4uZXZ0LCAuLi5vYmogfTtcbiAgICB9XG4gICAgLyoqIGNvcGllcyB0aGUgTW91c2VFdmVudCBwcm9wZXJ0aWVzIGFuZCBzZW5kcyBpdCBhcyBhbm90aGVyIGV2ZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgKi9cbiAgICBzdGF0aWMgc2ltdWxhdGVNb3VzZUV2ZW50KGUsIHNpbXVsYXRlZFR5cGUsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChzaW11bGF0ZWRUeXBlLCAvLyB0eXBlXG4gICAgICAgIHRydWUsIC8vIGJ1YmJsZXNcbiAgICAgICAgdHJ1ZSwgLy8gY2FuY2VsYWJsZVxuICAgICAgICB3aW5kb3csIC8vIHZpZXdcbiAgICAgICAgMSwgLy8gZGV0YWlsXG4gICAgICAgIGUuc2NyZWVuWCwgLy8gc2NyZWVuWFxuICAgICAgICBlLnNjcmVlblksIC8vIHNjcmVlbllcbiAgICAgICAgZS5jbGllbnRYLCAvLyBjbGllbnRYXG4gICAgICAgIGUuY2xpZW50WSwgLy8gY2xpZW50WVxuICAgICAgICBlLmN0cmxLZXksIC8vIGN0cmxLZXlcbiAgICAgICAgZS5hbHRLZXksIC8vIGFsdEtleVxuICAgICAgICBlLnNoaWZ0S2V5LCAvLyBzaGlmdEtleVxuICAgICAgICBlLm1ldGFLZXksIC8vIG1ldGFLZXlcbiAgICAgICAgMCwgLy8gYnV0dG9uXG4gICAgICAgIGUudGFyZ2V0IC8vIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgKHRhcmdldCB8fCBlLnRhcmdldCkuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIm9ic29sZXRlIiwic2VsZiIsImYiLCJvbGROYW1lIiwibmV3TmFtZSIsInJldiIsIndyYXBwZXIiLCJhcmdzIiwiY29uc29sZSIsIndhcm4iLCJhcHBseSIsInByb3RvdHlwZSIsIm9ic29sZXRlT3B0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJvYnNvbGV0ZU9wdHNEZWwiLCJpbmZvIiwib2Jzb2xldGVBdHRyIiwiZWwiLCJvbGRBdHRyIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiVXRpbHMiLCJnZXRFbGVtZW50cyIsImVscyIsInJvb3QiLCJkb2N1bWVudCIsImRvYyIsImlzTmFOIiwiZ2V0RWxlbWVudEJ5SWQiLCJsaXN0IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIkFycmF5IiwiZnJvbSIsImdldEVsZW1lbnQiLCJzdWJzdHJpbmciLCJxdWVyeVNlbGVjdG9yIiwic2hvdWxkU2l6ZVRvQ29udGVudCIsIm4iLCJncmlkIiwic2l6ZVRvQ29udGVudCIsImlzSW50ZXJjZXB0ZWQiLCJhIiwiYiIsInkiLCJoIiwieCIsInciLCJpc1RvdWNoaW5nIiwiYXJlYUludGVyY2VwdCIsIngwIiwieDEiLCJ5MCIsInkxIiwiYXJlYSIsInNvcnQiLCJub2RlcyIsImRpciIsImNvbHVtbiIsInJlZHVjZSIsImNvbCIsIk1hdGgiLCJtYXgiLCJmaW5kIiwiaWQiLCJjcmVhdGVTdHlsZXNoZWV0IiwicGFyZW50Iiwib3B0aW9ucyIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsIm5vbmNlIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2hlZXQiLCJyZW1vdmVTdHlsZXNoZWV0IiwicGFyZW50Tm9kZSIsInJlbW92ZSIsImFkZENTU1J1bGUiLCJzZWxlY3RvciIsInJ1bGVzIiwiYWRkUnVsZSIsImluc2VydFJ1bGUiLCJ0b0Jvb2wiLCJ2IiwidG9Mb3dlckNhc2UiLCJCb29sZWFuIiwidG9OdW1iZXIiLCJ2YWx1ZSIsIk51bWJlciIsInBhcnNlSGVpZ2h0IiwidmFsIiwidW5pdCIsIm1hdGNoIiwiRXJyb3IiLCJwYXJzZUZsb2F0IiwiZGVmYXVsdHMiLCJ0YXJnZXQiLCJzb3VyY2VzIiwiZm9yRWFjaCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5Iiwic2FtZSIsIk9iamVjdCIsImtleXMiLCJjb3B5UG9zIiwiZG9NaW5NYXgiLCJtaW5XIiwibWluSCIsIm1heFciLCJtYXhIIiwic2FtZVBvcyIsInNhbml0aXplTWluTWF4Iiwibm9kZSIsInJlbW92ZUludGVybmFsQW5kU2FtZSIsImkiLCJyZW1vdmVJbnRlcm5hbEZvclNhdmUiLCJyZW1vdmVFbCIsImF1dG9Qb3NpdGlvbiIsIm5vUmVzaXplIiwibm9Nb3ZlIiwibG9ja2VkIiwidGhyb3R0bGUiLCJmdW5jIiwiZGVsYXkiLCJpc1dhaXRpbmciLCJzZXRUaW1lb3V0IiwicmVtb3ZlUG9zaXRpb25pbmdTdHlsZXMiLCJwb3NpdGlvbiIsInJlbW92ZVByb3BlcnR5IiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0U2Nyb2xsRWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3dSZWdleCIsInRlc3QiLCJvdmVyZmxvdyIsIm92ZXJmbG93WSIsInBhcmVudEVsZW1lbnQiLCJ1cGRhdGVTY3JvbGxQb3NpdGlvbiIsImRpc3RhbmNlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImJvdHRvbSIsIm9mZnNldERpZmZEb3duIiwib2Zmc2V0RGlmZlVwIiwic2Nyb2xsRWwiLCJwcmV2U2Nyb2xsIiwic2Nyb2xsVG9wIiwib2Zmc2V0SGVpZ2h0IiwiYWJzIiwidXBkYXRlU2Nyb2xsUmVzaXplIiwiZXZlbnQiLCJvZmZzZXRUb3AiLCJwb2ludGVyUG9zWSIsImNsaWVudFkiLCJzY3JvbGxCeSIsImJlaGF2aW9yIiwiY2xvbmUiLCJvYmoiLCJjbG9uZURlZXAiLCJza2lwRmllbGRzIiwicmV0IiwiayIsImNsb25lTm9kZSIsInJlbW92ZUF0dHJpYnV0ZSIsImFwcGVuZFRvIiwiYWRkRWxTdHlsZXMiLCJzdHlsZXMiLCJzIiwiaXNBcnJheSIsImluaXRFdmVudCIsImUiLCJldnQiLCJ0eXBlIiwiYnV0dG9uIiwid2hpY2giLCJidXR0b25zIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkYXRhVHJhbnNmZXIiLCJwIiwic2ltdWxhdGVNb3VzZUV2ZW50Iiwic2ltdWxhdGVkVHlwZSIsInNpbXVsYXRlZEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImN0cmxLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/utils.js\n"));

/***/ }),

/***/ "./pages/dashboard.js":
/*!****************************!*\
  !*** ./pages/dashboard.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_DashboardContainer_DashboardContainer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/DashboardContainer/DashboardContainer.js */ \"./components/DashboardContainer/DashboardContainer.js\");\n\n\n\nconst Dashboard = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_DashboardContainer_DashboardContainer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n            fileName: \"C:\\\\Code\\\\Paul\\\\D3Examples\\\\lucidity-d3js\\\\pages\\\\dashboard.js\",\n            lineNumber: 7,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false);\n};\n_c = Dashboard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dashboard);\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9kYXNoYm9hcmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNnRDtBQUV4RixNQUFNRyxZQUFZO0lBQ2QscUJBQ0k7a0JBQ0ksNEVBQUNELDRGQUFrQkE7Ozs7OztBQUkvQjtLQVBNQztBQVNOLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2Rhc2hib2FyZC5qcz8wZTUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IERhc2hib2FyZENvbnRhaW5lciBmcm9tICcuLi9jb21wb25lbnRzL0Rhc2hib2FyZENvbnRhaW5lci9EYXNoYm9hcmRDb250YWluZXIuanMnO1xyXG5cclxuY29uc3QgRGFzaGJvYXJkID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8RGFzaGJvYXJkQ29udGFpbmVyPlxyXG4gICAgICAgICAgICA8L0Rhc2hib2FyZENvbnRhaW5lcj5cclxuICAgICAgICA8Lz5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhc2hib2FyZDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIkRhc2hib2FyZENvbnRhaW5lciIsIkRhc2hib2FyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/dashboard.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CCode%5CPaul%5CD3Examples%5Clucidity-d3js%5Cpages%5Cdashboard.js&page=%2Fdashboard!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);