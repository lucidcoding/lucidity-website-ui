/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gridstack";
exports.ids = ["vendor-chunks/gridstack"];
exports.modules = {

/***/ "./node_modules/gridstack/dist/dd-base-impl.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-base-impl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDBaseImplement: () => (/* binding */ DDBaseImplement)\n/* harmony export */ });\n/**\n * dd-base-impl.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ class DDBaseImplement {\n    constructor(){\n        /** @internal */ this._eventRegister = {};\n    }\n    /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */ get disabled() {\n        return this._disabled;\n    }\n    on(event, callback) {\n        this._eventRegister[event] = callback;\n    }\n    off(event) {\n        delete this._eventRegister[event];\n    }\n    enable() {\n        this._disabled = false;\n    }\n    disable() {\n        this._disabled = true;\n    }\n    destroy() {\n        delete this._eventRegister;\n    }\n    triggerEvent(eventName, event) {\n        if (!this.disabled && this._eventRegister && this._eventRegister[eventName]) return this._eventRegister[eventName](event);\n    }\n} //# sourceMappingURL=dd-base-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtYmFzZS1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxNQUFNQTtJQUNUQyxhQUFjO1FBQ1YsY0FBYyxHQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7SUFDM0I7SUFDQSxpSEFBaUgsR0FDakgsSUFBSUMsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDQyxTQUFTO0lBQUU7SUFDeENDLEdBQUdDLEtBQUssRUFBRUMsUUFBUSxFQUFFO1FBQ2hCLElBQUksQ0FBQ0wsY0FBYyxDQUFDSSxNQUFNLEdBQUdDO0lBQ2pDO0lBQ0FDLElBQUlGLEtBQUssRUFBRTtRQUNQLE9BQU8sSUFBSSxDQUFDSixjQUFjLENBQUNJLE1BQU07SUFDckM7SUFDQUcsU0FBUztRQUNMLElBQUksQ0FBQ0wsU0FBUyxHQUFHO0lBQ3JCO0lBQ0FNLFVBQVU7UUFDTixJQUFJLENBQUNOLFNBQVMsR0FBRztJQUNyQjtJQUNBTyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNULGNBQWM7SUFDOUI7SUFDQVUsYUFBYUMsU0FBUyxFQUFFUCxLQUFLLEVBQUU7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQ0gsUUFBUSxJQUFJLElBQUksQ0FBQ0QsY0FBYyxJQUFJLElBQUksQ0FBQ0EsY0FBYyxDQUFDVyxVQUFVLEVBQ3ZFLE9BQU8sSUFBSSxDQUFDWCxjQUFjLENBQUNXLFVBQVUsQ0FBQ1A7SUFDOUM7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2x1Y2lkaXR5LWQzanMvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtYmFzZS1pbXBsLmpzPzM1MTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZC1iYXNlLWltcGwudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMS0yMDIyIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG5leHBvcnQgY2xhc3MgRERCYXNlSW1wbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9ldmVudFJlZ2lzdGVyID0ge307XG4gICAgfVxuICAgIC8qKiByZXR1cm5zIHRoZSBlbmFibGUgc3RhdGUsIGJ1dCB5b3UgaGF2ZSB0byBjYWxsIGVuYWJsZSgpL2Rpc2FibGUoKSB0byBjaGFuZ2UgKGFzIG90aGVyIHRoaW5ncyBuZWVkIHRvIGhhcHBlbikgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfVxuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9ldmVudFJlZ2lzdGVyW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvZmYoZXZlbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50UmVnaXN0ZXJbZXZlbnRdO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50UmVnaXN0ZXI7XG4gICAgfVxuICAgIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLl9ldmVudFJlZ2lzdGVyICYmIHRoaXMuX2V2ZW50UmVnaXN0ZXJbZXZlbnROYW1lXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudFJlZ2lzdGVyW2V2ZW50TmFtZV0oZXZlbnQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLWJhc2UtaW1wbC5qcy5tYXAiXSwibmFtZXMiOlsiRERCYXNlSW1wbGVtZW50IiwiY29uc3RydWN0b3IiLCJfZXZlbnRSZWdpc3RlciIsImRpc2FibGVkIiwiX2Rpc2FibGVkIiwib24iLCJldmVudCIsImNhbGxiYWNrIiwib2ZmIiwiZW5hYmxlIiwiZGlzYWJsZSIsImRlc3Ryb3kiLCJ0cmlnZ2VyRXZlbnQiLCJldmVudE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-base-impl.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-draggable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-draggable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDraggable: () => (/* binding */ DDDraggable)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-draggable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n// let count = 0; // TEST\nclass DDDraggable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__.DDBaseImplement {\n    constructor(el, option = {}){\n        super();\n        this.el = el;\n        this.option = option;\n        // get the element that is actually supposed to be dragged by\n        let handleName = option.handle.substring(1);\n        this.dragEl = el.classList.contains(handleName) ? el : el.querySelector(option.handle) || el;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseDown = this._mouseDown.bind(this);\n        this._mouseMove = this._mouseMove.bind(this);\n        this._mouseUp = this._mouseUp.bind(this);\n        this.enable();\n    }\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        if (this.disabled === false) return;\n        super.enable();\n        this.dragEl.addEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.addEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n            this.dragEl.addEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n        // this.dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n        }\n        this.el.classList.remove(\"ui-draggable-disabled\");\n    }\n    disable(forDestroy = false) {\n        if (this.disabled === true) return;\n        super.disable();\n        this.dragEl.removeEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.removeEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n            this.dragEl.removeEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n        }\n        if (!forDestroy) this.el.classList.add(\"ui-draggable-disabled\");\n    }\n    destroy() {\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        delete this.dragTimeout;\n        if (this.dragging) this._mouseUp(this.mouseDownEvent);\n        this.disable(true);\n        delete this.el;\n        delete this.helper;\n        delete this.option;\n        super.destroy();\n    }\n    updateOption(opts) {\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        return this;\n    }\n    /** @internal call when mouse goes down before a dragstart happens */ _mouseDown(e) {\n        // don't let more than one widget handle mouseStart\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled) return;\n        if (e.button !== 0) return true; // only left click\n        // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n        if (e.target.closest(skipMouseDown)) return true;\n        if (this.option.cancel) {\n            if (e.target.closest(this.option.cancel)) return true;\n        }\n        // REMOVE: why would we get the event if it wasn't for us or child ?\n        // make sure we are clicking on a drag handle or child of it...\n        // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n        // let className = this.option.handle.substring(1);\n        // let el = e.target as HTMLElement;\n        // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n        // if (!el) return;\n        this.mouseDownEvent = e;\n        delete this.dragging;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n        // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n        document.addEventListener(\"mousemove\", this._mouseMove, true); // true=capture, not bubble\n        document.addEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.addEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove);\n            this.dragEl.addEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend);\n        }\n        e.preventDefault();\n        // preventDefault() prevents blur event which occurs just after mousedown event.\n        // if an editable content has focus, then blur must be call\n        if (document.activeElement) document.activeElement.blur();\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled = true;\n        return true;\n    }\n    /** @internal method to call actual drag event */ _callDrag(e) {\n        if (!this.dragging) return;\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"drag\"\n        });\n        if (this.option.drag) {\n            this.option.drag(ev, this.ui());\n        }\n        this.triggerEvent(\"drag\", ev);\n    }\n    /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */ _mouseMove(e) {\n        // console.log(`${count++} move ${e.x},${e.y}`)\n        let s = this.mouseDownEvent;\n        if (this.dragging) {\n            this._dragFollow(e);\n            // delay actual grid handling drag until we pause for a while if set\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) {\n                const pause = Number.isInteger(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) ? _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag : 100;\n                if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n                this.dragTimeout = window.setTimeout(()=>this._callDrag(e), pause);\n            } else {\n                this._callDrag(e);\n            }\n        } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n            /**\n             * don't start unless we've moved at least 3 pixels\n             */ this.dragging = true;\n            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement = this;\n            // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n            let grid = this.el.gridstackNode?.grid;\n            if (grid) {\n                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = grid.el.ddElement.ddDroppable;\n            } else {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            }\n            this.helper = this._createHelper(e);\n            this._setupHelperContainmentStyle();\n            this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n                target: this.el,\n                type: \"dragstart\"\n            });\n            this._setupHelperStyle(e);\n            if (this.option.start) {\n                this.option.start(ev, this.ui());\n            }\n            this.triggerEvent(\"dragstart\", ev);\n        }\n        e.preventDefault(); // needed otherwise we get text sweep text selection as we drag around\n        return true;\n    }\n    /** @internal call when the mouse gets released to drop the item at current location */ _mouseUp(e) {\n        document.removeEventListener(\"mousemove\", this._mouseMove, true);\n        document.removeEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.dragEl.removeEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove, true);\n            this.dragEl.removeEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend, true);\n        }\n        if (this.dragging) {\n            delete this.dragging;\n            // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement?.el === this.el.parentElement) {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            }\n            this.helperContainment.style.position = this.parentOriginStylePosition || null;\n            if (this.helper === this.el) {\n                this._removeHelperStyle();\n            } else {\n                this.helper.remove();\n            }\n            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n                target: this.el,\n                type: \"dragstop\"\n            });\n            if (this.option.stop) {\n                this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n            }\n            this.triggerEvent(\"dragstop\", ev);\n            // call the droppable method to receive the item\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement) {\n                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement.drop(e);\n            }\n        }\n        delete this.helper;\n        delete this.mouseDownEvent;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled;\n        e.preventDefault();\n    }\n    /** @internal create a clone copy (or user defined method) of the original drag item if set */ _createHelper(event) {\n        let helper = this.el;\n        if (typeof this.option.helper === \"function\") {\n            helper = this.option.helper(event);\n        } else if (this.option.helper === \"clone\") {\n            helper = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneNode(this.el);\n        }\n        if (!document.body.contains(helper)) {\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.appendTo(helper, this.option.appendTo === \"parent\" ? this.el.parentElement : this.option.appendTo);\n        }\n        if (helper === this.el) {\n            this.dragElementOriginStyle = DDDraggable.originStyleProp.map((prop)=>this.el.style[prop]);\n        }\n        return helper;\n    }\n    /** @internal set the fix position of the dragged item */ _setupHelperStyle(e) {\n        this.helper.classList.add(\"ui-draggable-dragging\");\n        // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n        const style = this.helper.style;\n        style.pointerEvents = \"none\"; // needed for over items to get enter/leave\n        // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n        style.width = this.dragOffset.width + \"px\";\n        style.height = this.dragOffset.height + \"px\";\n        style.willChange = \"left, top\";\n        style.position = \"fixed\"; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n        this._dragFollow(e); // now position it\n        style.transition = \"none\"; // show up instantly\n        setTimeout(()=>{\n            if (this.helper) {\n                style.transition = null; // recover animation\n            }\n        }, 0);\n        return this;\n    }\n    /** @internal restore back the original style before dragging */ _removeHelperStyle() {\n        this.helper.classList.remove(\"ui-draggable-dragging\");\n        let node = this.helper?.gridstackNode;\n        // don't bother restoring styles if we're gonna remove anyway...\n        if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n            let helper = this.helper;\n            // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n            // TODO: this also removes resizing animation which doesn't have this issue, but others.\n            // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n            // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n            // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n            let transition = this.dragElementOriginStyle[\"transition\"] || null;\n            helper.style.transition = this.dragElementOriginStyle[\"transition\"] = \"none\"; // can't be NULL #1973\n            DDDraggable.originStyleProp.forEach((prop)=>helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n            setTimeout(()=>helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n        }\n        delete this.dragElementOriginStyle;\n        return this;\n    }\n    /** @internal updates the top/left position to follow the mouse */ _dragFollow(e) {\n        let containmentRect = {\n            left: 0,\n            top: 0\n        };\n        // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n        //   const { left, top } = this.helperContainment.getBoundingClientRect();\n        //   containmentRect = { left, top };\n        // }\n        const style = this.helper.style;\n        const offset = this.dragOffset;\n        style.left = e.clientX + offset.offsetLeft - containmentRect.left + \"px\";\n        style.top = e.clientY + offset.offsetTop - containmentRect.top + \"px\";\n    }\n    /** @internal */ _setupHelperContainmentStyle() {\n        this.helperContainment = this.helper.parentElement;\n        if (this.helper.style.position !== \"fixed\") {\n            this.parentOriginStylePosition = this.helperContainment.style.position;\n            if (getComputedStyle(this.helperContainment).position.match(/static/)) {\n                this.helperContainment.style.position = \"relative\";\n            }\n        }\n        return this;\n    }\n    /** @internal */ _getDragOffset(event, el, parent) {\n        // in case ancestor has transform/perspective css properties that change the viewpoint\n        let xformOffsetX = 0;\n        let xformOffsetY = 0;\n        if (parent) {\n            const testEl = document.createElement(\"div\");\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addElStyles(testEl, {\n                opacity: \"0\",\n                position: \"fixed\",\n                top: 0 + \"px\",\n                left: 0 + \"px\",\n                width: \"1px\",\n                height: \"1px\",\n                zIndex: \"-999999\"\n            });\n            parent.appendChild(testEl);\n            const testElPosition = testEl.getBoundingClientRect();\n            parent.removeChild(testEl);\n            xformOffsetX = testElPosition.left;\n            xformOffsetY = testElPosition.top;\n        // TODO: scale ?\n        }\n        const targetOffset = el.getBoundingClientRect();\n        return {\n            left: targetOffset.left,\n            top: targetOffset.top,\n            offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n            offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n            width: targetOffset.width,\n            height: targetOffset.height\n        };\n    }\n    /** @internal TODO: set to public as called by DDDroppable! */ ui() {\n        const containmentEl = this.el.parentElement;\n        const containmentRect = containmentEl.getBoundingClientRect();\n        const offset = this.helper.getBoundingClientRect();\n        return {\n            position: {\n                top: offset.top - containmentRect.top,\n                left: offset.left - containmentRect.left\n            }\n        };\n    }\n}\n/** @internal properties we change during dragging, and restore back */ DDDraggable.originStyleProp = [\n    \"transition\",\n    \"pointerEvents\",\n    \"position\",\n    \"left\",\n    \"top\",\n    \"minWidth\",\n    \"willChange\"\n];\n //# sourceMappingURL=dd-draggable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZHJhZ2dhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3dDO0FBQ1Q7QUFDaUI7QUFDa0M7QUFDbkYsdUVBQXVFO0FBQ3ZFLE1BQU1RLGdCQUFnQjtBQUN0Qix5QkFBeUI7QUFDekIsTUFBTUMsb0JBQW9CUCwwREFBZUE7SUFDckNRLFlBQVlDLEVBQUUsRUFBRUMsU0FBUyxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLO1FBQ0wsSUFBSSxDQUFDRCxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsNkRBQTZEO1FBQzdELElBQUlDLGFBQWFELE9BQU9FLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO1FBQ3pDLElBQUksQ0FBQ0MsTUFBTSxHQUFHTCxHQUFHTSxTQUFTLENBQUNDLFFBQVEsQ0FBQ0wsY0FBY0YsS0FBS0EsR0FBR1EsYUFBYSxDQUFDUCxPQUFPRSxNQUFNLEtBQUtIO1FBQzFGLCtHQUErRztRQUMvRyxJQUFJLENBQUNTLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0UsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxDQUFDRixJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLENBQUNHLE1BQU07SUFDZjtJQUNBQyxHQUFHQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTtRQUNoQixLQUFLLENBQUNGLEdBQUdDLE9BQU9DO0lBQ3BCO0lBQ0FDLElBQUlGLEtBQUssRUFBRTtRQUNQLEtBQUssQ0FBQ0UsSUFBSUY7SUFDZDtJQUNBRixTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNLLFFBQVEsS0FBSyxPQUNsQjtRQUNKLEtBQUssQ0FBQ0w7UUFDTixJQUFJLENBQUNSLE1BQU0sQ0FB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QixhQUFhckIsSUFBSSxHQUFHVTtZQUNqREosV0FBVyxDQUFDNUYsTUFBTTJGLE9BQU8sR0FBR2dCLGFBQWFwQixHQUFHLEdBQUdVO1lBQy9DbEIsT0FBTzRCLGFBQWE1QixLQUFLO1lBQ3pCQyxRQUFRMkIsYUFBYTNCLE1BQU07UUFDL0I7SUFDSjtJQUNBLDREQUE0RCxHQUM1RHhDLEtBQUs7UUFDRCxNQUFNb0UsZ0JBQWdCLElBQUksQ0FBQzNILEVBQUUsQ0FBQytFLGFBQWE7UUFDM0MsTUFBTXFCLGtCQUFrQnVCLGNBQWNILHFCQUFxQjtRQUMzRCxNQUFNakIsU0FBUyxJQUFJLENBQUN4RSxNQUFNLENBQUN5RixxQkFBcUI7UUFDaEQsT0FBTztZQUNIdkMsVUFBVTtnQkFDTnFCLEtBQUtDLE9BQU9ELEdBQUcsR0FBR0YsZ0JBQWdCRSxHQUFHO2dCQUNyQ0QsTUFBTUUsT0FBT0YsSUFBSSxHQUFHRCxnQkFBZ0JDLElBQUk7WUFDNUM7UUFLSjtJQUNKO0FBQ0o7QUFDQSxxRUFBcUUsR0FDckV2RyxZQUFZNEYsZUFBZSxHQUFHO0lBQUM7SUFBYztJQUFpQjtJQUFZO0lBQVE7SUFBTztJQUFZO0NBQWE7QUFDM0YsQ0FDdkIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1kcmFnZ2FibGUuanM/MTM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLWRyYWdnYWJsZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IERETWFuYWdlciB9IGZyb20gJy4vZGQtbWFuYWdlcic7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRERCYXNlSW1wbGVtZW50IH0gZnJvbSAnLi9kZC1iYXNlLWltcGwnO1xuaW1wb3J0IHsgaXNUb3VjaCwgdG91Y2hlbmQsIHRvdWNobW92ZSwgdG91Y2hzdGFydCwgcG9pbnRlcmRvd24gfSBmcm9tICcuL2RkLXRvdWNoJztcbi8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IGNsaWNraW5nIG9uIGtub3duIG9iamVjdCB0aGF0IGhhbmRsZXMgbW91c2VEb3duXG5jb25zdCBza2lwTW91c2VEb3duID0gJ2lucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uLFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdLC51aS1yZXNpemFibGUtaGFuZGxlJztcbi8vIGxldCBjb3VudCA9IDA7IC8vIFRFU1RcbmNsYXNzIERERHJhZ2dhYmxlIGV4dGVuZHMgRERCYXNlSW1wbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9uID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50IHRoYXQgaXMgYWN0dWFsbHkgc3VwcG9zZWQgdG8gYmUgZHJhZ2dlZCBieVxuICAgICAgICBsZXQgaGFuZGxlTmFtZSA9IG9wdGlvbi5oYW5kbGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB0aGlzLmRyYWdFbCA9IGVsLmNsYXNzTGlzdC5jb250YWlucyhoYW5kbGVOYW1lKSA/IGVsIDogZWwucXVlcnlTZWxlY3RvcihvcHRpb24uaGFuZGxlKSB8fCBlbDtcbiAgICAgICAgLy8gY3JlYXRlIHZhciBldmVudCBiaW5kaW5nIHNvIHdlIGNhbiBlYXNpbHkgcmVtb3ZlIGFuZCBzdGlsbCBsb29rIGxpa2UgVFMgbWV0aG9kcyAodW5saWtlIGFub255bW91cyBmdW5jdGlvbnMpXG4gICAgICAgIHRoaXMuX21vdXNlRG93biA9IHRoaXMuX21vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmUgPSB0aGlzLl9tb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2VVcCA9IHRoaXMuX21vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9mZihldmVudCkge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnQpO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgICAgIHRoaXMuZHJhZ0VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bik7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJkb3duKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZHJhZ0VsLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnOyAvLyBub3QgbmVlZGVkIHVubGlrZSBwb2ludGVyZG93biBkb2MgY29tbWVudFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgndWktZHJhZ2dhYmxlLWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGRpc2FibGUoZm9yRGVzdHJveSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuZHJhZ0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bik7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJkb3duKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvckRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLWRyYWdnYWJsZS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnVGltZW91dClcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kcmFnVGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRyYWdUaW1lb3V0O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIHRoaXMuX21vdXNlVXAodGhpcy5tb3VzZURvd25FdmVudCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZSh0cnVlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhlbHBlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbihvcHRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdHMpLmZvckVhY2goa2V5ID0+IHRoaXMub3B0aW9uW2tleV0gPSBvcHRzW2tleV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsIHdoZW4gbW91c2UgZ29lcyBkb3duIGJlZm9yZSBhIGRyYWdzdGFydCBoYXBwZW5zICovXG4gICAgX21vdXNlRG93bihlKSB7XG4gICAgICAgIC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuICAgICAgICBpZiAoRERNYW5hZ2VyLm1vdXNlSGFuZGxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIG9ubHkgbGVmdCBjbGlja1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIG5vdCBjbGlja2luZyBvbiBrbm93biBvYmplY3QgdGhhdCBoYW5kbGVzIG1vdXNlRG93biwgb3Igb25lcyBzdXBwbGllZCBieSB0aGUgdXNlclxuICAgICAgICBpZiAoZS50YXJnZXQuY2xvc2VzdChza2lwTW91c2VEb3duKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uY2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2xvc2VzdCh0aGlzLm9wdGlvbi5jYW5jZWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJFTU9WRTogd2h5IHdvdWxkIHdlIGdldCB0aGUgZXZlbnQgaWYgaXQgd2Fzbid0IGZvciB1cyBvciBjaGlsZCA/XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgY2xpY2tpbmcgb24gYSBkcmFnIGhhbmRsZSBvciBjaGlsZCBvZiBpdC4uLlxuICAgICAgICAvLyBOb3RlOiB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoYXQncyBoYW5kbGUgaXMgYW4gaW1tZWRpYXRlIGNoaWxkLCBhcyBtb3VzZUhhbmRsZWQgd2lsbCBwcmV2ZW50IHBhcmVudHMgZnJvbSBhbHNvIGhhbmRsaW5nIGl0IChsb3dlc3Qgd2lucylcbiAgICAgICAgLy8gbGV0IGNsYXNzTmFtZSA9IHRoaXMub3B0aW9uLmhhbmRsZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIGxldCBlbCA9IGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAvLyB3aGlsZSAoZWwgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7IGVsID0gZWwucGFyZW50RWxlbWVudDsgfVxuICAgICAgICAvLyBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIHRoaXMubW91c2VEb3duRXZlbnQgPSBlO1xuICAgICAgICBkZWxldGUgdGhpcy5kcmFnZ2luZztcbiAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcmFnRWxlbWVudDtcbiAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcm9wRWxlbWVudDtcbiAgICAgICAgLy8gZG9jdW1lbnQgaGFuZGxlciBzbyB3ZSBjYW4gY29udGludWUgcmVjZWl2aW5nIG1vdmVzIGFzIHRoZSBpdGVtIGlzICdmaXhlZCcgcG9zaXRpb24sIGFuZCBjYXB0dXJlPXRydWUgc28gV0UgZ2V0IGEgZmlyc3QgY3JhY2tcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2VNb3ZlLCB0cnVlKTsgLy8gdHJ1ZT1jYXB0dXJlLCBub3QgYnViYmxlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9tb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIHByZXZlbnREZWZhdWx0KCkgcHJldmVudHMgYmx1ciBldmVudCB3aGljaCBvY2N1cnMganVzdCBhZnRlciBtb3VzZWRvd24gZXZlbnQuXG4gICAgICAgIC8vIGlmIGFuIGVkaXRhYmxlIGNvbnRlbnQgaGFzIGZvY3VzLCB0aGVuIGJsdXIgbXVzdCBiZSBjYWxsXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIERETWFuYWdlci5tb3VzZUhhbmRsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBtZXRob2QgdG8gY2FsbCBhY3R1YWwgZHJhZyBldmVudCAqL1xuICAgIF9jYWxsRHJhZyhlKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZSwgeyB0YXJnZXQ6IHRoaXMuZWwsIHR5cGU6ICdkcmFnJyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLmRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLmRyYWcoZXYsIHRoaXMudWkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2RyYWcnLCBldik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHdoZW4gdGhlIG1haW4gcGFnZSAoYWZ0ZXIgc3VjY2Vzc2Z1bCBtb3VzZWRvd24pIHJlY2VpdmVzIGEgbW92ZSBldmVudCB0byBkcmFnIHRoZSBpdGVtIGFyb3VuZCB0aGUgc2NyZWVuICovXG4gICAgX21vdXNlTW92ZShlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IG1vdmUgJHtlLnh9LCR7ZS55fWApXG4gICAgICAgIGxldCBzID0gdGhpcy5tb3VzZURvd25FdmVudDtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdGb2xsb3coZSk7XG4gICAgICAgICAgICAvLyBkZWxheSBhY3R1YWwgZ3JpZCBoYW5kbGluZyBkcmFnIHVudGlsIHdlIHBhdXNlIGZvciBhIHdoaWxlIGlmIHNldFxuICAgICAgICAgICAgaWYgKERETWFuYWdlci5wYXVzZURyYWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXVzZSA9IE51bWJlci5pc0ludGVnZXIoRERNYW5hZ2VyLnBhdXNlRHJhZykgPyBERE1hbmFnZXIucGF1c2VEcmFnIDogMTAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdUaW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZHJhZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9jYWxsRHJhZyhlKSwgcGF1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbERyYWcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoZS54IC0gcy54KSArIE1hdGguYWJzKGUueSAtIHMueSkgPiAzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGRvbid0IHN0YXJ0IHVubGVzcyB3ZSd2ZSBtb3ZlZCBhdCBsZWFzdCAzIHBpeGVsc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIERETWFuYWdlci5kcmFnRWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBkcmFnZ2luZyBhbiBhY3R1YWwgZ3JpZCBpdGVtLCBzZXQgdGhlIGN1cnJlbnQgZHJvcCBhcyB0aGUgZ3JpZCAodG8gZGV0ZWN0IGVudGVyL2xlYXZlKVxuICAgICAgICAgICAgbGV0IGdyaWQgPSB0aGlzLmVsLmdyaWRzdGFja05vZGU/LmdyaWQ7XG4gICAgICAgICAgICBpZiAoZ3JpZCkge1xuICAgICAgICAgICAgICAgIERETWFuYWdlci5kcm9wRWxlbWVudCA9IGdyaWQuZWwuZGRFbGVtZW50LmRkRHJvcHBhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcm9wRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVscGVyID0gdGhpcy5fY3JlYXRlSGVscGVyKGUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIZWxwZXJDb250YWlubWVudFN0eWxlKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQgPSB0aGlzLl9nZXREcmFnT2Zmc2V0KGUsIHRoaXMuZWwsIHRoaXMuaGVscGVyQ29udGFpbm1lbnQpO1xuICAgICAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZSwgeyB0YXJnZXQ6IHRoaXMuZWwsIHR5cGU6ICdkcmFnc3RhcnQnIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIZWxwZXJTdHlsZShlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbi5zdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uLnN0YXJ0KGV2LCB0aGlzLnVpKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIG5lZWRlZCBvdGhlcndpc2Ugd2UgZ2V0IHRleHQgc3dlZXAgdGV4dCBzZWxlY3Rpb24gYXMgd2UgZHJhZyBhcm91bmRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbCB3aGVuIHRoZSBtb3VzZSBnZXRzIHJlbGVhc2VkIHRvIGRyb3AgdGhlIGl0ZW0gYXQgY3VycmVudCBsb2NhdGlvbiAqL1xuICAgIF9tb3VzZVVwKGUpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNlVXAsIHRydWUpO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kcmFnZ2luZztcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBkcm9wIHRhcmdldCBpZiBkcmFnZ2luZyBvdmVyIG91cnNlbGYgKGFscmVhZHkgcGFyZW50ZWQsIGp1c3QgbW92aW5nIGR1cmluZyBzdG9wIGNhbGxiYWNrIGJlbG93KVxuICAgICAgICAgICAgaWYgKERETWFuYWdlci5kcm9wRWxlbWVudD8uZWwgPT09IHRoaXMuZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBERE1hbmFnZXIuZHJvcEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5tZW50LnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wYXJlbnRPcmlnaW5TdHlsZVBvc2l0aW9uIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxwZXIgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVIZWxwZXJTdHlsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChlLCB7IHRhcmdldDogdGhpcy5lbCwgdHlwZTogJ2RyYWdzdG9wJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbi5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb24uc3RvcChldik7IC8vIE5PVEU6IGRlc3Ryb3koKSB3aWxsIGJlIGNhbGxlZCB3aGVuIHJlbW92aW5nIGl0ZW0sIHNvIGV4cGVjdCBOVUxMIHB0ciBhZnRlciFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdkcmFnc3RvcCcsIGV2KTtcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGRyb3BwYWJsZSBtZXRob2QgdG8gcmVjZWl2ZSB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKERETWFuYWdlci5kcm9wRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIERETWFuYWdlci5kcm9wRWxlbWVudC5kcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhlbHBlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMubW91c2VEb3duRXZlbnQ7XG4gICAgICAgIGRlbGV0ZSBERE1hbmFnZXIuZHJhZ0VsZW1lbnQ7XG4gICAgICAgIGRlbGV0ZSBERE1hbmFnZXIuZHJvcEVsZW1lbnQ7XG4gICAgICAgIGRlbGV0ZSBERE1hbmFnZXIubW91c2VIYW5kbGVkO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY3JlYXRlIGEgY2xvbmUgY29weSAob3IgdXNlciBkZWZpbmVkIG1ldGhvZCkgb2YgdGhlIG9yaWdpbmFsIGRyYWcgaXRlbSBpZiBzZXQgKi9cbiAgICBfY3JlYXRlSGVscGVyKGV2ZW50KSB7XG4gICAgICAgIGxldCBoZWxwZXIgPSB0aGlzLmVsO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uLmhlbHBlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaGVscGVyID0gdGhpcy5vcHRpb24uaGVscGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbi5oZWxwZXIgPT09ICdjbG9uZScpIHtcbiAgICAgICAgICAgIGhlbHBlciA9IFV0aWxzLmNsb25lTm9kZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoaGVscGVyKSkge1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kVG8oaGVscGVyLCB0aGlzLm9wdGlvbi5hcHBlbmRUbyA9PT0gJ3BhcmVudCcgPyB0aGlzLmVsLnBhcmVudEVsZW1lbnQgOiB0aGlzLm9wdGlvbi5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlbHBlciA9PT0gdGhpcy5lbCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudE9yaWdpblN0eWxlID0gREREcmFnZ2FibGUub3JpZ2luU3R5bGVQcm9wLm1hcChwcm9wID0+IHRoaXMuZWwuc3R5bGVbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWxwZXI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgc2V0IHRoZSBmaXggcG9zaXRpb24gb2YgdGhlIGRyYWdnZWQgaXRlbSAqL1xuICAgIF9zZXR1cEhlbHBlclN0eWxlKGUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIuY2xhc3NMaXN0LmFkZCgndWktZHJhZ2dhYmxlLWRyYWdnaW5nJyk7XG4gICAgICAgIC8vIFRPRE86IHNldCBhbGwgYXQgb25jZSB3aXRoIHN0eWxlLmNzc1RleHQgKz0gLi4uID8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2ODU5M1xuICAgICAgICBjb25zdCBzdHlsZSA9IHRoaXMuaGVscGVyLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnOyAvLyBuZWVkZWQgZm9yIG92ZXIgaXRlbXMgdG8gZ2V0IGVudGVyL2xlYXZlXG4gICAgICAgIC8vIHN0eWxlLmN1cnNvciA9ICdtb3ZlJzsgLy8gIFRPRE86IGNhbid0IHNldCB3aXRoIHBvaW50ZXJFdmVudHM9bm9uZSAhIChkb25lIGluIENTUyBhcyB3ZWxsKVxuICAgICAgICBzdHlsZS53aWR0aCA9IHRoaXMuZHJhZ09mZnNldC53aWR0aCArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IHRoaXMuZHJhZ09mZnNldC5oZWlnaHQgKyAncHgnO1xuICAgICAgICBzdHlsZS53aWxsQ2hhbmdlID0gJ2xlZnQsIHRvcCc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJzsgLy8gbGV0IHVzIGRyYWcgYmV0d2VlbiBncmlkcyBieSBub3QgY2xpcHBpbmcgYXMgcGFyZW50IC5ncmlkLXN0YWNrIGlzIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICAgIHRoaXMuX2RyYWdGb2xsb3coZSk7IC8vIG5vdyBwb3NpdGlvbiBpdFxuICAgICAgICBzdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnOyAvLyBzaG93IHVwIGluc3RhbnRseVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbHBlcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBudWxsOyAvLyByZWNvdmVyIGFuaW1hdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVzdG9yZSBiYWNrIHRoZSBvcmlnaW5hbCBzdHlsZSBiZWZvcmUgZHJhZ2dpbmcgKi9cbiAgICBfcmVtb3ZlSGVscGVyU3R5bGUoKSB7XG4gICAgICAgIHRoaXMuaGVscGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWRyYWdnYWJsZS1kcmFnZ2luZycpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVscGVyPy5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAvLyBkb24ndCBib3RoZXIgcmVzdG9yaW5nIHN0eWxlcyBpZiB3ZSdyZSBnb25uYSByZW1vdmUgYW55d2F5Li4uXG4gICAgICAgIGlmICghbm9kZT8uX2lzQWJvdXRUb1JlbW92ZSAmJiB0aGlzLmRyYWdFbGVtZW50T3JpZ2luU3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBoZWxwZXIgPSB0aGlzLmhlbHBlcjtcbiAgICAgICAgICAgIC8vIGRvbid0IGFuaW1hdGUsIG90aGVyd2lzZSB3ZSBhbmltYXRlIG9mZnNldGVkIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gJ2Fic29sdXRlJyBmcm9tICdmaXhlZCcuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGFsc28gcmVtb3ZlcyByZXNpemluZyBhbmltYXRpb24gd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgaXNzdWUsIGJ1dCBvdGhlcnMuXG4gICAgICAgICAgICAvLyBJZGVhbGx5IGJvdGggd291bGQgYW5pbWF0ZSAoJ21vdmUnIHdvdWxkIGltbWVkaWF0ZWx5IHJlc3RvcmUgJ2Fic29sdXRlJyBhbmQgYWRqdXN0IGNvb3JkaW5hdGUgdG8gbWF0Y2gsXG4gICAgICAgICAgICAvLyB0aGVuIHRyaWdnZXIgYSBkZWxheSAocmVwYWludCkgdG8gcmVzdG9yZSB0byBmaW5hbCBkZXN0IHdpdGggYW5pbWF0ZSkgYnV0IHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmUgJ3Jlc2l6ZXN0b3AnXG4gICAgICAgICAgICAvLyBpcyBjYWxsZWQgQUZURVIgJ3RyYW5zaXRpb25lbmQnIGV2ZW50IGlzIHJlY2VpdmVkIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyaWRzdGFjay9ncmlkc3RhY2suanMvaXNzdWVzLzIwMzMpXG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IHRoaXMuZHJhZ0VsZW1lbnRPcmlnaW5TdHlsZVsndHJhbnNpdGlvbiddIHx8IG51bGw7XG4gICAgICAgICAgICBoZWxwZXIuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuZHJhZ0VsZW1lbnRPcmlnaW5TdHlsZVsndHJhbnNpdGlvbiddID0gJ25vbmUnOyAvLyBjYW4ndCBiZSBOVUxMICMxOTczXG4gICAgICAgICAgICBERERyYWdnYWJsZS5vcmlnaW5TdHlsZVByb3AuZm9yRWFjaChwcm9wID0+IGhlbHBlci5zdHlsZVtwcm9wXSA9IHRoaXMuZHJhZ0VsZW1lbnRPcmlnaW5TdHlsZVtwcm9wXSB8fCBudWxsKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gaGVscGVyLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLCA1MCk7IC8vIHJlY292ZXIgYW5pbWF0aW9uIGZyb20gc2F2ZWQgdmFycyBhZnRlciBhIHBhdXNlICgwIGlzbid0IGVub3VnaCAjMTk3MylcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5kcmFnRWxlbWVudE9yaWdpblN0eWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCB1cGRhdGVzIHRoZSB0b3AvbGVmdCBwb3NpdGlvbiB0byBmb2xsb3cgdGhlIG1vdXNlICovXG4gICAgX2RyYWdGb2xsb3coZSkge1xuICAgICAgICBsZXQgY29udGFpbm1lbnRSZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICAgICAgLy8gaWYgKHRoaXMuaGVscGVyLnN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7IC8vIHdlIHVzZSAnZml4ZWQnXG4gICAgICAgIC8vICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IHRoaXMuaGVscGVyQ29udGFpbm1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vICAgY29udGFpbm1lbnRSZWN0ID0geyBsZWZ0LCB0b3AgfTtcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdCBzdHlsZSA9IHRoaXMuaGVscGVyLnN0eWxlO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmRyYWdPZmZzZXQ7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBlLmNsaWVudFggKyBvZmZzZXQub2Zmc2V0TGVmdCAtIGNvbnRhaW5tZW50UmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUudG9wID0gZS5jbGllbnRZICsgb2Zmc2V0Lm9mZnNldFRvcCAtIGNvbnRhaW5tZW50UmVjdC50b3AgKyAncHgnO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldHVwSGVscGVyQ29udGFpbm1lbnRTdHlsZSgpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJDb250YWlubWVudCA9IHRoaXMuaGVscGVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmhlbHBlci5zdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRPcmlnaW5TdHlsZVBvc2l0aW9uID0gdGhpcy5oZWxwZXJDb250YWlubWVudC5zdHlsZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMuaGVscGVyQ29udGFpbm1lbnQpLnBvc2l0aW9uLm1hdGNoKC9zdGF0aWMvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyQ29udGFpbm1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldERyYWdPZmZzZXQoZXZlbnQsIGVsLCBwYXJlbnQpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBhbmNlc3RvciBoYXMgdHJhbnNmb3JtL3BlcnNwZWN0aXZlIGNzcyBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIHRoZSB2aWV3cG9pbnRcbiAgICAgICAgbGV0IHhmb3JtT2Zmc2V0WCA9IDA7XG4gICAgICAgIGxldCB4Zm9ybU9mZnNldFkgPSAwO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIFV0aWxzLmFkZEVsU3R5bGVzKHRlc3RFbCwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcwJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB0b3A6IDAgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMXB4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogJy05OTk5OTknLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGVzdEVsKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RFbFBvc2l0aW9uID0gdGVzdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRlc3RFbCk7XG4gICAgICAgICAgICB4Zm9ybU9mZnNldFggPSB0ZXN0RWxQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgeGZvcm1PZmZzZXRZID0gdGVzdEVsUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgLy8gVE9ETzogc2NhbGUgP1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGFyZ2V0T2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB0b3A6IHRhcmdldE9mZnNldC50b3AsXG4gICAgICAgICAgICBvZmZzZXRMZWZ0OiAtZXZlbnQuY2xpZW50WCArIHRhcmdldE9mZnNldC5sZWZ0IC0geGZvcm1PZmZzZXRYLFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiAtZXZlbnQuY2xpZW50WSArIHRhcmdldE9mZnNldC50b3AgLSB4Zm9ybU9mZnNldFksXG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0T2Zmc2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRPZmZzZXQuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgVE9ETzogc2V0IHRvIHB1YmxpYyBhcyBjYWxsZWQgYnkgREREcm9wcGFibGUhICovXG4gICAgdWkoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5tZW50RWwgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5tZW50UmVjdCA9IGNvbnRhaW5tZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuaGVscGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBjb250YWlubWVudFJlY3QudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gY29udGFpbm1lbnRSZWN0LmxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIG5vdCB1c2VkIGJ5IEdyaWRTdGFjayBmb3Igbm93Li4uXG4gICAgICAgICAgICBoZWxwZXI6IFt0aGlzLmhlbHBlcl0sIC8vVGhlIG9iamVjdCBhcnIgcmVwcmVzZW50aW5nIHRoZSBoZWxwZXIgdGhhdCdzIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAgICBvZmZzZXQ6IHsgdG9wOiBvZmZzZXQudG9wLCBsZWZ0OiBvZmZzZXQubGVmdCB9IC8vIEN1cnJlbnQgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgYXMgeyB0b3AsIGxlZnQgfSBvYmplY3QuXG4gICAgICAgICAgICAqL1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgcHJvcGVydGllcyB3ZSBjaGFuZ2UgZHVyaW5nIGRyYWdnaW5nLCBhbmQgcmVzdG9yZSBiYWNrICovXG5ERERyYWdnYWJsZS5vcmlnaW5TdHlsZVByb3AgPSBbJ3RyYW5zaXRpb24nLCAncG9pbnRlckV2ZW50cycsICdwb3NpdGlvbicsICdsZWZ0JywgJ3RvcCcsICdtaW5XaWR0aCcsICd3aWxsQ2hhbmdlJ107XG5leHBvcnQgeyBERERyYWdnYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtZHJhZ2dhYmxlLmpzLm1hcCJdLCJuYW1lcyI6WyJERE1hbmFnZXIiLCJVdGlscyIsIkREQmFzZUltcGxlbWVudCIsImlzVG91Y2giLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoc3RhcnQiLCJwb2ludGVyZG93biIsInNraXBNb3VzZURvd24iLCJERERyYWdnYWJsZSIsImNvbnN0cnVjdG9yIiwiZWwiLCJvcHRpb24iLCJoYW5kbGVOYW1lIiwiaGFuZGxlIiwic3Vic3RyaW5nIiwiZHJhZ0VsIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJxdWVyeVNlbGVjdG9yIiwiX21vdXNlRG93biIsImJpbmQiLCJfbW91c2VNb3ZlIiwiX21vdXNlVXAiLCJlbmFibGUiLCJvbiIsImV2ZW50IiwiY2FsbGJhY2siLCJvZmYiLCJkaXNhYmxlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmUiLCJkaXNhYmxlIiwiZm9yRGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGQiLCJkZXN0cm95IiwiZHJhZ1RpbWVvdXQiLCJ3aW5kb3ciLCJjbGVhclRpbWVvdXQiLCJkcmFnZ2luZyIsIm1vdXNlRG93bkV2ZW50IiwiaGVscGVyIiwidXBkYXRlT3B0aW9uIiwib3B0cyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZSIsIm1vdXNlSGFuZGxlZCIsImJ1dHRvbiIsInRhcmdldCIsImNsb3Nlc3QiLCJjYW5jZWwiLCJkcmFnRWxlbWVudCIsImRyb3BFbGVtZW50IiwiZG9jdW1lbnQiLCJwcmV2ZW50RGVmYXVsdCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiX2NhbGxEcmFnIiwiZXYiLCJpbml0RXZlbnQiLCJ0eXBlIiwiZHJhZyIsInVpIiwidHJpZ2dlckV2ZW50IiwicyIsIl9kcmFnRm9sbG93IiwicGF1c2VEcmFnIiwicGF1c2UiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJzZXRUaW1lb3V0IiwiTWF0aCIsImFicyIsIngiLCJ5IiwiZ3JpZCIsImdyaWRzdGFja05vZGUiLCJkZEVsZW1lbnQiLCJkZERyb3BwYWJsZSIsIl9jcmVhdGVIZWxwZXIiLCJfc2V0dXBIZWxwZXJDb250YWlubWVudFN0eWxlIiwiZHJhZ09mZnNldCIsIl9nZXREcmFnT2Zmc2V0IiwiaGVscGVyQ29udGFpbm1lbnQiLCJfc2V0dXBIZWxwZXJTdHlsZSIsInN0YXJ0IiwicGFyZW50RWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJwYXJlbnRPcmlnaW5TdHlsZVBvc2l0aW9uIiwiX3JlbW92ZUhlbHBlclN0eWxlIiwic3RvcCIsImRyb3AiLCJjbG9uZU5vZGUiLCJib2R5IiwiYXBwZW5kVG8iLCJkcmFnRWxlbWVudE9yaWdpblN0eWxlIiwib3JpZ2luU3R5bGVQcm9wIiwibWFwIiwicHJvcCIsInBvaW50ZXJFdmVudHMiLCJ3aWR0aCIsImhlaWdodCIsIndpbGxDaGFuZ2UiLCJ0cmFuc2l0aW9uIiwibm9kZSIsIl9pc0Fib3V0VG9SZW1vdmUiLCJjb250YWlubWVudFJlY3QiLCJsZWZ0IiwidG9wIiwib2Zmc2V0IiwiY2xpZW50WCIsIm9mZnNldExlZnQiLCJjbGllbnRZIiwib2Zmc2V0VG9wIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm1hdGNoIiwicGFyZW50IiwieGZvcm1PZmZzZXRYIiwieGZvcm1PZmZzZXRZIiwidGVzdEVsIiwiY3JlYXRlRWxlbWVudCIsImFkZEVsU3R5bGVzIiwib3BhY2l0eSIsInpJbmRleCIsImFwcGVuZENoaWxkIiwidGVzdEVsUG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZW1vdmVDaGlsZCIsInRhcmdldE9mZnNldCIsImNvbnRhaW5tZW50RWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-draggable.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-droppable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-droppable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDroppable: () => (/* binding */ DDDroppable)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-droppable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\n// let count = 0; // TEST\nclass DDDroppable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n    constructor(el, opts = {}){\n        super();\n        this.el = el;\n        this.option = opts;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseEnter = this._mouseEnter.bind(this);\n        this._mouseLeave = this._mouseLeave.bind(this);\n        this.enable();\n        this._setupAccept();\n    }\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        if (this.disabled === false) return;\n        super.enable();\n        this.el.classList.add(\"ui-droppable\");\n        this.el.classList.remove(\"ui-droppable-disabled\");\n        this.el.addEventListener(\"mouseenter\", this._mouseEnter);\n        this.el.addEventListener(\"mouseleave\", this._mouseLeave);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.el.addEventListener(\"pointerenter\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n            this.el.addEventListener(\"pointerleave\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n        }\n    }\n    disable(forDestroy = false) {\n        if (this.disabled === true) return;\n        super.disable();\n        this.el.classList.remove(\"ui-droppable\");\n        if (!forDestroy) this.el.classList.add(\"ui-droppable-disabled\");\n        this.el.removeEventListener(\"mouseenter\", this._mouseEnter);\n        this.el.removeEventListener(\"mouseleave\", this._mouseLeave);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n            this.el.removeEventListener(\"pointerenter\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n            this.el.removeEventListener(\"pointerleave\", _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n        }\n    }\n    destroy() {\n        this.disable(true);\n        this.el.classList.remove(\"ui-droppable\");\n        this.el.classList.remove(\"ui-droppable-disabled\");\n        super.destroy();\n    }\n    updateOption(opts) {\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        this._setupAccept();\n        return this;\n    }\n    /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */ _mouseEnter(e) {\n        // console.log(`${count++} Enter ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) return;\n        if (!this._canDrop(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement.el)) return;\n        e.preventDefault();\n        e.stopPropagation();\n        // make sure when we enter this, that the last one gets a leave FIRST to correctly cleanup as we don't always do\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement && _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) {\n            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement._mouseLeave(e);\n        }\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = this;\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"dropover\"\n        });\n        if (this.option.over) {\n            this.option.over(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"dropover\", ev);\n        this.el.classList.add(\"ui-droppable-over\");\n    // console.log('tracking'); // TEST\n    }\n    /** @internal called when the item is leaving our area, stop tracking if we had moving item */ _mouseLeave(e) {\n        // console.log(`${count++} Leave ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement || _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) return;\n        e.preventDefault();\n        e.stopPropagation();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"dropout\"\n        });\n        if (this.option.out) {\n            this.option.out(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"dropout\", ev);\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement === this) {\n            delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n            // console.log('not tracking'); // TEST\n            // if we're still over a parent droppable, send it an enter as we don't get one from leaving nested children\n            let parentDrop;\n            let parent = this.el.parentElement;\n            while(!parentDrop && parent){\n                parentDrop = parent.ddElement?.ddDroppable;\n                parent = parent.parentElement;\n            }\n            if (parentDrop) {\n                parentDrop._mouseEnter(e);\n            }\n        }\n    }\n    /** item is being dropped on us - called by the drag mouseup handler - this calls the client drop event */ drop(e) {\n        e.preventDefault();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n            target: this.el,\n            type: \"drop\"\n        });\n        if (this.option.drop) {\n            this.option.drop(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n        }\n        this.triggerEvent(\"drop\", ev);\n    }\n    /** @internal true if element matches the string/method accept option */ _canDrop(el) {\n        return el && (!this.accept || this.accept(el));\n    }\n    /** @internal */ _setupAccept() {\n        if (!this.option.accept) return this;\n        if (typeof this.option.accept === \"string\") {\n            this.accept = (el)=>el.classList.contains(this.option.accept) || el.matches(this.option.accept);\n        } else {\n            this.accept = this.option.accept;\n        }\n        return this;\n    }\n    /** @internal */ _ui(drag) {\n        return {\n            draggable: drag.el,\n            ...drag.ui()\n        };\n    }\n} //# sourceMappingURL=dd-droppable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZHJvcHBhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3dDO0FBQ1E7QUFDakI7QUFDaUM7QUFDakUseUJBQXlCO0FBQ2xCLE1BQU1NLG9CQUFvQkwsMERBQWVBO0lBQzVDTSxZQUFZQyxFQUFFLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDdkIsS0FBSztRQUNMLElBQUksQ0FBQ0QsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ0UsTUFBTSxHQUFHRDtRQUNkLCtHQUErRztRQUMvRyxJQUFJLENBQUNFLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDN0MsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQzdDLElBQUksQ0FBQ0UsTUFBTTtRQUNYLElBQUksQ0FBQ0MsWUFBWTtJQUNyQjtJQUNBQyxHQUFHQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTtRQUNoQixLQUFLLENBQUNGLEdBQUdDLE9BQU9DO0lBQ3BCO0lBQ0FDLElBQUlGLEtBQUssRUFBRTtRQUNQLEtBQUssQ0FBQ0UsSUFBSUY7SUFDZDtJQUNBSCxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNNLFFBQVEsS0FBSyxPQUNsQjtRQUNKLEtBQUssQ0FBQ047UUFDTixJQUFJLENBQUNOLEVBQUUsQ0FBQ2EsU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDZCxFQUFFLENBQUNhLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDO1FBQ3pCLElBQUksQ0FBQ2YsRUFBRSxDQUFDZ0IsZ0JBQWdCLENBQUMsY0FBYyxJQUFJLENBQUNiLFdBQVc7UUFDdkQsSUFBSSxDQUFDSCxFQUFFLENBQUNnQixnQkFBZ0IsQ0FBQyxjQUFjLElBQUksQ0FBQ1gsV0FBVztRQUN2RCxJQUFJViw4Q0FBT0EsRUFBRTtZQUNULElBQUksQ0FB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dEVKLFNBQVM1QixFQUFFLEVBQUU7UUFDVCxPQUFPQSxNQUFPLEVBQUMsSUFBSSxDQUFDOEMsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxDQUFDOUMsR0FBRTtJQUNoRDtJQUNBLGNBQWMsR0FDZE8sZUFBZTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNMLE1BQU0sQ0FBQzRDLE1BQU0sRUFDbkIsT0FBTyxJQUFJO1FBQ2YsSUFBSSxPQUFPLElBQUksQ0FBQzVDLE1BQU0sQ0FBQzRDLE1BQU0sS0FBSyxVQUFVO1lBQ3hDLElBQUksQ0FBQ0EsTUFBTSxHQUFHLENBQUM5QyxLQUFPQSxHQUFHYSxTQUFTLENBQUNrQyxRQUFRLENBQUMsSUFBSSxDQUFDN0MsTUFBTSxDQUFDNEMsTUFBTSxLQUFLOUMsR0FBR2dELE9BQU8sQ0FBQyxJQUFJLENBQUM5QyxNQUFNLENBQUM0QyxNQUFNO1FBQ3BHLE9BQ0s7WUFDRCxJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJLENBQUM1QyxNQUFNLENBQUM0QyxNQUFNO1FBQ3BDO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxjQUFjLEdBQ2RULElBQUlZLElBQUksRUFBRTtRQUNOLE9BQU87WUFDSEMsV0FBV0QsS0FBS2pELEVBQUU7WUFDbEIsR0FBR2lELEtBQUtFLEVBQUUsRUFBRTtRQUNoQjtJQUNKO0FBQ0osRUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sdWNpZGl0eS1kM2pzLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2RkLWRyb3BwYWJsZS5qcz9kYjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtZHJvcHBhYmxlLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEtMjAyMiBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERNYW5hZ2VyIH0gZnJvbSAnLi9kZC1tYW5hZ2VyJztcbmltcG9ydCB7IEREQmFzZUltcGxlbWVudCB9IGZyb20gJy4vZGQtYmFzZS1pbXBsJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBpc1RvdWNoLCBwb2ludGVyZW50ZXIsIHBvaW50ZXJsZWF2ZSB9IGZyb20gJy4vZGQtdG91Y2gnO1xuLy8gbGV0IGNvdW50ID0gMDsgLy8gVEVTVFxuZXhwb3J0IGNsYXNzIERERHJvcHBhYmxlIGV4dGVuZHMgRERCYXNlSW1wbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRzO1xuICAgICAgICAvLyBjcmVhdGUgdmFyIGV2ZW50IGJpbmRpbmcgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgYW5kIHN0aWxsIGxvb2sgbGlrZSBUUyBtZXRob2RzICh1bmxpa2UgYW5vbnltb3VzIGZ1bmN0aW9ucylcbiAgICAgICAgdGhpcy5fbW91c2VFbnRlciA9IHRoaXMuX21vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2VMZWF2ZSA9IHRoaXMuX21vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBY2NlcHQoKTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9mZihldmVudCkge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnQpO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndWktZHJvcHBhYmxlJyk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgndWktZHJvcHBhYmxlLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX21vdXNlRW50ZXIpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9tb3VzZUxlYXZlKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgcG9pbnRlcmVudGVyKTtcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgcG9pbnRlcmxlYXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhYmxlKGZvckRlc3Ryb3kgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3VwZXIuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWRyb3BwYWJsZScpO1xuICAgICAgICBpZiAoIWZvckRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLWRyb3BwYWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9tb3VzZUVudGVyKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fbW91c2VMZWF2ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJlbnRlcicsIHBvaW50ZXJlbnRlcik7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHBvaW50ZXJsZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKHRydWUpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWRyb3BwYWJsZScpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWRyb3BwYWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbihvcHRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdHMpLmZvckVhY2goa2V5ID0+IHRoaXMub3B0aW9uW2tleV0gPSBvcHRzW2tleV0pO1xuICAgICAgICB0aGlzLl9zZXR1cEFjY2VwdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsZWQgd2hlbiB0aGUgY3Vyc29yIGVudGVycyBvdXIgYXJlYSAtIHByZXBhcmUgZm9yIGEgcG9zc2libGUgZHJvcCBhbmQgdHJhY2sgbGVhdmluZyAqL1xuICAgIF9tb3VzZUVudGVyKGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7Y291bnQrK30gRW50ZXIgJHt0aGlzLmVsLmlkIHx8ICh0aGlzLmVsIGFzIEdyaWRIVE1MRWxlbWVudCkuZ3JpZHN0YWNrLm9wdHMuaWR9YCk7IC8vIFRFU1RcbiAgICAgICAgaWYgKCFERE1hbmFnZXIuZHJhZ0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fY2FuRHJvcChERE1hbmFnZXIuZHJhZ0VsZW1lbnQuZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3aGVuIHdlIGVudGVyIHRoaXMsIHRoYXQgdGhlIGxhc3Qgb25lIGdldHMgYSBsZWF2ZSBGSVJTVCB0byBjb3JyZWN0bHkgY2xlYW51cCBhcyB3ZSBkb24ndCBhbHdheXMgZG9cbiAgICAgICAgaWYgKERETWFuYWdlci5kcm9wRWxlbWVudCAmJiBERE1hbmFnZXIuZHJvcEVsZW1lbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIERETWFuYWdlci5kcm9wRWxlbWVudC5fbW91c2VMZWF2ZShlKTtcbiAgICAgICAgfVxuICAgICAgICBERE1hbmFnZXIuZHJvcEVsZW1lbnQgPSB0aGlzO1xuICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChlLCB7IHRhcmdldDogdGhpcy5lbCwgdHlwZTogJ2Ryb3BvdmVyJyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLm92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLm92ZXIoZXYsIHRoaXMuX3VpKERETWFuYWdlci5kcmFnRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdkcm9wb3ZlcicsIGV2KTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd1aS1kcm9wcGFibGUtb3ZlcicpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndHJhY2tpbmcnKTsgLy8gVEVTVFxuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB3aGVuIHRoZSBpdGVtIGlzIGxlYXZpbmcgb3VyIGFyZWEsIHN0b3AgdHJhY2tpbmcgaWYgd2UgaGFkIG1vdmluZyBpdGVtICovXG4gICAgX21vdXNlTGVhdmUoZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtjb3VudCsrfSBMZWF2ZSAke3RoaXMuZWwuaWQgfHwgKHRoaXMuZWwgYXMgR3JpZEhUTUxFbGVtZW50KS5ncmlkc3RhY2sub3B0cy5pZH1gKTsgLy8gVEVTVFxuICAgICAgICBpZiAoIURETWFuYWdlci5kcmFnRWxlbWVudCB8fCBERE1hbmFnZXIuZHJvcEVsZW1lbnQgIT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZSwgeyB0YXJnZXQ6IHRoaXMuZWwsIHR5cGU6ICdkcm9wb3V0JyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLm91dCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ub3V0KGV2LCB0aGlzLl91aShERE1hbmFnZXIuZHJhZ0VsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZHJvcG91dCcsIGV2KTtcbiAgICAgICAgaWYgKERETWFuYWdlci5kcm9wRWxlbWVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgZGVsZXRlIERETWFuYWdlci5kcm9wRWxlbWVudDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdub3QgdHJhY2tpbmcnKTsgLy8gVEVTVFxuICAgICAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgb3ZlciBhIHBhcmVudCBkcm9wcGFibGUsIHNlbmQgaXQgYW4gZW50ZXIgYXMgd2UgZG9uJ3QgZ2V0IG9uZSBmcm9tIGxlYXZpbmcgbmVzdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICBsZXQgcGFyZW50RHJvcDtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIXBhcmVudERyb3AgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RHJvcCA9IHBhcmVudC5kZEVsZW1lbnQ/LmRkRHJvcHBhYmxlO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudERyb3ApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnREcm9wLl9tb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBpdGVtIGlzIGJlaW5nIGRyb3BwZWQgb24gdXMgLSBjYWxsZWQgYnkgdGhlIGRyYWcgbW91c2V1cCBoYW5kbGVyIC0gdGhpcyBjYWxscyB0aGUgY2xpZW50IGRyb3AgZXZlbnQgKi9cbiAgICBkcm9wKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChlLCB7IHRhcmdldDogdGhpcy5lbCwgdHlwZTogJ2Ryb3AnIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24uZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24uZHJvcChldiwgdGhpcy5fdWkoRERNYW5hZ2VyLmRyYWdFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Ryb3AnLCBldik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgdHJ1ZSBpZiBlbGVtZW50IG1hdGNoZXMgdGhlIHN0cmluZy9tZXRob2QgYWNjZXB0IG9wdGlvbiAqL1xuICAgIF9jYW5Ecm9wKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCAmJiAoIXRoaXMuYWNjZXB0IHx8IHRoaXMuYWNjZXB0KGVsKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2V0dXBBY2NlcHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb24uYWNjZXB0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb24uYWNjZXB0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hY2NlcHQgPSAoZWwpID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbi5hY2NlcHQpIHx8IGVsLm1hdGNoZXModGhpcy5vcHRpb24uYWNjZXB0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0ID0gdGhpcy5vcHRpb24uYWNjZXB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3VpKGRyYWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZHJhZy5lbCxcbiAgICAgICAgICAgIC4uLmRyYWcudWkoKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLWRyb3BwYWJsZS5qcy5tYXAiXSwibmFtZXMiOlsiRERNYW5hZ2VyIiwiRERCYXNlSW1wbGVtZW50IiwiVXRpbHMiLCJpc1RvdWNoIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwiREREcm9wcGFibGUiLCJjb25zdHJ1Y3RvciIsImVsIiwib3B0cyIsIm9wdGlvbiIsIl9tb3VzZUVudGVyIiwiYmluZCIsIl9tb3VzZUxlYXZlIiwiZW5hYmxlIiwiX3NldHVwQWNjZXB0Iiwib24iLCJldmVudCIsImNhbGxiYWNrIiwib2ZmIiwiZGlzYWJsZWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzYWJsZSIsImZvckRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInVwZGF0ZU9wdGlvbiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZSIsImRyYWdFbGVtZW50IiwiX2NhbkRyb3AiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImRyb3BFbGVtZW50IiwiZXYiLCJpbml0RXZlbnQiLCJ0YXJnZXQiLCJ0eXBlIiwib3ZlciIsIl91aSIsInRyaWdnZXJFdmVudCIsIm91dCIsInBhcmVudERyb3AiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwiZGRFbGVtZW50IiwiZGREcm9wcGFibGUiLCJkcm9wIiwiYWNjZXB0IiwiY29udGFpbnMiLCJtYXRjaGVzIiwiZHJhZyIsImRyYWdnYWJsZSIsInVpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-droppable.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-element.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-element.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDElement: () => (/* binding */ DDElement)\n/* harmony export */ });\n/* harmony import */ var _dd_resizable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable */ \"./node_modules/gridstack/dist/dd-resizable.js\");\n/* harmony import */ var _dd_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-draggable */ \"./node_modules/gridstack/dist/dd-draggable.js\");\n/* harmony import */ var _dd_droppable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-droppable */ \"./node_modules/gridstack/dist/dd-droppable.js\");\n/**\n * dd-elements.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n\n\nclass DDElement {\n    static init(el) {\n        if (!el.ddElement) {\n            el.ddElement = new DDElement(el);\n        }\n        return el.ddElement;\n    }\n    constructor(el){\n        this.el = el;\n    }\n    on(eventName, callback) {\n        if (this.ddDraggable && [\n            \"drag\",\n            \"dragstart\",\n            \"dragstop\"\n        ].indexOf(eventName) > -1) {\n            this.ddDraggable.on(eventName, callback);\n        } else if (this.ddDroppable && [\n            \"drop\",\n            \"dropover\",\n            \"dropout\"\n        ].indexOf(eventName) > -1) {\n            this.ddDroppable.on(eventName, callback);\n        } else if (this.ddResizable && [\n            \"resizestart\",\n            \"resize\",\n            \"resizestop\"\n        ].indexOf(eventName) > -1) {\n            this.ddResizable.on(eventName, callback);\n        }\n        return this;\n    }\n    off(eventName) {\n        if (this.ddDraggable && [\n            \"drag\",\n            \"dragstart\",\n            \"dragstop\"\n        ].indexOf(eventName) > -1) {\n            this.ddDraggable.off(eventName);\n        } else if (this.ddDroppable && [\n            \"drop\",\n            \"dropover\",\n            \"dropout\"\n        ].indexOf(eventName) > -1) {\n            this.ddDroppable.off(eventName);\n        } else if (this.ddResizable && [\n            \"resizestart\",\n            \"resize\",\n            \"resizestop\"\n        ].indexOf(eventName) > -1) {\n            this.ddResizable.off(eventName);\n        }\n        return this;\n    }\n    setupDraggable(opts) {\n        if (!this.ddDraggable) {\n            this.ddDraggable = new _dd_draggable__WEBPACK_IMPORTED_MODULE_1__.DDDraggable(this.el, opts);\n        } else {\n            this.ddDraggable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanDraggable() {\n        if (this.ddDraggable) {\n            this.ddDraggable.destroy();\n            delete this.ddDraggable;\n        }\n        return this;\n    }\n    setupResizable(opts) {\n        if (!this.ddResizable) {\n            this.ddResizable = new _dd_resizable__WEBPACK_IMPORTED_MODULE_0__.DDResizable(this.el, opts);\n        } else {\n            this.ddResizable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanResizable() {\n        if (this.ddResizable) {\n            this.ddResizable.destroy();\n            delete this.ddResizable;\n        }\n        return this;\n    }\n    setupDroppable(opts) {\n        if (!this.ddDroppable) {\n            this.ddDroppable = new _dd_droppable__WEBPACK_IMPORTED_MODULE_2__.DDDroppable(this.el, opts);\n        } else {\n            this.ddDroppable.updateOption(opts);\n        }\n        return this;\n    }\n    cleanDroppable() {\n        if (this.ddDroppable) {\n            this.ddDroppable.destroy();\n            delete this.ddDroppable;\n        }\n        return this;\n    }\n} //# sourceMappingURL=dd-element.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBQzRDO0FBQ0E7QUFDQTtBQUN0QyxNQUFNRztJQUNULE9BQU9DLEtBQUtDLEVBQUUsRUFBRTtRQUNaLElBQUksQ0FBQ0EsR0FBR0MsU0FBUyxFQUFFO1lBQ2ZELEdBQUdDLFNBQVMsR0FBRyxJQUFJSCxVQUFVRTtRQUNqQztRQUNBLE9BQU9BLEdBQUdDLFNBQVM7SUFDdkI7SUFDQUMsWUFBWUYsRUFBRSxDQUFFO1FBQ1osSUFBSSxDQUFDQSxFQUFFLEdBQUdBO0lBQ2Q7SUFDQUcsR0FBR0MsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNDLFdBQVcsSUFBSTtZQUFDO1lBQVE7WUFBYTtTQUFXLENBQUNDLE9BQU8sQ0FBQ0gsYUFBYSxDQUFDLEdBQUc7WUFDL0UsSUFBSSxDQUFDRSxXQUFXLENBQUNILEVBQUUsQ0FBQ0MsV0FBV0M7UUFDbkMsT0FDSyxJQUFJLElBQUksQ0FBQ0csV0FBVyxJQUFJO1lBQUM7WUFBUTtZQUFZO1NBQVUsQ0FBQ0QsT0FBTyxDQUFDSCxhQUFhLENBQUMsR0FBRztZQUNsRixJQUFJLENBQUNJLFdBQVcsQ0FBQ0wsRUFBRSxDQUFDQyxXQUFXQztRQUNuQyxPQUNLLElBQUksSUFBSSxDQUFDSSxXQUFXLElBQUk7WUFBQztZQUFlO1lBQVU7U0FBYSxDQUFDRixPQUFPLENBQUNILGFBQWEsQ0FBQyxHQUFHO1lBQzFGLElBQUksQ0FBQ0ssV0FBVyxDQUFDTixFQUFFLENBQUNDLFdBQVdDO1FBQ25DO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQUssSUFBSU4sU0FBUyxFQUFFO1FBQ1gsSUFBSSxJQUFJLENBQUNFLFdBQVcsSUFBSTtZQUFDO1lBQVE7WUFBYTtTQUFXLENBQUNDLE9BQU8sQ0FBQ0gsYUFBYSxDQUFDLEdBQUc7WUFDL0UsSUFBSSxDQUFDRSxXQUFXLENBQUNJLEdBQUcsQ0FBQ047UUFDekIsT0FDSyxJQUFJLElBQUksQ0FBQ0ksV0FBVyxJQUFJO1lBQUM7WUFBUTtZQUFZO1NBQVUsQ0FBQ0QsT0FBTyxDQUFDSCxhQUFhLENBQUMsR0FBRztZQUNsRixJQUFJLENBQUNJLFdBQVcsQ0FBQ0UsR0FBRyxDQUFDTjtRQUN6QixPQUNLLElBQUksSUFBSSxDQUFDSyxXQUFXLElBQUk7WUFBQztZQUFlO1lBQVU7U0FBYSxDQUFDRixPQUFPLENBQUNILGFBQWEsQ0FBQyxHQUFHO1lBQzFGLElBQUksQ0FBQ0ssV0FBVyxDQUFDQyxHQUFHLENBQUNOO1FBQ3pCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQU8sZUFBZUMsSUFBSSxFQUFFO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUNOLFdBQVcsRUFBRTtZQUNuQixJQUFJLENBQUNBLFdBQVcsR0FBRyxJQUFJVixzREFBV0EsQ0FBQyxJQUFJLENBQUNJLEVBQUUsRUFBRVk7UUFDaEQsT0FDSztZQUNELElBQUksQ0FBQ04sV0FBVyxDQUFDTyxZQUFZLENBQUNEO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQUUsaUJBQWlCO1FBQ2IsSUFBSSxJQUFJLENBQUNSLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUNBLFdBQVcsQ0FBQ1MsT0FBTztZQUN4QixPQUFPLElBQUksQ0FBQ1QsV0FBVztRQUMzQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FVLGVBQWVKLElBQUksRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDSCxXQUFXLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSWQsc0RBQVdBLENBQUMsSUFBSSxDQUFDSyxFQUFFLEVBQUVZO1FBQ2hELE9BQ0s7WUFDRCxJQUFJLENBQUNILFdBQVcsQ0FBQ0ksWUFBWSxDQUFDRDtRQUNsQztRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FLLGlCQUFpQjtRQUNiLElBQUksSUFBSSxDQUFDUixXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDQSxXQUFXLENBQUNNLE9BQU87WUFDeEIsT0FBTyxJQUFJLENBQUNOLFdBQVc7UUFDM0I7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBUyxlQUFlTixJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ0osV0FBVyxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUlYLHNEQUFXQSxDQUFDLElBQUksQ0FBQ0csRUFBRSxFQUFFWTtRQUNoRCxPQUNLO1lBQ0QsSUFBSSxDQUFDSixXQUFXLENBQUNLLFlBQVksQ0FBQ0Q7UUFDbEM7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBTyxpQkFBaUI7UUFDYixJQUFJLElBQUksQ0FBQ1gsV0FBVyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDTyxPQUFPO1lBQ3hCLE9BQU8sSUFBSSxDQUFDUCxXQUFXO1FBQzNCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2x1Y2lkaXR5LWQzanMvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZWxlbWVudC5qcz8zOGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtZWxlbWVudHMudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERSZXNpemFibGUgfSBmcm9tICcuL2RkLXJlc2l6YWJsZSc7XG5pbXBvcnQgeyBERERyYWdnYWJsZSB9IGZyb20gJy4vZGQtZHJhZ2dhYmxlJztcbmltcG9ydCB7IERERHJvcHBhYmxlIH0gZnJvbSAnLi9kZC1kcm9wcGFibGUnO1xuZXhwb3J0IGNsYXNzIERERWxlbWVudCB7XG4gICAgc3RhdGljIGluaXQoZWwpIHtcbiAgICAgICAgaWYgKCFlbC5kZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsLmRkRWxlbWVudCA9IG5ldyBEREVsZW1lbnQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5kZEVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5kZERyYWdnYWJsZSAmJiBbJ2RyYWcnLCAnZHJhZ3N0YXJ0JywgJ2RyYWdzdG9wJ10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcmFnZ2FibGUub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZERyb3BwYWJsZSAmJiBbJ2Ryb3AnLCAnZHJvcG92ZXInLCAnZHJvcG91dCddLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRkRHJvcHBhYmxlLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGRSZXNpemFibGUgJiYgWydyZXNpemVzdGFydCcsICdyZXNpemUnLCAncmVzaXplc3RvcCddLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRkRHJhZ2dhYmxlICYmIFsnZHJhZycsICdkcmFnc3RhcnQnLCAnZHJhZ3N0b3AnXS5pbmRleE9mKGV2ZW50TmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS5vZmYoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRkRHJvcHBhYmxlICYmIFsnZHJvcCcsICdkcm9wb3ZlcicsICdkcm9wb3V0J10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZFJlc2l6YWJsZSAmJiBbJ3Jlc2l6ZXN0YXJ0JywgJ3Jlc2l6ZScsICdyZXNpemVzdG9wJ10uaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGRSZXNpemFibGUub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldHVwRHJhZ2dhYmxlKG9wdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRkRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRkRHJhZ2dhYmxlID0gbmV3IERERHJhZ2dhYmxlKHRoaXMuZWwsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS51cGRhdGVPcHRpb24ob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFuRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5kZERyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kZERyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZERyYWdnYWJsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0dXBSZXNpemFibGUob3B0cykge1xuICAgICAgICBpZiAoIXRoaXMuZGRSZXNpemFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGRSZXNpemFibGUgPSBuZXcgRERSZXNpemFibGUodGhpcy5lbCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLnVwZGF0ZU9wdGlvbihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2xlYW5SZXNpemFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRkUmVzaXphYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRkUmVzaXphYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRkUmVzaXphYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXR1cERyb3BwYWJsZShvcHRzKSB7XG4gICAgICAgIGlmICghdGhpcy5kZERyb3BwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kZERyb3BwYWJsZSA9IG5ldyBERERyb3BwYWJsZSh0aGlzLmVsLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUudXBkYXRlT3B0aW9uKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhbkRyb3BwYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGREcm9wcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGREcm9wcGFibGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGREcm9wcGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtZWxlbWVudC5qcy5tYXAiXSwibmFtZXMiOlsiRERSZXNpemFibGUiLCJERERyYWdnYWJsZSIsIkRERHJvcHBhYmxlIiwiRERFbGVtZW50IiwiaW5pdCIsImVsIiwiZGRFbGVtZW50IiwiY29uc3RydWN0b3IiLCJvbiIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwiZGREcmFnZ2FibGUiLCJpbmRleE9mIiwiZGREcm9wcGFibGUiLCJkZFJlc2l6YWJsZSIsIm9mZiIsInNldHVwRHJhZ2dhYmxlIiwib3B0cyIsInVwZGF0ZU9wdGlvbiIsImNsZWFuRHJhZ2dhYmxlIiwiZGVzdHJveSIsInNldHVwUmVzaXphYmxlIiwiY2xlYW5SZXNpemFibGUiLCJzZXR1cERyb3BwYWJsZSIsImNsZWFuRHJvcHBhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-element.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-gridstack.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-gridstack.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDGridStack: () => (/* binding */ DDGridStack)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-element */ \"./node_modules/gridstack/dist/dd-element.js\");\n/**\n * dd-gridstack.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n\n\n// let count = 0; // TEST\n/**\n * HTML Native Mouse and Touch Events Drag and Drop functionality.\n */ class DDGridStack {\n    resizable(el, opts, key, value) {\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\n            } else if (opts === \"destroy\") {\n                dEl.ddResizable && dEl.cleanResizable();\n            } else if (opts === \"option\") {\n                dEl.setupResizable({\n                    [key]: value\n                });\n            } else {\n                const grid = dEl.el.gridstackNode.grid;\n                let handles = dEl.el.getAttribute(\"gs-resize-handles\") ? dEl.el.getAttribute(\"gs-resize-handles\") : grid.opts.resizable.handles;\n                let autoHide = !grid.opts.alwaysShowResizeHandle;\n                dEl.setupResizable({\n                    ...grid.opts.resizable,\n                    ...{\n                        handles,\n                        autoHide\n                    },\n                    ...{\n                        start: opts.start,\n                        stop: opts.stop,\n                        resize: opts.resize\n                    }\n                });\n            }\n        });\n        return this;\n    }\n    draggable(el, opts, key, value) {\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\n            } else if (opts === \"destroy\") {\n                dEl.ddDraggable && dEl.cleanDraggable();\n            } else if (opts === \"option\") {\n                dEl.setupDraggable({\n                    [key]: value\n                });\n            } else {\n                const grid = dEl.el.gridstackNode.grid;\n                dEl.setupDraggable({\n                    ...grid.opts.draggable,\n                    ...{\n                        // containment: (grid.parentGridItem && !grid.opts.dragOut) ? grid.el.parentElement : (grid.opts.draggable.containment || null),\n                        start: opts.start,\n                        stop: opts.stop,\n                        drag: opts.drag\n                    }\n                });\n            }\n        });\n        return this;\n    }\n    dragIn(el, opts) {\n        this._getDDElements(el).forEach((dEl)=>dEl.setupDraggable(opts));\n        return this;\n    }\n    droppable(el, opts, key, value) {\n        if (typeof opts.accept === \"function\" && !opts._accept) {\n            opts._accept = opts.accept;\n            opts.accept = (el)=>opts._accept(el);\n        }\n        this._getDDElements(el).forEach((dEl)=>{\n            if (opts === \"disable\" || opts === \"enable\") {\n                dEl.ddDroppable && dEl.ddDroppable[opts]();\n            } else if (opts === \"destroy\") {\n                if (dEl.ddDroppable) {\n                    dEl.cleanDroppable();\n                }\n            } else if (opts === \"option\") {\n                dEl.setupDroppable({\n                    [key]: value\n                });\n            } else {\n                dEl.setupDroppable(opts);\n            }\n        });\n        return this;\n    }\n    /** true if element is droppable */ isDroppable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);\n    }\n    /** true if element is draggable */ isDraggable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);\n    }\n    /** true if element is draggable */ isResizable(el) {\n        return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);\n    }\n    on(el, name, callback) {\n        this._getDDElements(el).forEach((dEl)=>dEl.on(name, (event)=>{\n                callback(event, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.el : event.target, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.helper : null);\n            }));\n        return this;\n    }\n    off(el, name) {\n        this._getDDElements(el).forEach((dEl)=>dEl.off(name));\n        return this;\n    }\n    /** @internal returns a list of DD elements, creating them on the fly by default */ _getDDElements(els, create = true) {\n        let hosts = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.getElements(els);\n        if (!hosts.length) return [];\n        let list = hosts.map((e)=>e.ddElement || (create ? _dd_element__WEBPACK_IMPORTED_MODULE_2__.DDElement.init(e) : null));\n        if (!create) {\n            list.filter((d)=>d);\n        } // remove nulls\n        return list;\n    }\n} //# sourceMappingURL=dd-gridstack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtZ3JpZHN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDK0I7QUFDUztBQUNBO0FBQ3pDLHlCQUF5QjtBQUN6Qjs7Q0FFQyxHQUNNLE1BQU1HO0lBQ1RDLFVBQVVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUM1QixJQUFJLENBQUNDLGNBQWMsQ0FBQ0osSUFBSUssT0FBTyxDQUFDQyxDQUFBQTtZQUM1QixJQUFJTCxTQUFTLGFBQWFBLFNBQVMsVUFBVTtnQkFDekNLLElBQUlDLFdBQVcsSUFBSUQsSUFBSUMsV0FBVyxDQUFDTixLQUFLLElBQUksOERBQThEO1lBQzlHLE9BQ0ssSUFBSUEsU0FBUyxXQUFXO2dCQUN6QkssSUFBSUMsV0FBVyxJQUFJRCxJQUFJRSxjQUFjO1lBQ3pDLE9BQ0ssSUFBSVAsU0FBUyxVQUFVO2dCQUN4QkssSUFBSUcsY0FBYyxDQUFDO29CQUFFLENBQUNQLElBQUksRUFBRUM7Z0JBQU07WUFDdEMsT0FDSztnQkFDRCxNQUFNTyxPQUFPSixJQUFJTixFQUFFLENBQUNXLGFBQWEsQ0FBQ0QsSUFBSTtnQkFDdEMsSUFBSUUsVUFBVU4sSUFBSU4sRUFBRSxDQUFDYSxZQUFZLENBQUMsdUJBQXVCUCxJQUFJTixFQUFFLENBQUNhLFlBQVksQ0FBQyx1QkFBdUJILEtBQUtULElBQUksQ0FBQ0YsU0FBUyxDQUFDYSxPQUFPO2dCQUMvSCxJQUFJRSxXQUFXLENBQUNKLEtBQUtULElBQUksQ0FBQ2Msc0JBQXNCO2dCQUNoRFQsSUFBSUcsY0FBYyxDQUFDO29CQUNmLEdBQUdDLEtBQUtULElBQUksQ0FBQ0YsU0FBUztvQkFDdEIsR0FBRzt3QkFBRWE7d0JBQVNFO29CQUFTLENBQUM7b0JBQ3hCLEdBQUc7d0JBQ0NFLE9BQU9mLEtBQUtlLEtBQUs7d0JBQ2pCQyxNQUFNaEIsS0FBS2dCLElBQUk7d0JBQ2ZDLFFBQVFqQixLQUFL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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1ncmlkc3RhY2suanM/NjQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRkLWdyaWRzdGFjay50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRERNYW5hZ2VyIH0gZnJvbSAnLi9kZC1tYW5hZ2VyJztcbmltcG9ydCB7IERERWxlbWVudCB9IGZyb20gJy4vZGQtZWxlbWVudCc7XG4vLyBsZXQgY291bnQgPSAwOyAvLyBURVNUXG4vKipcbiAqIEhUTUwgTmF0aXZlIE1vdXNlIGFuZCBUb3VjaCBFdmVudHMgRHJhZyBhbmQgRHJvcCBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgRERHcmlkU3RhY2sge1xuICAgIHJlc2l6YWJsZShlbCwgb3B0cywga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9nZXREREVsZW1lbnRzKGVsKS5mb3JFYWNoKGRFbCA9PiB7XG4gICAgICAgICAgICBpZiAob3B0cyA9PT0gJ2Rpc2FibGUnIHx8IG9wdHMgPT09ICdlbmFibGUnKSB7XG4gICAgICAgICAgICAgICAgZEVsLmRkUmVzaXphYmxlICYmIGRFbC5kZFJlc2l6YWJsZVtvcHRzXSgpOyAvLyBjYW4ndCBjcmVhdGUgREQgYXMgaXQgcmVxdWlyZXMgb3B0aW9ucyBmb3Igc2V0dXBSZXNpemFibGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgICAgICAgICAgICAgZEVsLmRkUmVzaXphYmxlICYmIGRFbC5jbGVhblJlc2l6YWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBSZXNpemFibGUoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkID0gZEVsLmVsLmdyaWRzdGFja05vZGUuZ3JpZDtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlcyA9IGRFbC5lbC5nZXRBdHRyaWJ1dGUoJ2dzLXJlc2l6ZS1oYW5kbGVzJykgPyBkRWwuZWwuZ2V0QXR0cmlidXRlKCdncy1yZXNpemUtaGFuZGxlcycpIDogZ3JpZC5vcHRzLnJlc2l6YWJsZS5oYW5kbGVzO1xuICAgICAgICAgICAgICAgIGxldCBhdXRvSGlkZSA9ICFncmlkLm9wdHMuYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZTtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBSZXNpemFibGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5ncmlkLm9wdHMucmVzaXphYmxlLFxuICAgICAgICAgICAgICAgICAgICAuLi57IGhhbmRsZXMsIGF1dG9IaWRlIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvcHRzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcDogb3B0cy5zdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRzLnJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhZ2dhYmxlKGVsLCBvcHRzLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSAnZGlzYWJsZScgfHwgb3B0cyA9PT0gJ2VuYWJsZScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcmFnZ2FibGUgJiYgZEVsLmRkRHJhZ2dhYmxlW29wdHNdKCk7IC8vIGNhbid0IGNyZWF0ZSBERCBhcyBpdCByZXF1aXJlcyBvcHRpb25zIGZvciBzZXR1cERyYWdnYWJsZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcmFnZ2FibGUgJiYgZEVsLmNsZWFuRHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgIGRFbC5zZXR1cERyYWdnYWJsZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWQgPSBkRWwuZWwuZ3JpZHN0YWNrTm9kZS5ncmlkO1xuICAgICAgICAgICAgICAgIGRFbC5zZXR1cERyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdyaWQub3B0cy5kcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5tZW50OiAoZ3JpZC5wYXJlbnRHcmlkSXRlbSAmJiAhZ3JpZC5vcHRzLmRyYWdPdXQpID8gZ3JpZC5lbC5wYXJlbnRFbGVtZW50IDogKGdyaWQub3B0cy5kcmFnZ2FibGUuY29udGFpbm1lbnQgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogb3B0cy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IG9wdHMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWc6IG9wdHMuZHJhZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHJhZ0luKGVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5zZXR1cERyYWdnYWJsZShvcHRzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkcm9wcGFibGUoZWwsIG9wdHMsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmFjY2VwdCA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3B0cy5fYWNjZXB0KSB7XG4gICAgICAgICAgICBvcHRzLl9hY2NlcHQgPSBvcHRzLmFjY2VwdDtcbiAgICAgICAgICAgIG9wdHMuYWNjZXB0ID0gKGVsKSA9PiBvcHRzLl9hY2NlcHQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSAnZGlzYWJsZScgfHwgb3B0cyA9PT0gJ2VuYWJsZScpIHtcbiAgICAgICAgICAgICAgICBkRWwuZGREcm9wcGFibGUgJiYgZEVsLmRkRHJvcHBhYmxlW29wdHNdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICAgICAgICBpZiAoZEVsLmRkRHJvcHBhYmxlKSB7IC8vIGVycm9yIHRvIGNhbGwgZGVzdHJveSBpZiBub3QgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZEVsLmNsZWFuRHJvcHBhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBEcm9wcGFibGUoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkRWwuc2V0dXBEcm9wcGFibGUob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcm9wcGFibGUgKi9cbiAgICBpc0Ryb3BwYWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZERyb3BwYWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkRHJvcHBhYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcmFnZ2FibGUgKi9cbiAgICBpc0RyYWdnYWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZERyYWdnYWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkRHJhZ2dhYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgZWxlbWVudCBpcyBkcmFnZ2FibGUgKi9cbiAgICBpc1Jlc2l6YWJsZShlbCkge1xuICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuZGRFbGVtZW50ICYmIGVsLmRkRWxlbWVudC5kZFJlc2l6YWJsZSAmJiAhZWwuZGRFbGVtZW50LmRkUmVzaXphYmxlLmRpc2FibGVkKTtcbiAgICB9XG4gICAgb24oZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5vbihuYW1lLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBERE1hbmFnZXIuZHJhZ0VsZW1lbnQgPyBERE1hbmFnZXIuZHJhZ0VsZW1lbnQuZWwgOiBldmVudC50YXJnZXQsIERETWFuYWdlci5kcmFnRWxlbWVudCA/IERETWFuYWdlci5kcmFnRWxlbWVudC5oZWxwZXIgOiBudWxsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGVsLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuX2dldERERWxlbWVudHMoZWwpLmZvckVhY2goZEVsID0+IGRFbC5vZmYobmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCByZXR1cm5zIGEgbGlzdCBvZiBERCBlbGVtZW50cywgY3JlYXRpbmcgdGhlbSBvbiB0aGUgZmx5IGJ5IGRlZmF1bHQgKi9cbiAgICBfZ2V0RERFbGVtZW50cyhlbHMsIGNyZWF0ZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGhvc3RzID0gVXRpbHMuZ2V0RWxlbWVudHMoZWxzKTtcbiAgICAgICAgaWYgKCFob3N0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBsaXN0ID0gaG9zdHMubWFwKGUgPT4gZS5kZEVsZW1lbnQgfHwgKGNyZWF0ZSA/IERERWxlbWVudC5pbml0KGUpIDogbnVsbCkpO1xuICAgICAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICAgICAgbGlzdC5maWx0ZXIoZCA9PiBkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgbnVsbHNcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtZ3JpZHN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJVdGlscyIsIkRETWFuYWdlciIsIkRERWxlbWVudCIsIkRER3JpZFN0YWNrIiwicmVzaXphYmxlIiwiZWwiLCJvcHRzIiwia2V5IiwidmFsdWUiLCJfZ2V0RERFbGVtZW50cyIsImZvckVhY2giLCJkRWwiLCJkZFJlc2l6YWJsZSIsImNsZWFuUmVzaXphYmxlIiwic2V0dXBSZXNpemFibGUiLCJncmlkIiwiZ3JpZHN0YWNrTm9kZSIsImhhbmRsZXMiLCJnZXRBdHRyaWJ1dGUiLCJhdXRvSGlkZSIsImFsd2F5c1Nob3dSZXNpemVIYW5kbGUiLCJzdGFydCIsInN0b3AiLCJyZXNpemUiLCJkcmFnZ2FibGUiLCJkZERyYWdnYWJsZSIsImNsZWFuRHJhZ2dhYmxlIiwic2V0dXBEcmFnZ2FibGUiLCJkcmFnIiwiZHJhZ0luIiwiZHJvcHBhYmxlIiwiYWNjZXB0IiwiX2FjY2VwdCIsImRkRHJvcHBhYmxlIiwiY2xlYW5Ecm9wcGFibGUiLCJzZXR1cERyb3BwYWJsZSIsImlzRHJvcHBhYmxlIiwiZGRFbGVtZW50IiwiZGlzYWJsZWQiLCJpc0RyYWdnYWJsZSIsImlzUmVzaXphYmxlIiwib24iLCJuYW1lIiwiY2FsbGJhY2siLCJldmVudCIsImRyYWdFbGVtZW50IiwidGFyZ2V0IiwiaGVscGVyIiwib2ZmIiwiZWxzIiwiY3JlYXRlIiwiaG9zdHMiLCJnZXRFbGVtZW50cyIsImxlbmd0aCIsImxpc3QiLCJtYXAiLCJlIiwiaW5pdCIsImZpbHRlciIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-gridstack.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-manager.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-manager.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDManager: () => (/* binding */ DDManager)\n/* harmony export */ });\n/**\n * dd-manager.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ /**\n * globals that are shared across Drag & Drop instances\n */ class DDManager {\n} //# sourceMappingURL=dd-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBQ0Q7O0NBRUMsR0FDTSxNQUFNQTtBQUNiLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1tYW5hZ2VyLmpzPzVkMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZC1tYW5hZ2VyLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbi8qKlxuICogZ2xvYmFscyB0aGF0IGFyZSBzaGFyZWQgYWNyb3NzIERyYWcgJiBEcm9wIGluc3RhbmNlc1xuICovXG5leHBvcnQgY2xhc3MgRERNYW5hZ2VyIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbIkRETWFuYWdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-manager.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable-handle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable-handle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizableHandle: () => (/* binding */ DDResizableHandle)\n/* harmony export */ });\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-resizable-handle.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \nclass DDResizableHandle {\n    constructor(host, direction, option){\n        /** @internal true after we've moved enough pixels to start a resize */ this.moving = false;\n        this.host = host;\n        this.dir = direction;\n        this.option = option;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseDown = this._mouseDown.bind(this);\n        this._mouseMove = this._mouseMove.bind(this);\n        this._mouseUp = this._mouseUp.bind(this);\n        this._init();\n    }\n    /** @internal */ _init() {\n        const el = document.createElement(\"div\");\n        el.classList.add(\"ui-resizable-handle\");\n        el.classList.add(`${DDResizableHandle.prefix}${this.dir}`);\n        el.style.zIndex = \"100\";\n        el.style.userSelect = \"none\";\n        this.el = el;\n        this.host.appendChild(this.el);\n        this.el.addEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.addEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n            this.el.addEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n        // this.el.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n        }\n        return this;\n    }\n    /** call this when resize handle needs to be removed and cleaned up */ destroy() {\n        if (this.moving) this._mouseUp(this.mouseDownEvent);\n        this.el.removeEventListener(\"mousedown\", this._mouseDown);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.removeEventListener(\"touchstart\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n            this.el.removeEventListener(\"pointerdown\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n        }\n        this.host.removeChild(this.el);\n        delete this.el;\n        delete this.host;\n        return this;\n    }\n    /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */ _mouseDown(e) {\n        this.mouseDownEvent = e;\n        document.addEventListener(\"mousemove\", this._mouseMove, true); // capture, not bubble\n        document.addEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.addEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n            this.el.addEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _mouseMove(e) {\n        let s = this.mouseDownEvent;\n        if (this.moving) {\n            this._triggerEvent(\"move\", e);\n        } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n            // don't start unless we've moved at least 3 pixels\n            this.moving = true;\n            this._triggerEvent(\"start\", this.mouseDownEvent);\n            this._triggerEvent(\"move\", e);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _mouseUp(e) {\n        if (this.moving) {\n            this._triggerEvent(\"stop\", e);\n        }\n        document.removeEventListener(\"mousemove\", this._mouseMove, true);\n        document.removeEventListener(\"mouseup\", this._mouseUp, true);\n        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n            this.el.removeEventListener(\"touchmove\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n            this.el.removeEventListener(\"touchend\", _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n        }\n        delete this.moving;\n        delete this.mouseDownEvent;\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    /** @internal */ _triggerEvent(name, event) {\n        if (this.option[name]) this.option[name](event);\n        return this;\n    }\n}\n/** @internal */ DDResizableHandle.prefix = \"ui-resizable-\";\n //# sourceMappingURL=dd-resizable-handle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtcmVzaXphYmxlLWhhbmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUNrRjtBQUNuRixNQUFNSztJQUNGQyxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxDQUFFO1FBQ2pDLHFFQUFxRSxHQUNyRSxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0ksR0FBRyxHQUFHSDtRQUNYLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLCtHQUErRztRQUMvRyxJQUFJLENBQUNHLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0UsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxDQUFDRixJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLENBQUNHLEtBQUs7SUFDZDtJQUNBLGNBQWMsR0FDZEEsUUFBUTtRQUNKLE1BQU1DLEtBQUtDLFNBQVNDLGFBQWEsQ0FBQztRQUNsQ0YsR0FBR0csU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDakJKLEdBQUdHLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRWhCLGtCQUFrQmlCLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQ1gsR0FBRyxDQUFDLENBQUM7UUFDekRNLEdBQUdNLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO1FBQ2xCUCxHQUFHTSxLQUFLLENBQUNFLFVBQVUsR0FBRztRQUN0QixJQUFJLENBQUNSLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNWLElBQUksQ0FBQ21CLFdBQVcsQ0FBQyxJQUFJLENBQUNULEVBQUU7UUFDN0IsSUFBSSxDQUFDQSxFQUFFLENBQUNVLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDZixVQUFVO1FBQ3JELElBQUlaLDhDQUFPQSxFQUFFO1lBQ1QsSUFBSSxDQUFDaUIsRUFBRSxDQUFDVSxnQkFBZ0IsQ0FBQyxjQUFjdkIsaURBQVVBO1lBQ2pELElBQUksQ0FBQ2EsRUFBRSxDQUFDVSxnQkFBZ0IsQ0FBQyxlQUFlMUIsa0RBQVdBO1FBQ25ELG1GQUFtRjtRQUN2RjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0Esb0VBQW9FLEdBQ3BFMkIsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDbEIsTUFBTSxFQUNYLElBQUksQ0FBQ0ssUUFBUSxDQUFDLElBQUksQ0FBQ2MsY0FBYztRQUNyQyxJQUFJLENBQUNaLEVBQUUsQ0FBQ2EsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUNsQixVQUFVO1FBQ3hELElBQUlaLDhDQUFPQSxFQUFFO1lBQ1QsSUFBSSxDQUFDaUIsRUFBRSxDQUFDYSxtQkFBbUIsQ0FBQyxjQUFjMUIsaURBQVVBO1lBQ3BELElBQUksQ0FBQ2EsRUFBRSxDQUFDYSxtQkFBbUIsQ0FBQyxlQUFlN0Isa0RBQVdBO1FBQzFEO1FBQ0EsSUFBSSxDQUFDTSxJQUFJLENBQUN3QixXQUFXLENBQUMsSUFBSSxDQUFDZCxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDQSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUNWLElBQUk7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxzSUFBc0ksR0FDdElLLFdBQVdvQixDQUFDLEVBQUU7UUFDVixJQUFJLENBQUNILGNBQWMsR0FBR0c7UUFDdEJkLFNBQVNTLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDYixVQUFVLEVBQUUsT0FBTyxzQkFBc0I7UUFDckZJLFNBQVNTLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDWixRQUFRLEVBQUU7UUFDcEQsSUFBSWYsOENBQU9BLEVBQUU7WUFDVCxJQUFJLENBQUNpQixFQUFFLENBQUNVLGdCQUFnQixDQUFDLGFBQWF4QixnREFBU0E7WUFDL0MsSUFBSSxDQUFDYyxFQUFFLENBQUNVLGdCQUFnQixDQUFDLFlBQVl6QiwrQ0FBUUE7UUFDakQ7UUFDQThCLEVBQUVDLGVBQWU7UUFDakJELEVBQUVFLGNBQWM7SUFDcEI7SUFDQSxjQUFjLEdBQ2RwQixXQUFXa0IsQ0FBQyxFQUFFO1FBQ1YsSUFBSUcsSUFBSSxJQUFJLENBQUNOLGNBQWM7UUFDM0IsSUFBSSxJQUFJLENBQUNuQixNQUFNLEVBQUU7WUFDYixJQUFJLENBQUMwQixhQUFhLENBQUMsUUFBUUo7UUFDL0IsT0FDSyxJQUFJSyxLQUFLQyxHQUFHLENBQUNOLEVBQUVPLENBQUMsR0FBR0osRUFBRUksQ0FBQyxJQUFJRixLQUFLQyxHQUFHLENBQUNOLEVBQUVRLENBQUMsR0FBR0wsRUFBRUssQ0FBQyxJQUFJLEdBQUc7WUFDcEQsbURBQW1EO1lBQ25ELElBQUksQ0FBQzlCLE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQzBCLGFBQWEsQ0FBQyxTQUFTLElBQUksQ0FBQ1AsY0FBYztZQUMvQyxJQUFJLENBQUNPLGFBQWEsQ0FBQyxRQUFRSjtRQUMvQjtRQUNBQSxFQUFFQyxlQUFlO1FBQ2pCRCxFQUFFRSxjQUFjO0lBQ3BCO0lBQ0EsY0FBYyxHQUNkbkIsU0FBU2lCLENBQUMsRUFBRTtRQUNSLElBQUksSUFBSSxDQUFDdEIsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDMEIsYUFBYSxDQUFDLFFBQVFKO1FBQy9CO1FBQ0FkLFNBQVNZLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDaEIsVUFBVSxFQUFFO1FBQzNESSxTQUFTWSxtQkFBbUIsQ0FBQyxXQUFXLElBQUksQ0FBQ2YsUUFBUSxFQUFFO1FBQ3ZELElBQUlmLDhDQUFPQSxFQUFFO1lBQ1QsSUFBSSxDQUFDaUIsRUFBRSxDQUFDYSxtQkFBbUIsQ0FBQyxhQUFhM0IsZ0RBQVNBO1lBQ2xELElBQUksQ0FBQ2MsRUFBRSxDQUFDYSxtQkFBbUIsQ0FBQyxZQUFZNUIsK0NBQVFBO1FBQ3BEO1FBQ0EsT0FBTyxJQUFJLENBQUNRLE1BQU07UUFDbEIsT0FBTyxJQUFJLENBQUNtQixjQUFjO1FBQzFCRyxFQUFFQyxlQUFlO1FBQ2pCRCxFQUFFRSxjQUFjO0lBQ3BCO0lBQ0EsY0FBYyxHQUNkRSxjQUFjSyxJQUFJLEVBQUVDLEtBQUssRUFBRTtRQUN2QixJQUFJLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ2dDLEtBQUssRUFDakIsSUFBSSxDQUFDaEMsTUFBTSxDQUFDZ0MsS0FBSyxDQUFDQztRQUN0QixPQUFPLElBQUk7SUFDZjtBQUNKO0FBQ0EsY0FBYyxHQUNkckMsa0JBQWtCaUIsTUFBTSxHQUFHO0FBQ0UsQ0FDN0IsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC1yZXNpemFibGUtaGFuZGxlLmpzPzkxNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZC1yZXNpemFibGUtaGFuZGxlLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEtMjAyMiBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgaXNUb3VjaCwgcG9pbnRlcmRvd24sIHRvdWNoZW5kLCB0b3VjaG1vdmUsIHRvdWNoc3RhcnQgfSBmcm9tICcuL2RkLXRvdWNoJztcbmNsYXNzIEREUmVzaXphYmxlSGFuZGxlIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCBkaXJlY3Rpb24sIG9wdGlvbikge1xuICAgICAgICAvKiogQGludGVybmFsIHRydWUgYWZ0ZXIgd2UndmUgbW92ZWQgZW5vdWdoIHBpeGVscyB0byBzdGFydCBhIHJlc2l6ZSAqL1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmRpciA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRpb247XG4gICAgICAgIC8vIGNyZWF0ZSB2YXIgZXZlbnQgYmluZGluZyBzbyB3ZSBjYW4gZWFzaWx5IHJlbW92ZSBhbmQgc3RpbGwgbG9vayBsaWtlIFRTIG1ldGhvZHMgKHVubGlrZSBhbm9ueW1vdXMgZnVuY3Rpb25zKVxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSB0aGlzLl9tb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2VNb3ZlID0gdGhpcy5fbW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNlVXAgPSB0aGlzLl9tb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pbml0KCkge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd1aS1yZXNpemFibGUtaGFuZGxlJyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7RERSZXNpemFibGVIYW5kbGUucHJlZml4fSR7dGhpcy5kaXJ9YCk7XG4gICAgICAgIGVsLnN0eWxlLnpJbmRleCA9ICcxMDAnO1xuICAgICAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuaG9zdC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd24pO1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlcmRvd24pO1xuICAgICAgICAgICAgLy8gdGhpcy5lbC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJzsgLy8gbm90IG5lZWRlZCB1bmxpa2UgcG9pbnRlcmRvd24gZG9jIGNvbW1lbnRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIGNhbGwgdGhpcyB3aGVuIHJlc2l6ZSBoYW5kbGUgbmVlZHMgdG8gYmUgcmVtb3ZlZCBhbmQgY2xlYW5lZCB1cCAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmluZylcbiAgICAgICAgICAgIHRoaXMuX21vdXNlVXAodGhpcy5tb3VzZURvd25FdmVudCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duKTtcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJkb3duKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3QucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsO1xuICAgICAgICBkZWxldGUgdGhpcy5ob3N0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsZWQgb24gbW91c2UgZG93biBvbiB1czogY2FwdHVyZSBtb3ZlIG9uIHRoZSBlbnRpcmUgZG9jdW1lbnQgKG1vdXNlIG1pZ2h0IG5vdCBzdGF5IG9uIHVzKSB1bnRpbCB3ZSByZWxlYXNlIHRoZSBtb3VzZSAqL1xuICAgIF9tb3VzZURvd24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlRG93bkV2ZW50ID0gZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2VNb3ZlLCB0cnVlKTsgLy8gY2FwdHVyZSwgbm90IGJ1YmJsZVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tb3VzZU1vdmUoZSkge1xuICAgICAgICBsZXQgcyA9IHRoaXMubW91c2VEb3duRXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdtb3ZlJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoZS54IC0gcy54KSArIE1hdGguYWJzKGUueSAtIHMueSkgPiAyKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBzdGFydCB1bmxlc3Mgd2UndmUgbW92ZWQgYXQgbGVhc3QgMyBwaXhlbHNcbiAgICAgICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgnc3RhcnQnLCB0aGlzLm1vdXNlRG93bkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgnbW92ZScsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tb3VzZVVwKGUpIHtcbiAgICAgICAgaWYgKHRoaXMubW92aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ3N0b3AnLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZU1vdmUsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1vdmluZztcbiAgICAgICAgZGVsZXRlIHRoaXMubW91c2VEb3duRXZlbnQ7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyRXZlbnQobmFtZSwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uW25hbWVdKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25bbmFtZV0oZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5ERFJlc2l6YWJsZUhhbmRsZS5wcmVmaXggPSAndWktcmVzaXphYmxlLSc7XG5leHBvcnQgeyBERFJlc2l6YWJsZUhhbmRsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGQtcmVzaXphYmxlLWhhbmRsZS5qcy5tYXAiXSwibmFtZXMiOlsiaXNUb3VjaCIsInBvaW50ZXJkb3duIiwidG91Y2hlbmQiLCJ0b3VjaG1vdmUiLCJ0b3VjaHN0YXJ0IiwiRERSZXNpemFibGVIYW5kbGUiLCJjb25zdHJ1Y3RvciIsImhvc3QiLCJkaXJlY3Rpb24iLCJvcHRpb24iLCJtb3ZpbmciLCJkaXIiLCJfbW91c2VEb3duIiwiYmluZCIsIl9tb3VzZU1vdmUiLCJfbW91c2VVcCIsIl9pbml0IiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJwcmVmaXgiLCJzdHlsZSIsInpJbmRleCIsInVzZXJTZWxlY3QiLCJhcHBlbmRDaGlsZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwibW91c2VEb3duRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJlIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJzIiwiX3RyaWdnZXJFdmVudCIsIk1hdGgiLCJhYnMiLCJ4IiwieSIsIm5hbWUiLCJldmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-resizable-handle.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizable: () => (/* binding */ DDResizable)\n/* harmony export */ });\n/* harmony import */ var _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable-handle */ \"./node_modules/gridstack/dist/dd-resizable-handle.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * dd-resizable.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n\n\n\nclass DDResizable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n    constructor(el, opts = {}){\n        super();\n        /** @internal */ this._ui = ()=>{\n            const containmentEl = this.el.parentElement;\n            const containmentRect = containmentEl.getBoundingClientRect();\n            const newRect = {\n                width: this.originalRect.width,\n                height: this.originalRect.height + this.scrolled,\n                left: this.originalRect.left,\n                top: this.originalRect.top - this.scrolled\n            };\n            const rect = this.temporalRect || newRect;\n            return {\n                position: {\n                    left: rect.left - containmentRect.left,\n                    top: rect.top - containmentRect.top\n                },\n                size: {\n                    width: rect.width,\n                    height: rect.height\n                }\n            };\n        };\n        this.el = el;\n        this.option = opts;\n        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n        this._mouseOver = this._mouseOver.bind(this);\n        this._mouseOut = this._mouseOut.bind(this);\n        this.enable();\n        this._setupAutoHide(this.option.autoHide);\n        this._setupHandlers();\n    }\n    on(event, callback) {\n        super.on(event, callback);\n    }\n    off(event) {\n        super.off(event);\n    }\n    enable() {\n        super.enable();\n        this.el.classList.remove(\"ui-resizable-disabled\");\n        this._setupAutoHide(this.option.autoHide);\n    }\n    disable() {\n        super.disable();\n        this.el.classList.add(\"ui-resizable-disabled\");\n        this._setupAutoHide(false);\n    }\n    destroy() {\n        this._removeHandlers();\n        this._setupAutoHide(false);\n        delete this.el;\n        super.destroy();\n    }\n    updateOption(opts) {\n        let updateHandles = opts.handles && opts.handles !== this.option.handles;\n        let updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;\n        Object.keys(opts).forEach((key)=>this.option[key] = opts[key]);\n        if (updateHandles) {\n            this._removeHandlers();\n            this._setupHandlers();\n        }\n        if (updateAutoHide) {\n            this._setupAutoHide(this.option.autoHide);\n        }\n        return this;\n    }\n    /** @internal turns auto hide on/off */ _setupAutoHide(auto) {\n        if (auto) {\n            this.el.classList.add(\"ui-resizable-autohide\");\n            // use mouseover and not mouseenter to get better performance and track for nested cases\n            this.el.addEventListener(\"mouseover\", this._mouseOver);\n            this.el.addEventListener(\"mouseout\", this._mouseOut);\n        } else {\n            this.el.classList.remove(\"ui-resizable-autohide\");\n            this.el.removeEventListener(\"mouseover\", this._mouseOver);\n            this.el.removeEventListener(\"mouseout\", this._mouseOut);\n            if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement === this) {\n                delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n            }\n        }\n        return this;\n    }\n    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mouseOver(e) {\n        // console.log(`${count++} pre-enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        // already over a child, ignore. Ideally we just call e.stopPropagation() but see https://github.com/gridstack/gridstack.js/issues/2018\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement || _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.dragElement) return;\n        _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement = this;\n        // console.log(`${count++} enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        this.el.classList.remove(\"ui-resizable-autohide\");\n    }\n    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mouseOut(e) {\n        // console.log(`${count++} pre-leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement !== this) return;\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n        // console.log(`${count++} leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n        this.el.classList.add(\"ui-resizable-autohide\");\n    }\n    /** @internal */ _setupHandlers() {\n        let handlerDirection = this.option.handles || \"e,s,se\";\n        if (handlerDirection === \"all\") {\n            handlerDirection = \"n,e,s,w,se,sw,ne,nw\";\n        }\n        this.handlers = handlerDirection.split(\",\").map((dir)=>dir.trim()).map((dir)=>new _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__.DDResizableHandle(this.el, dir, {\n                start: (event)=>{\n                    this._resizeStart(event);\n                },\n                stop: (event)=>{\n                    this._resizeStop(event);\n                },\n                move: (event)=>{\n                    this._resizing(event, dir);\n                }\n            }));\n        return this;\n    }\n    /** @internal */ _resizeStart(event) {\n        this.originalRect = this.el.getBoundingClientRect();\n        this.scrollEl = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getScrollElement(this.el);\n        this.scrollY = this.scrollEl.scrollTop;\n        this.scrolled = 0;\n        this.startEvent = event;\n        this._setupHelper();\n        this._applyChange();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resizestart\",\n            target: this.el\n        });\n        if (this.option.start) {\n            this.option.start(ev, this._ui());\n        }\n        this.el.classList.add(\"ui-resizable-resizing\");\n        this.triggerEvent(\"resizestart\", ev);\n        return this;\n    }\n    /** @internal */ _resizing(event, dir) {\n        this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n        this.temporalRect = this._getChange(event, dir);\n        this._applyChange();\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resize\",\n            target: this.el\n        });\n        if (this.option.resize) {\n            this.option.resize(ev, this._ui());\n        }\n        this.triggerEvent(\"resize\", ev);\n        return this;\n    }\n    /** @internal */ _resizeStop(event) {\n        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n            type: \"resizestop\",\n            target: this.el\n        });\n        if (this.option.stop) {\n            this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n        }\n        this.el.classList.remove(\"ui-resizable-resizing\");\n        this.triggerEvent(\"resizestop\", ev);\n        this._cleanHelper();\n        delete this.startEvent;\n        delete this.originalRect;\n        delete this.temporalRect;\n        delete this.scrollY;\n        delete this.scrolled;\n        return this;\n    }\n    /** @internal */ _setupHelper() {\n        this.elOriginStyleVal = DDResizable._originStyleProp.map((prop)=>this.el.style[prop]);\n        this.parentOriginStylePosition = this.el.parentElement.style.position;\n        if (getComputedStyle(this.el.parentElement).position.match(/static/)) {\n            this.el.parentElement.style.position = \"relative\";\n        }\n        this.el.style.position = \"absolute\";\n        this.el.style.opacity = \"0.8\";\n        return this;\n    }\n    /** @internal */ _cleanHelper() {\n        DDResizable._originStyleProp.forEach((prop, i)=>{\n            this.el.style[prop] = this.elOriginStyleVal[i] || null;\n        });\n        this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n        return this;\n    }\n    /** @internal */ _getChange(event, dir) {\n        const oEvent = this.startEvent;\n        const newRect = {\n            width: this.originalRect.width,\n            height: this.originalRect.height + this.scrolled,\n            left: this.originalRect.left,\n            top: this.originalRect.top - this.scrolled\n        };\n        const offsetX = event.clientX - oEvent.clientX;\n        const offsetY = event.clientY - oEvent.clientY;\n        if (dir.indexOf(\"e\") > -1) {\n            newRect.width += offsetX;\n        } else if (dir.indexOf(\"w\") > -1) {\n            newRect.width -= offsetX;\n            newRect.left += offsetX;\n        }\n        if (dir.indexOf(\"s\") > -1) {\n            newRect.height += offsetY;\n        } else if (dir.indexOf(\"n\") > -1) {\n            newRect.height -= offsetY;\n            newRect.top += offsetY;\n        }\n        const constrain = this._constrainSize(newRect.width, newRect.height);\n        if (Math.round(newRect.width) !== Math.round(constrain.width)) {\n            if (dir.indexOf(\"w\") > -1) {\n                newRect.left += newRect.width - constrain.width;\n            }\n            newRect.width = constrain.width;\n        }\n        if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n            if (dir.indexOf(\"n\") > -1) {\n                newRect.top += newRect.height - constrain.height;\n            }\n            newRect.height = constrain.height;\n        }\n        return newRect;\n    }\n    /** @internal constrain the size to the set min/max values */ _constrainSize(oWidth, oHeight) {\n        const maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;\n        const minWidth = this.option.minWidth || oWidth;\n        const maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;\n        const minHeight = this.option.minHeight || oHeight;\n        const width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n        const height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n        return {\n            width,\n            height\n        };\n    }\n    /** @internal */ _applyChange() {\n        let containmentRect = {\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n        };\n        if (this.el.style.position === \"absolute\") {\n            const containmentEl = this.el.parentElement;\n            const { left, top } = containmentEl.getBoundingClientRect();\n            containmentRect = {\n                left,\n                top,\n                width: 0,\n                height: 0\n            };\n        }\n        if (!this.temporalRect) return this;\n        Object.keys(this.temporalRect).forEach((key)=>{\n            const value = this.temporalRect[key];\n            this.el.style[key] = value - containmentRect[key] + \"px\";\n        });\n        return this;\n    }\n    /** @internal */ _removeHandlers() {\n        this.handlers.forEach((handle)=>handle.destroy());\n        delete this.handlers;\n        return this;\n    }\n}\n/** @internal */ DDResizable._originStyleProp = [\n    \"width\",\n    \"height\",\n    \"position\",\n    \"left\",\n    \"top\",\n    \"opacity\",\n    \"zIndex\"\n];\n //# sourceMappingURL=dd-resizable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtcmVzaXphYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3lEO0FBQ1Q7QUFDakI7QUFDUztBQUN6QyxNQUFNSSxvQkFBb0JILDBEQUFlQTtJQUNyQ0ksWUFBWUMsRUFBRSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ3ZCLEtBQUs7UUFDTCxjQUFjLEdBQ2QsSUFBSSxDQUFDQyxHQUFHLEdBQUc7WUFDUCxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDSCxFQUFFLENBQUNJLGFBQWE7WUFDM0MsTUFBTUMsa0JBQWtCRixjQUFjRyxxQkFBcUI7WUFDM0QsTUFBTUMsVUFBVTtnQkFDWkMsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0QsS0FBSztnQkFDOUJFLFFBQVEsSUFBSSxDQUFDRCxZQUFZLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNDLFFBQVE7Z0JBQ2hEQyxNQUFNLElBQUksQ0FBQ0gsWUFBWSxDQUFDRyxJQUFJO2dCQUM1QkMsS0FBSyxJQUFJLENBQUNKLFlBQVksQ0FBQ0ksR0FBRyxHQUFHLElBQUksQ0FBQ0YsUUFBUTtZQUM5QztZQUNBLE1BQU1HLE9BQU8sSUFBSSxDQUFDQyxZQUFZLElBQUlSO1lBQ2xDLE9BQU87Z0JBQ0hTLFVBQVU7b0JBQ05KLE1BQU1FLEtBQUtGLElBQUksR0FBR1AsZ0JBQWdCTyxJQUFJO29CQUN0Q0MsS0FBS0MsS0FBS0QsR0FBRyxHQUFHUixnQkFBZ0JRLEdBQUc7Z0JBQ3ZDO2dCQUNBSSxNQUFNO29CQUNGVCxPQUFPTSxLQUFLTixLQUFLO29CQUNqQkUsUUFBUUksS0FBS0osTUFBTTtnQkFDdkI7WUFjSjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDa0IsTUFBTSxHQUFHakI7UUFDZCwrR0FBK0c7UUFDL0csSUFBSSxDQUFDa0IsVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDQyxJQUFJLENB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M0MsRUFBRSxDQUFDZ0YsS0FBSyxDQUFDckMsSUFBSSxHQUFHK0QsUUFBUXJHLGVBQWUsQ0FBQ3NDLElBQUksR0FBRztRQUN4RDtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0EsY0FBYyxHQUNkUixrQkFBa0I7UUFDZCxJQUFJLENBQUNnQixRQUFRLENBQUNULE9BQU8sQ0FBQ2lFLENBQUFBLFNBQVVBLE9BQU96RSxPQUFPO1FBQzlDLE9BQU8sSUFBSSxDQUFDaUIsUUFBUTtRQUNwQixPQUFPLElBQUk7SUFDZjtBQUNKO0FBQ0EsY0FBYyxHQUNkckQsWUFBWWdGLGdCQUFnQixHQUFHO0lBQUM7SUFBUztJQUFVO0lBQVk7SUFBUTtJQUFPO0lBQVc7Q0FBUztBQUMzRSxDQUN2Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sdWNpZGl0eS1kM2pzLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L2RkLXJlc2l6YWJsZS5qcz9iNDI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGQtcmVzaXphYmxlLnRzIDkuNC4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEtMjAyMiBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERSZXNpemFibGVIYW5kbGUgfSBmcm9tICcuL2RkLXJlc2l6YWJsZS1oYW5kbGUnO1xuaW1wb3J0IHsgRERCYXNlSW1wbGVtZW50IH0gZnJvbSAnLi9kZC1iYXNlLWltcGwnO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IERETWFuYWdlciB9IGZyb20gJy4vZGQtbWFuYWdlcic7XG5jbGFzcyBERFJlc2l6YWJsZSBleHRlbmRzIEREQmFzZUltcGxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3VpID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbm1lbnRFbCA9IHRoaXMuZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5tZW50UmVjdCA9IGNvbnRhaW5tZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBuZXdSZWN0ID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLm9yaWdpbmFsUmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub3JpZ2luYWxSZWN0LmhlaWdodCArIHRoaXMuc2Nyb2xsZWQsXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5vcmlnaW5hbFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMub3JpZ2luYWxSZWN0LnRvcCAtIHRoaXMuc2Nyb2xsZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy50ZW1wb3JhbFJlY3QgfHwgbmV3UmVjdDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gY29udGFpbm1lbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBjb250YWlubWVudFJlY3QudG9wXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEdyaWRzdGFjayBPTkxZIG5lZWRzIHBvc2l0aW9uIHNldCBhYm92ZS4uLiBrZWVwIGFyb3VuZCBpbiBjYXNlLlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IFt0aGlzLmVsXSwgLy8gVGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGVsZW1lbnQgdG8gYmUgcmVzaXplZFxuICAgICAgICAgICAgICAgIGhlbHBlcjogW10sIC8vIFRPRE86IG5vdCBzdXBwb3J0IHlldCAtIFRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBoZWxwZXIgdGhhdCdzIGJlaW5nIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQ6IFt0aGlzLmVsXSwvLyB3ZSBkb24ndCB3cmFwIGhlcmUsIHNvIHNpbXBsaWZ5IGFzIHRoaXMuZWwgLy9UaGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3JpZ2luYWwgZWxlbWVudCBiZWZvcmUgaXQgaXMgd3JhcHBlZFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zaXRpb246IHsgLy8gVGhlIHBvc2l0aW9uIHJlcHJlc2VudGVkIGFzIHsgbGVmdCwgdG9wIH0gYmVmb3JlIHRoZSByZXNpemFibGUgaXMgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5vcmlnaW5hbFJlY3QubGVmdCAtIGNvbnRhaW5tZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLm9yaWdpbmFsUmVjdC50b3AgLSBjb250YWlubWVudFJlY3QudG9wXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFNpemU6IHsgLy8gVGhlIHNpemUgcmVwcmVzZW50ZWQgYXMgeyB3aWR0aCwgaGVpZ2h0IH0gYmVmb3JlIHRoZSByZXNpemFibGUgaXMgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub3JpZ2luYWxSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9yaWdpbmFsUmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRzO1xuICAgICAgICAvLyBjcmVhdGUgdmFyIGV2ZW50IGJpbmRpbmcgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgYW5kIHN0aWxsIGxvb2sgbGlrZSBUUyBtZXRob2RzICh1bmxpa2UgYW5vbnltb3VzIGZ1bmN0aW9ucylcbiAgICAgICAgdGhpcy5fbW91c2VPdmVyID0gdGhpcy5fbW91c2VPdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNlT3V0ID0gdGhpcy5fbW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBdXRvSGlkZSh0aGlzLm9wdGlvbi5hdXRvSGlkZSk7XG4gICAgICAgIHRoaXMuX3NldHVwSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9mZihldmVudCkge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnQpO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHN1cGVyLmVuYWJsZSgpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLXJlc2l6YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLl9zZXR1cEF1dG9IaWRlKHRoaXMub3B0aW9uLmF1dG9IaWRlKTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLXJlc2l6YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLl9zZXR1cEF1dG9IaWRlKGZhbHNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBdXRvSGlkZShmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbihvcHRzKSB7XG4gICAgICAgIGxldCB1cGRhdGVIYW5kbGVzID0gKG9wdHMuaGFuZGxlcyAmJiBvcHRzLmhhbmRsZXMgIT09IHRoaXMub3B0aW9uLmhhbmRsZXMpO1xuICAgICAgICBsZXQgdXBkYXRlQXV0b0hpZGUgPSAob3B0cy5hdXRvSGlkZSAmJiBvcHRzLmF1dG9IaWRlICE9PSB0aGlzLm9wdGlvbi5hdXRvSGlkZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdHMpLmZvckVhY2goa2V5ID0+IHRoaXMub3B0aW9uW2tleV0gPSBvcHRzW2tleV0pO1xuICAgICAgICBpZiAodXBkYXRlSGFuZGxlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSGFuZGxlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwSGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlQXV0b0hpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwQXV0b0hpZGUodGhpcy5vcHRpb24uYXV0b0hpZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIHR1cm5zIGF1dG8gaGlkZSBvbi9vZmYgKi9cbiAgICBfc2V0dXBBdXRvSGlkZShhdXRvKSB7XG4gICAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3VpLXJlc2l6YWJsZS1hdXRvaGlkZScpO1xuICAgICAgICAgICAgLy8gdXNlIG1vdXNlb3ZlciBhbmQgbm90IG1vdXNlZW50ZXIgdG8gZ2V0IGJldHRlciBwZXJmb3JtYW5jZSBhbmQgdHJhY2sgZm9yIG5lc3RlZCBjYXNlc1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9tb3VzZU92ZXIpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX21vdXNlT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgndWktcmVzaXphYmxlLWF1dG9oaWRlJyk7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuX21vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fbW91c2VPdXQpO1xuICAgICAgICAgICAgaWYgKERETWFuYWdlci5vdmVyUmVzaXplRWxlbWVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBERE1hbmFnZXIub3ZlclJlc2l6ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX21vdXNlT3ZlcihlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IHByZS1lbnRlciAkeyh0aGlzLmVsIGFzIEdyaWRJdGVtSFRNTEVsZW1lbnQpLmdyaWRzdGFja05vZGUuX2lkfWApXG4gICAgICAgIC8vIGFscmVhZHkgb3ZlciBhIGNoaWxkLCBpZ25vcmUuIElkZWFsbHkgd2UganVzdCBjYWxsIGUuc3RvcFByb3BhZ2F0aW9uKCkgYnV0IHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9pc3N1ZXMvMjAxOFxuICAgICAgICBpZiAoRERNYW5hZ2VyLm92ZXJSZXNpemVFbGVtZW50IHx8IERETWFuYWdlci5kcmFnRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgRERNYW5hZ2VyLm92ZXJSZXNpemVFbGVtZW50ID0gdGhpcztcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7Y291bnQrK30gZW50ZXIgJHsodGhpcy5lbCBhcyBHcmlkSXRlbUhUTUxFbGVtZW50KS5ncmlkc3RhY2tOb2RlLl9pZH1gKVxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLXJlc2l6YWJsZS1hdXRvaGlkZScpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9tb3VzZU91dChlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IHByZS1sZWF2ZSAkeyh0aGlzLmVsIGFzIEdyaWRJdGVtSFRNTEVsZW1lbnQpLmdyaWRzdGFja05vZGUuX2lkfWApXG4gICAgICAgIGlmIChERE1hbmFnZXIub3ZlclJlc2l6ZUVsZW1lbnQgIT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBERE1hbmFnZXIub3ZlclJlc2l6ZUVsZW1lbnQ7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2NvdW50Kyt9IGxlYXZlICR7KHRoaXMuZWwgYXMgR3JpZEl0ZW1IVE1MRWxlbWVudCkuZ3JpZHN0YWNrTm9kZS5faWR9YClcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd1aS1yZXNpemFibGUtYXV0b2hpZGUnKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXR1cEhhbmRsZXJzKCkge1xuICAgICAgICBsZXQgaGFuZGxlckRpcmVjdGlvbiA9IHRoaXMub3B0aW9uLmhhbmRsZXMgfHwgJ2UscyxzZSc7XG4gICAgICAgIGlmIChoYW5kbGVyRGlyZWN0aW9uID09PSAnYWxsJykge1xuICAgICAgICAgICAgaGFuZGxlckRpcmVjdGlvbiA9ICduLGUscyx3LHNlLHN3LG5lLG53JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlckRpcmVjdGlvbi5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKGRpciA9PiBkaXIudHJpbSgpKVxuICAgICAgICAgICAgLm1hcChkaXIgPT4gbmV3IEREUmVzaXphYmxlSGFuZGxlKHRoaXMuZWwsIGRpciwge1xuICAgICAgICAgICAgc3RhcnQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZVN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVTdG9wKGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3ZlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemluZyhldmVudCwgZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZXNpemVTdGFydChldmVudCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsRWwgPSBVdGlscy5nZXRTY3JvbGxFbGVtZW50KHRoaXMuZWwpO1xuICAgICAgICB0aGlzLnNjcm9sbFkgPSB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5zY3JvbGxlZCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLl9zZXR1cEhlbHBlcigpO1xuICAgICAgICB0aGlzLl9hcHBseUNoYW5nZSgpO1xuICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChldmVudCwgeyB0eXBlOiAncmVzaXplc3RhcnQnLCB0YXJnZXQ6IHRoaXMuZWwgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24uc3RhcnQoZXYsIHRoaXMuX3VpKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndWktcmVzaXphYmxlLXJlc2l6aW5nJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdyZXNpemVzdGFydCcsIGV2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVzaXppbmcoZXZlbnQsIGRpcikge1xuICAgICAgICB0aGlzLnNjcm9sbGVkID0gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AgLSB0aGlzLnNjcm9sbFk7XG4gICAgICAgIHRoaXMudGVtcG9yYWxSZWN0ID0gdGhpcy5fZ2V0Q2hhbmdlKGV2ZW50LCBkaXIpO1xuICAgICAgICB0aGlzLl9hcHBseUNoYW5nZSgpO1xuICAgICAgICBjb25zdCBldiA9IFV0aWxzLmluaXRFdmVudChldmVudCwgeyB0eXBlOiAncmVzaXplJywgdGFyZ2V0OiB0aGlzLmVsIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24ucmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5yZXNpemUoZXYsIHRoaXMuX3VpKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdyZXNpemUnLCBldik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlc2l6ZVN0b3AoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXYgPSBVdGlscy5pbml0RXZlbnQoZXZlbnQsIHsgdHlwZTogJ3Jlc2l6ZXN0b3AnLCB0YXJnZXQ6IHRoaXMuZWwgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5zdG9wKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5zdG9wKGV2KTsgLy8gTm90ZTogdWkoKSBub3QgdXNlZCBieSBncmlkc3RhY2sgc28gZG9uJ3QgcGFzc1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgndWktcmVzaXphYmxlLXJlc2l6aW5nJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdyZXNpemVzdG9wJywgZXYpO1xuICAgICAgICB0aGlzLl9jbGVhbkhlbHBlcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5zdGFydEV2ZW50O1xuICAgICAgICBkZWxldGUgdGhpcy5vcmlnaW5hbFJlY3Q7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBvcmFsUmVjdDtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2Nyb2xsWTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2Nyb2xsZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldHVwSGVscGVyKCkge1xuICAgICAgICB0aGlzLmVsT3JpZ2luU3R5bGVWYWwgPSBERFJlc2l6YWJsZS5fb3JpZ2luU3R5bGVQcm9wLm1hcChwcm9wID0+IHRoaXMuZWwuc3R5bGVbcHJvcF0pO1xuICAgICAgICB0aGlzLnBhcmVudE9yaWdpblN0eWxlUG9zaXRpb24gPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb247XG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwucGFyZW50RWxlbWVudCkucG9zaXRpb24ubWF0Y2goL3N0YXRpYy8pKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAnMC44JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY2xlYW5IZWxwZXIoKSB7XG4gICAgICAgIEREUmVzaXphYmxlLl9vcmlnaW5TdHlsZVByb3AuZm9yRWFjaCgocHJvcCwgaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wXSA9IHRoaXMuZWxPcmlnaW5TdHlsZVZhbFtpXSB8fCBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wYXJlbnRPcmlnaW5TdHlsZVBvc2l0aW9uIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldENoYW5nZShldmVudCwgZGlyKSB7XG4gICAgICAgIGNvbnN0IG9FdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcbiAgICAgICAgY29uc3QgbmV3UmVjdCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLm9yaWdpbmFsUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcmlnaW5hbFJlY3QuaGVpZ2h0ICsgdGhpcy5zY3JvbGxlZCxcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMub3JpZ2luYWxSZWN0LmxlZnQsXG4gICAgICAgICAgICB0b3A6IHRoaXMub3JpZ2luYWxSZWN0LnRvcCAtIHRoaXMuc2Nyb2xsZWRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmNsaWVudFggLSBvRXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmNsaWVudFkgLSBvRXZlbnQuY2xpZW50WTtcbiAgICAgICAgaWYgKGRpci5pbmRleE9mKCdlJykgPiAtMSkge1xuICAgICAgICAgICAgbmV3UmVjdC53aWR0aCArPSBvZmZzZXRYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpci5pbmRleE9mKCd3JykgPiAtMSkge1xuICAgICAgICAgICAgbmV3UmVjdC53aWR0aCAtPSBvZmZzZXRYO1xuICAgICAgICAgICAgbmV3UmVjdC5sZWZ0ICs9IG9mZnNldFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpci5pbmRleE9mKCdzJykgPiAtMSkge1xuICAgICAgICAgICAgbmV3UmVjdC5oZWlnaHQgKz0gb2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIuaW5kZXhPZignbicpID4gLTEpIHtcbiAgICAgICAgICAgIG5ld1JlY3QuaGVpZ2h0IC09IG9mZnNldFk7XG4gICAgICAgICAgICBuZXdSZWN0LnRvcCArPSBvZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbiA9IHRoaXMuX2NvbnN0cmFpblNpemUobmV3UmVjdC53aWR0aCwgbmV3UmVjdC5oZWlnaHQpO1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChuZXdSZWN0LndpZHRoKSAhPT0gTWF0aC5yb3VuZChjb25zdHJhaW4ud2lkdGgpKSB7IC8vIHJvdW5kIHRvIGlnbm9yZSBzbGlnaHQgcm91bmQtb2ZmIGVycm9yc1xuICAgICAgICAgICAgaWYgKGRpci5pbmRleE9mKCd3JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG5ld1JlY3QubGVmdCArPSBuZXdSZWN0LndpZHRoIC0gY29uc3RyYWluLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmVjdC53aWR0aCA9IGNvbnN0cmFpbi53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5yb3VuZChuZXdSZWN0LmhlaWdodCkgIT09IE1hdGgucm91bmQoY29uc3RyYWluLmhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChkaXIuaW5kZXhPZignbicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdSZWN0LnRvcCArPSBuZXdSZWN0LmhlaWdodCAtIGNvbnN0cmFpbi5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSZWN0LmhlaWdodCA9IGNvbnN0cmFpbi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JlY3Q7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY29uc3RyYWluIHRoZSBzaXplIHRvIHRoZSBzZXQgbWluL21heCB2YWx1ZXMgKi9cbiAgICBfY29uc3RyYWluU2l6ZShvV2lkdGgsIG9IZWlnaHQpIHtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLm9wdGlvbi5tYXhXaWR0aCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSB0aGlzLm9wdGlvbi5taW5XaWR0aCB8fCBvV2lkdGg7XG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMub3B0aW9uLm1heEhlaWdodCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgY29uc3QgbWluSGVpZ2h0ID0gdGhpcy5vcHRpb24ubWluSGVpZ2h0IHx8IG9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIE1hdGgubWF4KG1pbldpZHRoLCBvV2lkdGgpKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0LCBNYXRoLm1heChtaW5IZWlnaHQsIG9IZWlnaHQpKTtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FwcGx5Q2hhbmdlKCkge1xuICAgICAgICBsZXQgY29udGFpbm1lbnRSZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgaWYgKHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5tZW50RWwgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gY29udGFpbm1lbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnRhaW5tZW50UmVjdCA9IHsgbGVmdCwgdG9wLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRlbXBvcmFsUmVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRlbXBvcmFsUmVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRlbXBvcmFsUmVjdFtrZXldO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZVtrZXldID0gdmFsdWUgLSBjb250YWlubWVudFJlY3Rba2V5XSArICdweCc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZW1vdmVIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKGhhbmRsZSA9PiBoYW5kbGUuZGVzdHJveSgpKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbkREUmVzaXphYmxlLl9vcmlnaW5TdHlsZVByb3AgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdwb3NpdGlvbicsICdsZWZ0JywgJ3RvcCcsICdvcGFjaXR5JywgJ3pJbmRleCddO1xuZXhwb3J0IHsgRERSZXNpemFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRkLXJlc2l6YWJsZS5qcy5tYXAiXSwibmFtZXMiOlsiRERSZXNpemFibGVIYW5kbGUiLCJEREJhc2VJbXBsZW1lbnQiLCJVdGlscyIsIkRETWFuYWdlciIsIkREUmVzaXphYmxlIiwiY29uc3RydWN0b3IiLCJlbCIsIm9wdHMiLCJfdWkiLCJjb250YWlubWVudEVsIiwicGFyZW50RWxlbWVudCIsImNvbnRhaW5tZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm5ld1JlY3QiLCJ3aWR0aCIsIm9yaWdpbmFsUmVjdCIsImhlaWdodCIsInNjcm9sbGVkIiwibGVmdCIsInRvcCIsInJlY3QiLCJ0ZW1wb3JhbFJlY3QiLCJwb3NpdGlvbiIsInNpemUiLCJvcHRpb24iLCJfbW91c2VPdmVyIiwiYmluZCIsIl9tb3VzZU91dCIsImVuYWJsZSIsIl9zZXR1cEF1dG9IaWRlIiwiYXV0b0hpZGUiLCJfc2V0dXBIYW5kbGVycyIsIm9uIiwiZXZlbnQiLCJjYWxsYmFjayIsIm9mZiIsImNsYXNzTGlzdCIsInJlbW92ZSIsImRpc2FibGUiLCJhZGQiLCJkZXN0cm95IiwiX3JlbW92ZUhhbmRsZXJzIiwidXBkYXRlT3B0aW9uIiwidXBkYXRlSGFuZGxlcyIsImhhbmRsZXMiLCJ1cGRhdGVBdXRvSGlkZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiYXV0byIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib3ZlclJlc2l6ZUVsZW1lbnQiLCJlIiwiZHJhZ0VsZW1lbnQiLCJoYW5kbGVyRGlyZWN0aW9uIiwiaGFuZGxlcnMiLCJzcGxpdCIsIm1hcCIsImRpciIsInRyaW0iLCJzdGFydCIsIl9yZXNpemVTdGFydCIsInN0b3AiLCJfcmVzaXplU3RvcCIsIm1vdmUiLCJfcmVzaXppbmciLCJzY3JvbGxFbCIsImdldFNjcm9sbEVsZW1lbnQiLCJzY3JvbGxZIiwic2Nyb2xsVG9wIiwic3RhcnRFdmVudCIsIl9zZXR1cEhlbHBlciIsIl9hcHBseUNoYW5nZSIsImV2IiwiaW5pdEV2ZW50IiwidHlwZSIsInRhcmdldCIsInRyaWdnZXJFdmVudCIsIl9nZXRDaGFuZ2UiLCJyZXNpemUiLCJfY2xlYW5IZWxwZXIiLCJlbE9yaWdpblN0eWxlVmFsIiwiX29yaWdpblN0eWxlUHJvcCIsInByb3AiLCJzdHlsZSIsInBhcmVudE9yaWdpblN0eWxlUG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwibWF0Y2giLCJvcGFjaXR5IiwiaSIsIm9FdmVudCIsIm9mZnNldFgiLCJjbGllbnRYIiwib2Zmc2V0WSIsImNsaWVudFkiLCJpbmRleE9mIiwiY29uc3RyYWluIiwiX2NvbnN0cmFpblNpemUiLCJNYXRoIiwicm91bmQiLCJvV2lkdGgiLCJvSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWluV2lkdGgiLCJtYXhIZWlnaHQiLCJtaW5IZWlnaHQiLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsImhhbmRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-resizable.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-touch.js":
/*!*************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-touch.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTouch: () => (/* binding */ isTouch),\n/* harmony export */   pointerdown: () => (/* binding */ pointerdown),\n/* harmony export */   pointerenter: () => (/* binding */ pointerenter),\n/* harmony export */   pointerleave: () => (/* binding */ pointerleave),\n/* harmony export */   touchend: () => (/* binding */ touchend),\n/* harmony export */   touchmove: () => (/* binding */ touchmove),\n/* harmony export */   touchstart: () => (/* binding */ touchstart)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * touch.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ \n/**\n * Detect touch support - Windows Surface devices and other touch devices\n * should we use this instead ? (what we had for always showing resize handles)\n * /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n */ const isTouch =  false && (0);\n// interface TouchCoord {x: number, y: number};\nclass DDTouch {\n}\n/**\n* Get the x,y position of a touch event\n*/ // function getTouchCoords(e: TouchEvent): TouchCoord {\n//   return {\n//     x: e.changedTouches[0].pageX,\n//     y: e.changedTouches[0].pageY\n//   };\n// }\n/**\n * Simulate a mouse event based on a corresponding touch event\n * @param {Object} e A touch event\n * @param {String} simulatedType The corresponding mouse event\n */ function simulateMouseEvent(e, simulatedType) {\n    // Ignore multi-touch events\n    if (e.touches.length > 1) return;\n    // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n    if (e.cancelable) e.preventDefault();\n    const touch = e.changedTouches[0], simulatedEvent = document.createEvent(\"MouseEvents\");\n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null // relatedTarget\n    );\n    // Dispatch the simulated event to the target element\n    e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Simulate a mouse event based on a corresponding Pointer event\n * @param {Object} e A pointer event\n * @param {String} simulatedType The corresponding mouse event\n */ function simulatePointerMouseEvent(e, simulatedType) {\n    // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n    if (e.cancelable) e.preventDefault();\n    const simulatedEvent = document.createEvent(\"MouseEvents\");\n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null // relatedTarget\n    );\n    // Dispatch the simulated event to the target element\n    e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Handle the touchstart events\n * @param {Object} e The widget element's touchstart event\n */ function touchstart(e) {\n    // Ignore the event if another widget is already being handled\n    if (DDTouch.touchHandled) return;\n    DDTouch.touchHandled = true;\n    // Simulate the mouse events\n    // simulateMouseEvent(e, 'mouseover');\n    // simulateMouseEvent(e, 'mousemove');\n    simulateMouseEvent(e, \"mousedown\");\n}\n/**\n * Handle the touchmove events\n * @param {Object} e The document's touchmove event\n */ function touchmove(e) {\n    // Ignore event if not handled by us\n    if (!DDTouch.touchHandled) return;\n    simulateMouseEvent(e, \"mousemove\");\n}\n/**\n * Handle the touchend events\n * @param {Object} e The document's touchend event\n */ function touchend(e) {\n    // Ignore event if not handled\n    if (!DDTouch.touchHandled) return;\n    // cancel delayed leave event when we release on ourself which happens BEFORE we get this!\n    if (DDTouch.pointerLeaveTimeout) {\n        window.clearTimeout(DDTouch.pointerLeaveTimeout);\n        delete DDTouch.pointerLeaveTimeout;\n    }\n    const wasDragging = !!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n    // Simulate the mouseup event\n    simulateMouseEvent(e, \"mouseup\");\n    // simulateMouseEvent(event, 'mouseout');\n    // If the touch interaction did not move, it should trigger a click\n    if (!wasDragging) {\n        simulateMouseEvent(e, \"click\");\n    }\n    // Unset the flag to allow other widgets to inherit the touch event\n    DDTouch.touchHandled = false;\n}\n/**\n * Note we don't get touchenter/touchleave (which are deprecated)\n * see https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter\n * so instead of PointerEvent to still get enter/leave and send the matching mouse event.\n */ function pointerdown(e) {\n    // console.log(\"pointer down\")\n    if (e.pointerType === \"mouse\") return;\n    e.target.releasePointerCapture(e.pointerId); // <- Important!\n}\nfunction pointerenter(e) {\n    // ignore the initial one we get on pointerdown on ourself\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n        // console.log('pointerenter ignored');\n        return;\n    }\n    // console.log('pointerenter');\n    if (e.pointerType === \"mouse\") return;\n    simulatePointerMouseEvent(e, \"mouseenter\");\n}\nfunction pointerleave(e) {\n    // ignore the leave on ourself we get before releasing the mouse over ourself\n    // by delaying sending the event and having the up event cancel us\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n        // console.log('pointerleave ignored');\n        return;\n    }\n    if (e.pointerType === \"mouse\") return;\n    DDTouch.pointerLeaveTimeout = window.setTimeout(()=>{\n        delete DDTouch.pointerLeaveTimeout;\n        // console.log('pointerleave delayed');\n        simulatePointerMouseEvent(e, \"mouseleave\");\n    }, 10);\n} //# sourceMappingURL=dd-touch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZGQtdG91Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDd0M7QUFDekM7Ozs7Q0FJQyxHQUNNLE1BQU1DLFVBQVUsTUFBcUQsSUFDdkUsRUFPbUMsRUFBRztBQUMzQywrQ0FBK0M7QUFDL0MsTUFBTU87QUFDTjtBQUNBOztBQUVBLEdBQ0EsdURBQXVEO0FBQ3ZELGFBQWE7QUFDYixvQ0FBb0M7QUFDcEMsbUNBQW1DO0FBQ25DLE9BQU87QUFDUCxJQUFJO0FBQ0o7Ozs7Q0FJQyxHQUNELFNBQVNDLG1CQUFtQkMsQ0FBQyxFQUFFQyxhQUFhO0lBQ3hDLDRCQUE0QjtJQUM1QixJQUFJRCxFQUFFRSxPQUFPLENBQUNDLE1BQU0sR0FBRyxHQUNuQjtJQUNKLHFGQUFxRjtJQUNyRixJQUFJSCxFQUFFSSxVQUFVLEVBQ1pKLEVBQUVLLGNBQWM7SUFDcEIsTUFBTUMsUUFBUU4sRUFBRU8sY0FBYyxDQUFDLEVBQUUsRUFBRUMsaUJBQWlCaEIsU0FBU2lCLFdBQVcsQ0FBQztJQUN6RSwyRUFBMkU7SUFDM0VELGVBQWVFLGNBQWMsQ0FBQ1QsZUFDOUIsTUFDQSxNQUNBUixRQUNBLEdBQ0FhLE1BQU1LLE9BQU8sRUFDYkwsTUFBTU0sT0FBTyxFQUNiTixNQUFNTyxPQUFPLEVBQ2JQLE1BQU1RLE9BQU8sRUFDYixPQUNBLE9BQ0EsT0FDQSxPQUNBLEdBQ0EsS0FBSyxnQkFBZ0I7O0lBRXJCLHFEQUFxRDtJQUNyRGQsRUFBRWUsTUFBTSxDQUFDQyxhQUFhLENBQUNSO0FBQzNCO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNTLDBCQUEwQmpCLENBQUMsRUFBRUMsYUFBYTtJQUMvQyxxRkFBcUY7SUFDckYsSUFBSUQsRUFBRUksVUFBVSxFQUNaSixFQUFFSyxjQUFjO0lBQ3BCLE1BQU1HLGlCQUFpQmhCLFNBQVNpQixXQUFXLENBQUM7SUFDNUMsMkVBQTJFO0lBQzNFRCxlQUFlRSxjQUFjLENBQUNULGVBQzlCLE1BQ0EsTUFDQVIsUUFDQSxHQUNBTyxFQUFFVyxPQUFPLEVBQ1RYLEVBQUVZLE9BQU8sRUFDVFosRUFBRWEsT0FBTyxFQUNUYixFQUFFYyxPQUFPLEVBQ1QsT0FDQSxPQUNBLE9BQ0EsT0FDQSxHQUNBLEtBQUssZ0JBQWdCOztJQUVyQixxREFBcUQ7SUFDckRkLEVBQUVlLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDUjtBQUMzQjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNVLFdBQVdsQixDQUFDO0lBQ3hCLDhEQUE4RDtJQUM5RCxJQUFJRixRQUFRcUIsWUFBWSxFQUNwQjtJQUNKckIsUUFBUXFCLFlBQVksR0FBRztJQUN2Qiw0QkFBNEI7SUFDNUIsc0NBQXNDO0lBQ3RDLHNDQUFzQztJQUN0Q3BCLG1CQUFtQkMsR0FBRztBQUMxQjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNvQixVQUFVcEIsQ0FBQztJQUN2QixvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDRixRQUFRcUIsWUFBWSxFQUNyQjtJQUNKcEIsbUJBQW1CQyxHQUFHO0FBQzFCO0FBQ0E7OztDQUdDLEdBQ00sU0FBU3FCLFNBQVNyQixDQUFDO0lBQ3RCLDhCQUE4QjtJQUM5QixJQUFJLENBQUNGLFFBQVFxQixZQUFZLEVBQ3JCO0lBQ0osMEZBQTBGO0lBQzFGLElBQUlyQixRQUFRd0IsbUJBQW1CLEVBQUU7UUFDN0I3QixPQUFPOEIsWUFBWSxDQUFDekIsUUFBUXdCLG1CQUFtQjtRQUMvQyxPQUFPeEIsUUFBUXdCLG1CQUFtQjtJQUN0QztJQUNBLE1BQU1FLGNBQWMsQ0FBQyxDQUFDbEMsa0RBQVNBLENBQUNtQyxXQUFXO0lBQzNDLDZCQUE2QjtJQUM3QjFCLG1CQUFtQkMsR0FBRztJQUN0Qix5Q0FBeUM7SUFDekMsbUVBQW1FO0lBQ25FLElBQUksQ0FBQ3dCLGFBQWE7UUFDZHpCLG1CQUFtQkMsR0FBRztJQUMxQjtJQUNBLG1FQUFtRTtJQUNuRUYsUUFBUXFCLFlBQVksR0FBRztBQUMzQjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTTyxZQUFZMUIsQ0FBQztJQUN6Qiw4QkFBOEI7SUFDOUIsSUFBSUEsRUFBRTJCLFdBQVcsS0FBSyxTQUNsQjtJQUNKM0IsRUFBRWUsTUFBTSxDQUFDYSxxQkFBcUIsQ0FBQzVCLEVBQUU2QixTQUFTLEdBQUcsZ0JBQWdCO0FBQ2pFO0FBQ08sU0FBU0MsYUFBYTlCLENBQUM7SUFDMUIsMERBQTBEO0lBQzFELElBQUksQ0FBQ1Ysa0RBQVNBLENBQUNtQyxXQUFXLEVBQUU7UUFDeEIsdUNBQXVDO1FBQ3ZDO0lBQ0o7SUFDQSwrQkFBK0I7SUFDL0IsSUFBSXpCLEVBQUUyQixXQUFXLEtBQUssU0FDbEI7SUFDSlYsMEJBQTBCakIsR0FBRztBQUNqQztBQUNPLFNBQVMrQixhQUFhL0IsQ0FBQztJQUMxQiw2RUFBNkU7SUFDN0Usa0VBQWtFO0lBQ2xFLElBQUksQ0FBQ1Ysa0RBQVNBLENBQUNtQyxXQUFXLEVBQUU7UUFDeEIsdUNBQXVDO1FBQ3ZDO0lBQ0o7SUFDQSxJQUFJekIsRUFBRTJCLFdBQVcsS0FBSyxTQUNsQjtJQUNKN0IsUUFBUXdCLG1CQUFtQixHQUFHN0IsT0FBT3VDLFVBQVUsQ0FBQztRQUM1QyxPQUFPbEMsUUFBUXdCLG1CQUFtQjtRQUNsQyx1Q0FBdUM7UUFDdkNMLDBCQUEwQmpCLEdBQUc7SUFDakMsR0FBRztBQUNQLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9kZC10b3VjaC5qcz9hNWNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdG91Y2gudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRERNYW5hZ2VyIH0gZnJvbSAnLi9kZC1tYW5hZ2VyJztcbi8qKlxuICogRGV0ZWN0IHRvdWNoIHN1cHBvcnQgLSBXaW5kb3dzIFN1cmZhY2UgZGV2aWNlcyBhbmQgb3RoZXIgdG91Y2ggZGV2aWNlc1xuICogc2hvdWxkIHdlIHVzZSB0aGlzIGluc3RlYWQgPyAod2hhdCB3ZSBoYWQgZm9yIGFsd2F5cyBzaG93aW5nIHJlc2l6ZSBoYW5kbGVzKVxuICogL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gKi9cbmV4cG9ydCBjb25zdCBpc1RvdWNoID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudFxuICAgICAgICB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3dcbiAgICAgICAgLy8gfHwgISF3aW5kb3cuVG91Y2hFdmVudCAvLyB0cnVlIG9uIFdpbmRvd3MgMTAgQ2hyb21lIGRlc2t0b3Agc28gZG9uJ3QgdXNlIHRoaXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfHwgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpXG4gICAgICAgIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKTtcbi8vIGludGVyZmFjZSBUb3VjaENvb3JkIHt4OiBudW1iZXIsIHk6IG51bWJlcn07XG5jbGFzcyBERFRvdWNoIHtcbn1cbi8qKlxuKiBHZXQgdGhlIHgseSBwb3NpdGlvbiBvZiBhIHRvdWNoIGV2ZW50XG4qL1xuLy8gZnVuY3Rpb24gZ2V0VG91Y2hDb29yZHMoZTogVG91Y2hFdmVudCk6IFRvdWNoQ29vcmQge1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHg6IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgsXG4vLyAgICAgeTogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWVxuLy8gICB9O1xuLy8gfVxuLyoqXG4gKiBTaW11bGF0ZSBhIG1vdXNlIGV2ZW50IGJhc2VkIG9uIGEgY29ycmVzcG9uZGluZyB0b3VjaCBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGUgQSB0b3VjaCBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNpbXVsYXRlZFR5cGUgVGhlIGNvcnJlc3BvbmRpbmcgbW91c2UgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2ltdWxhdGVNb3VzZUV2ZW50KGUsIHNpbXVsYXRlZFR5cGUpIHtcbiAgICAvLyBJZ25vcmUgbXVsdGktdG91Y2ggZXZlbnRzXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gUHJldmVudCBcIklnbm9yZWQgYXR0ZW1wdCB0byBjYW5jZWwgYSB0b3VjaG1vdmUgZXZlbnQgd2l0aCBjYW5jZWxhYmxlPWZhbHNlXCIgZXJyb3JzXG4gICAgaWYgKGUuY2FuY2VsYWJsZSlcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXSwgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzaW11bGF0ZWQgbW91c2UgZXZlbnQgdXNpbmcgdGhlIHRvdWNoIGV2ZW50J3MgY29vcmRpbmF0ZXNcbiAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChzaW11bGF0ZWRUeXBlLCAvLyB0eXBlXG4gICAgdHJ1ZSwgLy8gYnViYmxlc1xuICAgIHRydWUsIC8vIGNhbmNlbGFibGVcbiAgICB3aW5kb3csIC8vIHZpZXdcbiAgICAxLCAvLyBkZXRhaWxcbiAgICB0b3VjaC5zY3JlZW5YLCAvLyBzY3JlZW5YXG4gICAgdG91Y2guc2NyZWVuWSwgLy8gc2NyZWVuWVxuICAgIHRvdWNoLmNsaWVudFgsIC8vIGNsaWVudFhcbiAgICB0b3VjaC5jbGllbnRZLCAvLyBjbGllbnRZXG4gICAgZmFsc2UsIC8vIGN0cmxLZXlcbiAgICBmYWxzZSwgLy8gYWx0S2V5XG4gICAgZmFsc2UsIC8vIHNoaWZ0S2V5XG4gICAgZmFsc2UsIC8vIG1ldGFLZXlcbiAgICAwLCAvLyBidXR0b25cbiAgICBudWxsIC8vIHJlbGF0ZWRUYXJnZXRcbiAgICApO1xuICAgIC8vIERpc3BhdGNoIHRoZSBzaW11bGF0ZWQgZXZlbnQgdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG59XG4vKipcbiAqIFNpbXVsYXRlIGEgbW91c2UgZXZlbnQgYmFzZWQgb24gYSBjb3JyZXNwb25kaW5nIFBvaW50ZXIgZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIEEgcG9pbnRlciBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNpbXVsYXRlZFR5cGUgVGhlIGNvcnJlc3BvbmRpbmcgbW91c2UgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2ltdWxhdGVQb2ludGVyTW91c2VFdmVudChlLCBzaW11bGF0ZWRUeXBlKSB7XG4gICAgLy8gUHJldmVudCBcIklnbm9yZWQgYXR0ZW1wdCB0byBjYW5jZWwgYSB0b3VjaG1vdmUgZXZlbnQgd2l0aCBjYW5jZWxhYmxlPWZhbHNlXCIgZXJyb3JzXG4gICAgaWYgKGUuY2FuY2VsYWJsZSlcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2ltdWxhdGVkIG1vdXNlIGV2ZW50IHVzaW5nIHRoZSB0b3VjaCBldmVudCdzIGNvb3JkaW5hdGVzXG4gICAgc2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoc2ltdWxhdGVkVHlwZSwgLy8gdHlwZVxuICAgIHRydWUsIC8vIGJ1YmJsZXNcbiAgICB0cnVlLCAvLyBjYW5jZWxhYmxlXG4gICAgd2luZG93LCAvLyB2aWV3XG4gICAgMSwgLy8gZGV0YWlsXG4gICAgZS5zY3JlZW5YLCAvLyBzY3JlZW5YXG4gICAgZS5zY3JlZW5ZLCAvLyBzY3JlZW5ZXG4gICAgZS5jbGllbnRYLCAvLyBjbGllbnRYXG4gICAgZS5jbGllbnRZLCAvLyBjbGllbnRZXG4gICAgZmFsc2UsIC8vIGN0cmxLZXlcbiAgICBmYWxzZSwgLy8gYWx0S2V5XG4gICAgZmFsc2UsIC8vIHNoaWZ0S2V5XG4gICAgZmFsc2UsIC8vIG1ldGFLZXlcbiAgICAwLCAvLyBidXR0b25cbiAgICBudWxsIC8vIHJlbGF0ZWRUYXJnZXRcbiAgICApO1xuICAgIC8vIERpc3BhdGNoIHRoZSBzaW11bGF0ZWQgZXZlbnQgdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG59XG4vKipcbiAqIEhhbmRsZSB0aGUgdG91Y2hzdGFydCBldmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSB3aWRnZXQgZWxlbWVudCdzIHRvdWNoc3RhcnQgZXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvdWNoc3RhcnQoZSkge1xuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgYW5vdGhlciB3aWRnZXQgaXMgYWxyZWFkeSBiZWluZyBoYW5kbGVkXG4gICAgaWYgKEREVG91Y2gudG91Y2hIYW5kbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgRERUb3VjaC50b3VjaEhhbmRsZWQgPSB0cnVlO1xuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZSBldmVudHNcbiAgICAvLyBzaW11bGF0ZU1vdXNlRXZlbnQoZSwgJ21vdXNlb3ZlcicpO1xuICAgIC8vIHNpbXVsYXRlTW91c2VFdmVudChlLCAnbW91c2Vtb3ZlJyk7XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGUsICdtb3VzZWRvd24nKTtcbn1cbi8qKlxuICogSGFuZGxlIHRoZSB0b3VjaG1vdmUgZXZlbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZG9jdW1lbnQncyB0b3VjaG1vdmUgZXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvdWNobW92ZShlKSB7XG4gICAgLy8gSWdub3JlIGV2ZW50IGlmIG5vdCBoYW5kbGVkIGJ5IHVzXG4gICAgaWYgKCFERFRvdWNoLnRvdWNoSGFuZGxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHNpbXVsYXRlTW91c2VFdmVudChlLCAnbW91c2Vtb3ZlJyk7XG59XG4vKipcbiAqIEhhbmRsZSB0aGUgdG91Y2hlbmQgZXZlbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZG9jdW1lbnQncyB0b3VjaGVuZCBldmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG91Y2hlbmQoZSkge1xuICAgIC8vIElnbm9yZSBldmVudCBpZiBub3QgaGFuZGxlZFxuICAgIGlmICghRERUb3VjaC50b3VjaEhhbmRsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBjYW5jZWwgZGVsYXllZCBsZWF2ZSBldmVudCB3aGVuIHdlIHJlbGVhc2Ugb24gb3Vyc2VsZiB3aGljaCBoYXBwZW5zIEJFRk9SRSB3ZSBnZXQgdGhpcyFcbiAgICBpZiAoRERUb3VjaC5wb2ludGVyTGVhdmVUaW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoRERUb3VjaC5wb2ludGVyTGVhdmVUaW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIEREVG91Y2gucG9pbnRlckxlYXZlVGltZW91dDtcbiAgICB9XG4gICAgY29uc3Qgd2FzRHJhZ2dpbmcgPSAhIURETWFuYWdlci5kcmFnRWxlbWVudDtcbiAgICAvLyBTaW11bGF0ZSB0aGUgbW91c2V1cCBldmVudFxuICAgIHNpbXVsYXRlTW91c2VFdmVudChlLCAnbW91c2V1cCcpO1xuICAgIC8vIHNpbXVsYXRlTW91c2VFdmVudChldmVudCwgJ21vdXNlb3V0Jyk7XG4gICAgLy8gSWYgdGhlIHRvdWNoIGludGVyYWN0aW9uIGRpZCBub3QgbW92ZSwgaXQgc2hvdWxkIHRyaWdnZXIgYSBjbGlja1xuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgc2ltdWxhdGVNb3VzZUV2ZW50KGUsICdjbGljaycpO1xuICAgIH1cbiAgICAvLyBVbnNldCB0aGUgZmxhZyB0byBhbGxvdyBvdGhlciB3aWRnZXRzIHRvIGluaGVyaXQgdGhlIHRvdWNoIGV2ZW50XG4gICAgRERUb3VjaC50b3VjaEhhbmRsZWQgPSBmYWxzZTtcbn1cbi8qKlxuICogTm90ZSB3ZSBkb24ndCBnZXQgdG91Y2hlbnRlci90b3VjaGxlYXZlICh3aGljaCBhcmUgZGVwcmVjYXRlZClcbiAqIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzkwODMzOS9qcy10b3VjaC1lcXVpdmFsZW50LWZvci1tb3VzZWVudGVyXG4gKiBzbyBpbnN0ZWFkIG9mIFBvaW50ZXJFdmVudCB0byBzdGlsbCBnZXQgZW50ZXIvbGVhdmUgYW5kIHNlbmQgdGhlIG1hdGNoaW5nIG1vdXNlIGV2ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlcmRvd24oZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwicG9pbnRlciBkb3duXCIpXG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpXG4gICAgICAgIHJldHVybjtcbiAgICBlLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpOyAvLyA8LSBJbXBvcnRhbnQhXG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlcmVudGVyKGUpIHtcbiAgICAvLyBpZ25vcmUgdGhlIGluaXRpYWwgb25lIHdlIGdldCBvbiBwb2ludGVyZG93biBvbiBvdXJzZWxmXG4gICAgaWYgKCFERE1hbmFnZXIuZHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BvaW50ZXJlbnRlciBpZ25vcmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3BvaW50ZXJlbnRlcicpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKVxuICAgICAgICByZXR1cm47XG4gICAgc2ltdWxhdGVQb2ludGVyTW91c2VFdmVudChlLCAnbW91c2VlbnRlcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50ZXJsZWF2ZShlKSB7XG4gICAgLy8gaWdub3JlIHRoZSBsZWF2ZSBvbiBvdXJzZWxmIHdlIGdldCBiZWZvcmUgcmVsZWFzaW5nIHRoZSBtb3VzZSBvdmVyIG91cnNlbGZcbiAgICAvLyBieSBkZWxheWluZyBzZW5kaW5nIHRoZSBldmVudCBhbmQgaGF2aW5nIHRoZSB1cCBldmVudCBjYW5jZWwgdXNcbiAgICBpZiAoIURETWFuYWdlci5kcmFnRWxlbWVudCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncG9pbnRlcmxlYXZlIGlnbm9yZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJylcbiAgICAgICAgcmV0dXJuO1xuICAgIEREVG91Y2gucG9pbnRlckxlYXZlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIEREVG91Y2gucG9pbnRlckxlYXZlVGltZW91dDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BvaW50ZXJsZWF2ZSBkZWxheWVkJyk7XG4gICAgICAgIHNpbXVsYXRlUG9pbnRlck1vdXNlRXZlbnQoZSwgJ21vdXNlbGVhdmUnKTtcbiAgICB9LCAxMCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZC10b3VjaC5qcy5tYXAiXSwibmFtZXMiOlsiRERNYW5hZ2VyIiwiaXNUb3VjaCIsImRvY3VtZW50Iiwid2luZG93IiwiRG9jdW1lbnRUb3VjaCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsIkREVG91Y2giLCJzaW11bGF0ZU1vdXNlRXZlbnQiLCJlIiwic2ltdWxhdGVkVHlwZSIsInRvdWNoZXMiLCJsZW5ndGgiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaCIsImNoYW5nZWRUb3VjaGVzIiwic2ltdWxhdGVkRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInRhcmdldCIsImRpc3BhdGNoRXZlbnQiLCJzaW11bGF0ZVBvaW50ZXJNb3VzZUV2ZW50IiwidG91Y2hzdGFydCIsInRvdWNoSGFuZGxlZCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlckxlYXZlVGltZW91dCIsImNsZWFyVGltZW91dCIsIndhc0RyYWdnaW5nIiwiZHJhZ0VsZW1lbnQiLCJwb2ludGVyZG93biIsInBvaW50ZXJUeXBlIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwic2V0VGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/dd-touch.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack-engine.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-engine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridStackEngine: () => (/* binding */ GridStackEngine)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/**\n * gridstack-engine.ts 9.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */ \n/**\n * Defines the GridStack engine that does most no DOM grid manipulation.\n * See GridStack methods and vars for descriptions.\n *\n * NOTE: values should not be modified directly - call the main GridStack API instead\n */ class GridStackEngine {\n    constructor(opts = {}){\n        this.addedNodes = [];\n        this.removedNodes = [];\n        this.column = opts.column || 12;\n        this.maxRow = opts.maxRow;\n        this._float = opts.float;\n        this.nodes = opts.nodes || [];\n        this.onChange = opts.onChange;\n    }\n    batchUpdate(flag = true, doPack = true) {\n        if (!!this.batchMode === flag) return this;\n        this.batchMode = flag;\n        if (flag) {\n            this._prevFloat = this._float;\n            this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n            this.cleanNodes();\n            this.saveInitial(); // since begin update (which is called multiple times) won't do this\n        } else {\n            this._float = this._prevFloat;\n            delete this._prevFloat;\n            if (doPack) this._packNodes();\n            this._notify();\n        }\n        return this;\n    }\n    // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n    _useEntireRowArea(node, nn) {\n        return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n    }\n    /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n     * return true if we moved. */ _fixCollisions(node, nn = node, collide, opt = {}) {\n        this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n        collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n        if (!collide) return false;\n        // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n        if (node._moving && !opt.nested && !this.float) {\n            if (this.swap(node, collide)) return true;\n        }\n        // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n        let area = nn;\n        if (this._useEntireRowArea(node, nn)) {\n            area = {\n                x: 0,\n                w: this.column,\n                y: nn.y,\n                h: nn.h\n            };\n            collide = this.collide(node, area, opt.skip); // force new hit\n        }\n        let didMove = false;\n        let newOpt = {\n            nested: true,\n            pack: false\n        };\n        while(collide = collide || this.collide(node, area, opt.skip)){\n            let moved;\n            // if colliding with a locked item OR moving down with top gravity (and collide could move up) -> skip past the collide,\n            // but remember that skip down so we only do this once (and push others otherwise).\n            if (collide.locked || node._moving && !node._skipDown && nn.y > node.y && !this.float && // can take space we had, or before where we're going\n            (!this.collide(collide, {\n                ...collide,\n                y: node.y\n            }, node) || !this.collide(collide, {\n                ...collide,\n                y: nn.y - collide.h\n            }, node))) {\n                node._skipDown = node._skipDown || nn.y > node.y;\n                moved = this.moveNode(node, {\n                    ...nn,\n                    y: collide.y + collide.h,\n                    ...newOpt\n                });\n                if (collide.locked && moved) {\n                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, node); // moving after lock become our new desired location\n                } else if (!collide.locked && moved && opt.pack) {\n                    // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n                    this._packNodes();\n                    nn.y = collide.y + collide.h;\n                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n                }\n                didMove = didMove || moved;\n            } else {\n                // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n                moved = this.moveNode(collide, {\n                    ...collide,\n                    y: nn.y + nn.h,\n                    skip: node,\n                    ...newOpt\n                });\n            }\n            if (!moved) {\n                return didMove;\n            } // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n            collide = undefined;\n        }\n        return didMove;\n    }\n    /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */ collide(skip, area = skip, skip2) {\n        const skipId = skip._id;\n        const skip2Id = skip2?._id;\n        return this.nodes.find((n)=>n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n    }\n    collideAll(skip, area = skip, skip2) {\n        const skipId = skip._id;\n        const skip2Id = skip2?._id;\n        return this.nodes.filter((n)=>n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n    }\n    /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */ directionCollideCoverage(node, o, collides) {\n        if (!o.rect || !node._rect) return;\n        let r0 = node._rect; // where started\n        let r = {\n            ...o.rect\n        }; // where we are\n        // update dragged rect to show where it's coming from (above or below, etc...)\n        if (r.y > r0.y) {\n            r.h += r.y - r0.y;\n            r.y = r0.y;\n        } else {\n            r.h += r0.y - r.y;\n        }\n        if (r.x > r0.x) {\n            r.w += r.x - r0.x;\n            r.x = r0.x;\n        } else {\n            r.w += r0.x - r.x;\n        }\n        let collide;\n        let overMax = 0.5; // need >50%\n        collides.forEach((n)=>{\n            if (n.locked || !n._rect) return;\n            let r2 = n._rect; // overlapping target\n            let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE;\n            // depending on which side we started from, compute the overlap % of coverage\n            // (ex: from above/below we only compute the max horizontal line coverage)\n            if (r0.y < r2.y) {\n                yOver = (r.y + r.h - r2.y) / r2.h;\n            } else if (r0.y + r0.h > r2.y + r2.h) {\n                yOver = (r2.y + r2.h - r.y) / r2.h;\n            }\n            if (r0.x < r2.x) {\n                xOver = (r.x + r.w - r2.x) / r2.w;\n            } else if (r0.x + r0.w > r2.x + r2.w) {\n                xOver = (r2.x + r2.w - r.x) / r2.w;\n            }\n            let over = Math.min(xOver, yOver);\n            if (over > overMax) {\n                overMax = over;\n                collide = n;\n            }\n        });\n        o.collide = collide; // save it so we don't have to find it again\n        return collide;\n    }\n    /** does a pixel coverage returning the node that has the most coverage by area */ /*\n    protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n      let collide: GridStackNode;\n      let overMax = 0;\n      collides.forEach(n => {\n        if (n.locked || !n._rect) return;\n        let over = Utils.areaIntercept(r, n._rect);\n        if (over > overMax) {\n          overMax = over;\n          collide = n;\n        }\n      });\n      return {collide, over: overMax};\n    }\n    */ /** called to cache the nodes pixel rectangles used for collision detection during drag */ cacheRects(w, h, top, right, bottom, left) {\n        this.nodes.forEach((n)=>n._rect = {\n                y: n.y * h + top,\n                x: n.x * w + left,\n                w: n.w * w - left - right,\n                h: n.h * h - top - bottom\n            });\n        return this;\n    }\n    /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */ swap(a, b) {\n        if (!b || b.locked || !a || a.locked) return false;\n        function _doSwap() {\n            let x = b.x, y = b.y;\n            b.x = a.x;\n            b.y = a.y; // b -> a position\n            if (a.h != b.h) {\n                a.x = x;\n                a.y = b.y + b.h; // a -> goes after b\n            } else if (a.w != b.w) {\n                a.x = b.x + b.w;\n                a.y = y; // a -> goes after b\n            } else {\n                a.x = x;\n                a.y = y; // a -> old b position\n            }\n            a._dirty = b._dirty = true;\n            return true;\n        }\n        let touching; // remember if we called it (vs undefined)\n        // same size and same row or column, and touching\n        if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b))) return _doSwap();\n        if (touching === false) return; // IFF ran test and fail, bail out\n        // check for taking same columns (but different height) and touching\n        if (a.w === b.w && a.x === b.x && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n            if (b.y < a.y) {\n                let t = a;\n                a = b;\n                b = t;\n            } // swap a <-> b vars so a is first\n            return _doSwap();\n        }\n        if (touching === false) return;\n        // check if taking same row (but different width) and touching\n        if (a.h === b.h && a.y === b.y && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n            if (b.x < a.x) {\n                let t = a;\n                a = b;\n                b = t;\n            } // swap a <-> b vars so a is first\n            return _doSwap();\n        }\n        return false;\n    }\n    isAreaEmpty(x, y, w, h) {\n        let nn = {\n            x: x || 0,\n            y: y || 0,\n            w: w || 1,\n            h: h || 1\n        };\n        return !this.collide(nn);\n    }\n    /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */ compact(layout = \"compact\", doSort = true) {\n        if (this.nodes.length === 0) return this;\n        if (doSort) this.sortNodes();\n        const wasBatch = this.batchMode;\n        if (!wasBatch) this.batchUpdate();\n        const wasColumnResize = this._inColumnResize;\n        if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n        let copyNodes = this.nodes;\n        this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n        copyNodes.forEach((n, index, list)=>{\n            let after;\n            if (!n.locked) {\n                n.autoPosition = true;\n                if (layout === \"list\" && index) after = list[index - 1];\n            }\n            this.addNode(n, false, after); // 'false' for add event trigger\n        });\n        if (!wasColumnResize) delete this._inColumnResize;\n        if (!wasBatch) this.batchUpdate(false);\n        return this;\n    }\n    /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */ set float(val) {\n        if (this._float === val) return;\n        this._float = val || false;\n        if (!val) {\n            this._packNodes()._notify();\n        }\n    }\n    /** float getter method */ get float() {\n        return this._float || false;\n    }\n    /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */ sortNodes(dir = 1, column = this.column) {\n        this.nodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, dir, column);\n        return this;\n    }\n    /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */ _packNodes() {\n        if (this.batchMode) {\n            return this;\n        }\n        this.sortNodes(); // first to last\n        if (this.float) {\n            // restore original Y pos\n            this.nodes.forEach((n)=>{\n                if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n                let newY = n.y;\n                while(newY > n._orig.y){\n                    --newY;\n                    let collide = this.collide(n, {\n                        x: n.x,\n                        y: newY,\n                        w: n.w,\n                        h: n.h\n                    });\n                    if (!collide) {\n                        n._dirty = true;\n                        n.y = newY;\n                    }\n                }\n            });\n        } else {\n            // top gravity pack\n            this.nodes.forEach((n, i)=>{\n                if (n.locked) return;\n                while(n.y > 0){\n                    let newY = i === 0 ? 0 : n.y - 1;\n                    let canBeMoved = i === 0 || !this.collide(n, {\n                        x: n.x,\n                        y: newY,\n                        w: n.w,\n                        h: n.h\n                    });\n                    if (!canBeMoved) break;\n                    // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n                    // and move items back. The user 'change' CB should detect changes from the original\n                    // starting position instead.\n                    n._dirty = n.y !== newY;\n                    n.y = newY;\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * given a random node, makes sure it's coordinates/values are valid in the current grid\n     * @param node to adjust\n     * @param resizing if out of bound, resize down or move into the grid to fit ?\n     */ prepareNode(node, resizing) {\n        node = node || {};\n        node._id = node._id ?? GridStackEngine._idSeq++;\n        // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n        if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n            node.autoPosition = true;\n        }\n        // assign defaults for missing required fields\n        let defaults = {\n            x: 0,\n            y: 0,\n            w: 1,\n            h: 1\n        };\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.defaults(node, defaults);\n        if (!node.autoPosition) {\n            delete node.autoPosition;\n        }\n        if (!node.noResize) {\n            delete node.noResize;\n        }\n        if (!node.noMove) {\n            delete node.noMove;\n        }\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sanitizeMinMax(node);\n        // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n        if (typeof node.x == \"string\") {\n            node.x = Number(node.x);\n        }\n        if (typeof node.y == \"string\") {\n            node.y = Number(node.y);\n        }\n        if (typeof node.w == \"string\") {\n            node.w = Number(node.w);\n        }\n        if (typeof node.h == \"string\") {\n            node.h = Number(node.h);\n        }\n        if (isNaN(node.x)) {\n            node.x = defaults.x;\n            node.autoPosition = true;\n        }\n        if (isNaN(node.y)) {\n            node.y = defaults.y;\n            node.autoPosition = true;\n        }\n        if (isNaN(node.w)) {\n            node.w = defaults.w;\n        }\n        if (isNaN(node.h)) {\n            node.h = defaults.h;\n        }\n        return this.nodeBoundFix(node, resizing);\n    }\n    /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */ nodeBoundFix(node, resizing) {\n        let before = node._orig || _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n        if (node.maxW) {\n            node.w = Math.min(node.w, node.maxW);\n        }\n        if (node.maxH) {\n            node.h = Math.min(node.h, node.maxH);\n        }\n        if (node.minW && node.minW <= this.column) {\n            node.w = Math.max(node.w, node.minW);\n        }\n        if (node.minH) {\n            node.h = Math.max(node.h, node.minH);\n        }\n        // if user loaded a larger than allowed widget for current # of columns,\n        // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n        // IFF we're not in the middle of column resizing!\n        const saveOrig = (node.x || 0) + (node.w || 1) > this.column;\n        if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {\n            let copy = {\n                ...node\n            }; // need _id + positions\n            if (copy.autoPosition || copy.x === undefined) {\n                delete copy.x;\n                delete copy.y;\n            } else copy.x = Math.min(11, copy.x);\n            copy.w = Math.min(12, copy.w || 1);\n            this.cacheOneLayout(copy, 12);\n        }\n        if (node.w > this.column) {\n            node.w = this.column;\n        } else if (node.w < 1) {\n            node.w = 1;\n        }\n        if (this.maxRow && node.h > this.maxRow) {\n            node.h = this.maxRow;\n        } else if (node.h < 1) {\n            node.h = 1;\n        }\n        if (node.x < 0) {\n            node.x = 0;\n        }\n        if (node.y < 0) {\n            node.y = 0;\n        }\n        if (node.x + node.w > this.column) {\n            if (resizing) {\n                node.w = this.column - node.x;\n            } else {\n                node.x = this.column - node.w;\n            }\n        }\n        if (this.maxRow && node.y + node.h > this.maxRow) {\n            if (resizing) {\n                node.h = this.maxRow - node.y;\n            } else {\n                node.y = this.maxRow - node.h;\n            }\n        }\n        if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, before)) {\n            node._dirty = true;\n        }\n        return node;\n    }\n    /** returns a list of modified nodes from their original values */ getDirtyNodes(verify) {\n        // compare original x,y,w,h instead as _dirty can be a temporary state\n        if (verify) {\n            return this.nodes.filter((n)=>n._dirty && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig));\n        }\n        return this.nodes.filter((n)=>n._dirty);\n    }\n    /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */ _notify(removedNodes) {\n        if (this.batchMode || !this.onChange) return this;\n        let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n        this.onChange(dirtyNodes);\n        return this;\n    }\n    /** @internal remove dirty and last tried info */ cleanNodes() {\n        if (this.batchMode) return this;\n        this.nodes.forEach((n)=>{\n            delete n._dirty;\n            delete n._lastTried;\n        });\n        return this;\n    }\n    /** @internal called to save initial position/size to track real dirty state.\n     * Note: should be called right after we call change event (so next API is can detect changes)\n     * as well as right before we start move/resize/enter (so we can restore items to prev values) */ saveInitial() {\n        this.nodes.forEach((n)=>{\n            n._orig = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n            delete n._dirty;\n        });\n        this._hasLocked = this.nodes.some((n)=>n.locked);\n        return this;\n    }\n    /** @internal restore all the nodes back to initial values (called when we leave) */ restoreInitial() {\n        this.nodes.forEach((n)=>{\n            if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig)) return;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, n._orig);\n            n._dirty = true;\n        });\n        this._notify();\n        return this;\n    }\n    /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.\n     * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.\n     * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped\n     */ findEmptyPosition(node, nodeList = this.nodes, column = this.column, after) {\n        let start = after ? after.y * column + (after.x + after.w) : 0;\n        let found = false;\n        for(let i = start; !found; ++i){\n            let x = i % column;\n            let y = Math.floor(i / column);\n            if (x + node.w > column) {\n                continue;\n            }\n            let box = {\n                x,\n                y,\n                w: node.w,\n                h: node.h\n            };\n            if (!nodeList.find((n)=>_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(box, n))) {\n                if (node.x !== x || node.y !== y) node._dirty = true;\n                node.x = x;\n                node.y = y;\n                delete node.autoPosition;\n                found = true;\n            }\n        }\n        return found;\n    }\n    /** call to add the given node to our list, fixing collision and re-packing */ addNode(node, triggerAddEvent = false, after) {\n        let dup = this.nodes.find((n)=>n._id === node._id);\n        if (dup) return dup; // prevent inserting twice! return it instead.\n        // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n        node = this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n        delete node._temporaryRemoved;\n        delete node._removeDOM;\n        let skipCollision;\n        if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n            delete node.autoPosition; // found our slot\n            skipCollision = true;\n        }\n        this.nodes.push(node);\n        if (triggerAddEvent) {\n            this.addedNodes.push(node);\n        }\n        if (!skipCollision) this._fixCollisions(node);\n        if (!this.batchMode) {\n            this._packNodes()._notify();\n        }\n        return node;\n    }\n    removeNode(node, removeDOM = true, triggerEvent = false) {\n        if (!this.nodes.find((n)=>n._id === node._id)) {\n            // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n            return this;\n        }\n        if (triggerEvent) {\n            this.removedNodes.push(node);\n        }\n        if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n        // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n        this.nodes = this.nodes.filter((n)=>n._id !== node._id);\n        if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n        this._notify([\n            node\n        ]);\n        return this;\n    }\n    removeAll(removeDOM = true) {\n        delete this._layouts;\n        if (!this.nodes.length) return this;\n        removeDOM && this.nodes.forEach((n)=>n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n        this.removedNodes = this.nodes;\n        this.nodes = [];\n        return this._notify(this.removedNodes);\n    }\n    /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.\n     * In more complicated cases (maxRow) it will attempt at moving the item and fixing\n     * others in a clone first, then apply those changes if still within specs. */ moveNodeCheck(node, o) {\n        // if (node.locked) return false;\n        if (!this.changedPosConstrain(node, o)) return false;\n        o.pack = true;\n        // simpler case: move item directly...\n        if (!this.maxRow) {\n            return this.moveNode(node, o);\n        }\n        // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n        let clonedNode;\n        let clone = new GridStackEngine({\n            column: this.column,\n            float: this.float,\n            nodes: this.nodes.map((n)=>{\n                if (n._id === node._id) {\n                    clonedNode = {\n                        ...n\n                    };\n                    return clonedNode;\n                }\n                return {\n                    ...n\n                };\n            })\n        });\n        if (!clonedNode) return false;\n        // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse\n        // (case where widget was somehow added past our max #2449)\n        let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);\n        // else check if we can force a swap (float=true, or different shapes) on non-resize\n        if (!canMove && !o.resizing && o.collide) {\n            let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n            if (this.swap(node, collide)) {\n                this._notify();\n                return true;\n            }\n        }\n        if (!canMove) return false;\n        // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n        // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n        clone.nodes.filter((n)=>n._dirty).forEach((c)=>{\n            let n = this.nodes.find((a)=>a._id === c._id);\n            if (!n) return;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, c);\n            n._dirty = true;\n        });\n        this._notify();\n        return true;\n    }\n    /** return true if can fit in grid height constrain only (always true if no maxRow) */ willItFit(node) {\n        delete node._willFitPos;\n        if (!this.maxRow) return true;\n        // create a clone with NO maxRow and check if still within size\n        let clone = new GridStackEngine({\n            column: this.column,\n            float: this.float,\n            nodes: this.nodes.map((n)=>{\n                return {\n                    ...n\n                };\n            })\n        });\n        let n = {\n            ...node\n        }; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n        this.cleanupNode(n);\n        delete n.el;\n        delete n._id;\n        delete n.content;\n        delete n.grid;\n        clone.addNode(n);\n        if (clone.getRow() <= this.maxRow) {\n            node._willFitPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n            return true;\n        }\n        return false;\n    }\n    /** true if x,y or w,h are different after clamping to min/max */ changedPosConstrain(node, p) {\n        // first make sure w,h are set for caller\n        p.w = p.w || node.w;\n        p.h = p.h || node.h;\n        if (node.x !== p.x || node.y !== p.y) return true;\n        // check constrained w,h\n        if (node.maxW) {\n            p.w = Math.min(p.w, node.maxW);\n        }\n        if (node.maxH) {\n            p.h = Math.min(p.h, node.maxH);\n        }\n        if (node.minW) {\n            p.w = Math.max(p.w, node.minW);\n        }\n        if (node.minH) {\n            p.h = Math.max(p.h, node.minH);\n        }\n        return node.w !== p.w || node.h !== p.h;\n    }\n    /** return true if the passed in node was actually moved (checks for no-op and locked) */ moveNode(node, o) {\n        if (!node || /*node.locked ||*/ !o) return false;\n        let wasUndefinedPack;\n        if (o.pack === undefined && !this.batchMode) {\n            wasUndefinedPack = o.pack = true;\n        }\n        // constrain the passed in values and check if we're still changing our node\n        if (typeof o.x !== \"number\") {\n            o.x = node.x;\n        }\n        if (typeof o.y !== \"number\") {\n            o.y = node.y;\n        }\n        if (typeof o.w !== \"number\") {\n            o.w = node.w;\n        }\n        if (typeof o.h !== \"number\") {\n            o.h = node.h;\n        }\n        let resizing = node.w !== o.w || node.h !== o.h;\n        let nn = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, o);\n        nn = this.nodeBoundFix(nn, resizing);\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(o, nn);\n        if (!o.forceCollide && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, o)) return false;\n        let prevPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n        // check if we will need to fix collision at our new location\n        let collides = this.collideAll(node, nn, o.skip);\n        let needToMove = true;\n        if (collides.length) {\n            let activeDrag = node._moving && !o.nested;\n            // check to make sure we actually collided over 50% surface area while dragging\n            let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n            // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n            if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {\n                let over = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.areaIntercept(o.rect, collide._rect);\n                let a1 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(o.rect);\n                let a2 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(collide._rect);\n                let perc = over / (a1 < a2 ? a1 : a2);\n                if (perc > .8) {\n                    collide.grid.makeSubGrid(collide.el, undefined, node);\n                    collide = undefined;\n                }\n            }\n            if (collide) {\n                needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n            } else {\n                needToMove = false; // we didn't cover >50% for a move, skip...\n                if (wasUndefinedPack) delete o.pack;\n            }\n        }\n        // now move (to the original ask vs the collision version which might differ) and repack things\n        if (needToMove) {\n            node._dirty = true;\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n        }\n        if (o.pack) {\n            this._packNodes()._notify();\n        }\n        return !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, prevPos); // pack might have moved things back\n    }\n    getRow() {\n        return this.nodes.reduce((row, n)=>Math.max(row, n.y + n.h), 0);\n    }\n    beginUpdate(node) {\n        if (!node._updating) {\n            node._updating = true;\n            delete node._skipDown;\n            if (!this.batchMode) this.saveInitial();\n        }\n        return this;\n    }\n    endUpdate() {\n        let n = this.nodes.find((n)=>n._updating);\n        if (n) {\n            delete n._updating;\n            delete n._skipDown;\n        }\n        return this;\n    }\n    /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n     * returning a list of widgets for serialization */ save(saveElement = true, saveCB) {\n        // use the highest layout for any saved info so we can have full detail on reload #1849\n        let len = this._layouts?.length;\n        let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;\n        let list = [];\n        this.sortNodes();\n        this.nodes.forEach((n)=>{\n            let wl = layout?.find((l)=>l._id === n._id);\n            // use layout info fields instead if set\n            let w = {\n                ...n,\n                ...wl || {}\n            };\n            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.removeInternalForSave(w, !saveElement);\n            if (saveCB) saveCB(n, w);\n            list.push(w);\n        });\n        return list;\n    }\n    /** @internal called whenever a node is added or moved - updates the cached layouts */ layoutsNodesChange(nodes) {\n        if (!this._layouts || this._inColumnResize) return this;\n        // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n        this._layouts.forEach((layout, column)=>{\n            if (!layout || column === this.column) return this;\n            if (column < this.column) {\n                this._layouts[column] = undefined;\n            } else {\n                // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n                // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n                let ratio = column / this.column;\n                nodes.forEach((node)=>{\n                    if (!node._orig) return; // didn't change (newly added ?)\n                    let n = layout.find((l)=>l._id === node._id);\n                    if (!n) return; // no cache for new nodes. Will use those values.\n                    // Y changed, push down same amount\n                    // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n                    if (n.y >= 0 && node.y !== node._orig.y) {\n                        n.y += node.y - node._orig.y;\n                    }\n                    // X changed, scale from new position\n                    if (node.x !== node._orig.x) {\n                        n.x = Math.round(node.x * ratio);\n                    }\n                    // width changed, scale from new width\n                    if (node.w !== node._orig.w) {\n                        n.w = Math.round(node.w * ratio);\n                    }\n                // ...height always carries over from cache\n                });\n            }\n        });\n        return this;\n    }\n    /**\n     * @internal Called to scale the widget width & position up/down based on the column change.\n     * Note we store previous layouts (especially original ones) to make it possible to go\n     * from say 12 -> 1 -> 12 and get back to where we were.\n     *\n     * @param prevColumn previous number of columns\n     * @param column  new column number\n     * @param nodes different sorted list (ex: DOM order) instead of current list\n     * @param layout specify the type of re-layout that will happen (position, size, etc...).\n     * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n     */ columnChanged(prevColumn, column, nodes, layout = \"moveScale\") {\n        if (!this.nodes.length || !column || prevColumn === column) return this;\n        // simpler shortcuts layouts\n        const doCompact = layout === \"compact\" || layout === \"list\";\n        if (doCompact) {\n            this.sortNodes(1, prevColumn); // sort with original layout once and only once (new column will affect order otherwise)\n        }\n        // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n        if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n        this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n        let newNodes = [];\n        // if we're going to 1 column and using DOM order (item passed in) rather than default sorting, then generate that layout\n        let domOrder = false;\n        if (column === 1 && nodes?.length) {\n            domOrder = true;\n            let top = 0;\n            nodes.forEach((n)=>{\n                n.x = 0;\n                n.w = 1;\n                n.y = Math.max(n.y, top);\n                top = n.y + n.h;\n            });\n            newNodes = nodes;\n            nodes = [];\n        } else {\n            nodes = doCompact ? this.nodes : _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, -1, prevColumn); // current column reverse sorting so we can insert last to front (limit collision)\n        }\n        // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n        // generate next size down from where we are (looks more natural as you gradually size down).\n        if (column > prevColumn && this._layouts) {\n            const cacheNodes = this._layouts[column] || [];\n            // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n            // by pretending we came from that larger column by assigning those values as starting point\n            let lastIndex = this._layouts.length - 1;\n            if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {\n                prevColumn = lastIndex;\n                this._layouts[lastIndex].forEach((cacheNode)=>{\n                    let n = nodes.find((n)=>n._id === cacheNode._id);\n                    if (n) {\n                        // still current, use cache info positions\n                        if (!doCompact && !cacheNode.autoPosition) {\n                            n.x = cacheNode.x ?? n.x;\n                            n.y = cacheNode.y ?? n.y;\n                        }\n                        n.w = cacheNode.w ?? n.w;\n                        if (cacheNode.x == undefined || cacheNode.y === undefined) n.autoPosition = true;\n                    }\n                });\n            }\n            // if we found cache re-use those nodes that are still current\n            cacheNodes.forEach((cacheNode)=>{\n                let j = nodes.findIndex((n)=>n._id === cacheNode._id);\n                if (j !== -1) {\n                    const n = nodes[j];\n                    // still current, use cache info positions\n                    if (doCompact) {\n                        n.w = cacheNode.w; // only w is used, and don't trim the list\n                        return;\n                    }\n                    if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n                        this.findEmptyPosition(cacheNode, newNodes);\n                    }\n                    if (!cacheNode.autoPosition) {\n                        n.x = cacheNode.x ?? n.x;\n                        n.y = cacheNode.y ?? n.y;\n                        n.w = cacheNode.w ?? n.w;\n                        newNodes.push(n);\n                    }\n                    nodes.splice(j, 1);\n                }\n            });\n        }\n        // much simpler layout that just compacts\n        if (doCompact) {\n            this.compact(layout, false);\n        } else {\n            // ...and add any extra non-cached ones\n            if (nodes.length) {\n                if (typeof layout === \"function\") {\n                    layout(column, prevColumn, newNodes, nodes);\n                } else if (!domOrder) {\n                    let ratio = doCompact || layout === \"none\" ? 1 : column / prevColumn;\n                    let move = layout === \"move\" || layout === \"moveScale\";\n                    let scale = layout === \"scale\" || layout === \"moveScale\";\n                    nodes.forEach((node)=>{\n                        // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n                        node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);\n                        node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);\n                        newNodes.push(node);\n                    });\n                    nodes = [];\n                }\n            }\n            // finally re-layout them in reverse order (to get correct placement)\n            if (!domOrder) newNodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(newNodes, -1, column);\n            this._inColumnResize = true; // prevent cache update\n            this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n            newNodes.forEach((node)=>{\n                this.addNode(node, false); // 'false' for add event trigger\n                delete node._orig; // make sure the commit doesn't try to restore things back to original\n            });\n        }\n        this.nodes.forEach((n)=>delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n        this.batchUpdate(false, !doCompact);\n        delete this._inColumnResize;\n        return this;\n    }\n    /**\n     * call to cache the given layout internally to the given location so we can restore back when column changes size\n     * @param nodes list of nodes\n     * @param column corresponding column index to save it under\n     * @param clear if true, will force other caches to be removed (default false)\n     */ cacheLayout(nodes, column, clear = false) {\n        let copy = [];\n        nodes.forEach((n, i)=>{\n            n._id = n._id ?? GridStackEngine._idSeq++; // make sure we have an id in case this is new layout, else re-use id already set\n            copy[i] = {\n                x: n.x,\n                y: n.y,\n                w: n.w,\n                _id: n._id\n            }; // only thing we change is x,y,w and id to find it back\n        });\n        this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n        this._layouts[column] = copy;\n        return this;\n    }\n    /**\n     * call to cache the given node layout internally to the given location so we can restore back when column changes size\n     * @param node single node to cache\n     * @param column corresponding column index to save it under\n     */ cacheOneLayout(n, column) {\n        n._id = n._id ?? GridStackEngine._idSeq++;\n        let l = {\n            x: n.x,\n            y: n.y,\n            w: n.w,\n            _id: n._id\n        };\n        if (n.autoPosition || n.x === undefined) {\n            delete l.x;\n            delete l.y;\n            if (n.autoPosition) l.autoPosition = true;\n        }\n        this._layouts = this._layouts || [];\n        this._layouts[column] = this._layouts[column] || [];\n        let index = this.findCacheLayout(n, column);\n        if (index === -1) this._layouts[column].push(l);\n        else this._layouts[column][index] = l;\n        return this;\n    }\n    findCacheLayout(n, column) {\n        return this._layouts?.[column]?.findIndex((l)=>l._id === n._id) ?? -1;\n    }\n    removeNodeFromLayoutCache(n) {\n        if (!this._layouts) {\n            return;\n        }\n        for(let i = 0; i < this._layouts.length; i++){\n            let index = this.findCacheLayout(n, i);\n            if (index !== -1) {\n                this._layouts[i].splice(index, 1);\n            }\n        }\n    }\n    /** called to remove all internal values but the _id */ cleanupNode(node) {\n        for(let prop in node){\n            if (prop[0] === \"_\" && prop !== \"_id\") delete node[prop];\n        }\n        return this;\n    }\n}\n/** @internal unique global internal _id counter */ GridStackEngine._idSeq = 0;\n //# sourceMappingURL=gridstack-engine.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLWVuZ2luZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUMrQjtBQUNoQzs7Ozs7Q0FLQyxHQUNELE1BQU1DO0lBQ0ZDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsTUFBTSxHQUFHSCxLQUFLRyxNQUFNLElBQUk7UUFDN0IsSUFBSSxDQUFDQyxNQUFNLEdBQUdKLEtBQUtJLE1BQU07UUFDekIsSUFBSSxDQUFDQyxNQUFNLEdBQUdMLEtBQUtNLEtBQUs7UUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdQLEtBQUtPLEtBQUssSUFBSSxFQUFFO1FBQzdCLElBQUksQ0FBQ0MsUUFBUSxHQUFHUixLQUFLUSxRQUFRO0lBQ2pDO0lBQ0FDLFlBQVlDLE9BQU8sSUFBSSxFQUFFQyxTQUFTLElBQUksRUFBRTtRQUNwQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUNDLFNBQVMsS0FBS0YsTUFDckIsT0FBTyxJQUFJO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUdGO1FBQ2pCLElBQUlBLE1BQU07WUFDTixJQUFJLENBQUNHLFVBQVUsR0FBRyxJQUFJLENBQUNSLE1BQU07WUFDN0IsSUFBSSxDQUFDQSxNQUFNLEdBQUcsTUFBTSwrRUFBK0U7WUFDbkcsSUFBSSxDQUFDUyxVQUFVO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLElBQUksb0VBQW9FO1FBQzVGLE9BQ0s7WUFDRCxJQUFJLENBQUNWLE1BQU0sR0FBRyxJQUFJLENBQUNRLFVBQVU7WUFDN0IsT0FBTyxJQUFJLENBQUNBLFVBQVU7WUFDdEIsSUFBSUYsUUFDQSxJQUFJLENBQUNLLFVBQVU7WUFDbkIsSUFBSSxDQUFDQyxPQUFPO1FBQ2hCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxnSUFBZ0k7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SSxDQUFDNEM7YUFFM0IsSUFBSSxDQUFDdEMsUUFBUSxDQUFDakosT0FBTyxDQUFDd0YsTUFBTSxHQUFHK0Y7UUFDbkMsT0FBTyxJQUFJO0lBQ2Y7SUFDQWxFLGdCQUFnQnZFLENBQUMsRUFBRTlDLE1BQU0sRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ2lKLFFBQVEsRUFBRSxDQUFDakosT0FBTyxFQUFFc00sVUFBVWYsQ0FBQUEsSUFBS0EsRUFBRTVJLEdBQUcsS0FBS0csRUFBRUgsR0FBRyxLQUFLLENBQUM7SUFDeEU7SUFDQWdLLDBCQUEwQjdKLENBQUMsRUFBRTtRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDbUcsUUFBUSxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFLLElBQUk5QyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOEMsUUFBUSxDQUFDOUQsTUFBTSxFQUFFZ0IsSUFBSztZQUMzQyxJQUFJWCxRQUFRLElBQUksQ0FBQzZCLGVBQWUsQ0FBQ3ZFLEdBQUdxRDtZQUNwQyxJQUFJWCxVQUFVLENBQUMsR0FBRztnQkFDZCxJQUFJLENBQUN5RCxRQUFRLENBQUM5QyxFQUFFLENBQUNvRyxNQUFNLENBQUMvRyxPQUFPO1lBQ25DO1FBQ0o7SUFDSjtJQUNBLHFEQUFxRCxHQUNyRHNFLFlBQVk5SSxJQUFJLEVBQUU7UUFDZCxJQUFLLElBQUk0TCxRQUFRNUwsS0FBTTtZQUNuQixJQUFJNEwsSUFBSSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxTQUFTLE9BQzVCLE9BQU81TCxJQUFJLENBQUM0TCxLQUFLO1FBQ3pCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUNBLGlEQUFpRCxHQUNqRGpOLGdCQUFnQjRHLE1BQU0sR0FBRztBQUNFLENBQzNCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2x1Y2lkaXR5LWQzanMvLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLWVuZ2luZS5qcz84MjZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZ3JpZHN0YWNrLWVuZ2luZS50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueSAtIHNlZSBHcmlkU3RhY2sgcm9vdCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG4vKipcbiAqIERlZmluZXMgdGhlIEdyaWRTdGFjayBlbmdpbmUgdGhhdCBkb2VzIG1vc3Qgbm8gRE9NIGdyaWQgbWFuaXB1bGF0aW9uLlxuICogU2VlIEdyaWRTdGFjayBtZXRob2RzIGFuZCB2YXJzIGZvciBkZXNjcmlwdGlvbnMuXG4gKlxuICogTk9URTogdmFsdWVzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgZGlyZWN0bHkgLSBjYWxsIHRoZSBtYWluIEdyaWRTdGFjayBBUEkgaW5zdGVhZFxuICovXG5jbGFzcyBHcmlkU3RhY2tFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBvcHRzLmNvbHVtbiB8fCAxMjtcbiAgICAgICAgdGhpcy5tYXhSb3cgPSBvcHRzLm1heFJvdztcbiAgICAgICAgdGhpcy5fZmxvYXQgPSBvcHRzLmZsb2F0O1xuICAgICAgICB0aGlzLm5vZGVzID0gb3B0cy5ub2RlcyB8fCBbXTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9wdHMub25DaGFuZ2U7XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlKGZsYWcgPSB0cnVlLCBkb1BhY2sgPSB0cnVlKSB7XG4gICAgICAgIGlmICghIXRoaXMuYmF0Y2hNb2RlID09PSBmbGFnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuYmF0Y2hNb2RlID0gZmxhZztcbiAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZGbG9hdCA9IHRoaXMuX2Zsb2F0O1xuICAgICAgICAgICAgdGhpcy5fZmxvYXQgPSB0cnVlOyAvLyBsZXQgdGhpbmdzIGdvIGFueXdoZXJlIGZvciBub3cuLi4gd2lsbCByZXN0b3JlIGFuZCBwb3NzaWJseSByZXBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICB0aGlzLmNsZWFuTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUluaXRpYWwoKTsgLy8gc2luY2UgYmVnaW4gdXBkYXRlICh3aGljaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMpIHdvbid0IGRvIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Zsb2F0ID0gdGhpcy5fcHJldkZsb2F0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZGbG9hdDtcbiAgICAgICAgICAgIGlmIChkb1BhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFja05vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gdXNlIGVudGlyZSByb3cgZm9yIGhpdHRpbmcgYXJlYSAod2lsbCB1c2UgYm90dG9tIHJldmVyc2Ugc29ydGVkIGZpcnN0KSBpZiB3ZSBub3QgYWN0aXZlbHkgbW92aW5nIERPV04gYW5kIGRpZG4ndCBhbHJlYWR5IHNraXBcbiAgICBfdXNlRW50aXJlUm93QXJlYShub2RlLCBubikge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmZsb2F0IHx8IHRoaXMuYmF0Y2hNb2RlICYmICF0aGlzLl9wcmV2RmxvYXQpICYmICF0aGlzLl9oYXNMb2NrZWQgJiYgKCFub2RlLl9tb3ZpbmcgfHwgbm9kZS5fc2tpcERvd24gfHwgbm4ueSA8PSBub2RlLnkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGZpeCBjb2xsaXNpb24gb24gZ2l2ZW4gJ25vZGUnLCBnb2luZyB0byBnaXZlbiBuZXcgbG9jYXRpb24gJ25uJywgd2l0aCBvcHRpb25hbCAnY29sbGlkZScgbm9kZSBhbHJlYWR5IGZvdW5kLlxuICAgICAqIHJldHVybiB0cnVlIGlmIHdlIG1vdmVkLiAqL1xuICAgIF9maXhDb2xsaXNpb25zKG5vZGUsIG5uID0gbm9kZSwgY29sbGlkZSwgb3B0ID0ge30pIHtcbiAgICAgICAgdGhpcy5zb3J0Tm9kZXMoLTEpOyAvLyBmcm9tIGxhc3QgdG8gZmlyc3QsIHNvIHJlY3Vyc2l2ZSBjb2xsaXNpb24gbW92ZSBpdGVtcyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgY29sbGlkZSA9IGNvbGxpZGUgfHwgdGhpcy5jb2xsaWRlKG5vZGUsIG5uKTsgLy8gUkVBTCBhcmVhIGNvbGxpZGUgZm9yIHN3YXAgYW5kIHNraXAgaWYgbm9uZS4uLlxuICAgICAgICBpZiAoIWNvbGxpZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHN3YXAgY2hlY2s6IGlmIHdlJ3JlIGFjdGl2ZWx5IG1vdmluZyBpbiBncmF2aXR5IG1vZGUsIHNlZSBpZiB3ZSBjb2xsaWRlIHdpdGggYW4gb2JqZWN0IHRoZSBzYW1lIHNpemVcbiAgICAgICAgaWYgKG5vZGUuX21vdmluZyAmJiAhb3B0Lm5lc3RlZCAmJiAhdGhpcy5mbG9hdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3dhcChub2RlLCBjb2xsaWRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgd2hpbGUoKSBjb2xsaXNpb25zIE1BS0UgU1VSRSB0byBjaGVjayBlbnRpcmUgcm93IHNvIGxhcmdlciBpdGVtcyBkb24ndCBsZWFwIGZyb2cgc21hbGwgb25lcyAocHVzaCB0aGVtIGFsbCBkb3duIHN0YXJ0aW5nIGxhc3QgaW4gZ3JpZClcbiAgICAgICAgbGV0IGFyZWEgPSBubjtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUVudGlyZVJvd0FyZWEobm9kZSwgbm4pKSB7XG4gICAgICAgICAgICBhcmVhID0geyB4OiAwLCB3OiB0aGlzLmNvbHVtbiwgeTogbm4ueSwgaDogbm4uaCB9O1xuICAgICAgICAgICAgY29sbGlkZSA9IHRoaXMuY29sbGlkZShub2RlLCBhcmVhLCBvcHQuc2tpcCk7IC8vIGZvcmNlIG5ldyBoaXRcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV3T3B0ID0geyBuZXN0ZWQ6IHRydWUsIHBhY2s6IGZhbHNlIH07XG4gICAgICAgIHdoaWxlIChjb2xsaWRlID0gY29sbGlkZSB8fCB0aGlzLmNvbGxpZGUobm9kZSwgYXJlYSwgb3B0LnNraXApKSB7IC8vIGNvdWxkIGNvbGxpZGUgd2l0aCBtb3JlIHRoYW4gMSBpdGVtLi4uIHNvIHJlcGVhdCBmb3IgZWFjaFxuICAgICAgICAgICAgbGV0IG1vdmVkO1xuICAgICAgICAgICAgLy8gaWYgY29sbGlkaW5nIHdpdGggYSBsb2NrZWQgaXRlbSBPUiBtb3ZpbmcgZG93biB3aXRoIHRvcCBncmF2aXR5IChhbmQgY29sbGlkZSBjb3VsZCBtb3ZlIHVwKSAtPiBza2lwIHBhc3QgdGhlIGNvbGxpZGUsXG4gICAgICAgICAgICAvLyBidXQgcmVtZW1iZXIgdGhhdCBza2lwIGRvd24gc28gd2Ugb25seSBkbyB0aGlzIG9uY2UgKGFuZCBwdXNoIG90aGVycyBvdGhlcndpc2UpLlxuICAgICAgICAgICAgaWYgKGNvbGxpZGUubG9ja2VkIHx8IG5vZGUuX21vdmluZyAmJiAhbm9kZS5fc2tpcERvd24gJiYgbm4ueSA+IG5vZGUueSAmJiAhdGhpcy5mbG9hdCAmJlxuICAgICAgICAgICAgICAgIC8vIGNhbiB0YWtlIHNwYWNlIHdlIGhhZCwgb3IgYmVmb3JlIHdoZXJlIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAgICAgKCF0aGlzLmNvbGxpZGUoY29sbGlkZSwgeyAuLi5jb2xsaWRlLCB5OiBub2RlLnkgfSwgbm9kZSkgfHwgIXRoaXMuY29sbGlkZShjb2xsaWRlLCB7IC4uLmNvbGxpZGUsIHk6IG5uLnkgLSBjb2xsaWRlLmggfSwgbm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fc2tpcERvd24gPSAobm9kZS5fc2tpcERvd24gfHwgbm4ueSA+IG5vZGUueSk7XG4gICAgICAgICAgICAgICAgbW92ZWQgPSB0aGlzLm1vdmVOb2RlKG5vZGUsIHsgLi4ubm4sIHk6IGNvbGxpZGUueSArIGNvbGxpZGUuaCwgLi4ubmV3T3B0IH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlLmxvY2tlZCAmJiBtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5jb3B5UG9zKG5uLCBub2RlKTsgLy8gbW92aW5nIGFmdGVyIGxvY2sgYmVjb21lIG91ciBuZXcgZGVzaXJlZCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29sbGlkZS5sb2NrZWQgJiYgbW92ZWQgJiYgb3B0LnBhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbW92ZWQgYWZ0ZXIgYW5kIHdpbGwgcGFjazogZG8gaXQgbm93IGFuZCBrZWVwIHRoZSBvcmlnaW5hbCBkcm9wIGxvY2F0aW9uLCBidXQgcGFzdCB0aGUgb2xkIGNvbGxpZGUgdG8gc2VlIHdoYXQgZWxzZSB3ZSBtaWdodCBwdXNoIHdheVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgbm4ueSA9IGNvbGxpZGUueSArIGNvbGxpZGUuaDtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuY29weVBvcyhub2RlLCBubik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpZE1vdmUgPSBkaWRNb3ZlIHx8IG1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBjb2xsaWRlIGRvd24gKmFmdGVyKiB3aGVyZSB3ZSB3aWxsIGJlLCBpZ25vcmluZyB3aGVyZSB3ZSBhcmUgbm93IChkb24ndCBjb2xsaWRlIHdpdGggdXMpXG4gICAgICAgICAgICAgICAgbW92ZWQgPSB0aGlzLm1vdmVOb2RlKGNvbGxpZGUsIHsgLi4uY29sbGlkZSwgeTogbm4ueSArIG5uLmgsIHNraXA6IG5vZGUsIC4uLm5ld09wdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlkTW92ZTtcbiAgICAgICAgICAgIH0gLy8gYnJlYWsgaW5mIGxvb3AgaWYgd2UgY291bGRuJ3QgbW92ZSBhZnRlciBhbGwgKGV4OiBtYXhSb3csIGZpeGVkKVxuICAgICAgICAgICAgY29sbGlkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlkTW92ZTtcbiAgICB9XG4gICAgLyoqIHJldHVybiB0aGUgbm9kZXMgdGhhdCBpbnRlcmNlcHQgdGhlIGdpdmVuIG5vZGUuIE9wdGlvbmFsbHkgYSBkaWZmZXJlbnQgYXJlYSBjYW4gYmUgdXNlZCwgYXMgd2VsbCBhcyBhIHNlY29uZCBub2RlIHRvIHNraXAgKi9cbiAgICBjb2xsaWRlKHNraXAsIGFyZWEgPSBza2lwLCBza2lwMikge1xuICAgICAgICBjb25zdCBza2lwSWQgPSBza2lwLl9pZDtcbiAgICAgICAgY29uc3Qgc2tpcDJJZCA9IHNraXAyPy5faWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLl9pZCAhPT0gc2tpcElkICYmIG4uX2lkICE9PSBza2lwMklkICYmIFV0aWxzLmlzSW50ZXJjZXB0ZWQobiwgYXJlYSkpO1xuICAgIH1cbiAgICBjb2xsaWRlQWxsKHNraXAsIGFyZWEgPSBza2lwLCBza2lwMikge1xuICAgICAgICBjb25zdCBza2lwSWQgPSBza2lwLl9pZDtcbiAgICAgICAgY29uc3Qgc2tpcDJJZCA9IHNraXAyPy5faWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmZpbHRlcihuID0+IG4uX2lkICE9PSBza2lwSWQgJiYgbi5faWQgIT09IHNraXAySWQgJiYgVXRpbHMuaXNJbnRlcmNlcHRlZChuLCBhcmVhKSk7XG4gICAgfVxuICAgIC8qKiBkb2VzIGEgcGl4ZWwgY292ZXJhZ2UgY29sbGlzaW9uIGJhc2VkIG9uIHdoZXJlIHdlIHN0YXJ0ZWQsIHJldHVybmluZyB0aGUgbm9kZSB0aGF0IGhhcyB0aGUgbW9zdCBjb3ZlcmFnZSB0aGF0IGlzID41MCUgbWlkIGxpbmUgKi9cbiAgICBkaXJlY3Rpb25Db2xsaWRlQ292ZXJhZ2Uobm9kZSwgbywgY29sbGlkZXMpIHtcbiAgICAgICAgaWYgKCFvLnJlY3QgfHwgIW5vZGUuX3JlY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCByMCA9IG5vZGUuX3JlY3Q7IC8vIHdoZXJlIHN0YXJ0ZWRcbiAgICAgICAgbGV0IHIgPSB7IC4uLm8ucmVjdCB9OyAvLyB3aGVyZSB3ZSBhcmVcbiAgICAgICAgLy8gdXBkYXRlIGRyYWdnZWQgcmVjdCB0byBzaG93IHdoZXJlIGl0J3MgY29taW5nIGZyb20gKGFib3ZlIG9yIGJlbG93LCBldGMuLi4pXG4gICAgICAgIGlmIChyLnkgPiByMC55KSB7XG4gICAgICAgICAgICByLmggKz0gci55IC0gcjAueTtcbiAgICAgICAgICAgIHIueSA9IHIwLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByLmggKz0gcjAueSAtIHIueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci54ID4gcjAueCkge1xuICAgICAgICAgICAgci53ICs9IHIueCAtIHIwLng7XG4gICAgICAgICAgICByLnggPSByMC54O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgci53ICs9IHIwLnggLSByLng7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbGxpZGU7XG4gICAgICAgIGxldCBvdmVyTWF4ID0gMC41OyAvLyBuZWVkID41MCVcbiAgICAgICAgY29sbGlkZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmIChuLmxvY2tlZCB8fCAhbi5fcmVjdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcjIgPSBuLl9yZWN0OyAvLyBvdmVybGFwcGluZyB0YXJnZXRcbiAgICAgICAgICAgIGxldCB5T3ZlciA9IE51bWJlci5NQVhfVkFMVUUsIHhPdmVyID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHdlIHN0YXJ0ZWQgZnJvbSwgY29tcHV0ZSB0aGUgb3ZlcmxhcCAlIG9mIGNvdmVyYWdlXG4gICAgICAgICAgICAvLyAoZXg6IGZyb20gYWJvdmUvYmVsb3cgd2Ugb25seSBjb21wdXRlIHRoZSBtYXggaG9yaXpvbnRhbCBsaW5lIGNvdmVyYWdlKVxuICAgICAgICAgICAgaWYgKHIwLnkgPCByMi55KSB7IC8vIGZyb20gYWJvdmVcbiAgICAgICAgICAgICAgICB5T3ZlciA9ICgoci55ICsgci5oKSAtIHIyLnkpIC8gcjIuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIwLnkgKyByMC5oID4gcjIueSArIHIyLmgpIHsgLy8gZnJvbSBiZWxvd1xuICAgICAgICAgICAgICAgIHlPdmVyID0gKChyMi55ICsgcjIuaCkgLSByLnkpIC8gcjIuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMC54IDwgcjIueCkgeyAvLyBmcm9tIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgeE92ZXIgPSAoKHIueCArIHIudykgLSByMi54KSAvIHIyLnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyMC54ICsgcjAudyA+IHIyLnggKyByMi53KSB7IC8vIGZyb20gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgeE92ZXIgPSAoKHIyLnggKyByMi53KSAtIHIueCkgLyByMi53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG92ZXIgPSBNYXRoLm1pbih4T3ZlciwgeU92ZXIpO1xuICAgICAgICAgICAgaWYgKG92ZXIgPiBvdmVyTWF4KSB7XG4gICAgICAgICAgICAgICAgb3Zlck1heCA9IG92ZXI7XG4gICAgICAgICAgICAgICAgY29sbGlkZSA9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvLmNvbGxpZGUgPSBjb2xsaWRlOyAvLyBzYXZlIGl0IHNvIHdlIGRvbid0IGhhdmUgdG8gZmluZCBpdCBhZ2FpblxuICAgICAgICByZXR1cm4gY29sbGlkZTtcbiAgICB9XG4gICAgLyoqIGRvZXMgYSBwaXhlbCBjb3ZlcmFnZSByZXR1cm5pbmcgdGhlIG5vZGUgdGhhdCBoYXMgdGhlIG1vc3QgY292ZXJhZ2UgYnkgYXJlYSAqL1xuICAgIC8qXG4gICAgcHJvdGVjdGVkIGNvbGxpZGVDb3ZlcmFnZShyOiBHcmlkU3RhY2tQb3NpdGlvbiwgY29sbGlkZXM6IEdyaWRTdGFja05vZGVbXSk6IHtjb2xsaWRlOiBHcmlkU3RhY2tOb2RlLCBvdmVyOiBudW1iZXJ9IHtcbiAgICAgIGxldCBjb2xsaWRlOiBHcmlkU3RhY2tOb2RlO1xuICAgICAgbGV0IG92ZXJNYXggPSAwO1xuICAgICAgY29sbGlkZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgaWYgKG4ubG9ja2VkIHx8ICFuLl9yZWN0KSByZXR1cm47XG4gICAgICAgIGxldCBvdmVyID0gVXRpbHMuYXJlYUludGVyY2VwdChyLCBuLl9yZWN0KTtcbiAgICAgICAgaWYgKG92ZXIgPiBvdmVyTWF4KSB7XG4gICAgICAgICAgb3Zlck1heCA9IG92ZXI7XG4gICAgICAgICAgY29sbGlkZSA9IG47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtjb2xsaWRlLCBvdmVyOiBvdmVyTWF4fTtcbiAgICB9XG4gICAgKi9cbiAgICAvKiogY2FsbGVkIHRvIGNhY2hlIHRoZSBub2RlcyBwaXhlbCByZWN0YW5nbGVzIHVzZWQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24gZHVyaW5nIGRyYWcgKi9cbiAgICBjYWNoZVJlY3RzKHcsIGgsIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobiA9PiBuLl9yZWN0ID0ge1xuICAgICAgICAgICAgeTogbi55ICogaCArIHRvcCxcbiAgICAgICAgICAgIHg6IG4ueCAqIHcgKyBsZWZ0LFxuICAgICAgICAgICAgdzogbi53ICogdyAtIGxlZnQgLSByaWdodCxcbiAgICAgICAgICAgIGg6IG4uaCAqIGggLSB0b3AgLSBib3R0b21cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogY2FsbGVkIHRvIHBvc3NpYmx5IHN3YXAgYmV0d2VlbiAyIG5vZGVzIChzYW1lIHNpemUgb3IgY29sdW1uLCBub3QgbG9ja2VkLCB0b3VjaGluZyksIHJldHVybmluZyB0cnVlIGlmIHN1Y2Nlc3NmdWwgKi9cbiAgICBzd2FwKGEsIGIpIHtcbiAgICAgICAgaWYgKCFiIHx8IGIubG9ja2VkIHx8ICFhIHx8IGEubG9ja2VkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBfZG9Td2FwKCkge1xuICAgICAgICAgICAgbGV0IHggPSBiLngsIHkgPSBiLnk7XG4gICAgICAgICAgICBiLnggPSBhLng7XG4gICAgICAgICAgICBiLnkgPSBhLnk7IC8vIGIgLT4gYSBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKGEuaCAhPSBiLmgpIHtcbiAgICAgICAgICAgICAgICBhLnggPSB4O1xuICAgICAgICAgICAgICAgIGEueSA9IGIueSArIGIuaDsgLy8gYSAtPiBnb2VzIGFmdGVyIGJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEudyAhPSBiLncpIHtcbiAgICAgICAgICAgICAgICBhLnggPSBiLnggKyBiLnc7XG4gICAgICAgICAgICAgICAgYS55ID0geTsgLy8gYSAtPiBnb2VzIGFmdGVyIGJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEueCA9IHg7XG4gICAgICAgICAgICAgICAgYS55ID0geTsgLy8gYSAtPiBvbGQgYiBwb3NpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS5fZGlydHkgPSBiLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG91Y2hpbmc7IC8vIHJlbWVtYmVyIGlmIHdlIGNhbGxlZCBpdCAodnMgdW5kZWZpbmVkKVxuICAgICAgICAvLyBzYW1lIHNpemUgYW5kIHNhbWUgcm93IG9yIGNvbHVtbiwgYW5kIHRvdWNoaW5nXG4gICAgICAgIGlmIChhLncgPT09IGIudyAmJiBhLmggPT09IGIuaCAmJiAoYS54ID09PSBiLnggfHwgYS55ID09PSBiLnkpICYmICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKVxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgaWYgKHRvdWNoaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjsgLy8gSUZGIHJhbiB0ZXN0IGFuZCBmYWlsLCBiYWlsIG91dFxuICAgICAgICAvLyBjaGVjayBmb3IgdGFraW5nIHNhbWUgY29sdW1ucyAoYnV0IGRpZmZlcmVudCBoZWlnaHQpIGFuZCB0b3VjaGluZ1xuICAgICAgICBpZiAoYS53ID09PSBiLncgJiYgYS54ID09PSBiLnggJiYgKHRvdWNoaW5nIHx8ICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKSkge1xuICAgICAgICAgICAgaWYgKGIueSA8IGEueSkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdDtcbiAgICAgICAgICAgIH0gLy8gc3dhcCBhIDwtPiBiIHZhcnMgc28gYSBpcyBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBjaGVjayBpZiB0YWtpbmcgc2FtZSByb3cgKGJ1dCBkaWZmZXJlbnQgd2lkdGgpIGFuZCB0b3VjaGluZ1xuICAgICAgICBpZiAoYS5oID09PSBiLmggJiYgYS55ID09PSBiLnkgJiYgKHRvdWNoaW5nIHx8ICh0b3VjaGluZyA9IFV0aWxzLmlzVG91Y2hpbmcoYSwgYikpKSkge1xuICAgICAgICAgICAgaWYgKGIueCA8IGEueCkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdDtcbiAgICAgICAgICAgIH0gLy8gc3dhcCBhIDwtPiBiIHZhcnMgc28gYSBpcyBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIF9kb1N3YXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQXJlYUVtcHR5KHgsIHksIHcsIGgpIHtcbiAgICAgICAgbGV0IG5uID0geyB4OiB4IHx8IDAsIHk6IHkgfHwgMCwgdzogdyB8fCAxLCBoOiBoIHx8IDEgfTtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbGxpZGUobm4pO1xuICAgIH1cbiAgICAvKiogcmUtbGF5b3V0IGdyaWQgaXRlbXMgdG8gcmVjbGFpbSBhbnkgZW1wdHkgc3BhY2UgLSBvcHRpb25hbGx5IGtlZXBpbmcgdGhlIHNvcnQgb3JkZXIgZXhhY3RseSB0aGUgc2FtZSAoJ2xpc3QnIG1vZGUpIHZzIHRydWx5IGZpbmRpbmcgYW4gZW1wdHkgc3BhY2VzICovXG4gICAgY29tcGFjdChsYXlvdXQgPSAnY29tcGFjdCcsIGRvU29ydCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChkb1NvcnQpXG4gICAgICAgICAgICB0aGlzLnNvcnROb2RlcygpO1xuICAgICAgICBjb25zdCB3YXNCYXRjaCA9IHRoaXMuYmF0Y2hNb2RlO1xuICAgICAgICBpZiAoIXdhc0JhdGNoKVxuICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpO1xuICAgICAgICBjb25zdCB3YXNDb2x1bW5SZXNpemUgPSB0aGlzLl9pbkNvbHVtblJlc2l6ZTtcbiAgICAgICAgaWYgKCF3YXNDb2x1bW5SZXNpemUpXG4gICAgICAgICAgICB0aGlzLl9pbkNvbHVtblJlc2l6ZSA9IHRydWU7IC8vIGZhc3RlciBhZGROb2RlKClcbiAgICAgICAgbGV0IGNvcHlOb2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTsgLy8gcHJldGVuZCB3ZSBoYXZlIG5vIG5vZGVzIHRvIGNvbmZsaWN0IGxheW91dCB0byBzdGFydCB3aXRoLi4uXG4gICAgICAgIGNvcHlOb2Rlcy5mb3JFYWNoKChuLCBpbmRleCwgbGlzdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFmdGVyO1xuICAgICAgICAgICAgaWYgKCFuLmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIG4uYXV0b1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnbGlzdCcgJiYgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gbGlzdFtpbmRleCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGROb2RlKG4sIGZhbHNlLCBhZnRlcik7IC8vICdmYWxzZScgZm9yIGFkZCBldmVudCB0cmlnZ2VyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdhc0NvbHVtblJlc2l6ZSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbkNvbHVtblJlc2l6ZTtcbiAgICAgICAgaWYgKCF3YXNCYXRjaClcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIGVuYWJsZS9kaXNhYmxlIGZsb2F0aW5nIHdpZGdldHMgKGRlZmF1bHQ6IGBmYWxzZWApIFNlZSBbZXhhbXBsZV0oaHR0cDovL2dyaWRzdGFja2pzLmNvbS9kZW1vL2Zsb2F0Lmh0bWwpICovXG4gICAgc2V0IGZsb2F0KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5fZmxvYXQgPT09IHZhbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZmxvYXQgPSB2YWwgfHwgZmFsc2U7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKS5fbm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGZsb2F0IGdldHRlciBtZXRob2QgKi9cbiAgICBnZXQgZmxvYXQoKSB7IHJldHVybiB0aGlzLl9mbG9hdCB8fCBmYWxzZTsgfVxuICAgIC8qKiBzb3J0IHRoZSBub2RlcyBhcnJheSBmcm9tIGZpcnN0IHRvIGxhc3QsIG9yIHJldmVyc2UuIENhbGxlZCBkdXJpbmcgY29sbGlzaW9uL3BsYWNlbWVudCB0byBmb3JjZSBhbiBvcmRlciAqL1xuICAgIHNvcnROb2RlcyhkaXIgPSAxLCBjb2x1bW4gPSB0aGlzLmNvbHVtbikge1xuICAgICAgICB0aGlzLm5vZGVzID0gVXRpbHMuc29ydCh0aGlzLm5vZGVzLCBkaXIsIGNvbHVtbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byB0b3AgZ3Jhdml0eSBwYWNrIHRoZSBpdGVtcyBiYWNrIE9SIHJldmVydCBiYWNrIHRvIG9yaWdpbmFsIFkgcG9zaXRpb25zIHdoZW4gZmxvYXRpbmcgKi9cbiAgICBfcGFja05vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5iYXRjaE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydE5vZGVzKCk7IC8vIGZpcnN0IHRvIGxhc3RcbiAgICAgICAgaWYgKHRoaXMuZmxvYXQpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgWSBwb3NcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobi5fdXBkYXRpbmcgfHwgbi5fb3JpZyA9PT0gdW5kZWZpbmVkIHx8IG4ueSA9PT0gbi5fb3JpZy55KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IG5ld1kgPSBuLnk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1kgPiBuLl9vcmlnLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1uZXdZO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlkZSA9IHRoaXMuY29sbGlkZShuLCB7IHg6IG4ueCwgeTogbmV3WSwgdzogbi53LCBoOiBuLmggfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi55ID0gbmV3WTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9wIGdyYXZpdHkgcGFja1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKChuLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG4ubG9ja2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4ueSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1kgPSBpID09PSAwID8gMCA6IG4ueSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYW5CZU1vdmVkID0gaSA9PT0gMCB8fCAhdGhpcy5jb2xsaWRlKG4sIHsgeDogbi54LCB5OiBuZXdZLCB3OiBuLncsIGg6IG4uaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5CZU1vdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IG11c3QgYmUgZGlydHkgKGZyb20gbGFzdCBwb3NpdGlvbikgZm9yIEdyaWRTdGFjazo6T25DaGFuZ2UgQ0IgdG8gdXBkYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdGVtcyBiYWNrLiBUaGUgdXNlciAnY2hhbmdlJyBDQiBzaG91bGQgZGV0ZWN0IGNoYW5nZXMgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgcG9zaXRpb24gaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgbi5fZGlydHkgPSAobi55ICE9PSBuZXdZKTtcbiAgICAgICAgICAgICAgICAgICAgbi55ID0gbmV3WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSByYW5kb20gbm9kZSwgbWFrZXMgc3VyZSBpdCdzIGNvb3JkaW5hdGVzL3ZhbHVlcyBhcmUgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZ3JpZFxuICAgICAqIEBwYXJhbSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSByZXNpemluZyBpZiBvdXQgb2YgYm91bmQsIHJlc2l6ZSBkb3duIG9yIG1vdmUgaW50byB0aGUgZ3JpZCB0byBmaXQgP1xuICAgICAqL1xuICAgIHByZXBhcmVOb2RlKG5vZGUsIHJlc2l6aW5nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xuICAgICAgICBub2RlLl9pZCA9IG5vZGUuX2lkID8/IEdyaWRTdGFja0VuZ2luZS5faWRTZXErKztcbiAgICAgICAgLy8gaWYgd2UncmUgbWlzc2luZyBwb3NpdGlvbiwgaGF2ZSB0aGUgZ3JpZCBwb3NpdGlvbiB1cyBhdXRvbWF0aWNhbGx5IChiZWZvcmUgd2Ugc2V0IHRoZW0gdG8gMCwwKVxuICAgICAgICBpZiAobm9kZS54ID09PSB1bmRlZmluZWQgfHwgbm9kZS55ID09PSB1bmRlZmluZWQgfHwgbm9kZS54ID09PSBudWxsIHx8IG5vZGUueSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5hdXRvUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2lnbiBkZWZhdWx0cyBmb3IgbWlzc2luZyByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgbGV0IGRlZmF1bHRzID0geyB4OiAwLCB5OiAwLCB3OiAxLCBoOiAxIH07XG4gICAgICAgIFV0aWxzLmRlZmF1bHRzKG5vZGUsIGRlZmF1bHRzKTtcbiAgICAgICAgaWYgKCFub2RlLmF1dG9Qb3NpdGlvbikge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuYXV0b1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub1Jlc2l6ZSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubm9SZXNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vTW92ZSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubm9Nb3ZlO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzLnNhbml0aXplTWluTWF4KG5vZGUpO1xuICAgICAgICAvLyBjaGVjayBmb3IgTmFOIChpbiBjYXNlIG1lc3NlZCB1cCBzdHJpbmdzIHdlcmUgcGFzc2VkLiBjYW4ndCBkbyBwYXJzZUludCgpIHx8IGRlZmF1bHRzLnggYWJvdmUgYXMgMCBpcyB2YWxpZCAjKVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUueCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9kZS54ID0gTnVtYmVyKG5vZGUueCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLnkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IE51bWJlcihub2RlLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS53ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlLncgPSBOdW1iZXIobm9kZS53KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUuaCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9kZS5oID0gTnVtYmVyKG5vZGUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUueCkpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IGRlZmF1bHRzLng7XG4gICAgICAgICAgICBub2RlLmF1dG9Qb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IGRlZmF1bHRzLnk7XG4gICAgICAgICAgICBub2RlLmF1dG9Qb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUudykpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IGRlZmF1bHRzLnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG5vZGUuaCkpIHtcbiAgICAgICAgICAgIG5vZGUuaCA9IGRlZmF1bHRzLmg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUJvdW5kRml4KG5vZGUsIHJlc2l6aW5nKTtcbiAgICB9XG4gICAgLyoqIHBhcnQyIG9mIHByZXBhcmluZyBhIG5vZGUgdG8gZml0IGluc2lkZSBvdXIgZ3JpZCAtIGNoZWNrcyBmb3IgeCx5LHcgZnJvbSBncmlkIGRpbWVuc2lvbnMgKi9cbiAgICBub2RlQm91bmRGaXgobm9kZSwgcmVzaXppbmcpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuX29yaWcgfHwgVXRpbHMuY29weVBvcyh7fSwgbm9kZSk7XG4gICAgICAgIGlmIChub2RlLm1heFcpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IE1hdGgubWluKG5vZGUudywgbm9kZS5tYXhXKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5tYXhIKSB7XG4gICAgICAgICAgICBub2RlLmggPSBNYXRoLm1pbihub2RlLmgsIG5vZGUubWF4SCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubWluVyAmJiBub2RlLm1pblcgPD0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIG5vZGUudyA9IE1hdGgubWF4KG5vZGUudywgbm9kZS5taW5XKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5taW5IKSB7XG4gICAgICAgICAgICBub2RlLmggPSBNYXRoLm1heChub2RlLmgsIG5vZGUubWluSCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBsb2FkZWQgYSBsYXJnZXIgdGhhbiBhbGxvd2VkIHdpZGdldCBmb3IgY3VycmVudCAjIG9mIGNvbHVtbnMsXG4gICAgICAgIC8vIHJlbWVtYmVyIGl0J3MgcG9zaXRpb24gJiB3aWR0aCBzbyB3ZSBjYW4gcmVzdG9yZSBiYWNrICgxIC0+IDEyIGNvbHVtbikgIzE2NTUgIzE5ODVcbiAgICAgICAgLy8gSUZGIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGNvbHVtbiByZXNpemluZyFcbiAgICAgICAgY29uc3Qgc2F2ZU9yaWcgPSAobm9kZS54IHx8IDApICsgKG5vZGUudyB8fCAxKSA+IHRoaXMuY29sdW1uO1xuICAgICAgICBpZiAoc2F2ZU9yaWcgJiYgdGhpcy5jb2x1bW4gPCAxMiAmJiAhdGhpcy5faW5Db2x1bW5SZXNpemUgJiYgbm9kZS5faWQgJiYgdGhpcy5maW5kQ2FjaGVMYXlvdXQobm9kZSwgMTIpID09PSAtMSkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSB7IC4uLm5vZGUgfTsgLy8gbmVlZCBfaWQgKyBwb3NpdGlvbnNcbiAgICAgICAgICAgIGlmIChjb3B5LmF1dG9Qb3NpdGlvbiB8fCBjb3B5LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb3B5Lng7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvcHkueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb3B5LnggPSBNYXRoLm1pbigxMSwgY29weS54KTtcbiAgICAgICAgICAgIGNvcHkudyA9IE1hdGgubWluKDEyLCBjb3B5LncgfHwgMSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlT25lTGF5b3V0KGNvcHksIDEyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS53ID4gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIG5vZGUudyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudyA8IDEpIHtcbiAgICAgICAgICAgIG5vZGUudyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4Um93ICYmIG5vZGUuaCA+IHRoaXMubWF4Um93KSB7XG4gICAgICAgICAgICBub2RlLmggPSB0aGlzLm1heFJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLmggPCAxKSB7XG4gICAgICAgICAgICBub2RlLmggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnggPCAwKSB7XG4gICAgICAgICAgICBub2RlLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnkgPCAwKSB7XG4gICAgICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnggKyBub2RlLncgPiB0aGlzLmNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgbm9kZS53ID0gdGhpcy5jb2x1bW4gLSBub2RlLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSB0aGlzLmNvbHVtbiAtIG5vZGUudztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhSb3cgJiYgbm9kZS55ICsgbm9kZS5oID4gdGhpcy5tYXhSb3cpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemluZykge1xuICAgICAgICAgICAgICAgIG5vZGUuaCA9IHRoaXMubWF4Um93IC0gbm9kZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gdGhpcy5tYXhSb3cgLSBub2RlLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVdGlscy5zYW1lUG9zKG5vZGUsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqIHJldHVybnMgYSBsaXN0IG9mIG1vZGlmaWVkIG5vZGVzIGZyb20gdGhlaXIgb3JpZ2luYWwgdmFsdWVzICovXG4gICAgZ2V0RGlydHlOb2Rlcyh2ZXJpZnkpIHtcbiAgICAgICAgLy8gY29tcGFyZSBvcmlnaW5hbCB4LHksdyxoIGluc3RlYWQgYXMgX2RpcnR5IGNhbiBiZSBhIHRlbXBvcmFyeSBzdGF0ZVxuICAgICAgICBpZiAodmVyaWZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5maWx0ZXIobiA9PiBuLl9kaXJ0eSAmJiAhVXRpbHMuc2FtZVBvcyhuLCBuLl9vcmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuZmlsdGVyKG4gPT4gbi5fZGlydHkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGwgdGhpcyB0byBjYWxsIG9uQ2hhbmdlIGNhbGxiYWNrIHdpdGggZGlydHkgbm9kZXMgc28gRE9NIGNhbiBiZSB1cGRhdGVkICovXG4gICAgX25vdGlmeShyZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hNb2RlIHx8ICF0aGlzLm9uQ2hhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBkaXJ0eU5vZGVzID0gKHJlbW92ZWROb2RlcyB8fCBbXSkuY29uY2F0KHRoaXMuZ2V0RGlydHlOb2RlcygpKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShkaXJ0eU5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVtb3ZlIGRpcnR5IGFuZCBsYXN0IHRyaWVkIGluZm8gKi9cbiAgICBjbGVhbk5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5iYXRjaE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgZGVsZXRlIG4uX2RpcnR5O1xuICAgICAgICAgICAgZGVsZXRlIG4uX2xhc3RUcmllZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byBzYXZlIGluaXRpYWwgcG9zaXRpb24vc2l6ZSB0byB0cmFjayByZWFsIGRpcnR5IHN0YXRlLlxuICAgICAqIE5vdGU6IHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgY2FsbCBjaGFuZ2UgZXZlbnQgKHNvIG5leHQgQVBJIGlzIGNhbiBkZXRlY3QgY2hhbmdlcylcbiAgICAgKiBhcyB3ZWxsIGFzIHJpZ2h0IGJlZm9yZSB3ZSBzdGFydCBtb3ZlL3Jlc2l6ZS9lbnRlciAoc28gd2UgY2FuIHJlc3RvcmUgaXRlbXMgdG8gcHJldiB2YWx1ZXMpICovXG4gICAgc2F2ZUluaXRpYWwoKSB7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIG4uX29yaWcgPSBVdGlscy5jb3B5UG9zKHt9LCBuKTtcbiAgICAgICAgICAgIGRlbGV0ZSBuLl9kaXJ0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2hhc0xvY2tlZCA9IHRoaXMubm9kZXMuc29tZShuID0+IG4ubG9ja2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcmVzdG9yZSBhbGwgdGhlIG5vZGVzIGJhY2sgdG8gaW5pdGlhbCB2YWx1ZXMgKGNhbGxlZCB3aGVuIHdlIGxlYXZlKSAqL1xuICAgIHJlc3RvcmVJbml0aWFsKCkge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuc2FtZVBvcyhuLCBuLl9vcmlnKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBVdGlscy5jb3B5UG9zKG4sIG4uX29yaWcpO1xuICAgICAgICAgICAgbi5fZGlydHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogZmluZCB0aGUgZmlyc3QgYXZhaWxhYmxlIGVtcHR5IHNwb3QgZm9yIHRoZSBnaXZlbiBub2RlIHdpZHRoL2hlaWdodCwgdXBkYXRpbmcgdGhlIHgseSBhdHRyaWJ1dGVzLiByZXR1cm4gdHJ1ZSBpZiBmb3VuZC5cbiAgICAgKiBvcHRpb25hbGx5IHlvdSBjYW4gcGFzcyB5b3VyIG93biBleGlzdGluZyBub2RlIGxpc3QgYW5kIGNvbHVtbiBjb3VudCwgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIHRoYXQgZW5naW5lIGRhdGEuXG4gICAgICogT3B0aW9uYWxseSBwYXNzIGEgd2lkZ2V0IHRvIHN0YXJ0IHNlYXJjaCBBRlRFUiwgbWVhbmluZyB0aGUgb3JkZXIgd2lsbCByZW1haW4gdGhlIHNhbWUgYnV0IHBvc3NpYmx5IGhhdmUgZW1wdHkgc2xvdHMgd2Ugc2tpcHBlZFxuICAgICAqL1xuICAgIGZpbmRFbXB0eVBvc2l0aW9uKG5vZGUsIG5vZGVMaXN0ID0gdGhpcy5ub2RlcywgY29sdW1uID0gdGhpcy5jb2x1bW4sIGFmdGVyKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGFmdGVyID8gYWZ0ZXIueSAqIGNvbHVtbiArIChhZnRlci54ICsgYWZ0ZXIudykgOiAwO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyAhZm91bmQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHggPSBpICUgY29sdW1uO1xuICAgICAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKGkgLyBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKHggKyBub2RlLncgPiBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBib3ggPSB7IHgsIHksIHc6IG5vZGUudywgaDogbm9kZS5oIH07XG4gICAgICAgICAgICBpZiAoIW5vZGVMaXN0LmZpbmQobiA9PiBVdGlscy5pc0ludGVyY2VwdGVkKGJveCwgbikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUueCAhPT0geCB8fCBub2RlLnkgIT09IHkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnggPSB4O1xuICAgICAgICAgICAgICAgIG5vZGUueSA9IHk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuYXV0b1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKiBjYWxsIHRvIGFkZCB0aGUgZ2l2ZW4gbm9kZSB0byBvdXIgbGlzdCwgZml4aW5nIGNvbGxpc2lvbiBhbmQgcmUtcGFja2luZyAqL1xuICAgIGFkZE5vZGUobm9kZSwgdHJpZ2dlckFkZEV2ZW50ID0gZmFsc2UsIGFmdGVyKSB7XG4gICAgICAgIGxldCBkdXAgPSB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLl9pZCA9PT0gbm9kZS5faWQpO1xuICAgICAgICBpZiAoZHVwKVxuICAgICAgICAgICAgcmV0dXJuIGR1cDsgLy8gcHJldmVudCBpbnNlcnRpbmcgdHdpY2UhIHJldHVybiBpdCBpbnN0ZWFkLlxuICAgICAgICAvLyBza2lwIHByZXBhcmVOb2RlIGlmIHdlJ3JlIGluIG1pZGRsZSBvZiBjb2x1bW4gcmVzaXplIChub3QgbmV3KSBidXQgZG8gY2hlY2sgZm9yIGJvdW5kcyFcbiAgICAgICAgbm9kZSA9IHRoaXMuX2luQ29sdW1uUmVzaXplID8gdGhpcy5ub2RlQm91bmRGaXgobm9kZSkgOiB0aGlzLnByZXBhcmVOb2RlKG5vZGUpO1xuICAgICAgICBkZWxldGUgbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZDtcbiAgICAgICAgZGVsZXRlIG5vZGUuX3JlbW92ZURPTTtcbiAgICAgICAgbGV0IHNraXBDb2xsaXNpb247XG4gICAgICAgIGlmIChub2RlLmF1dG9Qb3NpdGlvbiAmJiB0aGlzLmZpbmRFbXB0eVBvc2l0aW9uKG5vZGUsIHRoaXMubm9kZXMsIHRoaXMuY29sdW1uLCBhZnRlcikpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmF1dG9Qb3NpdGlvbjsgLy8gZm91bmQgb3VyIHNsb3RcbiAgICAgICAgICAgIHNraXBDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKHRyaWdnZXJBZGRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5hZGRlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwQ29sbGlzaW9uKVxuICAgICAgICAgICAgdGhpcy5fZml4Q29sbGlzaW9ucyhub2RlKTtcbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fcGFja05vZGVzKCkuX25vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUsIHJlbW92ZURPTSA9IHRydWUsIHRyaWdnZXJFdmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5faWQgPT09IG5vZGUuX2lkKSkge1xuICAgICAgICAgICAgLy8gVEVTVCBjb25zb2xlLmxvZyhgRXJyb3I6IEdyaWRTdGFja0VuZ2luZS5yZW1vdmVOb2RlKCkgbm9kZS5faWQ9JHtub2RlLl9pZH0gbm90IGZvdW5kIWApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlckV2ZW50KSB7IC8vIHdlIHdhaXQgdW50aWwgZmluYWwgZHJvcCB0byBtYW51YWxseSB0cmFjayByZW1vdmVkIGl0ZW1zIChyYXRoZXIgdGhhbiBkdXJpbmcgZHJhZylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZURPTSlcbiAgICAgICAgICAgIG5vZGUuX3JlbW92ZURPTSA9IHRydWU7IC8vIGxldCBDQiByZW1vdmUgYWN0dWFsIEhUTUwgKHVzZWQgdG8gc2V0IF9pZCB0byBudWxsLCBidXQgdGhlbiB3ZSBsb29zZSBsYXlvdXQgaW5mbylcbiAgICAgICAgLy8gZG9uJ3QgdXNlICdmYXN0ZXInIC5zcGxpY2UoZmluZEluZGV4KCksMSkgaW4gY2FzZSBub2RlIGlzbid0IGluIG91ciBsaXN0LCBvciBpbiBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKG4gPT4gbi5faWQgIT09IG5vZGUuX2lkKTtcbiAgICAgICAgaWYgKCFub2RlLl9pc0Fib3V0VG9SZW1vdmUpXG4gICAgICAgICAgICB0aGlzLl9wYWNrTm9kZXMoKTsgLy8gaWYgZHJhZ2dlZCBvdXQsIG5vIG5lZWQgdG8gcmVsYXlvdXQgYXMgYWxyZWFkeSBkb25lLi4uXG4gICAgICAgIHRoaXMuX25vdGlmeShbbm9kZV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsKHJlbW92ZURPTSA9IHRydWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheW91dHM7XG4gICAgICAgIGlmICghdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmVtb3ZlRE9NICYmIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IG4uX3JlbW92ZURPTSA9IHRydWUpOyAvLyBsZXQgQ0IgcmVtb3ZlIGFjdHVhbCBIVE1MICh1c2VkIHRvIHNldCBfaWQgdG8gbnVsbCwgYnV0IHRoZW4gd2UgbG9vc2UgbGF5b3V0IGluZm8pXG4gICAgICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm90aWZ5KHRoaXMucmVtb3ZlZE5vZGVzKTtcbiAgICB9XG4gICAgLyoqIGNoZWNrcyBpZiBpdGVtIGNhbiBiZSBtb3ZlZCAobGF5b3V0IGNvbnN0cmFpbikgdnMgbW92ZU5vZGUoKSwgcmV0dXJuaW5nIHRydWUgaWYgd2FzIGFibGUgdG8gbW92ZS5cbiAgICAgKiBJbiBtb3JlIGNvbXBsaWNhdGVkIGNhc2VzIChtYXhSb3cpIGl0IHdpbGwgYXR0ZW1wdCBhdCBtb3ZpbmcgdGhlIGl0ZW0gYW5kIGZpeGluZ1xuICAgICAqIG90aGVycyBpbiBhIGNsb25lIGZpcnN0LCB0aGVuIGFwcGx5IHRob3NlIGNoYW5nZXMgaWYgc3RpbGwgd2l0aGluIHNwZWNzLiAqL1xuICAgIG1vdmVOb2RlQ2hlY2sobm9kZSwgbykge1xuICAgICAgICAvLyBpZiAobm9kZS5sb2NrZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5nZWRQb3NDb25zdHJhaW4obm9kZSwgbykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG8ucGFjayA9IHRydWU7XG4gICAgICAgIC8vIHNpbXBsZXIgY2FzZTogbW92ZSBpdGVtIGRpcmVjdGx5Li4uXG4gICAgICAgIGlmICghdGhpcy5tYXhSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVOb2RlKG5vZGUsIG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBsZXggY2FzZTogY3JlYXRlIGEgY2xvbmUgd2l0aCBOTyBtYXhSb3cgKHdpbGwgY2hlY2sgZm9yIG91dCBvZiBib3VuZHMgYXQgdGhlIGVuZClcbiAgICAgICAgbGV0IGNsb25lZE5vZGU7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBHcmlkU3RhY2tFbmdpbmUoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0OiB0aGlzLmZsb2F0LFxuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZSA9IHsgLi4ubiB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubiB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2xvbmVkTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UncmUgY292ZXJpbmcgNTAlIGNvbGxpc2lvbiBhbmQgY291bGQgbW92ZSwgd2hpbGUgc3RpbGwgYmVpbmcgdW5kZXIgbWF4Um93IG9yIGF0IGxlYXN0IG5vdCBtYWtpbmcgaXQgd29yc2VcbiAgICAgICAgLy8gKGNhc2Ugd2hlcmUgd2lkZ2V0IHdhcyBzb21laG93IGFkZGVkIHBhc3Qgb3VyIG1heCAjMjQ0OSlcbiAgICAgICAgbGV0IGNhbk1vdmUgPSBjbG9uZS5tb3ZlTm9kZShjbG9uZWROb2RlLCBvKSAmJiBjbG9uZS5nZXRSb3coKSA8PSBNYXRoLm1heCh0aGlzLmdldFJvdygpLCB0aGlzLm1heFJvdyk7XG4gICAgICAgIC8vIGVsc2UgY2hlY2sgaWYgd2UgY2FuIGZvcmNlIGEgc3dhcCAoZmxvYXQ9dHJ1ZSwgb3IgZGlmZmVyZW50IHNoYXBlcykgb24gbm9uLXJlc2l6ZVxuICAgICAgICBpZiAoIWNhbk1vdmUgJiYgIW8ucmVzaXppbmcgJiYgby5jb2xsaWRlKSB7XG4gICAgICAgICAgICBsZXQgY29sbGlkZSA9IG8uY29sbGlkZS5lbC5ncmlkc3RhY2tOb2RlOyAvLyBmaW5kIHRoZSBzb3VyY2Ugbm9kZSB0aGUgY2xvbmUgY29sbGlkZWQgd2l0aCBhdCA1MCVcbiAgICAgICAgICAgIGlmICh0aGlzLnN3YXAobm9kZSwgY29sbGlkZSkpIHsgLy8gc3dhcHMgYW5kIG1hcmsgZGlydHlcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbk1vdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGlmIGNsb25lIHdhcyBhYmxlIHRvIG1vdmUsIGNvcHkgdGhvc2UgbW9kcyBvdmVyIHRvIHVzIG5vdyBpbnN0ZWFkIG9mIGNhbGxlciB0cnlpbmcgdG8gZG8gdGhpcyBhbGwgb3ZlciFcbiAgICAgICAgLy8gTm90ZTogd2UgY2FuJ3QgdXNlIHRoZSBsaXN0IGRpcmVjdGx5IGFzIGVsZW1lbnRzIGFuZCBvdGhlciBwYXJ0cyBwb2ludCB0byBhY3R1YWwgbm9kZSwgc28gY29weSBjb250ZW50XG4gICAgICAgIGNsb25lLm5vZGVzLmZpbHRlcihuID0+IG4uX2RpcnR5KS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLm5vZGVzLmZpbmQoYSA9PiBhLl9pZCA9PT0gYy5faWQpO1xuICAgICAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFV0aWxzLmNvcHlQb3MobiwgYyk7XG4gICAgICAgICAgICBuLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiByZXR1cm4gdHJ1ZSBpZiBjYW4gZml0IGluIGdyaWQgaGVpZ2h0IGNvbnN0cmFpbiBvbmx5IChhbHdheXMgdHJ1ZSBpZiBubyBtYXhSb3cpICovXG4gICAgd2lsbEl0Rml0KG5vZGUpIHtcbiAgICAgICAgZGVsZXRlIG5vZGUuX3dpbGxGaXRQb3M7XG4gICAgICAgIGlmICghdGhpcy5tYXhSb3cpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY2xvbmUgd2l0aCBOTyBtYXhSb3cgYW5kIGNoZWNrIGlmIHN0aWxsIHdpdGhpbiBzaXplXG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBHcmlkU3RhY2tFbmdpbmUoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0OiB0aGlzLmZsb2F0LFxuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMubWFwKG4gPT4geyByZXR1cm4geyAuLi5uIH07IH0pXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbiA9IHsgLi4ubm9kZSB9OyAvLyBjbG9uZSBub2RlIHNvIHdlIGRvbid0IG1vZCBhbnkgc2V0dGluZ3Mgb24gaXQgYnV0IGhhdmUgZnVsbCBhdXRvUG9zaXRpb24gYW5kIG1pbi9tYXggYXMgd2VsbCEgIzE2ODdcbiAgICAgICAgdGhpcy5jbGVhbnVwTm9kZShuKTtcbiAgICAgICAgZGVsZXRlIG4uZWw7XG4gICAgICAgIGRlbGV0ZSBuLl9pZDtcbiAgICAgICAgZGVsZXRlIG4uY29udGVudDtcbiAgICAgICAgZGVsZXRlIG4uZ3JpZDtcbiAgICAgICAgY2xvbmUuYWRkTm9kZShuKTtcbiAgICAgICAgaWYgKGNsb25lLmdldFJvdygpIDw9IHRoaXMubWF4Um93KSB7XG4gICAgICAgICAgICBub2RlLl93aWxsRml0UG9zID0gVXRpbHMuY29weVBvcyh7fSwgbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiB0cnVlIGlmIHgseSBvciB3LGggYXJlIGRpZmZlcmVudCBhZnRlciBjbGFtcGluZyB0byBtaW4vbWF4ICovXG4gICAgY2hhbmdlZFBvc0NvbnN0cmFpbihub2RlLCBwKSB7XG4gICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB3LGggYXJlIHNldCBmb3IgY2FsbGVyXG4gICAgICAgIHAudyA9IHAudyB8fCBub2RlLnc7XG4gICAgICAgIHAuaCA9IHAuaCB8fCBub2RlLmg7XG4gICAgICAgIGlmIChub2RlLnggIT09IHAueCB8fCBub2RlLnkgIT09IHAueSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBjaGVjayBjb25zdHJhaW5lZCB3LGhcbiAgICAgICAgaWYgKG5vZGUubWF4Vykge1xuICAgICAgICAgICAgcC53ID0gTWF0aC5taW4ocC53LCBub2RlLm1heFcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm1heEgpIHtcbiAgICAgICAgICAgIHAuaCA9IE1hdGgubWluKHAuaCwgbm9kZS5tYXhIKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5taW5XKSB7XG4gICAgICAgICAgICBwLncgPSBNYXRoLm1heChwLncsIG5vZGUubWluVyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubWluSCkge1xuICAgICAgICAgICAgcC5oID0gTWF0aC5tYXgocC5oLCBub2RlLm1pbkgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobm9kZS53ICE9PSBwLncgfHwgbm9kZS5oICE9PSBwLmgpO1xuICAgIH1cbiAgICAvKiogcmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBub2RlIHdhcyBhY3R1YWxseSBtb3ZlZCAoY2hlY2tzIGZvciBuby1vcCBhbmQgbG9ja2VkKSAqL1xuICAgIG1vdmVOb2RlKG5vZGUsIG8pIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IC8qbm9kZS5sb2NrZWQgfHwqLyAhbylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHdhc1VuZGVmaW5lZFBhY2s7XG4gICAgICAgIGlmIChvLnBhY2sgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5iYXRjaE1vZGUpIHtcbiAgICAgICAgICAgIHdhc1VuZGVmaW5lZFBhY2sgPSBvLnBhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcGFzc2VkIGluIHZhbHVlcyBhbmQgY2hlY2sgaWYgd2UncmUgc3RpbGwgY2hhbmdpbmcgb3VyIG5vZGVcbiAgICAgICAgaWYgKHR5cGVvZiBvLnggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLnggPSBub2RlLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLnkgPSBub2RlLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLncgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLncgPSBub2RlLnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLmggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvLmggPSBub2RlLmg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc2l6aW5nID0gKG5vZGUudyAhPT0gby53IHx8IG5vZGUuaCAhPT0gby5oKTtcbiAgICAgICAgbGV0IG5uID0gVXRpbHMuY29weVBvcyh7fSwgbm9kZSwgdHJ1ZSk7IC8vIGdldCBtaW4vbWF4IG91dCBmaXJzdCwgdGhlbiBvcHQgcG9zaXRpb25zIG5leHRcbiAgICAgICAgVXRpbHMuY29weVBvcyhubiwgbyk7XG4gICAgICAgIG5uID0gdGhpcy5ub2RlQm91bmRGaXgobm4sIHJlc2l6aW5nKTtcbiAgICAgICAgVXRpbHMuY29weVBvcyhvLCBubik7XG4gICAgICAgIGlmICghby5mb3JjZUNvbGxpZGUgJiYgVXRpbHMuc2FtZVBvcyhub2RlLCBvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHByZXZQb3MgPSBVdGlscy5jb3B5UG9zKHt9LCBub2RlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugd2lsbCBuZWVkIHRvIGZpeCBjb2xsaXNpb24gYXQgb3VyIG5ldyBsb2NhdGlvblxuICAgICAgICBsZXQgY29sbGlkZXMgPSB0aGlzLmNvbGxpZGVBbGwobm9kZSwgbm4sIG8uc2tpcCk7XG4gICAgICAgIGxldCBuZWVkVG9Nb3ZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbGxpZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZURyYWcgPSBub2RlLl9tb3ZpbmcgJiYgIW8ubmVzdGVkO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGNvbGxpZGVkIG92ZXIgNTAlIHN1cmZhY2UgYXJlYSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgbGV0IGNvbGxpZGUgPSBhY3RpdmVEcmFnID8gdGhpcy5kaXJlY3Rpb25Db2xsaWRlQ292ZXJhZ2Uobm9kZSwgbywgY29sbGlkZXMpIDogY29sbGlkZXNbMF07XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBlbmFibGluZyBjcmVhdGlvbiBvZiBzdWItZ3JpZHMgb24gdGhlIGZseSwgc2VlIGlmIHdlJ3JlIGNvdmVyaW5nIDgwJSBvZiBlaXRoZXIgb25lLCBpZiB3ZSBkaWRuJ3QgYWxyZWFkeSBkbyB0aGF0XG4gICAgICAgICAgICBpZiAoYWN0aXZlRHJhZyAmJiBjb2xsaWRlICYmIG5vZGUuZ3JpZD8ub3B0cz8uc3ViR3JpZER5bmFtaWMgJiYgIW5vZGUuZ3JpZC5faXNUZW1wKSB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXIgPSBVdGlscy5hcmVhSW50ZXJjZXB0KG8ucmVjdCwgY29sbGlkZS5fcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IGExID0gVXRpbHMuYXJlYShvLnJlY3QpO1xuICAgICAgICAgICAgICAgIGxldCBhMiA9IFV0aWxzLmFyZWEoY29sbGlkZS5fcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmMgPSBvdmVyIC8gKGExIDwgYTIgPyBhMSA6IGEyKTtcbiAgICAgICAgICAgICAgICBpZiAocGVyYyA+IC44KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGUuZ3JpZC5tYWtlU3ViR3JpZChjb2xsaWRlLmVsLCB1bmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xsaWRlKSB7XG4gICAgICAgICAgICAgICAgbmVlZFRvTW92ZSA9ICF0aGlzLl9maXhDb2xsaXNpb25zKG5vZGUsIG5uLCBjb2xsaWRlLCBvKTsgLy8gY2hlY2sgaWYgYWxyZWFkeSBtb3ZlZC4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZFRvTW92ZSA9IGZhbHNlOyAvLyB3ZSBkaWRuJ3QgY292ZXIgPjUwJSBmb3IgYSBtb3ZlLCBza2lwLi4uXG4gICAgICAgICAgICAgICAgaWYgKHdhc1VuZGVmaW5lZFBhY2spXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvLnBhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IG1vdmUgKHRvIHRoZSBvcmlnaW5hbCBhc2sgdnMgdGhlIGNvbGxpc2lvbiB2ZXJzaW9uIHdoaWNoIG1pZ2h0IGRpZmZlcikgYW5kIHJlcGFjayB0aGluZ3NcbiAgICAgICAgaWYgKG5lZWRUb01vdmUpIHtcbiAgICAgICAgICAgIG5vZGUuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLmNvcHlQb3Mobm9kZSwgbm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLnBhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3BhY2tOb2RlcygpXG4gICAgICAgICAgICAgICAgLl9ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIVV0aWxzLnNhbWVQb3Mobm9kZSwgcHJldlBvcyk7IC8vIHBhY2sgbWlnaHQgaGF2ZSBtb3ZlZCB0aGluZ3MgYmFja1xuICAgIH1cbiAgICBnZXRSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgocm93LCBuKSA9PiBNYXRoLm1heChyb3csIG4ueSArIG4uaCksIDApO1xuICAgIH1cbiAgICBiZWdpblVwZGF0ZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5fdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG5vZGUuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9za2lwRG93bjtcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXRjaE1vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlSW5pdGlhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmRVcGRhdGUoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5fdXBkYXRpbmcpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZGVsZXRlIG4uX3VwZGF0aW5nO1xuICAgICAgICAgICAgZGVsZXRlIG4uX3NraXBEb3duO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogc2F2ZXMgYSBjb3B5IG9mIHRoZSBsYXJnZXN0IGNvbHVtbiBsYXlvdXQgKGVnIDEyIGV2ZW4gd2hlbiByZW5kZXJpbmcgb25lQ29sdW1uTW9kZSkgc28gd2UgZG9uJ3QgbG9vc2Ugb3JpZyBsYXlvdXQsXG4gICAgICogcmV0dXJuaW5nIGEgbGlzdCBvZiB3aWRnZXRzIGZvciBzZXJpYWxpemF0aW9uICovXG4gICAgc2F2ZShzYXZlRWxlbWVudCA9IHRydWUsIHNhdmVDQikge1xuICAgICAgICAvLyB1c2UgdGhlIGhpZ2hlc3QgbGF5b3V0IGZvciBhbnkgc2F2ZWQgaW5mbyBzbyB3ZSBjYW4gaGF2ZSBmdWxsIGRldGFpbCBvbiByZWxvYWQgIzE4NDlcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuX2xheW91dHM/Lmxlbmd0aDtcbiAgICAgICAgbGV0IGxheW91dCA9IGxlbiAmJiB0aGlzLmNvbHVtbiAhPT0gKGxlbiAtIDEpID8gdGhpcy5fbGF5b3V0c1tsZW4gLSAxXSA6IG51bGw7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIHRoaXMuc29ydE5vZGVzKCk7XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGxldCB3bCA9IGxheW91dD8uZmluZChsID0+IGwuX2lkID09PSBuLl9pZCk7XG4gICAgICAgICAgICAvLyB1c2UgbGF5b3V0IGluZm8gZmllbGRzIGluc3RlYWQgaWYgc2V0XG4gICAgICAgICAgICBsZXQgdyA9IHsgLi4ubiwgLi4uKHdsIHx8IHt9KSB9O1xuICAgICAgICAgICAgVXRpbHMucmVtb3ZlSW50ZXJuYWxGb3JTYXZlKHcsICFzYXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2F2ZUNCKVxuICAgICAgICAgICAgICAgIHNhdmVDQihuLCB3KTtcbiAgICAgICAgICAgIGxpc3QucHVzaCh3KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB3aGVuZXZlciBhIG5vZGUgaXMgYWRkZWQgb3IgbW92ZWQgLSB1cGRhdGVzIHRoZSBjYWNoZWQgbGF5b3V0cyAqL1xuICAgIGxheW91dHNOb2Rlc0NoYW5nZShub2Rlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2xheW91dHMgfHwgdGhpcy5faW5Db2x1bW5SZXNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gcmVtb3ZlIHNtYWxsZXIgbGF5b3V0cyAtIHdlIHdpbGwgcmUtZ2VuZXJhdGUgdGhvc2Ugb24gdGhlIGZseS4uLiBsYXJnZXIgb25lcyBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICB0aGlzLl9sYXlvdXRzLmZvckVhY2goKGxheW91dCwgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxheW91dCB8fCBjb2x1bW4gPT09IHRoaXMuY29sdW1uKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbHVtbiA8IHRoaXMuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2F2ZSB0aGUgb3JpZ2luYWwgeCx5LHcgKGggaXNuJ3QgY2FjaGVkKSB0byBzZWUgd2hhdCBhY3R1YWxseSBjaGFuZ2VkIHRvIHByb3BhZ2F0ZSBiZXR0ZXIuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhZ2FpbnN0IG91dCBvZiBib3VuZCBzY2FsaW5nL21vdmluZyBhcyB0aGF0IHdpbGwgYmUgZG9uZSB3aGVuIHVzaW5nIHRob3NlIGNhY2hlIHZhbHVlcy4gIzE3ODVcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSBjb2x1bW4gLyB0aGlzLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuX29yaWcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRpZG4ndCBjaGFuZ2UgKG5ld2x5IGFkZGVkID8pXG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gbGF5b3V0LmZpbmQobCA9PiBsLl9pZCA9PT0gbm9kZS5faWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGNhY2hlIGZvciBuZXcgbm9kZXMuIFdpbGwgdXNlIHRob3NlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gWSBjaGFuZ2VkLCBwdXNoIGRvd24gc2FtZSBhbW91bnRcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGV0ZWN0IGRvaW5nIGl0ZW0gJ3N3YXBzJyB3aWxsIGhlbHAgaW5zdGVhZCBvZiBtb3ZlIChlc3BlY2lhbGx5IGluIDEgY29sdW1uIG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnkgPj0gMCAmJiBub2RlLnkgIT09IG5vZGUuX29yaWcueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi55ICs9IChub2RlLnkgLSBub2RlLl9vcmlnLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFggY2hhbmdlZCwgc2NhbGUgZnJvbSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUueCAhPT0gbm9kZS5fb3JpZy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnggPSBNYXRoLnJvdW5kKG5vZGUueCAqIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWR0aCBjaGFuZ2VkLCBzY2FsZSBmcm9tIG5ldyB3aWR0aFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS53ICE9PSBub2RlLl9vcmlnLncpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4udyA9IE1hdGgucm91bmQobm9kZS53ICogcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmhlaWdodCBhbHdheXMgY2FycmllcyBvdmVyIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgQ2FsbGVkIHRvIHNjYWxlIHRoZSB3aWRnZXQgd2lkdGggJiBwb3NpdGlvbiB1cC9kb3duIGJhc2VkIG9uIHRoZSBjb2x1bW4gY2hhbmdlLlxuICAgICAqIE5vdGUgd2Ugc3RvcmUgcHJldmlvdXMgbGF5b3V0cyAoZXNwZWNpYWxseSBvcmlnaW5hbCBvbmVzKSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIGdvXG4gICAgICogZnJvbSBzYXkgMTIgLT4gMSAtPiAxMiBhbmQgZ2V0IGJhY2sgdG8gd2hlcmUgd2Ugd2VyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmV2Q29sdW1uIHByZXZpb3VzIG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogQHBhcmFtIGNvbHVtbiAgbmV3IGNvbHVtbiBudW1iZXJcbiAgICAgKiBAcGFyYW0gbm9kZXMgZGlmZmVyZW50IHNvcnRlZCBsaXN0IChleDogRE9NIG9yZGVyKSBpbnN0ZWFkIG9mIGN1cnJlbnQgbGlzdFxuICAgICAqIEBwYXJhbSBsYXlvdXQgc3BlY2lmeSB0aGUgdHlwZSBvZiByZS1sYXlvdXQgdGhhdCB3aWxsIGhhcHBlbiAocG9zaXRpb24sIHNpemUsIGV0Yy4uLikuXG4gICAgICogTm90ZTogaXRlbXMgd2lsbCBuZXZlciBiZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGNvbHVtbiBib3VuZGFyaWVzLiBkZWZhdWx0IChtb3ZlU2NhbGUpLiBJZ25vcmVkIGZvciAxIGNvbHVtblxuICAgICAqL1xuICAgIGNvbHVtbkNoYW5nZWQocHJldkNvbHVtbiwgY29sdW1uLCBub2RlcywgbGF5b3V0ID0gJ21vdmVTY2FsZScpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVzLmxlbmd0aCB8fCAhY29sdW1uIHx8IHByZXZDb2x1bW4gPT09IGNvbHVtbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBzaW1wbGVyIHNob3J0Y3V0cyBsYXlvdXRzXG4gICAgICAgIGNvbnN0IGRvQ29tcGFjdCA9IGxheW91dCA9PT0gJ2NvbXBhY3QnIHx8IGxheW91dCA9PT0gJ2xpc3QnO1xuICAgICAgICBpZiAoZG9Db21wYWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnROb2RlcygxLCBwcmV2Q29sdW1uKTsgLy8gc29ydCB3aXRoIG9yaWdpbmFsIGxheW91dCBvbmNlIGFuZCBvbmx5IG9uY2UgKG5ldyBjb2x1bW4gd2lsbCBhZmZlY3Qgb3JkZXIgb3RoZXJ3aXNlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIHRoZSBjdXJyZW50IGxheW91dCBpbiBjYXNlIHRoZXkgd2FudCB0byBnbyBiYWNrIChsaWtlIDEyIC0+IDEgLT4gMTIpIGFzIGl0IHJlcXVpcmVzIG9yaWdpbmFsIGRhdGEgSUZGIHdlJ3JlIHNpemluZyBkb3duIChzZWUgYmVsb3cpXG4gICAgICAgIGlmIChjb2x1bW4gPCBwcmV2Q29sdW1uKVxuICAgICAgICAgICAgdGhpcy5jYWNoZUxheW91dCh0aGlzLm5vZGVzLCBwcmV2Q29sdW1uKTtcbiAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpOyAvLyBkbyB0aGlzIEVBUkxZIGFzIGl0IHdpbGwgY2FsbCBzYXZlSW5pdGlhbCgpIHNvIHdlIGNhbiBkZXRlY3Qgd2hlcmUgd2Ugc3RhcnRlZCBmb3IgX2RpcnR5IGFuZCBjb2xsaXNpb25cbiAgICAgICAgbGV0IG5ld05vZGVzID0gW107XG4gICAgICAgIC8vIGlmIHdlJ3JlIGdvaW5nIHRvIDEgY29sdW1uIGFuZCB1c2luZyBET00gb3JkZXIgKGl0ZW0gcGFzc2VkIGluKSByYXRoZXIgdGhhbiBkZWZhdWx0IHNvcnRpbmcsIHRoZW4gZ2VuZXJhdGUgdGhhdCBsYXlvdXRcbiAgICAgICAgbGV0IGRvbU9yZGVyID0gZmFsc2U7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDEgJiYgbm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgZG9tT3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIG4ueCA9IDA7XG4gICAgICAgICAgICAgICAgbi53ID0gMTtcbiAgICAgICAgICAgICAgICBuLnkgPSBNYXRoLm1heChuLnksIHRvcCk7XG4gICAgICAgICAgICAgICAgdG9wID0gbi55ICsgbi5oO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdOb2RlcyA9IG5vZGVzO1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzID0gZG9Db21wYWN0ID8gdGhpcy5ub2RlcyA6IFV0aWxzLnNvcnQodGhpcy5ub2RlcywgLTEsIHByZXZDb2x1bW4pOyAvLyBjdXJyZW50IGNvbHVtbiByZXZlcnNlIHNvcnRpbmcgc28gd2UgY2FuIGluc2VydCBsYXN0IHRvIGZyb250IChsaW1pdCBjb2xsaXNpb24pXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgY2FjaGVkIHByZXZpb3VzIGxheW91dCBJRkYgd2UgYXJlIGdvaW5nIHVwIGluIHNpemUgKHJlc3RvcmUpIG90aGVyd2lzZSBhbHdheXNcbiAgICAgICAgLy8gZ2VuZXJhdGUgbmV4dCBzaXplIGRvd24gZnJvbSB3aGVyZSB3ZSBhcmUgKGxvb2tzIG1vcmUgbmF0dXJhbCBhcyB5b3UgZ3JhZHVhbGx5IHNpemUgZG93bikuXG4gICAgICAgIGlmIChjb2x1bW4gPiBwcmV2Q29sdW1uICYmIHRoaXMuX2xheW91dHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlTm9kZXMgPSB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gfHwgW107XG4gICAgICAgICAgICAvLyAuLi5pZiBub3QsIHN0YXJ0IHdpdGggdGhlIGxhcmdlc3QgbGF5b3V0IChpZiBub3QgYWxyZWFkeSB0aGVyZSkgYXMgZG93bi1zY2FsaW5nIGlzIG1vcmUgYWNjdXJhdGVcbiAgICAgICAgICAgIC8vIGJ5IHByZXRlbmRpbmcgd2UgY2FtZSBmcm9tIHRoYXQgbGFyZ2VyIGNvbHVtbiBieSBhc3NpZ25pbmcgdGhvc2UgdmFsdWVzIGFzIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5fbGF5b3V0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCFjYWNoZU5vZGVzLmxlbmd0aCAmJiBwcmV2Q29sdW1uICE9PSBsYXN0SW5kZXggJiYgdGhpcy5fbGF5b3V0c1tsYXN0SW5kZXhdPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29sdW1uID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dHNbbGFzdEluZGV4XS5mb3JFYWNoKGNhY2hlTm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gbm9kZXMuZmluZChuID0+IG4uX2lkID09PSBjYWNoZU5vZGUuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIGN1cnJlbnQsIHVzZSBjYWNoZSBpbmZvIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb0NvbXBhY3QgJiYgIWNhY2hlTm9kZS5hdXRvUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnggPSBjYWNoZU5vZGUueCA/PyBuLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi55ID0gY2FjaGVOb2RlLnkgPz8gbi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbi53ID0gY2FjaGVOb2RlLncgPz8gbi53O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlTm9kZS54ID09IHVuZGVmaW5lZCB8fCBjYWNoZU5vZGUueSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uYXV0b1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZm91bmQgY2FjaGUgcmUtdXNlIHRob3NlIG5vZGVzIHRoYXQgYXJlIHN0aWxsIGN1cnJlbnRcbiAgICAgICAgICAgIGNhY2hlTm9kZXMuZm9yRWFjaChjYWNoZU5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBqID0gbm9kZXMuZmluZEluZGV4KG4gPT4gbi5faWQgPT09IGNhY2hlTm9kZS5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIGN1cnJlbnQsIHVzZSBjYWNoZSBpbmZvIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLncgPSBjYWNoZU5vZGUudzsgLy8gb25seSB3IGlzIHVzZWQsIGFuZCBkb24ndCB0cmltIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlTm9kZS5hdXRvUG9zaXRpb24gfHwgaXNOYU4oY2FjaGVOb2RlLngpIHx8IGlzTmFOKGNhY2hlTm9kZS55KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kRW1wdHlQb3NpdGlvbihjYWNoZU5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlTm9kZS5hdXRvUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ueCA9IGNhY2hlTm9kZS54ID8/IG4ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ueSA9IGNhY2hlTm9kZS55ID8/IG4ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4udyA9IGNhY2hlTm9kZS53ID8/IG4udztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11Y2ggc2ltcGxlciBsYXlvdXQgdGhhdCBqdXN0IGNvbXBhY3RzXG4gICAgICAgIGlmIChkb0NvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdChsYXlvdXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIC4uLmFuZCBhZGQgYW55IGV4dHJhIG5vbi1jYWNoZWQgb25lc1xuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dChjb2x1bW4sIHByZXZDb2x1bW4sIG5ld05vZGVzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkb21PcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSAoZG9Db21wYWN0IHx8IGxheW91dCA9PT0gJ25vbmUnKSA/IDEgOiBjb2x1bW4gLyBwcmV2Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZSA9IChsYXlvdXQgPT09ICdtb3ZlJyB8fCBsYXlvdXQgPT09ICdtb3ZlU2NhbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlID0gKGxheW91dCA9PT0gJ3NjYWxlJyB8fCBsYXlvdXQgPT09ICdtb3ZlU2NhbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHggKyB3IGNvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGdyaWQsIGJ1dCBhZGROb2RlKCkgYmVsb3cgd2lsbCBoYW5kbGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gKGNvbHVtbiA9PT0gMSA/IDAgOiAobW92ZSA/IE1hdGgucm91bmQobm9kZS54ICogcmF0aW8pIDogTWF0aC5taW4obm9kZS54LCBjb2x1bW4gLSAxKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS53ID0gKChjb2x1bW4gPT09IDEgfHwgcHJldkNvbHVtbiA9PT0gMSkgPyAxIDogc2NhbGUgPyAoTWF0aC5yb3VuZChub2RlLncgKiByYXRpbykgfHwgMSkgOiAoTWF0aC5taW4obm9kZS53LCBjb2x1bW4pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHJlLWxheW91dCB0aGVtIGluIHJldmVyc2Ugb3JkZXIgKHRvIGdldCBjb3JyZWN0IHBsYWNlbWVudClcbiAgICAgICAgICAgIGlmICghZG9tT3JkZXIpXG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMgPSBVdGlscy5zb3J0KG5ld05vZGVzLCAtMSwgY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuX2luQ29sdW1uUmVzaXplID0gdHJ1ZTsgLy8gcHJldmVudCBjYWNoZSB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTsgLy8gcHJldGVuZCB3ZSBoYXZlIG5vIG5vZGVzIHRvIHN0YXJ0IHdpdGggKGFkZCgpIHdpbGwgdXNlIHNhbWUgc3RydWN0dXJlcykgdG8gc2ltcGxpZnkgbGF5b3V0XG4gICAgICAgICAgICBuZXdOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9kZShub2RlLCBmYWxzZSk7IC8vICdmYWxzZScgZm9yIGFkZCBldmVudCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX29yaWc7IC8vIG1ha2Ugc3VyZSB0aGUgY29tbWl0IGRvZXNuJ3QgdHJ5IHRvIHJlc3RvcmUgdGhpbmdzIGJhY2sgdG8gb3JpZ2luYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChuID0+IGRlbGV0ZSBuLl9vcmlnKTsgLy8gY2xlYXIgX29yaWcgYmVmb3JlIGJhdGNoPWZhbHNlIHNvIGl0IGRvZXNuJ3QgaGFuZGxlIGZsb2F0PXRydWUgcmVzdG9yZVxuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlLCAhZG9Db21wYWN0KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2luQ29sdW1uUmVzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbCB0byBjYWNoZSB0aGUgZ2l2ZW4gbGF5b3V0IGludGVybmFsbHkgdG8gdGhlIGdpdmVuIGxvY2F0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGJhY2sgd2hlbiBjb2x1bW4gY2hhbmdlcyBzaXplXG4gICAgICogQHBhcmFtIG5vZGVzIGxpc3Qgb2Ygbm9kZXNcbiAgICAgKiBAcGFyYW0gY29sdW1uIGNvcnJlc3BvbmRpbmcgY29sdW1uIGluZGV4IHRvIHNhdmUgaXQgdW5kZXJcbiAgICAgKiBAcGFyYW0gY2xlYXIgaWYgdHJ1ZSwgd2lsbCBmb3JjZSBvdGhlciBjYWNoZXMgdG8gYmUgcmVtb3ZlZCAoZGVmYXVsdCBmYWxzZSlcbiAgICAgKi9cbiAgICBjYWNoZUxheW91dChub2RlcywgY29sdW1uLCBjbGVhciA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjb3B5ID0gW107XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG4sIGkpID0+IHtcbiAgICAgICAgICAgIG4uX2lkID0gbi5faWQgPz8gR3JpZFN0YWNrRW5naW5lLl9pZFNlcSsrOyAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBpZCBpbiBjYXNlIHRoaXMgaXMgbmV3IGxheW91dCwgZWxzZSByZS11c2UgaWQgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGNvcHlbaV0gPSB7IHg6IG4ueCwgeTogbi55LCB3OiBuLncsIF9pZDogbi5faWQgfTsgLy8gb25seSB0aGluZyB3ZSBjaGFuZ2UgaXMgeCx5LHcgYW5kIGlkIHRvIGZpbmQgaXQgYmFja1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5b3V0cyA9IGNsZWFyID8gW10gOiB0aGlzLl9sYXlvdXRzIHx8IFtdOyAvLyB1c2UgYXJyYXkgdG8gZmluZCBsYXJnZXIgcXVpY2tcbiAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dID0gY29weTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGwgdG8gY2FjaGUgdGhlIGdpdmVuIG5vZGUgbGF5b3V0IGludGVybmFsbHkgdG8gdGhlIGdpdmVuIGxvY2F0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGJhY2sgd2hlbiBjb2x1bW4gY2hhbmdlcyBzaXplXG4gICAgICogQHBhcmFtIG5vZGUgc2luZ2xlIG5vZGUgdG8gY2FjaGVcbiAgICAgKiBAcGFyYW0gY29sdW1uIGNvcnJlc3BvbmRpbmcgY29sdW1uIGluZGV4IHRvIHNhdmUgaXQgdW5kZXJcbiAgICAgKi9cbiAgICBjYWNoZU9uZUxheW91dChuLCBjb2x1bW4pIHtcbiAgICAgICAgbi5faWQgPSBuLl9pZCA/PyBHcmlkU3RhY2tFbmdpbmUuX2lkU2VxKys7XG4gICAgICAgIGxldCBsID0geyB4OiBuLngsIHk6IG4ueSwgdzogbi53LCBfaWQ6IG4uX2lkIH07XG4gICAgICAgIGlmIChuLmF1dG9Qb3NpdGlvbiB8fCBuLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGwueDtcbiAgICAgICAgICAgIGRlbGV0ZSBsLnk7XG4gICAgICAgICAgICBpZiAobi5hdXRvUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgbC5hdXRvUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dHMgPSB0aGlzLl9sYXlvdXRzIHx8IFtdO1xuICAgICAgICB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gPSB0aGlzLl9sYXlvdXRzW2NvbHVtbl0gfHwgW107XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZmluZENhY2hlTGF5b3V0KG4sIGNvbHVtbik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRzW2NvbHVtbl0ucHVzaChsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tjb2x1bW5dW2luZGV4XSA9IGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5kQ2FjaGVMYXlvdXQobiwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzPy5bY29sdW1uXT8uZmluZEluZGV4KGwgPT4gbC5faWQgPT09IG4uX2lkKSA/PyAtMTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZUZyb21MYXlvdXRDYWNoZShuKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGF5b3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5maW5kQ2FjaGVMYXlvdXQobiwgaSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0c1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBjYWxsZWQgdG8gcmVtb3ZlIGFsbCBpbnRlcm5hbCB2YWx1ZXMgYnV0IHRoZSBfaWQgKi9cbiAgICBjbGVhbnVwTm9kZShub2RlKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb3BbMF0gPT09ICdfJyAmJiBwcm9wICE9PSAnX2lkJylcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKiogQGludGVybmFsIHVuaXF1ZSBnbG9iYWwgaW50ZXJuYWwgX2lkIGNvdW50ZXIgKi9cbkdyaWRTdGFja0VuZ2luZS5faWRTZXEgPSAwO1xuZXhwb3J0IHsgR3JpZFN0YWNrRW5naW5lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkc3RhY2stZW5naW5lLmpzLm1hcCJdLCJuYW1lcyI6WyJVdGlscyIsIkdyaWRTdGFja0VuZ2luZSIsImNvbnN0cnVjdG9yIiwib3B0cyIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJjb2x1bW4iLCJtYXhSb3ciLCJfZmxvYXQiLCJmbG9hdCIsIm5vZGVzIiwib25DaGFuZ2UiLCJiYXRjaFVwZGF0ZSIsImZsYWciLCJkb1BhY2siLCJiYXRjaE1vZGUiLCJfcHJldkZsb2F0IiwiY2xlYW5Ob2RlcyIsInNhdmVJbml0aWFsIiwiX3BhY2tOb2RlcyIsIl9ub3RpZnkiLCJfdXNlRW50aXJlUm93QXJlYSIsIm5vZGUiLCJubiIsIl9oYXNMb2NrZWQiLCJfbW92aW5nIiwiX3NraXBEb3duIiwieSIsIl9maXhDb2xsaXNpb25zIiwiY29sbGlkZSIsIm9wdCIsInNvcnROb2RlcyIsIm5lc3RlZCIsInN3YXAiLCJhcmVhIiwieCIsInciLCJoIiwic2tpcCIsImRpZE1vdmUiLCJuZXdPcHQiLCJwYWNrIiwibW92ZWQiLCJsb2NrZWQiLCJtb3ZlTm9kZSIsImNvcHlQb3MiLCJ1bmRlZmluZWQiLCJza2lwMiIsInNraXBJZCIsIl9pZCIsInNraXAySWQiLCJmaW5kIiwibiIsImlzSW50ZXJjZXB0ZWQiLCJjb2xsaWRlQWxsIiwiZmlsdGVyIiwiZGlyZWN0aW9uQ29sbGlkZUNvdmVyYWdlIiwibyIsImNvbGxpZGVzIiwicmVjdCIsIl9yZWN0IiwicjAiLCJyIiwib3Zlck1heCIsImZvckVhY2giLCJyMiIsInlPdmVyIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwieE92ZXIiLCJvdmVyIiwiTWF0aCIsIm1pbiIsImNhY2hlUmVjdHMiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJhIiwiYiIsIl9kb1N3YXAiLCJfZGlydHkiLCJ0b3VjaGluZyIsImlzVG91Y2hpbmciLCJ0IiwiaXNBcmVhRW1wdHkiLCJjb21wYWN0IiwibGF5b3V0IiwiZG9Tb3J0IiwibGVuZ3RoIiwid2FzQmF0Y2giLCJ3YXNDb2x1bW5SZXNpemUiLCJfaW5Db2x1bW5SZXNpemUiLCJjb3B5Tm9kZXMiLCJpbmRleCIsImxpc3QiLCJhZnRlciIsImF1dG9Qb3NpdGlvbiIsImFkZE5vZGUiLCJ2YWwiLCJkaXIiLCJzb3J0IiwiX3VwZGF0aW5nIiwiX29yaWciLCJuZXdZIiwiaSIsImNhbkJlTW92ZWQiLCJwcmVwYXJlTm9kZSIsInJlc2l6aW5nIiwiX2lkU2VxIiwiZGVmYXVsdHMiLCJub1Jlc2l6ZSIsIm5vTW92ZSIsInNhbml0aXplTWluTWF4IiwiaXNOYU4iLCJub2RlQm91bmRGaXgiLCJiZWZvcmUiLCJtYXhXIiwibWF4SCIsIm1pblciLCJtYXgiLCJtaW5IIiwic2F2ZU9yaWciLCJmaW5kQ2FjaGVMYXlvdXQiLCJjb3B5IiwiY2FjaGVPbmVMYXlvdXQiLCJzYW1lUG9zIiwiZ2V0RGlydHlOb2RlcyIsInZlcmlmeSIsImRpcnR5Tm9kZXMiLCJjb25jYXQiLCJfbGFzdFRyaWVkIiwic29tZSIsInJlc3RvcmVJbml0aWFsIiwiZmluZEVtcHR5UG9zaXRpb24iLCJub2RlTGlzdCIsInN0YXJ0IiwiZm91bmQiLCJmbG9vciIsImJveCIsInRyaWdnZXJBZGRFdmVudCIsImR1cCIsIl90ZW1wb3JhcnlSZW1vdmVkIiwiX3JlbW92ZURPTSIsInNraXBDb2xsaXNpb24iLCJwdXNoIiwicmVtb3ZlTm9kZSIsInJlbW92ZURPTSIsInRyaWdnZXJFdmVudCIsIl9pc0Fib3V0VG9SZW1vdmUiLCJyZW1vdmVBbGwiLCJfbGF5b3V0cyIsIm1vdmVOb2RlQ2hlY2siLCJjaGFuZ2VkUG9zQ29uc3RyYWluIiwiY2xvbmVkTm9kZSIsImNsb25lIiwibWFwIiwiY2FuTW92ZSIsImdldFJvdyIsImVsIiwiZ3JpZHN0YWNrTm9kZSIsImMiLCJ3aWxsSXRGaXQiLCJfd2lsbEZpdFBvcyIsImNsZWFudXBOb2RlIiwiY29udGVudCIsImdyaWQiLCJwIiwid2FzVW5kZWZpbmVkUGFjayIsImZvcmNlQ29sbGlkZSIsInByZXZQb3MiLCJuZWVkVG9Nb3ZlIiwiYWN0aXZlRHJhZyIsInN1YkdyaWREeW5hbWljIiwiX2lzVGVtcCIsImFyZWFJbnRlcmNlcHQiLCJhMSIsImEyIiwicGVyYyIsIm1ha2VTdWJHcmlkIiwicmVkdWNlIiwicm93IiwiYmVnaW5VcGRhdGUiLCJlbmRVcGRhdGUiLCJzYXZlIiwic2F2ZUVsZW1lbnQiLCJzYXZlQ0IiLCJsZW4iLCJ3bCIsImwiLCJyZW1vdmVJbnRlcm5hbEZvclNhdmUiLCJsYXlvdXRzTm9kZXNDaGFuZ2UiLCJyYXRpbyIsInJvdW5kIiwiY29sdW1uQ2hhbmdlZCIsInByZXZDb2x1bW4iLCJkb0NvbXBhY3QiLCJjYWNoZUxheW91dCIsIm5ld05vZGVzIiwiZG9tT3JkZXIiLCJjYWNoZU5vZGVzIiwibGFzdEluZGV4IiwiY2FjaGVOb2RlIiwiaiIsImZpbmRJbmRleCIsInNwbGljZSIsIm1vdmUiLCJzY2FsZSIsImNsZWFyIiwicmVtb3ZlTm9kZUZyb21MYXlvdXRDYWNoZSIsInByb3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/gridstack-engine.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.js":
/*!**************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridStack: () => (/* binding */ GridStack)\n/* harmony export */ });\n/* harmony import */ var _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gridstack-engine */ \"./node_modules/gridstack/dist/gridstack-engine.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./node_modules/gridstack/dist/types.js\");\n/* harmony import */ var _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-gridstack */ \"./node_modules/gridstack/dist/dd-gridstack.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"GridStack\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/*!\n * GridStack 9.4.0\n * https://gridstackjs.com/\n *\n * Copyright (c) 2021-2022 Alain Dumesny\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\n */ \n\n\n/*\n * and include D&D by default\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n */ \n\n\n/** global instance */ const dd = new _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack;\n// export all dependent file as well to make it easier for users to just import the main file\n\n\n\n\n/**\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\n * @example\n * <div class=\"grid-stack\">\n *   <div class=\"grid-stack-item\">\n *     <div class=\"grid-stack-item-content\">Item 1</div>\n *   </div>\n * </div>\n */ class GridStack {\n    /**\n     * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\n     * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\n     * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\n     * @param options grid options (optional)\n     * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\n     *\n     * @example\n     * let grid = GridStack.init();\n     *\n     * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\n     * let grid = document.querySelector('.grid-stack').gridstack;\n     */ static init(options = {}, elOrString = \".grid-stack\") {\n        let el = GridStack.getGridElement(elOrString);\n        if (!el) {\n            if (typeof elOrString === \"string\") {\n                console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n            } else {\n                console.error(\"GridStack.init() no grid element was passed.\");\n            }\n            return null;\n        }\n        if (!el.gridstack) {\n            el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n        }\n        return el.gridstack;\n    }\n    /**\n     * Will initialize a list of elements (given a selector) and return an array of grids.\n     * @param options grid options (optional)\n     * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\n     *\n     * @example\n     * let grids = GridStack.initAll();\n     * grids.forEach(...)\n     */ static initAll(options = {}, selector = \".grid-stack\") {\n        let grids = [];\n        GridStack.getGridElements(selector).forEach((el)=>{\n            if (!el.gridstack) {\n                el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n            }\n            grids.push(el.gridstack);\n        });\n        if (grids.length === 0) {\n            console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n        }\n        return grids;\n    }\n    /**\n     * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\n     * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\n     * JSON serialized data, including options.\n     * @param parent HTML element parent to the grid\n     * @param opt grids options used to initialize the grid, and list of children\n     */ static addGrid(parent, opt = {}) {\n        if (!parent) return null;\n        let el = parent;\n        if (el.gridstack) {\n            // already a grid - set option and load data\n            const grid = el.gridstack;\n            if (opt) grid.opts = {\n                ...grid.opts,\n                ...opt\n            };\n            if (opt.children !== undefined) grid.load(opt.children);\n            return grid;\n        }\n        // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n        const parentIsGrid = parent.classList.contains(\"grid-stack\");\n        if (!parentIsGrid || GridStack.addRemoveCB) {\n            if (GridStack.addRemoveCB) {\n                el = GridStack.addRemoveCB(parent, opt, true, true);\n            } else {\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || \"\"}\"></div>`;\n                el = doc.body.children[0];\n                parent.appendChild(el);\n            }\n        }\n        // create grid class and load any children\n        let grid = GridStack.init(opt, el);\n        return grid;\n    }\n    /** call this method to register your engine instead of the default one.\n     * See instead `GridStackOptions.engineClass` if you only need to\n     * replace just one instance.\n     */ static registerEngine(engineClass) {\n        GridStack.engineClass = engineClass;\n    }\n    /** @internal create placeholder DIV as needed */ get placeholder() {\n        if (!this._placeholder) {\n            let placeholderChild = document.createElement(\"div\"); // child so padding match item-content\n            placeholderChild.className = \"placeholder-content\";\n            if (this.opts.placeholderText) {\n                placeholderChild.innerHTML = this.opts.placeholderText;\n            }\n            this._placeholder = document.createElement(\"div\");\n            this._placeholder.classList.add(this.opts.placeholderClass, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n            this.placeholder.appendChild(placeholderChild);\n        }\n        return this._placeholder;\n    }\n    /**\n     * Construct a grid item from the given element and options\n     * @param el\n     * @param opts\n     */ constructor(el, opts = {}){\n        /** @internal */ this._gsEventHandler = {};\n        /** @internal extra row added when dragging at the bottom of the grid */ this._extraDragRow = 0;\n        this.el = el; // exposed HTML element to the user\n        opts = opts || {}; // handles null/undefined/0\n        if (!el.classList.contains(\"grid-stack\")) {\n            this.el.classList.add(\"grid-stack\");\n        }\n        // if row property exists, replace minRow and maxRow instead\n        if (opts.row) {\n            opts.minRow = opts.maxRow = opts.row;\n            delete opts.row;\n        }\n        let rowAttr = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-row\"));\n        // flag only valid in sub-grids (handled by parent, not here)\n        if (opts.column === \"auto\") {\n            delete opts.column;\n        }\n        // save original setting so we can restore on save\n        if (opts.alwaysShowResizeHandle !== undefined) {\n            opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n        }\n        // elements DOM attributes override any passed options (like CSS style) - merge the two together\n        let defaults = {\n            ..._utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),\n            column: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-column\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.column,\n            minRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-row\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.minRow,\n            maxRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-row\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.maxRow,\n            staticGrid: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-static\")) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.staticGrid,\n            draggable: {\n                handle: (opts.handleClass ? \".\" + opts.handleClass : opts.handle ? opts.handle : \"\") || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.draggable.handle\n            },\n            removableOptions: {\n                accept: opts.itemClass || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.accept,\n                decline: _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.decline\n            }\n        };\n        if (el.getAttribute(\"gs-animate\")) {\n            defaults.animate = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-animate\"));\n        }\n        this.opts = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(opts, defaults);\n        opts = null; // make sure we use this.opts instead\n        this._initMargin(); // part of settings defaults...\n        // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n        if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {\n            this._prevColumn = this.getColumn();\n            this.opts.column = 1;\n        }\n        if (this.opts.rtl === \"auto\") {\n            this.opts.rtl = el.style.direction === \"rtl\";\n        }\n        if (this.opts.rtl) {\n            this.el.classList.add(\"grid-stack-rtl\");\n        }\n        // check if we're been nested, and if so update our style and keep pointer around (used during save)\n        const grandParent = this.el.parentElement?.parentElement;\n        let parentGridItem = grandParent?.classList.contains(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;\n        if (parentGridItem) {\n            parentGridItem.subGrid = this;\n            this.parentGridItem = parentGridItem;\n            this.el.classList.add(\"grid-stack-nested\");\n            parentGridItem.el.classList.add(\"grid-stack-sub-grid\");\n        }\n        this._isAutoCellHeight = this.opts.cellHeight === \"auto\";\n        if (this._isAutoCellHeight || this.opts.cellHeight === \"initial\") {\n            // make the cell content square initially (will use resize/column event to keep it square)\n            this.cellHeight(undefined, false);\n        } else {\n            // append unit if any are set\n            if (typeof this.opts.cellHeight == \"number\" && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.cellHeightUnit) {\n                this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;\n                delete this.opts.cellHeightUnit;\n            }\n            this.cellHeight(this.opts.cellHeight, false);\n        }\n        // see if we need to adjust auto-hide\n        if (this.opts.alwaysShowResizeHandle === \"mobile\") {\n            this.opts.alwaysShowResizeHandle = _dd_touch__WEBPACK_IMPORTED_MODULE_4__.isTouch;\n        }\n        this._styleSheetClass = \"gs-id-\" + _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine._idSeq++;\n        this.el.classList.add(this._styleSheetClass);\n        this._setStaticClass();\n        let engineClass = this.opts.engineClass || GridStack.engineClass || _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\n        this.engine = new engineClass({\n            column: this.getColumn(),\n            float: this.opts.float,\n            maxRow: this.opts.maxRow,\n            onChange: (cbNodes)=>{\n                let maxH = 0;\n                this.engine.nodes.forEach((n)=>{\n                    maxH = Math.max(maxH, n.y + n.h);\n                });\n                cbNodes.forEach((n)=>{\n                    let el = n.el;\n                    if (!el) return;\n                    if (n._removeDOM) {\n                        if (el) el.remove();\n                        delete n._removeDOM;\n                    } else {\n                        this._writePosAttr(el, n);\n                    }\n                });\n                this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n            }\n        });\n        if (this.opts.auto) {\n            this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n            this.getGridItems().forEach((el)=>this._prepareElement(el));\n            this.batchUpdate(false);\n        }\n        // load any passed in children as well, which overrides any DOM layout done above\n        if (this.opts.children) {\n            let children = this.opts.children;\n            delete this.opts.children;\n            if (children.length) this.load(children); // don't load empty\n        }\n        this.setAnimation(this.opts.animate);\n        this._updateStyles();\n        this.el.classList.add(\"gs-\" + this.opts.column);\n        // dynamic grids require pausing during drag to detect over to nest vs push\n        if (this.opts.subGridDynamic && !_dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = true;\n        if (this.opts.draggable?.pause !== undefined) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = this.opts.draggable.pause;\n        this._setupRemoveDrop();\n        this._setupAcceptWidget();\n        this._updateResizeEvent();\n    }\n    /**\n     * add a new widget and returns it.\n     *\n     * Widget will be always placed even if result height is more than actual grid height.\n     * You need to use `willItFit()` before calling addWidget for additional check.\n     * See also `makeWidget()`.\n     *\n     * @example\n     * let grid = GridStack.init();\n     * grid.addWidget({w: 3, content: 'hello'});\n     * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\n     *\n     * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\n     * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\n     */ addWidget(els, options) {\n        function isGridStackWidget(w) {\n            return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n        }\n        let el;\n        let node;\n        if (typeof els === \"string\") {\n            let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n            doc.body.innerHTML = els;\n            el = doc.body.children[0];\n        } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n            node = options = els;\n            if (node?.el) {\n                el = node.el; // re-use element stored in the node\n            } else if (GridStack.addRemoveCB) {\n                el = GridStack.addRemoveCB(this.el, options, true, false);\n            } else {\n                let content = options?.content || \"\";\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || \"\"}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\n                el = doc.body.children[0];\n            }\n        } else {\n            el = els;\n        }\n        if (!el) return;\n        // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\n        node = el.gridstackNode;\n        if (node && el.parentElement === this.el && this.engine.nodes.find((n)=>n._id === node._id)) return el;\n        // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n        // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n        // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n        let domAttr = this._readAttr(el);\n        options = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(options, domAttr);\n        node = this.engine.prepareNode(options);\n        this._writeAttr(el, options);\n        if (this._insertNotAppend) {\n            this.el.prepend(el);\n        } else {\n            this.el.appendChild(el);\n        }\n        this.makeWidget(el, options);\n        return el;\n    }\n    /**\n     * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\n     * from the parent's subGrid options.\n     * @param el gridItem element to convert\n     * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\n     * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\n     * @returns newly created grid\n     */ makeSubGrid(el, ops, nodeToAdd, saveContent = true) {\n        let node = el.gridstackNode;\n        if (!node) {\n            node = this.makeWidget(el).gridstackNode;\n        }\n        if (node.subGrid?.el) return node.subGrid; // already done\n        // find the template subGrid stored on a parent as fallback...\n        let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let grid = this;\n        while(grid && !subGridTemplate){\n            subGridTemplate = grid.opts?.subGridOpts;\n            grid = grid.parentGridItem?.grid;\n        }\n        //... and set the create options\n        ops = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep({\n            ...subGridTemplate || {},\n            children: undefined,\n            ...ops || node.subGridOpts\n        });\n        node.subGridOpts = ops;\n        // if column special case it set, remember that flag and set default\n        let autoColumn;\n        if (ops.column === \"auto\") {\n            autoColumn = true;\n            ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\n            ops.disableOneColumnMode = true; // driven by parent\n        }\n        // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n        let content = node.el.querySelector(\".grid-stack-item-content\");\n        let newItem;\n        let newItemOpt;\n        if (saveContent) {\n            this._removeDD(node.el); // remove D&D since it's set on content div\n            newItemOpt = {\n                ...node,\n                x: 0,\n                y: 0\n            };\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalForSave(newItemOpt);\n            delete newItemOpt.subGridOpts;\n            if (node.content) {\n                newItemOpt.content = node.content;\n                delete node.content;\n            }\n            if (GridStack.addRemoveCB) {\n                newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\n            } else {\n                let doc = document.implementation.createHTMLDocument(\"\"); // IE needs a param\n                doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\n                newItem = doc.body.children[0];\n                newItem.appendChild(content);\n                doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\n                content = doc.body.children[0];\n                node.el.appendChild(content);\n            }\n            this._prepareDragDropByNode(node); // ... and restore original D&D\n        }\n        // if we're adding an additional item, make the container large enough to have them both\n        if (nodeToAdd) {\n            let w = autoColumn ? ops.column : node.w;\n            let h = node.h + nodeToAdd.h;\n            let style = node.el.style;\n            style.transition = \"none\"; // show up instantly so we don't see scrollbar with nodeToAdd\n            this.update(node.el, {\n                w,\n                h\n            });\n            setTimeout(()=>style.transition = null); // recover animation\n        }\n        let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n        if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n        if (autoColumn) subGrid._autoColumn = true;\n        // add the original content back as a child of hte newly created grid\n        if (saveContent) {\n            subGrid.addWidget(newItem, newItemOpt);\n        }\n        // now add any additional node\n        if (nodeToAdd) {\n            if (nodeToAdd._moving) {\n                // create an artificial event even for the just created grid to receive this item\n                window.setTimeout(()=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeToAdd._event, \"mouseenter\", subGrid.el), 0);\n            } else {\n                subGrid.addWidget(node.el, node);\n            }\n        }\n        return subGrid;\n    }\n    /**\n     * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\n     * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\n     */ removeAsSubGrid(nodeThatRemoved) {\n        let pGrid = this.parentGridItem?.grid;\n        if (!pGrid) return;\n        pGrid.batchUpdate();\n        pGrid.removeWidget(this.parentGridItem.el, true, true);\n        this.engine.nodes.forEach((n)=>{\n            // migrate any children over and offsetting by our location\n            n.x += this.parentGridItem.x;\n            n.y += this.parentGridItem.y;\n            pGrid.addWidget(n.el, n);\n        });\n        pGrid.batchUpdate(false);\n        if (this.parentGridItem) delete this.parentGridItem.subGrid;\n        delete this.parentGridItem;\n        // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n        if (nodeThatRemoved) {\n            window.setTimeout(()=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeThatRemoved._event, \"mouseenter\", pGrid.el), 0);\n        }\n    }\n    /**\n     * saves the current layout returning a list of widgets for serialization which might include any nested grids.\n     * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\n     * be removed.\n     * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\n     * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\n     * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\n     * @returns list of widgets or full grid option, including .children list of widgets\n     */ save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB) {\n        // return copied GridStackWidget (with optionally .el) we can modify at will...\n        let list = this.engine.save(saveContent, saveCB);\n        // check for HTML content and nested grids\n        list.forEach((n)=>{\n            if (saveContent && n.el && !n.subGrid && !saveCB) {\n                let sub = n.el.querySelector(\".grid-stack-item-content\");\n                n.content = sub ? sub.innerHTML : undefined;\n                if (!n.content) delete n.content;\n            } else {\n                if (!saveContent && !saveCB) {\n                    delete n.content;\n                }\n                // check for nested grid\n                if (n.subGrid?.el) {\n                    const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\n                    n.subGridOpts = saveGridOpt ? listOrOpt : {\n                        children: listOrOpt\n                    };\n                    delete n.subGrid;\n                }\n            }\n            delete n.el;\n        });\n        // check if save entire grid options (needed for recursive) + children...\n        if (saveGridOpt) {\n            let o = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(this.opts);\n            // delete default values that will be recreated on launch\n            if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n                o.margin = o.marginTop;\n                delete o.marginTop;\n                delete o.marginRight;\n                delete o.marginBottom;\n                delete o.marginLeft;\n            }\n            if (o.rtl === (this.el.style.direction === \"rtl\")) {\n                o.rtl = \"auto\";\n            }\n            if (this._isAutoCellHeight) {\n                o.cellHeight = \"auto\";\n            }\n            if (this._autoColumn) {\n                o.column = \"auto\";\n                delete o.disableOneColumnMode;\n            }\n            const origShow = o._alwaysShowResizeHandle;\n            delete o._alwaysShowResizeHandle;\n            if (origShow !== undefined) {\n                o.alwaysShowResizeHandle = origShow;\n            } else {\n                delete o.alwaysShowResizeHandle;\n            }\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalAndSame(o, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults);\n            o.children = list;\n            return o;\n        }\n        return list;\n    }\n    /**\n     * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\n     *\n     * @param layout list of widgets definition to update/create\n     * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\n     * the user control of insertion.\n     *\n     * @example\n     * see http://gridstackjs.com/demo/serialization.html\n     */ load(items, addRemove = GridStack.addRemoveCB || true) {\n        items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(items); // so we can mod\n        // if passed list has coordinates, use them (insert from end to beginning for conflict resolution) else force widget same order\n        const haveCoord = items.some((w)=>w.x !== undefined || w.y !== undefined);\n        if (haveCoord) items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sort(items, -1, this._prevColumn || this.getColumn());\n        this._insertNotAppend = haveCoord; // if we create in reverse order...\n        // if we're loading a layout into for example 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save\n        // the original wanted layout so we can scale back up correctly #1471\n        if (this._prevColumn && this._prevColumn !== this.opts.column && items.some((n)=>(n.x || 0) + n.w > this.opts.column)) {\n            this._ignoreLayoutsNodeChange = true; // skip layout update\n            this.engine.cacheLayout(items, this._prevColumn, true);\n        }\n        // if given a different callback, temporally set it as global option so creating will use it\n        const prevCB = GridStack.addRemoveCB;\n        if (typeof addRemove === \"function\") GridStack.addRemoveCB = addRemove;\n        let removed = [];\n        this.batchUpdate();\n        // see if any items are missing from new layout and need to be removed first\n        if (addRemove) {\n            let copyNodes = [\n                ...this.engine.nodes\n            ]; // don't loop through array you modify\n            copyNodes.forEach((n)=>{\n                if (!n.id) return;\n                let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id);\n                if (!item) {\n                    if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\n                    removed.push(n); // batch keep track\n                    this.removeWidget(n.el, true, false);\n                }\n            });\n        }\n        // now add/update the widgets - starting with removing items in the new layout we will reposition\n        // to reduce collision and add no-coord ones at next available spot\n        let updateNodes = [];\n        this.engine.nodes = this.engine.nodes.filter((n)=>{\n            if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id)) {\n                updateNodes.push(n);\n                return false;\n            } // remove if found from list\n            return true;\n        });\n        let widthChanged = false;\n        items.forEach((w)=>{\n            let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(updateNodes, w.id);\n            if (item) {\n                // if item sizes to content, re-use the exiting height so it's a better guess at the final size 9same if width doesn't change)\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(item)) w.h = item.h;\n                // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\n                if (w.autoPosition || w.x === undefined || w.y === undefined) {\n                    w.w = w.w || item.w;\n                    w.h = w.h || item.h;\n                    this.engine.findEmptyPosition(w);\n                }\n                widthChanged = widthChanged || w.w !== undefined && w.w !== item.w;\n                // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\n                this.engine.nodes.push(item);\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.samePos(item, w)) {\n                    this.moveNode(item, {\n                        ...w,\n                        forceCollide: true\n                    });\n                    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(w, item, true);\n                }\n                this.update(item.el, w);\n                if (w.subGridOpts?.children) {\n                    let sub = item.el.querySelector(\".grid-stack\");\n                    if (sub && sub.gridstack) {\n                        sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\n                        this._insertNotAppend = true; // got reset by above call\n                    }\n                }\n            } else if (addRemove) {\n                this.addWidget(w);\n            }\n        });\n        this.engine.removedNodes = removed;\n        this.doContentResize(widthChanged, true); // we only need to wait for animation if we changed any widths\n        this.batchUpdate(false);\n        // after commit, clear that flag\n        delete this._ignoreLayoutsNodeChange;\n        delete this._insertNotAppend;\n        prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\n        return this;\n    }\n    /**\n     * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\n     * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\n     */ batchUpdate(flag = true) {\n        this.engine.batchUpdate(flag);\n        if (!flag) {\n            this._updateContainerHeight();\n            this._triggerRemoveEvent();\n            this._triggerAddEvent();\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * Gets current cell height.\n     */ getCellHeight(forcePixel = false) {\n        if (this.opts.cellHeight && this.opts.cellHeight !== \"auto\" && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === \"px\")) {\n            return this.opts.cellHeight;\n        }\n        // else get first cell height\n        let el = this.el.querySelector(\".\" + this.opts.itemClass);\n        if (el) {\n            let height = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-h\")) || 1; // since we don't write 1 anymore\n            return Math.round(el.offsetHeight / height);\n        }\n        // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n        let rows = parseInt(this.el.getAttribute(\"gs-current-row\"));\n        return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n    }\n    /**\n     * Update current cell height - see `GridStackOptions.cellHeight` for format.\n     * This method rebuilds an internal CSS style sheet.\n     * Note: You can expect performance issues if call this method too often.\n     *\n     * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\n     * if pass 0 the CSS will be generated by the application instead.\n     * @param update (Optional) if false, styles will not be updated\n     *\n     * @example\n     * grid.cellHeight(100); // same as 100px\n     * grid.cellHeight('70px');\n     * grid.cellHeight(grid.cellWidth() * 1.2);\n     */ cellHeight(val, update = true) {\n        // if not called internally, check if we're changing mode\n        if (update && val !== undefined) {\n            if (this._isAutoCellHeight !== (val === \"auto\")) {\n                this._isAutoCellHeight = val === \"auto\";\n                this._updateResizeEvent();\n            }\n        }\n        if (val === \"initial\" || val === \"auto\") {\n            val = undefined;\n        }\n        // make item content be square\n        if (val === undefined) {\n            let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n            val = this.cellWidth() + marginDiff;\n        }\n        let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(val);\n        if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n            return this;\n        }\n        this.opts.cellHeightUnit = data.unit;\n        this.opts.cellHeight = data.h;\n        this.doContentResize(false, true); // no anim wait, but use attributes since we only change row height\n        if (update) {\n            this._updateStyles(true); // true = force re-create for current # of rows\n        }\n        return this;\n    }\n    /** Gets current cell width. */ cellWidth() {\n        return this._widthOrContainer() / this.getColumn();\n    }\n    /** return our expected width (or parent) for 1 column check */ _widthOrContainer() {\n        // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n        // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n        return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n    }\n    /**\n     * re-layout grid items to reclaim any empty space. Options are:\n     * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\n     * 'compact' might re-order items to fill any empty space\n     *\n     * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\n     */ compact(layout = \"compact\", doSort = true) {\n        this.engine.compact(layout, doSort);\n        this._triggerChangeEvent();\n        return this;\n    }\n    /**\n     * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\n     * as well as cache the original layout so you can revert back to previous positions without loss.\n     * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\n     * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\n     * @param column - Integer > 0 (default 12).\n     * @param layout specify the type of re-layout that will happen (position, size, etc...).\n     * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\n     */ column(column, layout = \"moveScale\") {\n        if (!column || column < 1 || this.opts.column === column) return this;\n        let oldColumn = this.getColumn();\n        // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)\n        // then remember the original columns so we can restore.\n        if (column === 1) {\n            this._prevColumn = oldColumn;\n        } else {\n            delete this._prevColumn;\n        }\n        this.el.classList.remove(\"gs-\" + oldColumn);\n        this.el.classList.add(\"gs-\" + column);\n        this.opts.column = this.engine.column = column;\n        // update the items now - see if the dom order nodes should be passed instead (else default to current list)\n        let domNodes;\n        if (column === 1 && this.opts.oneColumnModeDomSort) {\n            domNodes = [];\n            this.getGridItems().forEach((el)=>{\n                if (el.gridstackNode) {\n                    domNodes.push(el.gridstackNode);\n                }\n            });\n            if (!domNodes.length) {\n                domNodes = undefined;\n            }\n        }\n        this.engine.columnChanged(oldColumn, column, domNodes, layout);\n        if (this._isAutoCellHeight) this.cellHeight();\n        this.doContentResize();\n        // and trigger our event last...\n        this._ignoreLayoutsNodeChange = true; // skip layout update\n        this._triggerChangeEvent();\n        delete this._ignoreLayoutsNodeChange;\n        return this;\n    }\n    /**\n     * get the number of columns in the grid (default 12)\n     */ getColumn() {\n        return this.opts.column;\n    }\n    /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */ getGridItems() {\n        return Array.from(this.el.children).filter((el)=>el.matches(\".\" + this.opts.itemClass) && !el.matches(\".\" + this.opts.placeholderClass));\n    }\n    /**\n     * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\n     * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\n     */ destroy(removeDOM = true) {\n        if (!this.el) return; // prevent multiple calls\n        this.offAll();\n        this._updateResizeEvent(true);\n        this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n        this.setAnimation(false);\n        if (!removeDOM) {\n            this.removeAll(removeDOM);\n            this.el.classList.remove(this._styleSheetClass);\n            this.el.removeAttribute(\"gs-current-row\");\n        } else {\n            this.el.parentNode.removeChild(this.el);\n        }\n        this._removeStylesheet();\n        if (this.parentGridItem) delete this.parentGridItem.subGrid;\n        delete this.parentGridItem;\n        delete this.opts;\n        delete this._placeholder;\n        delete this.engine;\n        delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n        delete this.el;\n        return this;\n    }\n    /**\n     * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\n     */ float(val) {\n        if (this.opts.float !== val) {\n            this.opts.float = this.engine.float = val;\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * get the current float mode\n     */ getFloat() {\n        return this.engine.float;\n    }\n    /**\n     * Get the position of the cell under a pixel on screen.\n     * @param position the position of the pixel to resolve in\n     * absolute coordinates, as an object with top and left properties\n     * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\n     * Useful when grid is within `position: relative` element\n     *\n     * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\n     */ getCellFromPixel(position, useDocRelative = false) {\n        let box = this.el.getBoundingClientRect();\n        // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n        let containerPos;\n        if (useDocRelative) {\n            containerPos = {\n                top: box.top + document.documentElement.scrollTop,\n                left: box.left\n            };\n        // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n        } else {\n            containerPos = {\n                top: this.el.offsetTop,\n                left: this.el.offsetLeft\n            };\n        // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n        }\n        let relativeLeft = position.left - containerPos.left;\n        let relativeTop = position.top - containerPos.top;\n        let columnWidth = box.width / this.getColumn();\n        let rowHeight = box.height / parseInt(this.el.getAttribute(\"gs-current-row\"));\n        return {\n            x: Math.floor(relativeLeft / columnWidth),\n            y: Math.floor(relativeTop / rowHeight)\n        };\n    }\n    /** returns the current number of rows, which will be at least `minRow` if set */ getRow() {\n        return Math.max(this.engine.getRow(), this.opts.minRow);\n    }\n    /**\n     * Checks if specified area is empty.\n     * @param x the position x.\n     * @param y the position y.\n     * @param w the width of to check\n     * @param h the height of to check\n     */ isAreaEmpty(x, y, w, h) {\n        return this.engine.isAreaEmpty(x, y, w, h);\n    }\n    /**\n     * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\n     * If you want gridstack to add the elements for you, use `addWidget()` instead.\n     * Makes the given element a widget and returns it.\n     * @param els widget or single selector to convert.\n     * @param options widget definition to use instead of reading attributes or using default sizing values\n     *\n     * @example\n     * let grid = GridStack.init();\n     * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\n     * grid.el.appendChild('<div id=\"2\"></div>');\n     * grid.makeWidget('1');\n     * grid.makeWidget('2', {w:2, content: 'hello'});\n     */ makeWidget(els, options) {\n        let el = GridStack.getElement(els);\n        this._prepareElement(el, true, options);\n        const node = el.gridstackNode;\n        this._updateContainerHeight();\n        this.doContentResize(false, false, node);\n        // see if there is a sub-grid to create\n        if (node.subGridOpts) {\n            this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\n        }\n        // if we're adding an item into 1 column (_prevColumn is set only when going to 1) make sure\n        // we don't override the larger 12 column layout that was already saved. #1985\n        if (this._prevColumn && this.opts.column === 1) {\n            this._ignoreLayoutsNodeChange = true;\n        }\n        this._triggerAddEvent();\n        this._triggerChangeEvent();\n        delete this._ignoreLayoutsNodeChange;\n        return el;\n    }\n    /**\n     * Event handler that extracts our CustomEvent data out automatically for receiving custom\n     * notifications (see doc for supported events)\n     * @param name of the event (see possible values) or list of names space separated\n     * @param callback function called with event and optional second/third param\n     * (see README documentation for each signature).\n     *\n     * @example\n     * grid.on('added', function(e, items) { log('added ', items)} );\n     * or\n     * grid.on('added removed change', function(e, items) { log(e.type, items)} );\n     *\n     * Note: in some cases it is the same as calling native handler and parsing the event.\n     * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\n     *\n     */ on(name, callback) {\n        // check for array of names being passed instead\n        if (name.indexOf(\" \") !== -1) {\n            let names = name.split(\" \");\n            names.forEach((name)=>this.on(name, callback));\n            return this;\n        }\n        if (name === \"change\" || name === \"added\" || name === \"removed\" || name === \"enable\" || name === \"disable\") {\n            // native CustomEvent handlers - cash the generic handlers so we can easily remove\n            let noData = name === \"enable\" || name === \"disable\";\n            if (noData) {\n                this._gsEventHandler[name] = (event)=>callback(event);\n            } else {\n                this._gsEventHandler[name] = (event)=>callback(event, event.detail);\n            }\n            this.el.addEventListener(name, this._gsEventHandler[name]);\n        } else if (name === \"drag\" || name === \"dragstart\" || name === \"dragstop\" || name === \"resizestart\" || name === \"resize\" || name === \"resizestop\" || name === \"dropped\" || name === \"resizecontent\") {\n            // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n            // do same for start event to make it easier...\n            this._gsEventHandler[name] = callback;\n        } else {\n            console.log(\"GridStack.on(\" + name + ') event not supported, but you can still use $(\".grid-stack\").on(...) while jquery-ui is still used internally.');\n        }\n        return this;\n    }\n    /**\n     * unsubscribe from the 'on' event below\n     * @param name of the event (see possible values)\n     */ off(name) {\n        // check for array of names being passed instead\n        if (name.indexOf(\" \") !== -1) {\n            let names = name.split(\" \");\n            names.forEach((name)=>this.off(name));\n            return this;\n        }\n        if (name === \"change\" || name === \"added\" || name === \"removed\" || name === \"enable\" || name === \"disable\") {\n            // remove native CustomEvent handlers\n            if (this._gsEventHandler[name]) {\n                this.el.removeEventListener(name, this._gsEventHandler[name]);\n            }\n        }\n        delete this._gsEventHandler[name];\n        return this;\n    }\n    /** remove all event handlers */ offAll() {\n        Object.keys(this._gsEventHandler).forEach((key)=>this.off(key));\n        return this;\n    }\n    /**\n     * Removes widget from the grid.\n     * @param el  widget or selector to modify\n     * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\n     * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n     */ removeWidget(els, removeDOM = true, triggerEvent = true) {\n        GridStack.getElements(els).forEach((el)=>{\n            if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n            let node = el.gridstackNode;\n            // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n            if (!node) {\n                node = this.engine.nodes.find((n)=>el === n.el);\n            }\n            if (!node) return;\n            if (GridStack.addRemoveCB) {\n                GridStack.addRemoveCB(this.el, node, false, false);\n            }\n            // remove our DOM data (circular link) and drag&drop permanently\n            delete el.gridstackNode;\n            this._removeDD(el);\n            this.engine.removeNode(node, removeDOM, triggerEvent);\n            if (removeDOM && el.parentElement) {\n                el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n            }\n        });\n        if (triggerEvent) {\n            this._triggerRemoveEvent();\n            this._triggerChangeEvent();\n        }\n        return this;\n    }\n    /**\n     * Removes all widgets from the grid.\n     * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\n     */ removeAll(removeDOM = true) {\n        // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n        this.engine.nodes.forEach((n)=>{\n            delete n.el.gridstackNode;\n            this._removeDD(n.el);\n        });\n        this.engine.removeAll(removeDOM);\n        this._triggerRemoveEvent();\n        return this;\n    }\n    /**\n     * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\n     * @param doAnimate if true the grid will animate.\n     */ setAnimation(doAnimate) {\n        if (doAnimate) {\n            this.el.classList.add(\"grid-stack-animate\");\n        } else {\n            this.el.classList.remove(\"grid-stack-animate\");\n        }\n        return this;\n    }\n    /**\n     * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\n     * Also toggle the grid-stack-static class.\n     * @param val if true the grid become static.\n     * @param updateClass true (default) if css class gets updated\n     * @param recurse true (default) if sub-grids also get updated\n     */ setStatic(val, updateClass = true, recurse = true) {\n        if (!!this.opts.staticGrid === val) return this;\n        val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\n        this._setupRemoveDrop();\n        this._setupAcceptWidget();\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n); // either delete or init Drag&drop\n            if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n        });\n        if (updateClass) {\n            this._setStaticClass();\n        }\n        return this;\n    }\n    /**\n     * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\n     * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\n     * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\n     */ update(els, opt) {\n        // support legacy call for now ?\n        if (arguments.length > 2) {\n            console.warn(\"gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon\");\n            // eslint-disable-next-line prefer-rest-params\n            let a = arguments, i = 1;\n            opt = {\n                x: a[i++],\n                y: a[i++],\n                w: a[i++],\n                h: a[i++]\n            };\n            return this.update(els, opt);\n        }\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el?.gridstackNode;\n            if (!n) return;\n            let w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n            delete w.autoPosition;\n            delete w.id;\n            // move/resize widget if anything changed\n            let keys = [\n                \"x\",\n                \"y\",\n                \"w\",\n                \"h\"\n            ];\n            let m;\n            if (keys.some((k)=>w[k] !== undefined && w[k] !== n[k])) {\n                m = {};\n                keys.forEach((k)=>{\n                    m[k] = w[k] !== undefined ? w[k] : n[k];\n                    delete w[k];\n                });\n            }\n            // for a move as well IFF there is any min/max fields set\n            if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n                m = {}; // will use node position but validate values\n            }\n            // check for content changing\n            if (w.content !== undefined) {\n                const itemContent = el.querySelector(\".grid-stack-item-content\");\n                if (itemContent && itemContent.innerHTML !== w.content) {\n                    itemContent.innerHTML = w.content;\n                    // restore any sub-grid back\n                    if (n.subGrid?.el) {\n                        itemContent.appendChild(n.subGrid.el);\n                        if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\n                    }\n                }\n                delete w.content;\n            }\n            // any remaining fields are assigned, but check for dragging changes, resize constrain\n            let changed = false;\n            let ddChanged = false;\n            for(const key in w){\n                if (key[0] !== \"_\" && n[key] !== w[key]) {\n                    n[key] = w[key];\n                    changed = true;\n                    ddChanged = ddChanged || !this.opts.staticGrid && (key === \"noResize\" || key === \"noMove\" || key === \"locked\");\n                }\n            }\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sanitizeMinMax(n);\n            // finally move the widget\n            if (m !== undefined) this.moveNode(n, m);\n            if (changed) {\n                this._writeAttr(el, n);\n            }\n            if (ddChanged) {\n                this._prepareDragDropByNode(n);\n            }\n        });\n        return this;\n    }\n    moveNode(n, m) {\n        this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);\n        this._updateContainerHeight();\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n    }\n    /**\n     * Updates widget height to match the content height to avoid v-scrollbar or dead space.\n     * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\n     * useAttrSize set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\n     */ resizeToContent(el, useAttrSize = false) {\n        if (!el) return;\n        el.classList.remove(\"size-to-content-max\");\n        if (!el.clientHeight) return; // 0 when hidden, skip\n        let n = el.gridstackNode;\n        if (!n) return;\n        const grid = n.grid;\n        if (!grid) return;\n        if (el.parentElement !== grid.el) return; // skip if we are not inside a grid\n        const cell = grid.getCellHeight();\n        if (!cell) return;\n        let height = useAttrSize && n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\n        let item;\n        if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\n        if (!item) item = el.querySelector(GridStack.resizeToContentParent);\n        if (!item) return;\n        const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\n        const itemH = useAttrSize && n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\n        let wantedH;\n        if (n.subGrid) {\n            // sub-grid - use their actual row count * their cell height\n            wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight();\n        } else {\n            // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\n            const child = item.firstElementChild;\n            if (!child) {\n                console.log(`Error: resizeToContent() '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);\n                return;\n            }\n            wantedH = child.getBoundingClientRect().height || itemH;\n        }\n        if (itemH === wantedH) return;\n        height += wantedH - itemH;\n        let h = Math.ceil(height / cell);\n        // check for min/max and special sizing\n        const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent : 0;\n        if (softMax && h > softMax) {\n            h = softMax;\n            el.classList.add(\"size-to-content-max\"); // get v-scroll back\n        }\n        if (n.minH && h < n.minH) h = n.minH;\n        else if (n.maxH && h > n.maxH) h = n.maxH;\n        if (h !== n.h) {\n            grid._ignoreLayoutsNodeChange = true;\n            grid.moveNode(n, {\n                h\n            });\n            delete grid._ignoreLayoutsNodeChange;\n        }\n    }\n    /** call the user resize (so they can do extra work) else our build in version */ resizeToContentCheck(el, useAttr = false) {\n        if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el, useAttr);\n        else this.resizeToContent(el, useAttr);\n    }\n    /**\n     * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\n     * @param value margin value\n     */ margin(value) {\n        let isMultiValue = typeof value === \"string\" && value.split(\" \").length > 1;\n        // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n        if (!isMultiValue) {\n            let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(value);\n            if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n        }\n        // re-use existing margin handling\n        this.opts.margin = value;\n        this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n        this._initMargin();\n        this._updateStyles(true); // true = force re-create\n        return this;\n    }\n    /** returns current margin number value (undefined if 4 sides don't match) */ getMargin() {\n        return this.opts.margin;\n    }\n    /**\n     * Returns true if the height of the grid will be less than the vertical\n     * constraint. Always returns true if grid doesn't have height constraint.\n     * @param node contains x,y,w,h,auto-position options\n     *\n     * @example\n     * if (grid.willItFit(newWidget)) {\n     *   grid.addWidget(newWidget);\n     * } else {\n     *   alert('Not enough free space to place the widget');\n     * }\n     */ willItFit(node) {\n        // support legacy call for now\n        if (arguments.length > 1) {\n            console.warn(\"gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon\");\n            // eslint-disable-next-line prefer-rest-params\n            let a = arguments, i = 0, w = {\n                x: a[i++],\n                y: a[i++],\n                w: a[i++],\n                h: a[i++],\n                autoPosition: a[i++]\n            };\n            return this.willItFit(w);\n        }\n        return this.engine.willItFit(node);\n    }\n    /** @internal */ _triggerChangeEvent() {\n        if (this.engine.batchMode) return this;\n        let elements = this.engine.getDirtyNodes(true); // verify they really changed\n        if (elements && elements.length) {\n            if (!this._ignoreLayoutsNodeChange) {\n                this.engine.layoutsNodesChange(elements);\n            }\n            this._triggerEvent(\"change\", elements);\n        }\n        this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n        return this;\n    }\n    /** @internal */ _triggerAddEvent() {\n        if (this.engine.batchMode) return this;\n        if (this.engine.addedNodes?.length) {\n            if (!this._ignoreLayoutsNodeChange) {\n                this.engine.layoutsNodesChange(this.engine.addedNodes);\n            }\n            // prevent added nodes from also triggering 'change' event (which is called next)\n            this.engine.addedNodes.forEach((n)=>{\n                delete n._dirty;\n            });\n            this._triggerEvent(\"added\", this.engine.addedNodes);\n            this.engine.addedNodes = [];\n        }\n        return this;\n    }\n    /** @internal */ _triggerRemoveEvent() {\n        if (this.engine.batchMode) return this;\n        if (this.engine.removedNodes?.length) {\n            this._triggerEvent(\"removed\", this.engine.removedNodes);\n            this.engine.removedNodes = [];\n        }\n        return this;\n    }\n    /** @internal */ _triggerEvent(type, data) {\n        let event = data ? new CustomEvent(type, {\n            bubbles: false,\n            detail: data\n        }) : new Event(type);\n        this.el.dispatchEvent(event);\n        return this;\n    }\n    /** @internal called to delete the current dynamic style sheet used for our layout */ _removeStylesheet() {\n        if (this._styles) {\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeStylesheet(this._styleSheetClass);\n            delete this._styles;\n        }\n        return this;\n    }\n    /** @internal updated/create the CSS styles for row based layout and initial margin setting */ _updateStyles(forceUpdate = false, maxH) {\n        // call to delete existing one if we change cellHeight / margin\n        if (forceUpdate) {\n            this._removeStylesheet();\n        }\n        if (!maxH) maxH = this.getRow();\n        this._updateContainerHeight();\n        // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n        if (this.opts.cellHeight === 0) {\n            return this;\n        }\n        let cellHeight = this.opts.cellHeight;\n        let cellHeightUnit = this.opts.cellHeightUnit;\n        let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\n        // create one as needed\n        if (!this._styles) {\n            // insert style to parent (instead of 'head' by default) to support WebComponent\n            let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n            this._styles = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.createStylesheet(this._styleSheetClass, styleLocation, {\n                nonce: this.opts.nonce\n            });\n            if (!this._styles) return this;\n            this._styles._max = 0;\n            // these are done once only\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\n            // content margins\n            let top = this.opts.marginTop + this.opts.marginUnit;\n            let bottom = this.opts.marginBottom + this.opts.marginUnit;\n            let right = this.opts.marginRight + this.opts.marginUnit;\n            let left = this.opts.marginLeft + this.opts.marginUnit;\n            let content = `${prefix} > .grid-stack-item-content`;\n            let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n            // resize handles offset (to match margin)\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\n        }\n        // now update the height specific fields\n        maxH = maxH || this._styles._max;\n        if (maxH > this._styles._max) {\n            let getHeight = (rows)=>cellHeight * rows + cellHeightUnit;\n            for(let i = this._styles._max + 1; i <= maxH; i++){\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i + 1}\"]`, `height: ${getHeight(i + 1)}`); // start at 2\n            }\n            this._styles._max = maxH;\n        }\n        return this;\n    }\n    /** @internal */ _updateContainerHeight() {\n        if (!this.engine || this.engine.batchMode) return this;\n        const parent = this.parentGridItem;\n        let row = this.getRow() + this._extraDragRow; // this checks for minRow already\n        const cellHeight = this.opts.cellHeight;\n        const unit = this.opts.cellHeightUnit;\n        if (!cellHeight) return this;\n        // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\n        if (!parent) {\n            const cssMinHeight = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(getComputedStyle(this.el)[\"minHeight\"]);\n            if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\n                const minRow = Math.floor(cssMinHeight.h / cellHeight);\n                if (row < minRow) {\n                    row = minRow;\n                }\n            }\n        }\n        this.el.setAttribute(\"gs-current-row\", String(row));\n        this.el.style.removeProperty(\"min-height\");\n        this.el.style.removeProperty(\"height\");\n        if (row) {\n            // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\n            this.el.style[parent ? \"minHeight\" : \"height\"] = row * cellHeight + unit;\n        }\n        // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\n        if (parent && !parent.grid.engine.batchMode && _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(parent)) {\n            parent.grid.resizeToContentCheck(parent.el);\n        }\n        return this;\n    }\n    /** @internal */ _prepareElement(el, triggerAddEvent = false, node) {\n        el.classList.add(this.opts.itemClass);\n        node = node || this._readAttr(el);\n        el.gridstackNode = node;\n        node.el = el;\n        node.grid = this;\n        let copy = {\n            ...node\n        };\n        node = this.engine.addNode(node, triggerAddEvent);\n        // write node attr back in case there was collision or we have to fix bad values during addNode()\n        if (!_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.same(node, copy)) {\n            this._writeAttr(el, node);\n        }\n        if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(node)) el.classList.add(\"size-to-content\");\n        this._prepareDragDropByNode(node);\n        return this;\n    }\n    /** @internal call to write position x,y,w,h attributes back to element */ _writePosAttr(el, n) {\n        if (n.x !== undefined && n.x !== null) {\n            el.setAttribute(\"gs-x\", String(n.x));\n        }\n        if (n.y !== undefined && n.y !== null) {\n            el.setAttribute(\"gs-y\", String(n.y));\n        }\n        n.w > 1 ? el.setAttribute(\"gs-w\", String(n.w)) : el.removeAttribute(\"gs-w\");\n        n.h > 1 ? el.setAttribute(\"gs-h\", String(n.h)) : el.removeAttribute(\"gs-h\");\n        return this;\n    }\n    /** @internal call to write any default attributes back to element */ _writeAttr(el, node) {\n        if (!node) return this;\n        this._writePosAttr(el, node);\n        let attrs /*: GridStackWidget but strings */  = {\n            autoPosition: \"gs-auto-position\",\n            noResize: \"gs-no-resize\",\n            noMove: \"gs-no-move\",\n            locked: \"gs-locked\",\n            id: \"gs-id\"\n        };\n        for(const key in attrs){\n            if (node[key]) {\n                el.setAttribute(attrs[key], String(node[key]));\n            } else {\n                el.removeAttribute(attrs[key]);\n            }\n        }\n        return this;\n    }\n    /** @internal call to read any default attributes from element */ _readAttr(el, clearDefaultAttr = true) {\n        let n = {};\n        n.x = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-x\"));\n        n.y = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-y\"));\n        n.w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-w\"));\n        n.h = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-h\"));\n        n.autoPosition = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-auto-position\"));\n        n.noResize = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-no-resize\"));\n        n.noMove = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-no-move\"));\n        n.locked = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute(\"gs-locked\"));\n        n.id = el.getAttribute(\"gs-id\");\n        // read but never written out\n        n.maxW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-w\"));\n        n.minW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-w\"));\n        n.maxH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-max-h\"));\n        n.minH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute(\"gs-min-h\"));\n        // v8.x optimization to reduce un-needed attr that don't render or are default CSS\n        if (clearDefaultAttr) {\n            if (n.w === 1) el.removeAttribute(\"gs-w\");\n            if (n.h === 1) el.removeAttribute(\"gs-h\");\n            if (n.maxW) el.removeAttribute(\"gs-max-w\");\n            if (n.minW) el.removeAttribute(\"gs-min-w\");\n            if (n.maxH) el.removeAttribute(\"gs-max-h\");\n            if (n.minH) el.removeAttribute(\"gs-min-h\");\n        }\n        // remove any key not found (null or false which is default)\n        for(const key in n){\n            if (!n.hasOwnProperty(key)) return;\n            if (!n[key] && n[key] !== 0) {\n                delete n[key];\n            }\n        }\n        return n;\n    }\n    /** @internal */ _setStaticClass() {\n        let classes = [\n            \"grid-stack-static\"\n        ];\n        if (this.opts.staticGrid) {\n            this.el.classList.add(...classes);\n            this.el.setAttribute(\"gs-static\", \"true\");\n        } else {\n            this.el.classList.remove(...classes);\n            this.el.removeAttribute(\"gs-static\");\n        }\n        return this;\n    }\n    /**\n     * called when we are being resized - check if the one Column Mode needs to be turned on/off\n     * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\n     * or `sizeToContent` gridItem options.\n     */ onResize() {\n        if (!this.el?.clientWidth) return; // return if we're gone or no size yet (will get called again)\n        if (this.prevWidth === this.el.clientWidth) return; // no-op\n        this.prevWidth = this.el.clientWidth;\n        // console.log('onResize ', this.el.clientWidth);\n        this.batchUpdate();\n        // see if we're nested and take our column count from our parent....\n        let columnChanged = false;\n        if (this._autoColumn && this.parentGridItem) {\n            if (this.opts.column !== this.parentGridItem.w) {\n                this.column(this.parentGridItem.w, \"none\");\n                columnChanged = true;\n            }\n        } else {\n            // else check for 1 column in/out behavior\n            let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize || this.opts.column === 1 && !this._prevColumn;\n            if (this.opts.column === 1 !== oneColumn) {\n                // if (this.opts.animate) this.setAnimation(false); // 1 <-> 12 is too radical, turn off animation and we need it for sizeToContent\n                this.column(oneColumn ? 1 : this._prevColumn);\n                // if (this.opts.animate) setTimeout(() => this.setAnimation(true));\n                columnChanged = true;\n            }\n        }\n        // make the cells content square again\n        if (this._isAutoCellHeight) this.cellHeight();\n        // update any nested grids, or items size\n        this.engine.nodes.forEach((n)=>{\n            if (n.subGrid) n.subGrid.onResize();\n        });\n        if (!this._skipInitialResize) this.doContentResize(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\n        delete this._skipInitialResize;\n        this.batchUpdate(false);\n        return this;\n    }\n    doContentResize(delay = true, useAttr = false, n = undefined) {\n        // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\n        // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\n        setTimeout(()=>{\n            if (n) {\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n)) this.resizeToContentCheck(n.el, useAttr);\n            } else if (this.engine.nodes.some((n)=>_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n))) {\n                const nodes = [\n                    ...this.engine.nodes\n                ]; // in case order changes while resizing one\n                this.batchUpdate();\n                nodes.forEach((n)=>{\n                    if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n)) this.resizeToContentCheck(n.el, useAttr);\n                });\n                this.batchUpdate(false);\n            }\n            // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\n            if (this._gsEventHandler[\"resizecontent\"]) this._gsEventHandler[\"resizecontent\"](null, n ? [\n                n\n            ] : this.engine.nodes);\n        }, delay ? 300 + 10 : 0);\n    }\n    /** add or remove the grid element size event handler */ _updateResizeEvent(forceRemove = false) {\n        // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)\n        // or supporting new sizeToContent option.\n        const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || !this.opts.disableOneColumnMode || this.engine.nodes.find((n)=>n.sizeToContent));\n        if (!forceRemove && trackSize && !this.resizeObserver) {\n            this._sizeThrottle = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.throttle(()=>this.onResize(), this.opts.cellHeightThrottle);\n            this.resizeObserver = new ResizeObserver(()=>this._sizeThrottle());\n            this.resizeObserver.observe(this.el);\n            this._skipInitialResize = true; // makeWidget will originally have called on startup\n        } else if ((forceRemove || !trackSize) && this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            delete this.resizeObserver;\n            delete this._sizeThrottle;\n        }\n        return this;\n    }\n    /** @internal convert a potential selector into actual element */ static getElement(els = \".grid-stack-item\") {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElement(els);\n    }\n    /** @internal */ static getElements(els = \".grid-stack-item\") {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n    }\n    /** @internal */ static getGridElement(els) {\n        return GridStack.getElement(els);\n    }\n    /** @internal */ static getGridElements(els) {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n    }\n    /** @internal initialize margin top/bottom/left/right and units */ _initMargin() {\n        let data;\n        let margin = 0;\n        // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n        let margins = [];\n        if (typeof this.opts.margin === \"string\") {\n            margins = this.opts.margin.split(\" \");\n        }\n        if (margins.length === 2) {\n            this.opts.marginTop = this.opts.marginBottom = margins[0];\n            this.opts.marginLeft = this.opts.marginRight = margins[1];\n        } else if (margins.length === 4) {\n            this.opts.marginTop = margins[0];\n            this.opts.marginRight = margins[1];\n            this.opts.marginBottom = margins[2];\n            this.opts.marginLeft = margins[3];\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.margin);\n            this.opts.marginUnit = data.unit;\n            margin = this.opts.margin = data.h;\n        }\n        // see if top/bottom/left/right need to be set as well\n        if (this.opts.marginTop === undefined) {\n            this.opts.marginTop = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginTop);\n            this.opts.marginTop = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginBottom === undefined) {\n            this.opts.marginBottom = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginBottom);\n            this.opts.marginBottom = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginRight === undefined) {\n            this.opts.marginRight = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginRight);\n            this.opts.marginRight = data.h;\n            delete this.opts.margin;\n        }\n        if (this.opts.marginLeft === undefined) {\n            this.opts.marginLeft = margin;\n        } else {\n            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginLeft);\n            this.opts.marginLeft = data.h;\n            delete this.opts.margin;\n        }\n        this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n        if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n            this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n        }\n        return this;\n    }\n    /* ===========================================================================================\n     * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\n     * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n     * ===========================================================================================\n     */ /** get the global (but static to this code) DD implementation */ static getDD() {\n        return dd;\n    }\n    /**\n     * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\n     * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\n     * is dynamically create and needs to be set later.\n     * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\n     * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\n     * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\n     */ static setupDragIn(dragIn, dragInOptions, root = document) {\n        if (dragInOptions?.pause !== undefined) {\n            _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = dragInOptions.pause;\n        }\n        dragInOptions = {\n            ..._types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions,\n            ...dragInOptions || {}\n        };\n        let els = typeof dragIn === \"string\" ? _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(dragIn, root) : dragIn;\n        if (els.length) els?.forEach((el)=>{\n            if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n        });\n    }\n    /**\n     * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\n     * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\n     * @param els widget or selector to modify.\n     * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\n     */ movable(els, val) {\n        if (this.opts.staticGrid) return this; // can't move a static grid!\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el.gridstackNode;\n            if (!n) return;\n            val ? delete n.noMove : n.noMove = true;\n            this._prepareDragDropByNode(n); // init DD if need be, and adjust\n        });\n        return this;\n    }\n    /**\n     * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\n     * @param els  widget or selector to modify\n     * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\n     */ resizable(els, val) {\n        if (this.opts.staticGrid) return this; // can't resize a static grid!\n        GridStack.getElements(els).forEach((el)=>{\n            let n = el.gridstackNode;\n            if (!n) return;\n            val ? delete n.noResize : n.noResize = true;\n            this._prepareDragDropByNode(n); // init DD if need be, and adjust\n        });\n        return this;\n    }\n    /**\n     * Temporarily disables widgets moving/resizing.\n     * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\n     * Note: no-op for static grid\n     * This is a shortcut for:\n     * @example\n     *  grid.enableMove(false);\n     *  grid.enableResize(false);\n     * @param recurse true (default) if sub-grids also get updated\n     */ disable(recurse = true) {\n        if (this.opts.staticGrid) return;\n        this.enableMove(false, recurse);\n        this.enableResize(false, recurse);\n        this._triggerEvent(\"disable\");\n        return this;\n    }\n    /**\n     * Re-enables widgets moving/resizing - see disable().\n     * Note: no-op for static grid.\n     * This is a shortcut for:\n     * @example\n     *  grid.enableMove(true);\n     *  grid.enableResize(true);\n     * @param recurse true (default) if sub-grids also get updated\n     */ enable(recurse = true) {\n        if (this.opts.staticGrid) return;\n        this.enableMove(true, recurse);\n        this.enableResize(true, recurse);\n        this._triggerEvent(\"enable\");\n        return this;\n    }\n    /**\n     * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\n     * @param recurse true (default) if sub-grids also get updated\n     */ enableMove(doEnable, recurse = true) {\n        if (this.opts.staticGrid) return this; // can't move a static grid!\n        doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n);\n            if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n        });\n        return this;\n    }\n    /**\n     * Enables/disables widget resizing. No-op for static grids.\n     * @param recurse true (default) if sub-grids also get updated\n     */ enableResize(doEnable, recurse = true) {\n        if (this.opts.staticGrid) return this; // can't size a static grid!\n        doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\n        this.engine.nodes.forEach((n)=>{\n            this._prepareDragDropByNode(n);\n            if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n        });\n        return this;\n    }\n    /** @internal removes any drag&drop present (called during destroy) */ _removeDD(el) {\n        dd.draggable(el, \"destroy\").resizable(el, \"destroy\");\n        if (el.gridstackNode) {\n            delete el.gridstackNode._initDD; // reset our DD init flag\n        }\n        delete el.ddElement;\n        return this;\n    }\n    /** @internal called to add drag over to support widgets being added externally */ _setupAcceptWidget() {\n        // check if we need to disable things\n        if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n            dd.droppable(this.el, \"destroy\");\n            return this;\n        }\n        // vars shared across all methods\n        let cellHeight, cellWidth;\n        let onDrag = (event, el, helper)=>{\n            let node = el.gridstackNode;\n            if (!node) return;\n            helper = helper || el;\n            let parent = this.el.getBoundingClientRect();\n            let { top, left } = helper.getBoundingClientRect();\n            left -= parent.left;\n            top -= parent.top;\n            let ui = {\n                position: {\n                    top,\n                    left\n                }\n            };\n            if (node._temporaryRemoved) {\n                node.x = Math.max(0, Math.round(left / cellWidth));\n                node.y = Math.max(0, Math.round(top / cellHeight));\n                delete node.autoPosition;\n                this.engine.nodeBoundFix(node);\n                // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n                if (!this.engine.willItFit(node)) {\n                    node.autoPosition = true; // ignore x,y and try for any slot...\n                    if (!this.engine.willItFit(node)) {\n                        dd.off(el, \"drag\"); // stop calling us\n                        return; // full grid or can't grow\n                    }\n                    if (node._willFitPos) {\n                        // use the auto position instead #1687\n                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._willFitPos);\n                        delete node._willFitPos;\n                    }\n                }\n                // re-use the existing node dragging method\n                this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n            } else {\n                // re-use the existing node dragging that does so much of the collision detection\n                this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n            }\n        };\n        dd.droppable(this.el, {\n            accept: (el)=>{\n                let node = el.gridstackNode;\n                // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n                if (node?.grid === this) return true;\n                if (!this.opts.acceptWidgets) return false;\n                // check for accept method or class matching\n                let canAccept = true;\n                if (typeof this.opts.acceptWidgets === \"function\") {\n                    canAccept = this.opts.acceptWidgets(el);\n                } else {\n                    let selector = this.opts.acceptWidgets === true ? \".grid-stack-item\" : this.opts.acceptWidgets;\n                    canAccept = el.matches(selector);\n                }\n                // finally check to make sure we actually have space left #1571\n                if (canAccept && node && this.opts.maxRow) {\n                    let n = {\n                        w: node.w,\n                        h: node.h,\n                        minW: node.minW,\n                        minH: node.minH\n                    }; // only width/height matters and autoPosition\n                    canAccept = this.engine.willItFit(n);\n                }\n                return canAccept;\n            }\n        })/**\n             * entering our grid area\n             */ .on(this.el, \"dropover\", (event, el, helper)=>{\n            // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n            let node = el.gridstackNode;\n            // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n            if (node?.grid === this && !node._temporaryRemoved) {\n                // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n                return false; // prevent parent from receiving msg (which may be a grid as well)\n            }\n            // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n            if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\n                // console.log('dropover without leave'); // TEST\n                let otherGrid = node.grid;\n                otherGrid._leave(el, helper);\n            }\n            // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n            cellWidth = this.cellWidth();\n            cellHeight = this.getCellHeight(true);\n            // load any element attributes if we don't have a node\n            if (!node) {\n                node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\n            }\n            if (!node.grid) {\n                node._isExternal = true;\n                el.gridstackNode = node;\n            }\n            // calculate the grid size based on element outer size\n            helper = helper || el;\n            let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n            let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n            // if the item came from another grid, make a copy and save the original info in case we go back there\n            if (node.grid && node.grid !== this) {\n                // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n                // console.log('dropover cloning node'); // TEST\n                if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n                el.gridstackNode = node = {\n                    ...node,\n                    w,\n                    h,\n                    grid: this\n                };\n                delete node.x;\n                delete node.y;\n                this.engine.cleanupNode(node).nodeBoundFix(node);\n                // restore some internal fields we need after clearing them all\n                node._initDD = node._isExternal = node._temporaryRemoved = true; // so it can be inserted onDrag below\n            } else {\n                node.w = w;\n                node.h = h;\n                node._temporaryRemoved = true; // so we can insert it\n            }\n            // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n            this._itemRemoving(node.el, false);\n            dd.on(el, \"drag\", onDrag);\n            // make sure this is called at least once when going fast #1578\n            onDrag(event, el, helper);\n            return false; // prevent parent from receiving msg (which may be a grid as well)\n        })/**\n             * Leaving our grid area...\n             */ .on(this.el, \"dropout\", (event, el, helper)=>{\n            // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n            let node = el.gridstackNode;\n            if (!node) return false;\n            // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n            // so skip this one if we're not the active grid really..\n            if (!node.grid || node.grid === this) {\n                this._leave(el, helper);\n                // if we were created as temporary nested grid, go back to before state\n                if (this._isTemp) {\n                    this.removeAsSubGrid(node);\n                }\n            }\n            return false; // prevent parent from receiving msg (which may be grid as well)\n        })/**\n             * end - releasing the mouse\n             */ .on(this.el, \"drop\", (event, el, helper)=>{\n            let node = el.gridstackNode;\n            // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n            if (node?.grid === this && !node._isExternal) return false;\n            let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n            this.placeholder.remove();\n            // notify previous grid of removal\n            // console.log('drop delete _gridstackNodeOrig') // TEST\n            let origNode = el._gridstackNodeOrig;\n            delete el._gridstackNodeOrig;\n            if (wasAdded && origNode?.grid && origNode.grid !== this) {\n                let oGrid = origNode.grid;\n                oGrid.engine.removeNodeFromLayoutCache(origNode);\n                oGrid.engine.removedNodes.push(origNode);\n                oGrid._triggerRemoveEvent()._triggerChangeEvent();\n                // if it's an empty sub-grid that got auto-created, nuke it\n                if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n                    oGrid.removeAsSubGrid();\n                }\n            }\n            if (!node) return false;\n            // use existing placeholder node as it's already in our list with drop location\n            if (wasAdded) {\n                this.engine.cleanupNode(node); // removes all internal _xyz values\n                node.grid = this;\n            }\n            dd.off(el, \"drag\");\n            // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n            // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n            if (helper !== el) {\n                helper.remove();\n                el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n                if (wasAdded) {\n                    el = el.cloneNode(true);\n                }\n            } else {\n                el.remove(); // reduce flicker as we change depth here, and size further down\n                this._removeDD(el);\n            }\n            if (!wasAdded) return false;\n            el.gridstackNode = node;\n            node.el = el;\n            let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\n            // @ts-ignore\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(el); // @ts-ignore\n            this._writeAttr(el, node);\n            el.classList.add(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n            this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n            if (subGrid) {\n                subGrid.parentGridItem = node;\n                if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n            }\n            this._updateContainerHeight();\n            this.engine.addedNodes.push(node); // @ts-ignore\n            this._triggerAddEvent(); // @ts-ignore\n            this._triggerChangeEvent();\n            this.engine.endUpdate();\n            if (this._gsEventHandler[\"dropped\"]) {\n                this._gsEventHandler[\"dropped\"]({\n                    ...event,\n                    type: \"dropped\"\n                }, origNode && origNode.grid ? origNode : undefined, node);\n            }\n            // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n            window.setTimeout(()=>{\n                // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n                if (node.el && node.el.parentElement) {\n                    this._prepareDragDropByNode(node);\n                } else {\n                    this.engine.removeNode(node);\n                }\n                delete node.grid._isTemp;\n            });\n            return false; // prevent parent from receiving msg (which may be grid as well)\n        });\n        return this;\n    }\n    /** @internal mark item for removal */ _itemRemoving(el, remove) {\n        let node = el ? el.gridstackNode : undefined;\n        if (!node || !node.grid || el.classList.contains(this.opts.removableOptions.decline)) return;\n        remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n        remove ? el.classList.add(\"grid-stack-item-removing\") : el.classList.remove(\"grid-stack-item-removing\");\n    }\n    /** @internal called to setup a trash drop zone if the user specifies it */ _setupRemoveDrop() {\n        if (!this.opts.staticGrid && typeof this.opts.removable === \"string\") {\n            let trashEl = document.querySelector(this.opts.removable);\n            if (!trashEl) return this;\n            // only register ONE drop-over/dropout callback for the 'trash', and it will\n            // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n            // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n            if (!dd.isDroppable(trashEl)) {\n                dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, \"dropover\", (event, el)=>this._itemRemoving(el, true)).on(trashEl, \"dropout\", (event, el)=>this._itemRemoving(el, false));\n            }\n        }\n        return this;\n    }\n    /** @internal prepares the element for drag&drop */ _prepareDragDropByNode(node) {\n        let el = node.el;\n        const noMove = node.noMove || this.opts.disableDrag;\n        const noResize = node.noResize || this.opts.disableResize;\n        // check for disabled grid first\n        if (this.opts.staticGrid || noMove && noResize) {\n            if (node._initDD) {\n                this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n                delete node._initDD;\n            }\n            el.classList.add(\"ui-draggable-disabled\", \"ui-resizable-disabled\"); // add styles one might depend on #1435\n            return this;\n        }\n        if (!node._initDD) {\n            // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n            let cellWidth;\n            let cellHeight;\n            /** called when item starts moving/resizing */ let onStartMoving = (event, ui)=>{\n                // trigger any 'dragstart' / 'resizestart' manually\n                if (this._gsEventHandler[event.type]) {\n                    this._gsEventHandler[event.type](event, event.target);\n                }\n                cellWidth = this.cellWidth();\n                cellHeight = this.getCellHeight(true); // force pixels for calculations\n                this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n            };\n            /** called when item is being dragged/resized */ let dragOrResize = (event, ui)=>{\n                this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n            };\n            /** called when the item stops moving/resizing */ let onEndMoving = (event)=>{\n                this.placeholder.remove();\n                delete node._moving;\n                delete node._event;\n                delete node._lastTried;\n                // if the item has moved to another grid, we're done here\n                let target = event.target;\n                if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n                node.el = target;\n                if (node._isAboutToRemove) {\n                    let grid = el.gridstackNode.grid;\n                    if (grid._gsEventHandler[event.type]) {\n                        grid._gsEventHandler[event.type](event, target);\n                    }\n                    grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\n                    grid.removeWidget(el, true, true);\n                } else {\n                    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(target);\n                    if (node._temporaryRemoved) {\n                        // got removed - restore item back to before dragging position\n                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._orig); // @ts-ignore\n                        this._writePosAttr(target, node);\n                        this.engine.addNode(node);\n                    } else {\n                        // move to new placeholder location\n                        this._writePosAttr(target, node);\n                    }\n                    if (this._gsEventHandler[event.type]) {\n                        this._gsEventHandler[event.type](event, target);\n                    }\n                }\n                // @ts-ignore\n                this._extraDragRow = 0; // @ts-ignore\n                this._updateContainerHeight(); // @ts-ignore\n                this._triggerChangeEvent();\n                this.engine.endUpdate();\n                if (event.type === \"resizestop\") {\n                    if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\n                    this.doContentResize(false, true, node); // no amin wait as will use the actual sized coordinate attr\n                }\n            };\n            dd.draggable(el, {\n                start: onStartMoving,\n                stop: onEndMoving,\n                drag: dragOrResize\n            }).resizable(el, {\n                start: onStartMoving,\n                stop: onEndMoving,\n                resize: dragOrResize\n            });\n            node._initDD = true; // we've set DD support now\n        }\n        // finally fine tune move vs resize by disabling any part...\n        dd.draggable(el, noMove ? \"disable\" : \"enable\").resizable(el, noResize ? \"disable\" : \"enable\");\n        return this;\n    }\n    /** @internal handles actual drag/resize start */ _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n        this.engine.cleanNodes().beginUpdate(node);\n        // @ts-ignore\n        this._writePosAttr(this.placeholder, node);\n        this.el.appendChild(this.placeholder);\n        // console.log('_onStartMoving placeholder') // TEST\n        node.el = this.placeholder;\n        node._lastUiPosition = ui.position;\n        node._prevYPix = ui.position.top;\n        node._moving = event.type === \"dragstart\"; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n        delete node._lastTried;\n        if (event.type === \"dropover\" && node._temporaryRemoved) {\n            // console.log('engine.addNode x=' + node.x); // TEST\n            this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n            node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n        }\n        // set the min/max resize info\n        this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n        if (event.type === \"resizestart\") {\n            dd.resizable(el, \"option\", \"minWidth\", cellWidth * (node.minW || 1)).resizable(el, \"option\", \"minHeight\", cellHeight * (node.minH || 1));\n            if (node.maxW) {\n                dd.resizable(el, \"option\", \"maxWidth\", cellWidth * node.maxW);\n            }\n            if (node.maxH) {\n                dd.resizable(el, \"option\", \"maxHeight\", cellHeight * node.maxH);\n            }\n        }\n    }\n    /** @internal handles actual drag/resize */ _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n        let p = {\n            ...node._orig\n        }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n        let resizing;\n        let mLeft = this.opts.marginLeft, mRight = this.opts.marginRight, mTop = this.opts.marginTop, mBottom = this.opts.marginBottom;\n        // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n        let mHeight = Math.round(cellHeight * 0.1), mWidth = Math.round(cellWidth * 0.1);\n        mLeft = Math.min(mLeft, mWidth);\n        mRight = Math.min(mRight, mWidth);\n        mTop = Math.min(mTop, mHeight);\n        mBottom = Math.min(mBottom, mHeight);\n        if (event.type === \"drag\") {\n            if (node._temporaryRemoved) return; // handled by dropover\n            let distance = ui.position.top - node._prevYPix;\n            node._prevYPix = ui.position.top;\n            if (this.opts.draggable.scroll !== false) {\n                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollPosition(el, ui.position, distance);\n            }\n            // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n            let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n            let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n            p.x = Math.round(left / cellWidth);\n            p.y = Math.round(top / cellHeight);\n            // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n            let prev = this._extraDragRow;\n            if (this.engine.collide(node, p)) {\n                let row = this.getRow();\n                let extra = Math.max(0, p.y + node.h - row);\n                if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n                    extra = Math.max(0, this.opts.maxRow - row);\n                } // @ts-ignore\n                this._extraDragRow = extra; // @ts-ignore\n            } else this._extraDragRow = 0; // @ts-ignore\n            if (this._extraDragRow !== prev) this._updateContainerHeight();\n            if (node.x === p.x && node.y === p.y) return; // skip same\n        // DON'T skip one we tried as we might have failed because of coverage <50% before\n        // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n        } else if (event.type === \"resize\") {\n            if (p.x < 0) return;\n            // Scrolling page if needed\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollResize(event, el, cellHeight);\n            // get new size\n            p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n            p.h = Math.round((ui.size.height - mTop) / cellHeight);\n            if (node.w === p.w && node.h === p.h) return;\n            if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n            // if we size on left/top side this might move us, so get possible new position as well\n            let left = ui.position.left + mLeft;\n            let top = ui.position.top + mTop;\n            p.x = Math.round(left / cellWidth);\n            p.y = Math.round(top / cellHeight);\n            resizing = true;\n        }\n        node._event = event;\n        node._lastTried = p; // set as last tried (will nuke if we go there)\n        let rect = {\n            x: ui.position.left + mLeft,\n            y: ui.position.top + mTop,\n            w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n            h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n        };\n        if (this.engine.moveNodeCheck(node, {\n            ...p,\n            cellWidth,\n            cellHeight,\n            rect,\n            resizing\n        })) {\n            node._lastUiPosition = ui.position;\n            this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n            delete node._skipDown;\n            if (resizing && node.subGrid) node.subGrid.onResize();\n            this._extraDragRow = 0; // @ts-ignore\n            this._updateContainerHeight();\n            let target = event.target; // @ts-ignore\n            this._writePosAttr(target, node);\n            if (this._gsEventHandler[event.type]) {\n                this._gsEventHandler[event.type](event, target);\n            }\n        }\n    }\n    /** @internal called when item leaving our area by either cursor dropout event\n     * or shape is outside our boundaries. remove it from us, and mark temporary if this was\n     * our item to start with else restore prev node values from prev grid it came from.\n     */ _leave(el, helper) {\n        let node = el.gridstackNode;\n        if (!node) return;\n        dd.off(el, \"drag\"); // no need to track while being outside\n        // this gets called when cursor leaves and shape is outside, so only do this once\n        if (node._temporaryRemoved) return;\n        node._temporaryRemoved = true;\n        this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n        node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n        if (this.opts.removable === true) {\n            // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n            this._itemRemoving(el, true);\n        }\n        // finally if item originally came from another grid, but left us, restore things back to prev info\n        if (el._gridstackNodeOrig) {\n            // console.log('leave delete _gridstackNodeOrig') // TEST\n            el.gridstackNode = el._gridstackNodeOrig;\n            delete el._gridstackNodeOrig;\n        } else if (node._isExternal) {\n            // item came from outside (like a toolbar) so nuke any node info\n            delete node.el;\n            delete el.gridstackNode;\n            // and restore all nodes back to original\n            this.engine.restoreInitial();\n        }\n    }\n    // legacy method removed\n    commit() {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.obsolete)(this, this.batchUpdate(false), \"commit\", \"batchUpdate\", \"5.2\");\n        return this;\n    }\n}\n/** parent class for sizing content. defaults to '.grid-stack-item-content' */ GridStack.resizeToContentParent = \".grid-stack-item-content\";\n/** scoping so users can call GridStack.Utils.sort() for example */ GridStack.Utils = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */ GridStack.Engine = _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\nGridStack.GDRev = \"9.4.0\";\n //# sourceMappingURL=gridstack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvZ3JpZHN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDb0Q7QUFDWDtBQUNtQjtBQUM3RDs7Ozs7Q0FLQyxHQUM0QztBQUNSO0FBQ0k7QUFDekMsb0JBQW9CLEdBQ3BCLE1BQU1RLEtBQUssSUFBSUgsc0RBQVdBO0FBQzFCLDZGQUE2RjtBQUNyRTtBQUNBO0FBQ1c7QUFDSjtBQUMvQjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNSTtJQUNGOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE9BQU9DLEtBQUtDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLGFBQWEsYUFBYSxFQUFFO1FBQ2xELElBQUlDLEtBQUtKLFVBQVVLLGNBQWMsQ0FBQ0Y7UUFDbEMsSUFBSSxDQUFDQyxJQUFJO1lBQ0wsSUFBSSxPQUFPRCxlQUFlLFVBQVU7Z0JBQ2hDRyxRQUFRQyxLQUFLLENBQUMsMERBQTBESixhQUFhLDRDQUNqRjtZQUNSLE9BQ0s7Z0JBQ0RHLFFBQVFDLEtBQUssQ0FBQztZQUNsQjtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0gsR0FBR0ksU0FBUyxFQUFFO1lBQ2ZKLEdBQUdJLFNBQVMsR0FBRyxJQUFJUixVQUFVSSxJQUFJWix5Q0FBS0EsQ0FBQ2lCLFNBQVMsQ0FBQ1A7UUFDckQ7UUFDQSxPQUFPRSxHQUFHSSxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPRSxRQUFRUixVQUFVLENBQUMsQ0FBQyxFQUFFUyxXQUFXLGFBQWEsRUFBRTtRQUNuRCxJQUFJQyxRQUFRLEVBQUU7UUFDZFosVUFBVWEsZUFBZSxDQUFDRixVQUFVRyxPQUFPLENBQUNWLENBQUFBO1lBQ3hDLElBQUksQ0FBQ0EsR0FBR0ksU0FBUyxFQUFFO2dCQUNmSixHQUFHSSxTQUFTLEdBQUcsSUFBSVIsVUFBVUksSUFBSVoseUNBQUtBLENBQUNpQixTQUFTLENBQUNQO1lBQ3JEO1lB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MUosT0FBTyxxR0FBcUc7UUFDbklBLEtBQUt0SCxFQUFFLEdBQUdzSCxLQUFLNFIsV0FBVyxJQUFJVixTQUFTQSxTQUFTeFksSUFBSSx3Q0FBd0M7UUFDNUYsSUFBSSxJQUFJLENBQUNpQixJQUFJLENBQUNvWCxTQUFTLEtBQUssTUFBTTtZQUM5QixpR0FBaUc7WUFDakcsSUFBSSxDQUFDaUIsYUFBYSxDQUFDdFosSUFBSTtRQUMzQjtRQUNBLG1HQUFtRztRQUNuRyxJQUFJQSxHQUFHb1osa0JBQWtCLEVBQUU7WUFDdkIseURBQXlEO1lBQ3pEcFosR0FBRzhFLGFBQWEsR0FBRzlFLEdBQUdvWixrQkFBa0I7WUFDeEMsT0FBT3BaLEdBQUdvWixrQkFBa0I7UUFDaEMsT0FDSyxJQUFJOVIsS0FBSzRSLFdBQVcsRUFBRTtZQUN2QixnRUFBZ0U7WUFDaEUsT0FBTzVSLEtBQUt0SCxFQUFFO1lBQ2QsT0FBT0EsR0FBRzhFLGFBQWE7WUFDdkIseUNBQXlDO1lBQ3pDLElBQUksQ0FBQ1EsTUFBTSxDQUFDMlcsY0FBYztRQUM5QjtJQUNKO0lBQ0Esd0JBQXdCO0lBQ3hCQyxTQUFTO1FBQUU3YyxnREFBUUEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDaUgsV0FBVyxDQUFDLFFBQVEsVUFBVSxlQUFlO1FBQVEsT0FBTyxJQUFJO0lBQUU7QUFDckc7QUFDQSw0RUFBNEUsR0FDNUUxRyxVQUFVNFMscUJBQXFCLEdBQUc7QUFDbEMsaUVBQWlFLEdBQ2pFNVMsVUFBVVIsS0FBSyxHQUFHQSx5Q0FBS0E7QUFDdkIsbUVBQW1FLEdBQ25FUSxVQUFVdWMsTUFBTSxHQUFHaGQsOERBQWVBO0FBQ2xDUyxVQUFVd2MsS0FBSyxHQUFHO0FBQ0csQ0FDckIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC9ncmlkc3RhY2suanM/ZWNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEdyaWRTdGFjayA5LjQuMFxuICogaHR0cHM6Ly9ncmlkc3RhY2tqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxLTIwMjIgQWxhaW4gRHVtZXNueVxuICogc2VlIHJvb3QgbGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy90cmVlL21hc3Rlci9MSUNFTlNFXG4gKi9cbmltcG9ydCB7IEdyaWRTdGFja0VuZ2luZSB9IGZyb20gJy4vZ3JpZHN0YWNrLWVuZ2luZSc7XG5pbXBvcnQgeyBVdGlscywgb2Jzb2xldGUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGdyaWREZWZhdWx0cywgZHJhZ0luRGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbi8qXG4gKiBhbmQgaW5jbHVkZSBEJkQgYnkgZGVmYXVsdFxuICogVE9ETzogd2hpbGUgd2UgY291bGQgZ2VuZXJhdGUgYSBncmlkc3RhY2stc3RhdGljLmpzIGF0IHNtYWxsZXIgc2l6ZSAtIHNhdmVzIGFib3V0IDMxayAoNDFrIC0+IDcyaylcbiAqIEkgZG9uJ3Qga25vdyBob3cgdG8gZ2VuZXJhdGUgdGhlIEREIG9ubHkgY29kZSBhdCB0aGUgcmVtYWluaW5nIDMxayB0byBkZWxheSBsb2FkIGFzIGNvZGUgZGVwZW5kcyBvbiBHcmlkc3RhY2sudHNcbiAqIGFsc28gaXQgY2F1c2VkIGxvYWRpbmcgaXNzdWVzIGluIHByb2QgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyaWRzdGFjay9ncmlkc3RhY2suanMvaXNzdWVzLzIwMzlcbiAqL1xuaW1wb3J0IHsgRERHcmlkU3RhY2sgfSBmcm9tICcuL2RkLWdyaWRzdGFjayc7XG5pbXBvcnQgeyBpc1RvdWNoIH0gZnJvbSAnLi9kZC10b3VjaCc7XG5pbXBvcnQgeyBERE1hbmFnZXIgfSBmcm9tICcuL2RkLW1hbmFnZXInO1xuLyoqIGdsb2JhbCBpbnN0YW5jZSAqL1xuY29uc3QgZGQgPSBuZXcgRERHcmlkU3RhY2s7XG4vLyBleHBvcnQgYWxsIGRlcGVuZGVudCBmaWxlIGFzIHdlbGwgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHVzZXJzIHRvIGp1c3QgaW1wb3J0IHRoZSBtYWluIGZpbGVcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2dyaWRzdGFjay1lbmdpbmUnO1xuZXhwb3J0ICogZnJvbSAnLi9kZC1ncmlkc3RhY2snO1xuLyoqXG4gKiBNYWluIGdyaWRzdGFjayBjbGFzcyAtIHlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgR3JpZFN0YWNrLmluaXQoKWAgZmlyc3QgdG8gaW5pdGlhbGl6ZSB5b3VyIGdyaWQuXG4gKiBOb3RlOiB5b3VyIGdyaWQgZWxlbWVudHMgTVVTVCBoYXZlIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBmb3IgdGhlIENTUyBsYXlvdXQgdG8gd29yazpcbiAqIEBleGFtcGxlXG4gKiA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFja1wiPlxuICogICA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImdyaWQtc3RhY2staXRlbS1jb250ZW50XCI+SXRlbSAxPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogPC9kaXY+XG4gKi9cbmNsYXNzIEdyaWRTdGFjayB7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6aW5nIHRoZSBIVE1MIGVsZW1lbnQsIG9yIHNlbGVjdG9yIHN0cmluZywgaW50byBhIGdyaWQgd2lsbCByZXR1cm4gdGhlIGdyaWQuIENhbGxpbmcgaXQgYWdhaW4gd2lsbFxuICAgICAqIHNpbXBseSByZXR1cm4gdGhlIGV4aXN0aW5nIGluc3RhbmNlIChpZ25vcmUgYW55IHBhc3NlZCBvcHRpb25zKS4gVGhlcmUgaXMgYWxzbyBhbiBpbml0QWxsKCkgdmVyc2lvbiB0aGF0IHN1cHBvcnRcbiAgICAgKiBtdWx0aXBsZSBncmlkcyBpbml0aWFsaXphdGlvbiBhdCBvbmNlLiBPciB5b3UgY2FuIHVzZSBhZGRHcmlkKCkgdG8gY3JlYXRlIHRoZSBlbnRpcmUgZ3JpZCBmcm9tIEpTT04uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZ3JpZCBvcHRpb25zIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0gZWxPclN0cmluZyBlbGVtZW50IG9yIENTUyBzZWxlY3RvciAoZmlyc3Qgb25lIHVzZWQpIHRvIGNvbnZlcnQgdG8gYSBncmlkIChkZWZhdWx0IHRvICcuZ3JpZC1zdGFjaycgY2xhc3Mgc2VsZWN0b3IpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxldCBncmlkID0gR3JpZFN0YWNrLmluaXQoKTtcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBIVE1MRWxlbWVudCAob2YgdHlwZSBHcmlkSFRNTEVsZW1lbnQpIHdpbGwgc3RvcmUgYSBgZ3JpZHN0YWNrOiBHcmlkU3RhY2tgIHZhbHVlIHRoYXQgY2FuIGJlIHJldHJpZXZlIGxhdGVyXG4gICAgICogbGV0IGdyaWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZ3JpZC1zdGFjaycpLmdyaWRzdGFjaztcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdChvcHRpb25zID0ge30sIGVsT3JTdHJpbmcgPSAnLmdyaWQtc3RhY2snKSB7XG4gICAgICAgIGxldCBlbCA9IEdyaWRTdGFjay5nZXRHcmlkRWxlbWVudChlbE9yU3RyaW5nKTtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dyaWRTdGFjay5pbml0QWxsKCkgbm8gZ3JpZCB3YXMgZm91bmQgd2l0aCBzZWxlY3RvciBcIicgKyBlbE9yU3RyaW5nICsgJ1wiIC0gZWxlbWVudCBtaXNzaW5nIG9yIHdyb25nIHNlbGVjdG9yID8nICtcbiAgICAgICAgICAgICAgICAgICAgJ1xcbk5vdGU6IFwiLmdyaWQtc3RhY2tcIiBpcyByZXF1aXJlZCBmb3IgcHJvcGVyIENTUyBzdHlsaW5nIGFuZCBkcmFnL2Ryb3AsIGFuZCBpcyB0aGUgZGVmYXVsdCBzZWxlY3Rvci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dyaWRTdGFjay5pbml0KCkgbm8gZ3JpZCBlbGVtZW50IHdhcyBwYXNzZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsLmdyaWRzdGFjaykge1xuICAgICAgICAgICAgZWwuZ3JpZHN0YWNrID0gbmV3IEdyaWRTdGFjayhlbCwgVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWwuZ3JpZHN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGluaXRpYWxpemUgYSBsaXN0IG9mIGVsZW1lbnRzIChnaXZlbiBhIHNlbGVjdG9yKSBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIGdyaWRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGdyaWQgb3B0aW9ucyAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIGVsZW1lbnRzIHNlbGVjdG9yIHRvIGNvbnZlcnQgdG8gZ3JpZHMgKGRlZmF1bHQgdG8gJy5ncmlkLXN0YWNrJyBjbGFzcyBzZWxlY3RvcilcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGdyaWRzID0gR3JpZFN0YWNrLmluaXRBbGwoKTtcbiAgICAgKiBncmlkcy5mb3JFYWNoKC4uLilcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdEFsbChvcHRpb25zID0ge30sIHNlbGVjdG9yID0gJy5ncmlkLXN0YWNrJykge1xuICAgICAgICBsZXQgZ3JpZHMgPSBbXTtcbiAgICAgICAgR3JpZFN0YWNrLmdldEdyaWRFbGVtZW50cyhzZWxlY3RvcikuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsLmdyaWRzdGFjaykge1xuICAgICAgICAgICAgICAgIGVsLmdyaWRzdGFjayA9IG5ldyBHcmlkU3RhY2soZWwsIFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkcy5wdXNoKGVsLmdyaWRzdGFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZ3JpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHcmlkU3RhY2suaW5pdEFsbCgpIG5vIGdyaWQgd2FzIGZvdW5kIHdpdGggc2VsZWN0b3IgXCInICsgc2VsZWN0b3IgKyAnXCIgLSBlbGVtZW50IG1pc3Npbmcgb3Igd3Jvbmcgc2VsZWN0b3IgPycgK1xuICAgICAgICAgICAgICAgICdcXG5Ob3RlOiBcIi5ncmlkLXN0YWNrXCIgaXMgcmVxdWlyZWQgZm9yIHByb3BlciBDU1Mgc3R5bGluZyBhbmQgZHJhZy9kcm9wLCBhbmQgaXMgdGhlIGRlZmF1bHQgc2VsZWN0b3IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsIHRvIGNyZWF0ZSBhIGdyaWQgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucywgaW5jbHVkaW5nIGxvYWRpbmcgYW55IGNoaWxkcmVuIGZyb20gSlNPTiBzdHJ1Y3R1cmUuIFRoaXMgd2lsbCBjYWxsIEdyaWRTdGFjay5pbml0KCksIHRoZW5cbiAgICAgKiBncmlkLmxvYWQoKSBvbiBhbnkgcGFzc2VkIGNoaWxkcmVuIChyZWN1cnNpdmVseSkuIEdyZWF0IGFsdGVybmF0aXZlIHRvIGNhbGxpbmcgaW5pdCgpIGlmIHlvdSB3YW50IGVudGlyZSBncmlkIHRvIGNvbWUgZnJvbVxuICAgICAqIEpTT04gc2VyaWFsaXplZCBkYXRhLCBpbmNsdWRpbmcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcGFyZW50IEhUTUwgZWxlbWVudCBwYXJlbnQgdG8gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0gb3B0IGdyaWRzIG9wdGlvbnMgdXNlZCB0byBpbml0aWFsaXplIHRoZSBncmlkLCBhbmQgbGlzdCBvZiBjaGlsZHJlblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmlkKHBhcmVudCwgb3B0ID0ge30pIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVsID0gcGFyZW50O1xuICAgICAgICBpZiAoZWwuZ3JpZHN0YWNrKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgZ3JpZCAtIHNldCBvcHRpb24gYW5kIGxvYWQgZGF0YVxuICAgICAgICAgICAgY29uc3QgZ3JpZCA9IGVsLmdyaWRzdGFjaztcbiAgICAgICAgICAgIGlmIChvcHQpXG4gICAgICAgICAgICAgICAgZ3JpZC5vcHRzID0geyAuLi5ncmlkLm9wdHMsIC4uLm9wdCB9O1xuICAgICAgICAgICAgaWYgKG9wdC5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdyaWQubG9hZChvcHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBncmlkIGVsZW1lbnQsIGJ1dCBjaGVjayBpZiB0aGUgcGFzc2VkICdwYXJlbnQnIGFscmVhZHkgaGFzIGdyaWQgc3R5bGluZyBhbmQgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICAgICAgICBjb25zdCBwYXJlbnRJc0dyaWQgPSBwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdncmlkLXN0YWNrJyk7XG4gICAgICAgIGlmICghcGFyZW50SXNHcmlkIHx8IEdyaWRTdGFjay5hZGRSZW1vdmVDQikge1xuICAgICAgICAgICAgaWYgKEdyaWRTdGFjay5hZGRSZW1vdmVDQikge1xuICAgICAgICAgICAgICAgIGVsID0gR3JpZFN0YWNrLmFkZFJlbW92ZUNCKHBhcmVudCwgb3B0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpOyAvLyBJRSBuZWVkcyBhIHBhcmFtXG4gICAgICAgICAgICAgICAgZG9jLmJvZHkuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJncmlkLXN0YWNrICR7b3B0LmNsYXNzIHx8ICcnfVwiPjwvZGl2PmA7XG4gICAgICAgICAgICAgICAgZWwgPSBkb2MuYm9keS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBncmlkIGNsYXNzIGFuZCBsb2FkIGFueSBjaGlsZHJlblxuICAgICAgICBsZXQgZ3JpZCA9IEdyaWRTdGFjay5pbml0KG9wdCwgZWwpO1xuICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICB9XG4gICAgLyoqIGNhbGwgdGhpcyBtZXRob2QgdG8gcmVnaXN0ZXIgeW91ciBlbmdpbmUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogU2VlIGluc3RlYWQgYEdyaWRTdGFja09wdGlvbnMuZW5naW5lQ2xhc3NgIGlmIHlvdSBvbmx5IG5lZWQgdG9cbiAgICAgKiByZXBsYWNlIGp1c3Qgb25lIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckVuZ2luZShlbmdpbmVDbGFzcykge1xuICAgICAgICBHcmlkU3RhY2suZW5naW5lQ2xhc3MgPSBlbmdpbmVDbGFzcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjcmVhdGUgcGxhY2Vob2xkZXIgRElWIGFzIG5lZWRlZCAqL1xuICAgIGdldCBwbGFjZWhvbGRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gY2hpbGQgc28gcGFkZGluZyBtYXRjaCBpdGVtLWNvbnRlbnRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyQ2hpbGQuY2xhc3NOYW1lID0gJ3BsYWNlaG9sZGVyLWNvbnRlbnQnO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5wbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNoaWxkLmlubmVySFRNTCA9IHRoaXMub3B0cy5wbGFjZWhvbGRlclRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdHMucGxhY2Vob2xkZXJDbGFzcywgZ3JpZERlZmF1bHRzLml0ZW1DbGFzcywgdGhpcy5vcHRzLml0ZW1DbGFzcyk7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgZ3JpZCBpdGVtIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgYW5kIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRzID0ge30pIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlciA9IHt9O1xuICAgICAgICAvKiogQGludGVybmFsIGV4dHJhIHJvdyBhZGRlZCB3aGVuIGRyYWdnaW5nIGF0IHRoZSBib3R0b20gb2YgdGhlIGdyaWQgKi9cbiAgICAgICAgdGhpcy5fZXh0cmFEcmFnUm93ID0gMDtcbiAgICAgICAgdGhpcy5lbCA9IGVsOyAvLyBleHBvc2VkIEhUTUwgZWxlbWVudCB0byB0aGUgdXNlclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gaGFuZGxlcyBudWxsL3VuZGVmaW5lZC8wXG4gICAgICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdncmlkLXN0YWNrJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZ3JpZC1zdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJvdyBwcm9wZXJ0eSBleGlzdHMsIHJlcGxhY2UgbWluUm93IGFuZCBtYXhSb3cgaW5zdGVhZFxuICAgICAgICBpZiAob3B0cy5yb3cpIHtcbiAgICAgICAgICAgIG9wdHMubWluUm93ID0gb3B0cy5tYXhSb3cgPSBvcHRzLnJvdztcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLnJvdztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm93QXR0ciA9IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3Mtcm93JykpO1xuICAgICAgICAvLyBmbGFnIG9ubHkgdmFsaWQgaW4gc3ViLWdyaWRzIChoYW5kbGVkIGJ5IHBhcmVudCwgbm90IGhlcmUpXG4gICAgICAgIGlmIChvcHRzLmNvbHVtbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBzZXR0aW5nIHNvIHdlIGNhbiByZXN0b3JlIG9uIHNhdmVcbiAgICAgICAgaWYgKG9wdHMuYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRzLl9hbHdheXNTaG93UmVzaXplSGFuZGxlID0gb3B0cy5hbHdheXNTaG93UmVzaXplSGFuZGxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsZW1lbnRzIERPTSBhdHRyaWJ1dGVzIG92ZXJyaWRlIGFueSBwYXNzZWQgb3B0aW9ucyAobGlrZSBDU1Mgc3R5bGUpIC0gbWVyZ2UgdGhlIHR3byB0b2dldGhlclxuICAgICAgICBsZXQgZGVmYXVsdHMgPSB7IC4uLlV0aWxzLmNsb25lRGVlcChncmlkRGVmYXVsdHMpLFxuICAgICAgICAgICAgY29sdW1uOiBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLWNvbHVtbicpKSB8fCBncmlkRGVmYXVsdHMuY29sdW1uLFxuICAgICAgICAgICAgbWluUm93OiByb3dBdHRyID8gcm93QXR0ciA6IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MtbWluLXJvdycpKSB8fCBncmlkRGVmYXVsdHMubWluUm93LFxuICAgICAgICAgICAgbWF4Um93OiByb3dBdHRyID8gcm93QXR0ciA6IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MtbWF4LXJvdycpKSB8fCBncmlkRGVmYXVsdHMubWF4Um93LFxuICAgICAgICAgICAgc3RhdGljR3JpZDogVXRpbHMudG9Cb29sKGVsLmdldEF0dHJpYnV0ZSgnZ3Mtc3RhdGljJykpIHx8IGdyaWREZWZhdWx0cy5zdGF0aWNHcmlkLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlOiAob3B0cy5oYW5kbGVDbGFzcyA/ICcuJyArIG9wdHMuaGFuZGxlQ2xhc3MgOiAob3B0cy5oYW5kbGUgPyBvcHRzLmhhbmRsZSA6ICcnKSkgfHwgZ3JpZERlZmF1bHRzLmRyYWdnYWJsZS5oYW5kbGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZhYmxlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGFjY2VwdDogb3B0cy5pdGVtQ2xhc3MgfHwgZ3JpZERlZmF1bHRzLnJlbW92YWJsZU9wdGlvbnMuYWNjZXB0LFxuICAgICAgICAgICAgICAgIGRlY2xpbmU6IGdyaWREZWZhdWx0cy5yZW1vdmFibGVPcHRpb25zLmRlY2xpbmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2dzLWFuaW1hdGUnKSkgeyAvLyBkZWZhdWx0IHRvIHRydWUsIGJ1dCBpZiBzZXQgdG8gZmFsc2UgdXNlIHRoYXQgaW5zdGVhZFxuICAgICAgICAgICAgZGVmYXVsdHMuYW5pbWF0ZSA9IFV0aWxzLnRvQm9vbChlbC5nZXRBdHRyaWJ1dGUoJ2dzLWFuaW1hdGUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRzID0gVXRpbHMuZGVmYXVsdHMob3B0cywgZGVmYXVsdHMpO1xuICAgICAgICBvcHRzID0gbnVsbDsgLy8gbWFrZSBzdXJlIHdlIHVzZSB0aGlzLm9wdHMgaW5zdGVhZFxuICAgICAgICB0aGlzLl9pbml0TWFyZ2luKCk7IC8vIHBhcnQgb2Ygc2V0dGluZ3MgZGVmYXVsdHMuLi5cbiAgICAgICAgLy8gTm93IGNoZWNrIGlmIHdlJ3JlIGxvYWRpbmcgaW50byAxIGNvbHVtbiBtb2RlIEZJUlNUIHNvIHdlIGRvbid0IGRvIHVuLW5lY2Vzc2FyeSB3b3JrIChsaWtlIGNlbGxIZWlnaHQgPSB3aWR0aCAvIDEyIHRoZW4gZ28gMSBjb2x1bW4pXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29sdW1uICE9PSAxICYmICF0aGlzLm9wdHMuZGlzYWJsZU9uZUNvbHVtbk1vZGUgJiYgdGhpcy5fd2lkdGhPckNvbnRhaW5lcigpIDw9IHRoaXMub3B0cy5vbmVDb2x1bW5TaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2Q29sdW1uID0gdGhpcy5nZXRDb2x1bW4oKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5jb2x1bW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMucnRsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5ydGwgPSAoZWwuc3R5bGUuZGlyZWN0aW9uID09PSAncnRsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5ydGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZ3JpZC1zdGFjay1ydGwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSdyZSBiZWVuIG5lc3RlZCwgYW5kIGlmIHNvIHVwZGF0ZSBvdXIgc3R5bGUgYW5kIGtlZXAgcG9pbnRlciBhcm91bmQgKHVzZWQgZHVyaW5nIHNhdmUpXG4gICAgICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50Py5wYXJlbnRFbGVtZW50O1xuICAgICAgICBsZXQgcGFyZW50R3JpZEl0ZW0gPSBncmFuZFBhcmVudD8uY2xhc3NMaXN0LmNvbnRhaW5zKGdyaWREZWZhdWx0cy5pdGVtQ2xhc3MpID8gZ3JhbmRQYXJlbnQuZ3JpZHN0YWNrTm9kZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBhcmVudEdyaWRJdGVtKSB7XG4gICAgICAgICAgICBwYXJlbnRHcmlkSXRlbS5zdWJHcmlkID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50R3JpZEl0ZW0gPSBwYXJlbnRHcmlkSXRlbTtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZ3JpZC1zdGFjay1uZXN0ZWQnKTtcbiAgICAgICAgICAgIHBhcmVudEdyaWRJdGVtLmVsLmNsYXNzTGlzdC5hZGQoJ2dyaWQtc3RhY2stc3ViLWdyaWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0ID0gKHRoaXMub3B0cy5jZWxsSGVpZ2h0ID09PSAnYXV0bycpO1xuICAgICAgICBpZiAodGhpcy5faXNBdXRvQ2VsbEhlaWdodCB8fCB0aGlzLm9wdHMuY2VsbEhlaWdodCA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSBjZWxsIGNvbnRlbnQgc3F1YXJlIGluaXRpYWxseSAod2lsbCB1c2UgcmVzaXplL2NvbHVtbiBldmVudCB0byBrZWVwIGl0IHNxdWFyZSlcbiAgICAgICAgICAgIHRoaXMuY2VsbEhlaWdodCh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCB1bml0IGlmIGFueSBhcmUgc2V0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5jZWxsSGVpZ2h0ID09ICdudW1iZXInICYmIHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdCAmJiB0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQgIT09IGdyaWREZWZhdWx0cy5jZWxsSGVpZ2h0VW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0cy5jZWxsSGVpZ2h0ID0gdGhpcy5vcHRzLmNlbGxIZWlnaHQgKyB0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2VsbEhlaWdodCh0aGlzLm9wdHMuY2VsbEhlaWdodCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIGFkanVzdCBhdXRvLWhpZGVcbiAgICAgICAgaWYgKHRoaXMub3B0cy5hbHdheXNTaG93UmVzaXplSGFuZGxlID09PSAnbW9iaWxlJykge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmFsd2F5c1Nob3dSZXNpemVIYW5kbGUgPSBpc1RvdWNoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0eWxlU2hlZXRDbGFzcyA9ICdncy1pZC0nICsgR3JpZFN0YWNrRW5naW5lLl9pZFNlcSsrO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5fc3R5bGVTaGVldENsYXNzKTtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGljQ2xhc3MoKTtcbiAgICAgICAgbGV0IGVuZ2luZUNsYXNzID0gdGhpcy5vcHRzLmVuZ2luZUNsYXNzIHx8IEdyaWRTdGFjay5lbmdpbmVDbGFzcyB8fCBHcmlkU3RhY2tFbmdpbmU7XG4gICAgICAgIHRoaXMuZW5naW5lID0gbmV3IGVuZ2luZUNsYXNzKHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5nZXRDb2x1bW4oKSxcbiAgICAgICAgICAgIGZsb2F0OiB0aGlzLm9wdHMuZmxvYXQsXG4gICAgICAgICAgICBtYXhSb3c6IHRoaXMub3B0cy5tYXhSb3csXG4gICAgICAgICAgICBvbkNoYW5nZTogKGNiTm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWF4SCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMuZm9yRWFjaChuID0+IHsgbWF4SCA9IE1hdGgubWF4KG1heEgsIG4ueSArIG4uaCk7IH0pO1xuICAgICAgICAgICAgICAgIGNiTm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVsID0gbi5lbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uX3JlbW92ZURPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG4uX3JlbW92ZURPTTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUG9zQXR0cihlbCwgbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZXMoZmFsc2UsIG1heEgpOyAvLyBmYWxzZSA9IGRvbid0IHJlY3JlYXRlLCBqdXN0IGFwcGVuZCBpZiBuZWVkIGJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG8pIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoKTsgLy8gcHJldmVudCBpbiBiZXR3ZWVuIHJlLWxheW91dCAjMTUzNSBUT0RPOiB0aGlzIG9ubHkgc2V0IGZsb2F0PXRydWUsIG5lZWQgdG8gcHJldmVudCBjb2xsaXNpb24gY2hlY2suLi5cbiAgICAgICAgICAgIHRoaXMuZ2V0R3JpZEl0ZW1zKCkuZm9yRWFjaChlbCA9PiB0aGlzLl9wcmVwYXJlRWxlbWVudChlbCkpO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9hZCBhbnkgcGFzc2VkIGluIGNoaWxkcmVuIGFzIHdlbGwsIHdoaWNoIG92ZXJyaWRlcyBhbnkgRE9NIGxheW91dCBkb25lIGFib3ZlXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMub3B0cy5jaGlsZHJlbjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdHMuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubG9hZChjaGlsZHJlbik7IC8vIGRvbid0IGxvYWQgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvbih0aGlzLm9wdHMuYW5pbWF0ZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlcygpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2dzLScgKyB0aGlzLm9wdHMuY29sdW1uKTtcbiAgICAgICAgLy8gZHluYW1pYyBncmlkcyByZXF1aXJlIHBhdXNpbmcgZHVyaW5nIGRyYWcgdG8gZGV0ZWN0IG92ZXIgdG8gbmVzdCB2cyBwdXNoXG4gICAgICAgIGlmICh0aGlzLm9wdHMuc3ViR3JpZER5bmFtaWMgJiYgIURETWFuYWdlci5wYXVzZURyYWcpXG4gICAgICAgICAgICBERE1hbmFnZXIucGF1c2VEcmFnID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kcmFnZ2FibGU/LnBhdXNlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBERE1hbmFnZXIucGF1c2VEcmFnID0gdGhpcy5vcHRzLmRyYWdnYWJsZS5wYXVzZTtcbiAgICAgICAgdGhpcy5fc2V0dXBSZW1vdmVEcm9wKCk7XG4gICAgICAgIHRoaXMuX3NldHVwQWNjZXB0V2lkZ2V0KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlc2l6ZUV2ZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyB3aWRnZXQgYW5kIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBXaWRnZXQgd2lsbCBiZSBhbHdheXMgcGxhY2VkIGV2ZW4gaWYgcmVzdWx0IGhlaWdodCBpcyBtb3JlIHRoYW4gYWN0dWFsIGdyaWQgaGVpZ2h0LlxuICAgICAqIFlvdSBuZWVkIHRvIHVzZSBgd2lsbEl0Rml0KClgIGJlZm9yZSBjYWxsaW5nIGFkZFdpZGdldCBmb3IgYWRkaXRpb25hbCBjaGVjay5cbiAgICAgKiBTZWUgYWxzbyBgbWFrZVdpZGdldCgpYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGdyaWQgPSBHcmlkU3RhY2suaW5pdCgpO1xuICAgICAqIGdyaWQuYWRkV2lkZ2V0KHt3OiAzLCBjb250ZW50OiAnaGVsbG8nfSk7XG4gICAgICogZ3JpZC5hZGRXaWRnZXQoJzxkaXYgY2xhc3M9XCJncmlkLXN0YWNrLWl0ZW1cIj48ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnRcIj5oZWxsbzwvZGl2PjwvZGl2PicsIHt3OiAzfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWwgIEdyaWRTdGFja1dpZGdldCAod2hpY2ggY2FuIGhhdmUgY29udGVudCBzdHJpbmcgYXMgd2VsbCksIGh0bWwgZWxlbWVudCwgb3Igc3RyaW5nIGRlZmluaXRpb24gdG8gYWRkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgd2lkZ2V0IHBvc2l0aW9uL3NpemUgb3B0aW9ucyAob3B0aW9uYWwsIGFuZCBpZ25vcmUgaWYgZmlyc3QgcGFyYW0gaXMgYWxyZWFkeSBvcHRpb24pIC0gc2VlIEdyaWRTdGFja1dpZGdldFxuICAgICAqL1xuICAgIGFkZFdpZGdldChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNHcmlkU3RhY2tXaWRnZXQodykge1xuICAgICAgICAgICAgcmV0dXJuIHcuZWwgIT09IHVuZGVmaW5lZCB8fCB3LnggIT09IHVuZGVmaW5lZCB8fCB3LnkgIT09IHVuZGVmaW5lZCB8fCB3LncgIT09IHVuZGVmaW5lZCB8fCB3LmggIT09IHVuZGVmaW5lZCB8fCB3LmNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWw7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIGVscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpOyAvLyBJRSBuZWVkcyBhIHBhcmFtXG4gICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBlbHM7XG4gICAgICAgICAgICBlbCA9IGRvYy5ib2R5LmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0dyaWRTdGFja1dpZGdldChlbHMpKSB7XG4gICAgICAgICAgICBub2RlID0gb3B0aW9ucyA9IGVscztcbiAgICAgICAgICAgIGlmIChub2RlPy5lbCkge1xuICAgICAgICAgICAgICAgIGVsID0gbm9kZS5lbDsgLy8gcmUtdXNlIGVsZW1lbnQgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChHcmlkU3RhY2suYWRkUmVtb3ZlQ0IpIHtcbiAgICAgICAgICAgICAgICBlbCA9IEdyaWRTdGFjay5hZGRSZW1vdmVDQih0aGlzLmVsLCBvcHRpb25zLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IG9wdGlvbnM/LmNvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICAgICAgbGV0IGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7IC8vIElFIG5lZWRzIGEgcGFyYW1cbiAgICAgICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImdyaWQtc3RhY2staXRlbSAke3RoaXMub3B0cy5pdGVtQ2xhc3MgfHwgJyd9XCI+PGRpdiBjbGFzcz1cImdyaWQtc3RhY2staXRlbS1jb250ZW50XCI+JHtjb250ZW50fTwvZGl2PjwvZGl2PmA7XG4gICAgICAgICAgICAgICAgZWwgPSBkb2MuYm9keS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gZWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGlmIHRoZSBjYWxsZXIgZW5kZWQgdXAgaW5pdGlhbGl6aW5nIHRoZSB3aWRnZXQgaW4gYWRkUmVtb3ZlQ0IsIG9yIHdlIHN0YXJlZCB3aXRoIG9uZSBhbHJlYWR5LCBza2lwIHRoZSByZXN0XG4gICAgICAgIG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICBpZiAobm9kZSAmJiBlbC5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsICYmIHRoaXMuZW5naW5lLm5vZGVzLmZpbmQobiA9PiBuLl9pZCA9PT0gbm9kZS5faWQpKVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAvLyBUZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBwYXNzZWQgaW4gb3B0IHdpdGggZGVmYXVsdCBhbmQgdmFsaWQgdmFsdWVzLCBidXQgdGhpcyBicmVhayBrbm9ja291dCBkZW1vc1xuICAgICAgICAvLyBhcyB0aGUgYWN0dWFsIHZhbHVlIGFyZSBmaWxsZWQgaW4gd2hlbiBfcHJlcGFyZUVsZW1lbnQoKSBjYWxscyBlbC5nZXRBdHRyaWJ1dGUoJ2dzLXh5eicpIGJlZm9yZSBhZGRpbmcgdGhlIG5vZGUuXG4gICAgICAgIC8vIFNvIG1ha2Ugc3VyZSB3ZSBsb2FkIGFueSBET00gYXR0cmlidXRlcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGluIHBhc3NlZCBpbiBvcHRpb25zICh3aGljaCBvdmVycmlkZSlcbiAgICAgICAgbGV0IGRvbUF0dHIgPSB0aGlzLl9yZWFkQXR0cihlbCk7XG4gICAgICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307IC8vIG1ha2UgYSBjb3B5IGJlZm9yZSB3ZSBtb2RpZnkgaW4gY2FzZSBjYWxsZXIgcmUtdXNlcyBpdFxuICAgICAgICBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCBkb21BdHRyKTtcbiAgICAgICAgbm9kZSA9IHRoaXMuZW5naW5lLnByZXBhcmVOb2RlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl93cml0ZUF0dHIoZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5faW5zZXJ0Tm90QXBwZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnByZXBlbmQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWtlV2lkZ2V0KGVsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGV4aXN0aW5nIGdyaWRJdGVtIGVsZW1lbnQgaW50byBhIHN1Yi1ncmlkIHdpdGggdGhlIGdpdmVuIChvcHRpb25hbCkgb3B0aW9ucywgZWxzZSBpbmhlcml0IHRoZW1cbiAgICAgKiBmcm9tIHRoZSBwYXJlbnQncyBzdWJHcmlkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGVsIGdyaWRJdGVtIGVsZW1lbnQgdG8gY29udmVydFxuICAgICAqIEBwYXJhbSBvcHMgKG9wdGlvbmFsKSBzdWItZ3JpZCBvcHRpb25zLCBlbHNlIGRlZmF1bHQgdG8gbm9kZSwgdGhlbiBwYXJlbnQgc2V0dGluZ3MsIGVsc2UgZGVmYXVsdHNcbiAgICAgKiBAcGFyYW0gbm9kZVRvQWRkIChvcHRpb25hbCkgbm9kZSB0byBhZGQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgc3ViIGdyaWQgKHVzZWQgd2hlbiBkcmFnZ2luZyBvdmVyIGV4aXN0aW5nIHJlZ3VsYXIgaXRlbSlcbiAgICAgKiBAcmV0dXJucyBuZXdseSBjcmVhdGVkIGdyaWRcbiAgICAgKi9cbiAgICBtYWtlU3ViR3JpZChlbCwgb3BzLCBub2RlVG9BZGQsIHNhdmVDb250ZW50ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubWFrZVdpZGdldChlbCkuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zdWJHcmlkPy5lbClcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN1YkdyaWQ7IC8vIGFscmVhZHkgZG9uZVxuICAgICAgICAvLyBmaW5kIHRoZSB0ZW1wbGF0ZSBzdWJHcmlkIHN0b3JlZCBvbiBhIHBhcmVudCBhcyBmYWxsYmFjay4uLlxuICAgICAgICBsZXQgc3ViR3JpZFRlbXBsYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IGdyaWQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZ3JpZCAmJiAhc3ViR3JpZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBzdWJHcmlkVGVtcGxhdGUgPSBncmlkLm9wdHM/LnN1YkdyaWRPcHRzO1xuICAgICAgICAgICAgZ3JpZCA9IGdyaWQucGFyZW50R3JpZEl0ZW0/LmdyaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8uLi4gYW5kIHNldCB0aGUgY3JlYXRlIG9wdGlvbnNcbiAgICAgICAgb3BzID0gVXRpbHMuY2xvbmVEZWVwKHsgLi4uKHN1YkdyaWRUZW1wbGF0ZSB8fCB7fSksIGNoaWxkcmVuOiB1bmRlZmluZWQsIC4uLihvcHMgfHwgbm9kZS5zdWJHcmlkT3B0cykgfSk7XG4gICAgICAgIG5vZGUuc3ViR3JpZE9wdHMgPSBvcHM7XG4gICAgICAgIC8vIGlmIGNvbHVtbiBzcGVjaWFsIGNhc2UgaXQgc2V0LCByZW1lbWJlciB0aGF0IGZsYWcgYW5kIHNldCBkZWZhdWx0XG4gICAgICAgIGxldCBhdXRvQ29sdW1uO1xuICAgICAgICBpZiAob3BzLmNvbHVtbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBhdXRvQ29sdW1uID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wcy5jb2x1bW4gPSBNYXRoLm1heChub2RlLncgfHwgMSwgbm9kZVRvQWRkPy53IHx8IDEpO1xuICAgICAgICAgICAgb3BzLmRpc2FibGVPbmVDb2x1bW5Nb2RlID0gdHJ1ZTsgLy8gZHJpdmVuIGJ5IHBhcmVudFxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIGNvbnZlcnRpbmcgYW4gZXhpc3RpbmcgZnVsbCBpdGVtLCBtb3ZlIG92ZXIgdGhlIGNvbnRlbnQgdG8gYmUgdGhlIGZpcnN0IHN1YiBpdGVtIGluIHRoZSBuZXcgZ3JpZFxuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuZWwucXVlcnlTZWxlY3RvcignLmdyaWQtc3RhY2staXRlbS1jb250ZW50Jyk7XG4gICAgICAgIGxldCBuZXdJdGVtO1xuICAgICAgICBsZXQgbmV3SXRlbU9wdDtcbiAgICAgICAgaWYgKHNhdmVDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVERChub2RlLmVsKTsgLy8gcmVtb3ZlIEQmRCBzaW5jZSBpdCdzIHNldCBvbiBjb250ZW50IGRpdlxuICAgICAgICAgICAgbmV3SXRlbU9wdCA9IHsgLi4ubm9kZSwgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgVXRpbHMucmVtb3ZlSW50ZXJuYWxGb3JTYXZlKG5ld0l0ZW1PcHQpO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0l0ZW1PcHQuc3ViR3JpZE9wdHM7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbmV3SXRlbU9wdC5jb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoR3JpZFN0YWNrLmFkZFJlbW92ZUNCKSB7XG4gICAgICAgICAgICAgICAgbmV3SXRlbSA9IEdyaWRTdGFjay5hZGRSZW1vdmVDQih0aGlzLmVsLCBuZXdJdGVtT3B0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTsgLy8gSUUgbmVlZHMgYSBwYXJhbVxuICAgICAgICAgICAgICAgIGRvYy5ib2R5LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZ3JpZC1zdGFjay1pdGVtXCI+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtID0gZG9jLmJvZHkuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgbmV3SXRlbS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImdyaWQtc3RhY2staXRlbS1jb250ZW50XCI+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZG9jLmJvZHkuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgbm9kZS5lbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShub2RlKTsgLy8gLi4uIGFuZCByZXN0b3JlIG9yaWdpbmFsIEQmRFxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIGFkZGluZyBhbiBhZGRpdGlvbmFsIGl0ZW0sIG1ha2UgdGhlIGNvbnRhaW5lciBsYXJnZSBlbm91Z2ggdG8gaGF2ZSB0aGVtIGJvdGhcbiAgICAgICAgaWYgKG5vZGVUb0FkZCkge1xuICAgICAgICAgICAgbGV0IHcgPSBhdXRvQ29sdW1uID8gb3BzLmNvbHVtbiA6IG5vZGUudztcbiAgICAgICAgICAgIGxldCBoID0gbm9kZS5oICsgbm9kZVRvQWRkLmg7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBub2RlLmVsLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJzsgLy8gc2hvdyB1cCBpbnN0YW50bHkgc28gd2UgZG9uJ3Qgc2VlIHNjcm9sbGJhciB3aXRoIG5vZGVUb0FkZFxuICAgICAgICAgICAgdGhpcy51cGRhdGUobm9kZS5lbCwgeyB3LCBoIH0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzdHlsZS50cmFuc2l0aW9uID0gbnVsbCk7IC8vIHJlY292ZXIgYW5pbWF0aW9uXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YkdyaWQgPSBub2RlLnN1YkdyaWQgPSBHcmlkU3RhY2suYWRkR3JpZChjb250ZW50LCBvcHMpO1xuICAgICAgICBpZiAobm9kZVRvQWRkPy5fbW92aW5nKVxuICAgICAgICAgICAgc3ViR3JpZC5faXNUZW1wID0gdHJ1ZTsgLy8gcHJldmVudCByZS1uZXN0aW5nIGFzIHdlIGFkZCBvdmVyXG4gICAgICAgIGlmIChhdXRvQ29sdW1uKVxuICAgICAgICAgICAgc3ViR3JpZC5fYXV0b0NvbHVtbiA9IHRydWU7XG4gICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWwgY29udGVudCBiYWNrIGFzIGEgY2hpbGQgb2YgaHRlIG5ld2x5IGNyZWF0ZWQgZ3JpZFxuICAgICAgICBpZiAoc2F2ZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHN1YkdyaWQuYWRkV2lkZ2V0KG5ld0l0ZW0sIG5ld0l0ZW1PcHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBhZGQgYW55IGFkZGl0aW9uYWwgbm9kZVxuICAgICAgICBpZiAobm9kZVRvQWRkKSB7XG4gICAgICAgICAgICBpZiAobm9kZVRvQWRkLl9tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gYXJ0aWZpY2lhbCBldmVudCBldmVuIGZvciB0aGUganVzdCBjcmVhdGVkIGdyaWQgdG8gcmVjZWl2ZSB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBVdGlscy5zaW11bGF0ZU1vdXNlRXZlbnQobm9kZVRvQWRkLl9ldmVudCwgJ21vdXNlZW50ZXInLCBzdWJHcmlkLmVsKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJHcmlkLmFkZFdpZGdldChub2RlLmVsLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViR3JpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gYW4gaXRlbSB3YXMgY29udmVydGVkIGludG8gYSBuZXN0ZWQgZ3JpZCB0byBhY2NvbW1vZGF0ZSBhIGRyYWdnZWQgb3ZlciBpdGVtLCBidXQgdGhlbiBpdGVtIGxlYXZlcyAtIHJldHVybiBiYWNrXG4gICAgICogdG8gdGhlIG9yaWdpbmFsIGdyaWQtaXRlbS4gQWxzbyBjYWxsZWQgdG8gcmVtb3ZlIGVtcHR5IHN1Yi1ncmlkcyB3aGVuIGxhc3QgaXRlbSBpcyBkcmFnZ2VkIG91dCAoc2luY2UgcmUtY3JlYXRpbmcgaXMgc2ltcGxlKVxuICAgICAqL1xuICAgIHJlbW92ZUFzU3ViR3JpZChub2RlVGhhdFJlbW92ZWQpIHtcbiAgICAgICAgbGV0IHBHcmlkID0gdGhpcy5wYXJlbnRHcmlkSXRlbT8uZ3JpZDtcbiAgICAgICAgaWYgKCFwR3JpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcEdyaWQuYmF0Y2hVcGRhdGUoKTtcbiAgICAgICAgcEdyaWQucmVtb3ZlV2lkZ2V0KHRoaXMucGFyZW50R3JpZEl0ZW0uZWwsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgLy8gbWlncmF0ZSBhbnkgY2hpbGRyZW4gb3ZlciBhbmQgb2Zmc2V0dGluZyBieSBvdXIgbG9jYXRpb25cbiAgICAgICAgICAgIG4ueCArPSB0aGlzLnBhcmVudEdyaWRJdGVtLng7XG4gICAgICAgICAgICBuLnkgKz0gdGhpcy5wYXJlbnRHcmlkSXRlbS55O1xuICAgICAgICAgICAgcEdyaWQuYWRkV2lkZ2V0KG4uZWwsIG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcEdyaWQuYmF0Y2hVcGRhdGUoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRHcmlkSXRlbSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmVudEdyaWRJdGVtLnN1YkdyaWQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcmVudEdyaWRJdGVtO1xuICAgICAgICAvLyBjcmVhdGUgYW4gYXJ0aWZpY2lhbCBldmVudCBmb3IgdGhlIG9yaWdpbmFsIGdyaWQgbm93IHRoYXQgdGhpcyBvbmUgaXMgZ29uZSAoZ290IGEgbGVhdmUsIGJ1dCB3b24ndCBnZXQgZW50ZXIpXG4gICAgICAgIGlmIChub2RlVGhhdFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IFV0aWxzLnNpbXVsYXRlTW91c2VFdmVudChub2RlVGhhdFJlbW92ZWQuX2V2ZW50LCAnbW91c2VlbnRlcicsIHBHcmlkLmVsKSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2F2ZXMgdGhlIGN1cnJlbnQgbGF5b3V0IHJldHVybmluZyBhIGxpc3Qgb2Ygd2lkZ2V0cyBmb3Igc2VyaWFsaXphdGlvbiB3aGljaCBtaWdodCBpbmNsdWRlIGFueSBuZXN0ZWQgZ3JpZHMuXG4gICAgICogQHBhcmFtIHNhdmVDb250ZW50IGlmIHRydWUgKGRlZmF1bHQpIHRoZSBsYXRlc3QgaHRtbCBpbnNpZGUgLmdyaWQtc3RhY2stY29udGVudCB3aWxsIGJlIHNhdmVkIHRvIEdyaWRTdGFja1dpZGdldC5jb250ZW50IGZpZWxkLCBlbHNlIGl0IHdpbGxcbiAgICAgKiBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSBzYXZlR3JpZE9wdCBpZiB0cnVlIChkZWZhdWx0IGZhbHNlKSwgc2F2ZSB0aGUgZ3JpZCBvcHRpb25zIGl0c2VsZiwgc28geW91IGNhbiBjYWxsIHRoZSBuZXcgR3JpZFN0YWNrLmFkZEdyaWQoKVxuICAgICAqIHRvIHJlY3JlYXRlIGV2ZXJ5dGhpbmcgZnJvbSBzY3JhdGNoLiBHcmlkU3RhY2tPcHRpb25zLmNoaWxkcmVuIHdvdWxkIHRoZW4gY29udGFpbiB0aGUgd2lkZ2V0IGxpc3QgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gc2F2ZUNCIGNhbGxiYWNrIGZvciBlYWNoIG5vZGUgLT4gd2lkZ2V0LCBzbyBhcHBsaWNhdGlvbiBjYW4gaW5zZXJ0IGFkZGl0aW9uYWwgZGF0YSB0byBiZSBzYXZlZCBpbnRvIHRoZSB3aWRnZXQgZGF0YSBzdHJ1Y3R1cmUuXG4gICAgICogQHJldHVybnMgbGlzdCBvZiB3aWRnZXRzIG9yIGZ1bGwgZ3JpZCBvcHRpb24sIGluY2x1ZGluZyAuY2hpbGRyZW4gbGlzdCBvZiB3aWRnZXRzXG4gICAgICovXG4gICAgc2F2ZShzYXZlQ29udGVudCA9IHRydWUsIHNhdmVHcmlkT3B0ID0gZmFsc2UsIHNhdmVDQiA9IEdyaWRTdGFjay5zYXZlQ0IpIHtcbiAgICAgICAgLy8gcmV0dXJuIGNvcGllZCBHcmlkU3RhY2tXaWRnZXQgKHdpdGggb3B0aW9uYWxseSAuZWwpIHdlIGNhbiBtb2RpZnkgYXQgd2lsbC4uLlxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuZW5naW5lLnNhdmUoc2F2ZUNvbnRlbnQsIHNhdmVDQik7XG4gICAgICAgIC8vIGNoZWNrIGZvciBIVE1MIGNvbnRlbnQgYW5kIG5lc3RlZCBncmlkc1xuICAgICAgICBsaXN0LmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICBpZiAoc2F2ZUNvbnRlbnQgJiYgbi5lbCAmJiAhbi5zdWJHcmlkICYmICFzYXZlQ0IpIHsgLy8gc3ViLWdyaWQgYXJlIHNhdmVkIGRpZmZlcmVudGx5LCBub3QgcGxhaW4gY29udGVudFxuICAgICAgICAgICAgICAgIGxldCBzdWIgPSBuLmVsLnF1ZXJ5U2VsZWN0b3IoJy5ncmlkLXN0YWNrLWl0ZW0tY29udGVudCcpO1xuICAgICAgICAgICAgICAgIG4uY29udGVudCA9IHN1YiA/IHN1Yi5pbm5lckhUTUwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFuLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNhdmVDb250ZW50ICYmICFzYXZlQ0IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG4uY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBncmlkXG4gICAgICAgICAgICAgICAgaWYgKG4uc3ViR3JpZD8uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdE9yT3B0ID0gbi5zdWJHcmlkLnNhdmUoc2F2ZUNvbnRlbnQsIHNhdmVHcmlkT3B0LCBzYXZlQ0IpO1xuICAgICAgICAgICAgICAgICAgICBuLnN1YkdyaWRPcHRzID0gKHNhdmVHcmlkT3B0ID8gbGlzdE9yT3B0IDogeyBjaGlsZHJlbjogbGlzdE9yT3B0IH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbi5zdWJHcmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBuLmVsO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgc2F2ZSBlbnRpcmUgZ3JpZCBvcHRpb25zIChuZWVkZWQgZm9yIHJlY3Vyc2l2ZSkgKyBjaGlsZHJlbi4uLlxuICAgICAgICBpZiAoc2F2ZUdyaWRPcHQpIHtcbiAgICAgICAgICAgIGxldCBvID0gVXRpbHMuY2xvbmVEZWVwKHRoaXMub3B0cyk7XG4gICAgICAgICAgICAvLyBkZWxldGUgZGVmYXVsdCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHJlY3JlYXRlZCBvbiBsYXVuY2hcbiAgICAgICAgICAgIGlmIChvLm1hcmdpbkJvdHRvbSA9PT0gby5tYXJnaW5Ub3AgJiYgby5tYXJnaW5SaWdodCA9PT0gby5tYXJnaW5MZWZ0ICYmIG8ubWFyZ2luVG9wID09PSBvLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgby5tYXJnaW4gPSBvLm1hcmdpblRvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5tYXJnaW5Ub3A7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8ubWFyZ2luUmlnaHQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8ubWFyZ2luQm90dG9tO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvLm1hcmdpbkxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoby5ydGwgPT09ICh0aGlzLmVsLnN0eWxlLmRpcmVjdGlvbiA9PT0gJ3J0bCcpKSB7XG4gICAgICAgICAgICAgICAgby5ydGwgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNBdXRvQ2VsbEhlaWdodCkge1xuICAgICAgICAgICAgICAgIG8uY2VsbEhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgby5jb2x1bW4gPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uZGlzYWJsZU9uZUNvbHVtbk1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmlnU2hvdyA9IG8uX2Fsd2F5c1Nob3dSZXNpemVIYW5kbGU7XG4gICAgICAgICAgICBkZWxldGUgby5fYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZTtcbiAgICAgICAgICAgIGlmIChvcmlnU2hvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgby5hbHdheXNTaG93UmVzaXplSGFuZGxlID0gb3JpZ1Nob3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5hbHdheXNTaG93UmVzaXplSGFuZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVXRpbHMucmVtb3ZlSW50ZXJuYWxBbmRTYW1lKG8sIGdyaWREZWZhdWx0cyk7XG4gICAgICAgICAgICBvLmNoaWxkcmVuID0gbGlzdDtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb2FkIHRoZSB3aWRnZXRzIGZyb20gYSBsaXN0LiBUaGlzIHdpbGwgY2FsbCB1cGRhdGUoKSBvbiBlYWNoIChtYXRjaGluZyBieSBpZCkgb3IgYWRkL3JlbW92ZSB3aWRnZXRzIHRoYXQgYXJlIG5vdCB0aGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXlvdXQgbGlzdCBvZiB3aWRnZXRzIGRlZmluaXRpb24gdG8gdXBkYXRlL2NyZWF0ZVxuICAgICAqIEBwYXJhbSBhZGRBbmRSZW1vdmUgYm9vbGVhbiAoZGVmYXVsdCB0cnVlKSBvciBjYWxsYmFjayBtZXRob2QgY2FuIGJlIHBhc3NlZCB0byBjb250cm9sIGlmIGFuZCBob3cgbWlzc2luZyB3aWRnZXRzIGNhbiBiZSBhZGRlZC9yZW1vdmVkLCBnaXZpbmdcbiAgICAgKiB0aGUgdXNlciBjb250cm9sIG9mIGluc2VydGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc2VlIGh0dHA6Ly9ncmlkc3RhY2tqcy5jb20vZGVtby9zZXJpYWxpemF0aW9uLmh0bWxcbiAgICAgKi9cbiAgICBsb2FkKGl0ZW1zLCBhZGRSZW1vdmUgPSBHcmlkU3RhY2suYWRkUmVtb3ZlQ0IgfHwgdHJ1ZSkge1xuICAgICAgICBpdGVtcyA9IFV0aWxzLmNsb25lRGVlcChpdGVtcyk7IC8vIHNvIHdlIGNhbiBtb2RcbiAgICAgICAgLy8gaWYgcGFzc2VkIGxpc3QgaGFzIGNvb3JkaW5hdGVzLCB1c2UgdGhlbSAoaW5zZXJ0IGZyb20gZW5kIHRvIGJlZ2lubmluZyBmb3IgY29uZmxpY3QgcmVzb2x1dGlvbikgZWxzZSBmb3JjZSB3aWRnZXQgc2FtZSBvcmRlclxuICAgICAgICBjb25zdCBoYXZlQ29vcmQgPSBpdGVtcy5zb21lKHcgPT4gdy54ICE9PSB1bmRlZmluZWQgfHwgdy55ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaGF2ZUNvb3JkKVxuICAgICAgICAgICAgaXRlbXMgPSBVdGlscy5zb3J0KGl0ZW1zLCAtMSwgdGhpcy5fcHJldkNvbHVtbiB8fCB0aGlzLmdldENvbHVtbigpKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0Tm90QXBwZW5kID0gaGF2ZUNvb3JkOyAvLyBpZiB3ZSBjcmVhdGUgaW4gcmV2ZXJzZSBvcmRlci4uLlxuICAgICAgICAvLyBpZiB3ZSdyZSBsb2FkaW5nIGEgbGF5b3V0IGludG8gZm9yIGV4YW1wbGUgMSBjb2x1bW4gKF9wcmV2Q29sdW1uIGlzIHNldCBvbmx5IHdoZW4gZ29pbmcgdG8gMSkgYW5kIGl0ZW1zIGRvbid0IGZpdCwgbWFrZSBzdXJlIHRvIHNhdmVcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHdhbnRlZCBsYXlvdXQgc28gd2UgY2FuIHNjYWxlIGJhY2sgdXAgY29ycmVjdGx5ICMxNDcxXG4gICAgICAgIGlmICh0aGlzLl9wcmV2Q29sdW1uICYmIHRoaXMuX3ByZXZDb2x1bW4gIT09IHRoaXMub3B0cy5jb2x1bW4gJiYgaXRlbXMuc29tZShuID0+ICgobi54IHx8IDApICsgbi53KSA+IHRoaXMub3B0cy5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZSA9IHRydWU7IC8vIHNraXAgbGF5b3V0IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2FjaGVMYXlvdXQoaXRlbXMsIHRoaXMuX3ByZXZDb2x1bW4sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGdpdmVuIGEgZGlmZmVyZW50IGNhbGxiYWNrLCB0ZW1wb3JhbGx5IHNldCBpdCBhcyBnbG9iYWwgb3B0aW9uIHNvIGNyZWF0aW5nIHdpbGwgdXNlIGl0XG4gICAgICAgIGNvbnN0IHByZXZDQiA9IEdyaWRTdGFjay5hZGRSZW1vdmVDQjtcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkUmVtb3ZlKSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIEdyaWRTdGFjay5hZGRSZW1vdmVDQiA9IGFkZFJlbW92ZTtcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZSgpO1xuICAgICAgICAvLyBzZWUgaWYgYW55IGl0ZW1zIGFyZSBtaXNzaW5nIGZyb20gbmV3IGxheW91dCBhbmQgbmVlZCB0byBiZSByZW1vdmVkIGZpcnN0XG4gICAgICAgIGlmIChhZGRSZW1vdmUpIHtcbiAgICAgICAgICAgIGxldCBjb3B5Tm9kZXMgPSBbLi4udGhpcy5lbmdpbmUubm9kZXNdOyAvLyBkb24ndCBsb29wIHRocm91Z2ggYXJyYXkgeW91IG1vZGlmeVxuICAgICAgICAgICAgY29weU5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFuLmlkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBVdGlscy5maW5kKGl0ZW1zLCBuLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEdyaWRTdGFjay5hZGRSZW1vdmVDQilcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyaWRTdGFjay5hZGRSZW1vdmVDQih0aGlzLmVsLCBuLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gobik7IC8vIGJhdGNoIGtlZXAgdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXQobi5lbCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBhZGQvdXBkYXRlIHRoZSB3aWRnZXRzIC0gc3RhcnRpbmcgd2l0aCByZW1vdmluZyBpdGVtcyBpbiB0aGUgbmV3IGxheW91dCB3ZSB3aWxsIHJlcG9zaXRpb25cbiAgICAgICAgLy8gdG8gcmVkdWNlIGNvbGxpc2lvbiBhbmQgYWRkIG5vLWNvb3JkIG9uZXMgYXQgbmV4dCBhdmFpbGFibGUgc3BvdFxuICAgICAgICBsZXQgdXBkYXRlTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMgPSB0aGlzLmVuZ2luZS5ub2Rlcy5maWx0ZXIobiA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuZmluZChpdGVtcywgbi5pZCkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2Rlcy5wdXNoKG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gcmVtb3ZlIGlmIGZvdW5kIGZyb20gbGlzdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgd2lkdGhDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGl0ZW1zLmZvckVhY2godyA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IFV0aWxzLmZpbmQodXBkYXRlTm9kZXMsIHcuaWQpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdGVtIHNpemVzIHRvIGNvbnRlbnQsIHJlLXVzZSB0aGUgZXhpdGluZyBoZWlnaHQgc28gaXQncyBhIGJldHRlciBndWVzcyBhdCB0aGUgZmluYWwgc2l6ZSA5c2FtZSBpZiB3aWR0aCBkb2Vzbid0IGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuc2hvdWxkU2l6ZVRvQ29udGVudChpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgdy5oID0gaXRlbS5oO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG1pc3NpbmcgY29vcmQsIGluIHdoaWNoIGNhc2UgZmluZCBuZXh0IGVtcHR5IHNsb3Qgd2l0aCBuZXcgKG9yIG9sZCBpZiBtaXNzaW5nKSBzaXplc1xuICAgICAgICAgICAgICAgIGlmICh3LmF1dG9Qb3NpdGlvbiB8fCB3LnggPT09IHVuZGVmaW5lZCB8fCB3LnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB3LncgPSB3LncgfHwgaXRlbS53O1xuICAgICAgICAgICAgICAgICAgICB3LmggPSB3LmggfHwgaXRlbS5oO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5maW5kRW1wdHlQb3NpdGlvbih3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2lkdGhDaGFuZ2VkID0gd2lkdGhDaGFuZ2VkIHx8ICh3LncgIT09IHVuZGVmaW5lZCAmJiB3LncgIT09IGl0ZW0udyk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGJhY2sgdG8gY3VycmVudCBsaXN0IEJVVCBmb3JjZSBhIGNvbGxpc2lvbiBjaGVjayBpZiBpdCAnYXBwZWFycycgd2UgZGlkbid0IGNoYW5nZSB0byBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcmxhcCBvdGhlcnMgbm93XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuc2FtZVBvcyhpdGVtLCB3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlKGl0ZW0sIHsgLi4udywgZm9yY2VDb2xsaWRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5jb3B5UG9zKHcsIGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShpdGVtLmVsLCB3KTtcbiAgICAgICAgICAgICAgICBpZiAody5zdWJHcmlkT3B0cz8uY2hpbGRyZW4pIHsgLy8gdXBkYXRlIGFueSBzdWIgZ3JpZCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWIgPSBpdGVtLmVsLnF1ZXJ5U2VsZWN0b3IoJy5ncmlkLXN0YWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIgJiYgc3ViLmdyaWRzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLmdyaWRzdGFjay5sb2FkKHcuc3ViR3JpZE9wdHMuY2hpbGRyZW4pOyAvLyBUT0RPOiBzdXBwb3J0IHVwZGF0aW5nIGdyaWQgb3B0aW9ucyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnROb3RBcHBlbmQgPSB0cnVlOyAvLyBnb3QgcmVzZXQgYnkgYWJvdmUgY2FsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQodyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuZ2luZS5yZW1vdmVkTm9kZXMgPSByZW1vdmVkO1xuICAgICAgICB0aGlzLmRvQ29udGVudFJlc2l6ZSh3aWR0aENoYW5nZWQsIHRydWUpOyAvLyB3ZSBvbmx5IG5lZWQgdG8gd2FpdCBmb3IgYW5pbWF0aW9uIGlmIHdlIGNoYW5nZWQgYW55IHdpZHRoc1xuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgLy8gYWZ0ZXIgY29tbWl0LCBjbGVhciB0aGF0IGZsYWdcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlO1xuICAgICAgICBkZWxldGUgdGhpcy5faW5zZXJ0Tm90QXBwZW5kO1xuICAgICAgICBwcmV2Q0IgPyBHcmlkU3RhY2suYWRkUmVtb3ZlQ0IgPSBwcmV2Q0IgOiBkZWxldGUgR3JpZFN0YWNrLmFkZFJlbW92ZUNCO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXNlIGJlZm9yZSBjYWxsaW5nIGEgYnVuY2ggb2YgYGFkZFdpZGdldCgpYCB0byBwcmV2ZW50IHVuLW5lY2Vzc2FyeSByZWxheW91dHMgaW4gYmV0d2VlbiAobW9yZSBlZmZpY2llbnQpXG4gICAgICogYW5kIGdldCBhIHNpbmdsZSBldmVudCBjYWxsYmFjay4gWW91IHdpbGwgc2VlIG5vIGNoYW5nZXMgdW50aWwgYGJhdGNoVXBkYXRlKGZhbHNlKWAgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGJhdGNoVXBkYXRlKGZsYWcgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmJhdGNoVXBkYXRlKGZsYWcpO1xuICAgICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlbW92ZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQWRkRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1cnJlbnQgY2VsbCBoZWlnaHQuXG4gICAgICovXG4gICAgZ2V0Q2VsbEhlaWdodChmb3JjZVBpeGVsID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jZWxsSGVpZ2h0ICYmIHRoaXMub3B0cy5jZWxsSGVpZ2h0ICE9PSAnYXV0bycgJiZcbiAgICAgICAgICAgICghZm9yY2VQaXhlbCB8fCAhdGhpcy5vcHRzLmNlbGxIZWlnaHRVbml0IHx8IHRoaXMub3B0cy5jZWxsSGVpZ2h0VW5pdCA9PT0gJ3B4JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMuY2VsbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGdldCBmaXJzdCBjZWxsIGhlaWdodFxuICAgICAgICBsZXQgZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5vcHRzLml0ZW1DbGFzcyk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MtaCcpKSB8fCAxOyAvLyBzaW5jZSB3ZSBkb24ndCB3cml0ZSAxIGFueW1vcmVcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGVsLm9mZnNldEhlaWdodCAvIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBkbyBlbnRpcmUgZ3JpZCBhbmQgIyBvZiByb3dzIChidXQgZG9lc24ndCB3b3JrIGlmIG1pbi1oZWlnaHQgaXMgdGhlIGFjdHVhbCBjb25zdHJhaW4pXG4gICAgICAgIGxldCByb3dzID0gcGFyc2VJbnQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2dzLWN1cnJlbnQtcm93JykpO1xuICAgICAgICByZXR1cm4gcm93cyA/IE1hdGgucm91bmQodGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLyByb3dzKSA6IHRoaXMub3B0cy5jZWxsSGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY3VycmVudCBjZWxsIGhlaWdodCAtIHNlZSBgR3JpZFN0YWNrT3B0aW9ucy5jZWxsSGVpZ2h0YCBmb3IgZm9ybWF0LlxuICAgICAqIFRoaXMgbWV0aG9kIHJlYnVpbGRzIGFuIGludGVybmFsIENTUyBzdHlsZSBzaGVldC5cbiAgICAgKiBOb3RlOiBZb3UgY2FuIGV4cGVjdCBwZXJmb3JtYW5jZSBpc3N1ZXMgaWYgY2FsbCB0aGlzIG1ldGhvZCB0b28gb2Z0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIHRoZSBjZWxsIGhlaWdodC4gSWYgbm90IHBhc3NlZCAodW5kZWZpbmVkKSwgY2VsbHMgY29udGVudCB3aWxsIGJlIG1hZGUgc3F1YXJlIChtYXRjaCB3aWR0aCBtaW51cyBtYXJnaW4pLFxuICAgICAqIGlmIHBhc3MgMCB0aGUgQ1NTIHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB1cGRhdGUgKE9wdGlvbmFsKSBpZiBmYWxzZSwgc3R5bGVzIHdpbGwgbm90IGJlIHVwZGF0ZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZ3JpZC5jZWxsSGVpZ2h0KDEwMCk7IC8vIHNhbWUgYXMgMTAwcHhcbiAgICAgKiBncmlkLmNlbGxIZWlnaHQoJzcwcHgnKTtcbiAgICAgKiBncmlkLmNlbGxIZWlnaHQoZ3JpZC5jZWxsV2lkdGgoKSAqIDEuMik7XG4gICAgICovXG4gICAgY2VsbEhlaWdodCh2YWwsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgLy8gaWYgbm90IGNhbGxlZCBpbnRlcm5hbGx5LCBjaGVjayBpZiB3ZSdyZSBjaGFuZ2luZyBtb2RlXG4gICAgICAgIGlmICh1cGRhdGUgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0ICE9PSAodmFsID09PSAnYXV0bycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNBdXRvQ2VsbEhlaWdodCA9ICh2YWwgPT09ICdhdXRvJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVzaXplRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09PSAnaW5pdGlhbCcgfHwgdmFsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIGl0ZW0gY29udGVudCBiZSBzcXVhcmVcbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWFyZ2luRGlmZiA9IC10aGlzLm9wdHMubWFyZ2luUmlnaHQgLSB0aGlzLm9wdHMubWFyZ2luTGVmdFxuICAgICAgICAgICAgICAgICsgdGhpcy5vcHRzLm1hcmdpblRvcCArIHRoaXMub3B0cy5tYXJnaW5Cb3R0b207XG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNlbGxXaWR0aCgpICsgbWFyZ2luRGlmZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHZhbCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQgPT09IGRhdGEudW5pdCAmJiB0aGlzLm9wdHMuY2VsbEhlaWdodCA9PT0gZGF0YS5oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQgPSBkYXRhLnVuaXQ7XG4gICAgICAgIHRoaXMub3B0cy5jZWxsSGVpZ2h0ID0gZGF0YS5oO1xuICAgICAgICB0aGlzLmRvQ29udGVudFJlc2l6ZShmYWxzZSwgdHJ1ZSk7IC8vIG5vIGFuaW0gd2FpdCwgYnV0IHVzZSBhdHRyaWJ1dGVzIHNpbmNlIHdlIG9ubHkgY2hhbmdlIHJvdyBoZWlnaHRcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGVzKHRydWUpOyAvLyB0cnVlID0gZm9yY2UgcmUtY3JlYXRlIGZvciBjdXJyZW50ICMgb2Ygcm93c1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogR2V0cyBjdXJyZW50IGNlbGwgd2lkdGguICovXG4gICAgY2VsbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGhPckNvbnRhaW5lcigpIC8gdGhpcy5nZXRDb2x1bW4oKTtcbiAgICB9XG4gICAgLyoqIHJldHVybiBvdXIgZXhwZWN0ZWQgd2lkdGggKG9yIHBhcmVudCkgZm9yIDEgY29sdW1uIGNoZWNrICovXG4gICAgX3dpZHRoT3JDb250YWluZXIoKSB7XG4gICAgICAgIC8vIHVzZSBgb2Zmc2V0V2lkdGhgIG9yIGBjbGllbnRXaWR0aGAgKG5vIHNjcm9sbGJhcikgP1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTA2NDEwMS91bmRlcnN0YW5kaW5nLW9mZnNldHdpZHRoLWNsaWVudHdpZHRoLXNjcm9sbHdpZHRoLWFuZC1oZWlnaHQtcmVzcGVjdGl2ZWx5XG4gICAgICAgIHJldHVybiAodGhpcy5lbC5jbGllbnRXaWR0aCB8fCB0aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZS1sYXlvdXQgZ3JpZCBpdGVtcyB0byByZWNsYWltIGFueSBlbXB0eSBzcGFjZS4gT3B0aW9ucyBhcmU6XG4gICAgICogJ2xpc3QnIGtlZXAgdGhlIHdpZGdldCBsZWZ0LT5yaWdodCBvcmRlciB0aGUgc2FtZSwgZXZlbiBpZiB0aGF0IG1lYW5zIGxlYXZpbmcgYW4gZW1wdHkgc2xvdCBpZiB0aGluZ3MgZG9uJ3QgZml0XG4gICAgICogJ2NvbXBhY3QnIG1pZ2h0IHJlLW9yZGVyIGl0ZW1zIHRvIGZpbGwgYW55IGVtcHR5IHNwYWNlXG4gICAgICpcbiAgICAgKiBkb1NvcnQgLSAnZmFsc2UnIHRvIGxldCB5b3UgZG8geW91ciBvd24gc29ydGluZyBhaGVhZCBpbiBjYXNlIHlvdSBuZWVkIHRvIGNvbnRyb2wgYSBkaWZmZXJlbnQgb3JkZXIuIChkZWZhdWx0IHRvIHNvcnQpXG4gICAgICovXG4gICAgY29tcGFjdChsYXlvdXQgPSAnY29tcGFjdCcsIGRvU29ydCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuY29tcGFjdChsYXlvdXQsIGRvU29ydCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgZ3JpZC4gV2lsbCB1cGRhdGUgZXhpc3Rpbmcgd2lkZ2V0cyB0byBjb25mb3JtIHRvIG5ldyBudW1iZXIgb2YgY29sdW1ucyxcbiAgICAgKiBhcyB3ZWxsIGFzIGNhY2hlIHRoZSBvcmlnaW5hbCBsYXlvdXQgc28geW91IGNhbiByZXZlcnQgYmFjayB0byBwcmV2aW91cyBwb3NpdGlvbnMgd2l0aG91dCBsb3NzLlxuICAgICAqIFJlcXVpcmVzIGBncmlkc3RhY2stZXh0cmEuY3NzYCBvciBgZ3JpZHN0YWNrLWV4dHJhLm1pbi5jc3NgIGZvciBbMi0xMV0sXG4gICAgICogZWxzZSB5b3Ugd2lsbCBuZWVkIHRvIGdlbmVyYXRlIGNvcnJlY3QgQ1NTIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyaWRzdGFjay9ncmlkc3RhY2suanMjY2hhbmdlLWdyaWQtY29sdW1ucylcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gSW50ZWdlciA+IDAgKGRlZmF1bHQgMTIpLlxuICAgICAqIEBwYXJhbSBsYXlvdXQgc3BlY2lmeSB0aGUgdHlwZSBvZiByZS1sYXlvdXQgdGhhdCB3aWxsIGhhcHBlbiAocG9zaXRpb24sIHNpemUsIGV0Yy4uLikuXG4gICAgICogTm90ZTogaXRlbXMgd2lsbCBuZXZlciBiZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGNvbHVtbiBib3VuZGFyaWVzLiBkZWZhdWx0ICgnbW92ZVNjYWxlJykuIElnbm9yZWQgZm9yIDEgY29sdW1uXG4gICAgICovXG4gICAgY29sdW1uKGNvbHVtbiwgbGF5b3V0ID0gJ21vdmVTY2FsZScpIHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgY29sdW1uIDwgMSB8fCB0aGlzLm9wdHMuY29sdW1uID09PSBjb2x1bW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG9sZENvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKCk7XG4gICAgICAgIC8vIGlmIHdlIGdvIGludG8gMSBjb2x1bW4gbW9kZSAod2hpY2ggaGFwcGVucyBpZiB3ZSdyZSBzaXplZCBsZXNzIHRoYW4gbWluVyB1bmxlc3MgZGlzYWJsZU9uZUNvbHVtbk1vZGUgaXMgb24pXG4gICAgICAgIC8vIHRoZW4gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIGNvbHVtbnMgc28gd2UgY2FuIHJlc3RvcmUuXG4gICAgICAgIGlmIChjb2x1bW4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZDb2x1bW4gPSBvbGRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJldkNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2dzLScgKyBvbGRDb2x1bW4pO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2dzLScgKyBjb2x1bW4pO1xuICAgICAgICB0aGlzLm9wdHMuY29sdW1uID0gdGhpcy5lbmdpbmUuY29sdW1uID0gY29sdW1uO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGl0ZW1zIG5vdyAtIHNlZSBpZiB0aGUgZG9tIG9yZGVyIG5vZGVzIHNob3VsZCBiZSBwYXNzZWQgaW5zdGVhZCAoZWxzZSBkZWZhdWx0IHRvIGN1cnJlbnQgbGlzdClcbiAgICAgICAgbGV0IGRvbU5vZGVzO1xuICAgICAgICBpZiAoY29sdW1uID09PSAxICYmIHRoaXMub3B0cy5vbmVDb2x1bW5Nb2RlRG9tU29ydCkge1xuICAgICAgICAgICAgZG9tTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JpZEl0ZW1zKCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmdyaWRzdGFja05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZXMucHVzaChlbC5ncmlkc3RhY2tOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmdpbmUuY29sdW1uQ2hhbmdlZChvbGRDb2x1bW4sIGNvbHVtbiwgZG9tTm9kZXMsIGxheW91dCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5jZWxsSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuZG9Db250ZW50UmVzaXplKCk7XG4gICAgICAgIC8vIGFuZCB0cmlnZ2VyIG91ciBldmVudCBsYXN0Li4uXG4gICAgICAgIHRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlID0gdHJ1ZTsgLy8gc2tpcCBsYXlvdXQgdXBkYXRlXG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBncmlkIChkZWZhdWx0IDEyKVxuICAgICAqL1xuICAgIGdldENvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5jb2x1bW47XG4gICAgfVxuICAgIC8qKiByZXR1cm5zIGFuIGFycmF5IG9mIGdyaWQgSFRNTCBlbGVtZW50cyAobm8gcGxhY2Vob2xkZXIpIC0gdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggb3VyIGNoaWxkcmVuIGluIERPTSBvcmRlciAqL1xuICAgIGdldEdyaWRJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbC5jaGlsZHJlbilcbiAgICAgICAgICAgIC5maWx0ZXIoKGVsKSA9PiBlbC5tYXRjaGVzKCcuJyArIHRoaXMub3B0cy5pdGVtQ2xhc3MpICYmICFlbC5tYXRjaGVzKCcuJyArIHRoaXMub3B0cy5wbGFjZWhvbGRlckNsYXNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JpZCBpbnN0YW5jZS4gRE8gTk9UIENBTEwgYW55IG1ldGhvZHMgb3IgYWNjZXNzIGFueSB2YXJzIGFmdGVyIHRoaXMgYXMgaXQgd2lsbCBmcmVlIHVwIG1lbWJlcnMuXG4gICAgICogQHBhcmFtIHJlbW92ZURPTSBpZiBgZmFsc2VgIGdyaWQgYW5kIGl0ZW1zIEhUTUwgZWxlbWVudHMgd2lsbCBub3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET00gKE9wdGlvbmFsLiBEZWZhdWx0IGB0cnVlYCkuXG4gICAgICovXG4gICAgZGVzdHJveShyZW1vdmVET00gPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbClcbiAgICAgICAgICAgIHJldHVybjsgLy8gcHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgICAgICB0aGlzLm9mZkFsbCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVSZXNpemVFdmVudCh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0aWModHJ1ZSwgZmFsc2UpOyAvLyBwZXJtYW5lbnRseSByZW1vdmVzIEREIGJ1dCBkb24ndCBzZXQgQ1NTIGNsYXNzICh3ZSdyZSBnb2luZyBhd2F5KVxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvbihmYWxzZSk7XG4gICAgICAgIGlmICghcmVtb3ZlRE9NKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbChyZW1vdmVET00pO1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX3N0eWxlU2hlZXRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtY3VycmVudC1yb3cnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVTdHlsZXNoZWV0KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudEdyaWRJdGVtKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50R3JpZEl0ZW0uc3ViR3JpZDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50R3JpZEl0ZW07XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9wdHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wbGFjZWhvbGRlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMuZW5naW5lO1xuICAgICAgICBkZWxldGUgdGhpcy5lbC5ncmlkc3RhY2s7IC8vIHJlbW92ZSBjaXJjdWxhciBkZXBlbmRlbmN5IHRoYXQgd291bGQgcHJldmVudCBhIGZyZWVpbmdcbiAgICAgICAgZGVsZXRlIHRoaXMuZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGUvZGlzYWJsZSBmbG9hdGluZyB3aWRnZXRzIChkZWZhdWx0OiBgZmFsc2VgKSBTZWUgW2V4YW1wbGVdKGh0dHA6Ly9ncmlkc3RhY2tqcy5jb20vZGVtby9mbG9hdC5odG1sKVxuICAgICAqL1xuICAgIGZsb2F0KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLmZsb2F0ICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5mbG9hdCA9IHRoaXMuZW5naW5lLmZsb2F0ID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY3VycmVudCBmbG9hdCBtb2RlXG4gICAgICovXG4gICAgZ2V0RmxvYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5mbG9hdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2VsbCB1bmRlciBhIHBpeGVsIG9uIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwaXhlbCB0byByZXNvbHZlIGluXG4gICAgICogYWJzb2x1dGUgY29vcmRpbmF0ZXMsIGFzIGFuIG9iamVjdCB3aXRoIHRvcCBhbmQgbGVmdCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHVzZURvY1JlbGF0aXZlIGlmIHRydWUsIHZhbHVlIHdpbGwgYmUgYmFzZWQgb24gZG9jdW1lbnQgcG9zaXRpb24gdnMgcGFyZW50IHBvc2l0aW9uIChPcHRpb25hbC4gRGVmYXVsdCBmYWxzZSkuXG4gICAgICogVXNlZnVsIHdoZW4gZ3JpZCBpcyB3aXRoaW4gYHBvc2l0aW9uOiByZWxhdGl2ZWAgZWxlbWVudFxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGB4YCBhbmQgYHlgIGkuZS4gdGhlIGNvbHVtbiBhbmQgcm93IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGdldENlbGxGcm9tUGl4ZWwocG9zaXRpb24sIHVzZURvY1JlbGF0aXZlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJveCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbGVmdDogJHtib3gubGVmdH0gdG9wOiAke2JveC50b3B9IHc6ICR7Ym94Lnd9IGg6ICR7Ym94Lmh9YClcbiAgICAgICAgbGV0IGNvbnRhaW5lclBvcztcbiAgICAgICAgaWYgKHVzZURvY1JlbGF0aXZlKSB7XG4gICAgICAgICAgICBjb250YWluZXJQb3MgPSB7IHRvcDogYm94LnRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsIGxlZnQ6IGJveC5sZWZ0IH07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgZ2V0Q2VsbEZyb21QaXhlbCBzY3JvbGxUb3A6ICR7ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcH1gKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyUG9zID0geyB0b3A6IHRoaXMuZWwub2Zmc2V0VG9wLCBsZWZ0OiB0aGlzLmVsLm9mZnNldExlZnQgfTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBnZXRDZWxsRnJvbVBpeGVsIG9mZnNldFRvcDogJHtjb250YWluZXJQb3MubGVmdH0gb2Zmc2V0TGVmdDogJHtjb250YWluZXJQb3MudG9wfWApXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbGF0aXZlTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBjb250YWluZXJQb3MubGVmdDtcbiAgICAgICAgbGV0IHJlbGF0aXZlVG9wID0gcG9zaXRpb24udG9wIC0gY29udGFpbmVyUG9zLnRvcDtcbiAgICAgICAgbGV0IGNvbHVtbldpZHRoID0gKGJveC53aWR0aCAvIHRoaXMuZ2V0Q29sdW1uKCkpO1xuICAgICAgICBsZXQgcm93SGVpZ2h0ID0gKGJveC5oZWlnaHQgLyBwYXJzZUludCh0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZ3MtY3VycmVudC1yb3cnKSkpO1xuICAgICAgICByZXR1cm4geyB4OiBNYXRoLmZsb29yKHJlbGF0aXZlTGVmdCAvIGNvbHVtbldpZHRoKSwgeTogTWF0aC5mbG9vcihyZWxhdGl2ZVRvcCAvIHJvd0hlaWdodCkgfTtcbiAgICB9XG4gICAgLyoqIHJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJvd3MsIHdoaWNoIHdpbGwgYmUgYXQgbGVhc3QgYG1pblJvd2AgaWYgc2V0ICovXG4gICAgZ2V0Um93KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5lbmdpbmUuZ2V0Um93KCksIHRoaXMub3B0cy5taW5Sb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIGFyZWEgaXMgZW1wdHkuXG4gICAgICogQHBhcmFtIHggdGhlIHBvc2l0aW9uIHguXG4gICAgICogQHBhcmFtIHkgdGhlIHBvc2l0aW9uIHkuXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0byBjaGVja1xuICAgICAqL1xuICAgIGlzQXJlYUVtcHR5KHgsIHksIHcsIGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmlzQXJlYUVtcHR5KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYWRkIGVsZW1lbnRzIHRvIHlvdXIgZ3JpZCBieSBoYW5kIChvciBoYXZlIHNvbWUgZnJhbWV3b3JrIGNyZWF0aW5nIERPTSksIHlvdSBoYXZlIHRvIHRlbGwgZ3JpZHN0YWNrIGFmdGVyd2FyZHMgdG8gbWFrZSB0aGVtIHdpZGdldHMuXG4gICAgICogSWYgeW91IHdhbnQgZ3JpZHN0YWNrIHRvIGFkZCB0aGUgZWxlbWVudHMgZm9yIHlvdSwgdXNlIGBhZGRXaWRnZXQoKWAgaW5zdGVhZC5cbiAgICAgKiBNYWtlcyB0aGUgZ2l2ZW4gZWxlbWVudCBhIHdpZGdldCBhbmQgcmV0dXJucyBpdC5cbiAgICAgKiBAcGFyYW0gZWxzIHdpZGdldCBvciBzaW5nbGUgc2VsZWN0b3IgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB3aWRnZXQgZGVmaW5pdGlvbiB0byB1c2UgaW5zdGVhZCBvZiByZWFkaW5nIGF0dHJpYnV0ZXMgb3IgdXNpbmcgZGVmYXVsdCBzaXppbmcgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxldCBncmlkID0gR3JpZFN0YWNrLmluaXQoKTtcbiAgICAgKiBncmlkLmVsLmFwcGVuZENoaWxkKCc8ZGl2IGlkPVwiMVwiIGdzLXc9XCIzXCI+PC9kaXY+Jyk7XG4gICAgICogZ3JpZC5lbC5hcHBlbmRDaGlsZCgnPGRpdiBpZD1cIjJcIj48L2Rpdj4nKTtcbiAgICAgKiBncmlkLm1ha2VXaWRnZXQoJzEnKTtcbiAgICAgKiBncmlkLm1ha2VXaWRnZXQoJzInLCB7dzoyLCBjb250ZW50OiAnaGVsbG8nfSk7XG4gICAgICovXG4gICAgbWFrZVdpZGdldChlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGVsID0gR3JpZFN0YWNrLmdldEVsZW1lbnQoZWxzKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUVsZW1lbnQoZWwsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBub2RlID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuZG9Db250ZW50UmVzaXplKGZhbHNlLCBmYWxzZSwgbm9kZSk7XG4gICAgICAgIC8vIHNlZSBpZiB0aGVyZSBpcyBhIHN1Yi1ncmlkIHRvIGNyZWF0ZVxuICAgICAgICBpZiAobm9kZS5zdWJHcmlkT3B0cykge1xuICAgICAgICAgICAgdGhpcy5tYWtlU3ViR3JpZChlbCwgbm9kZS5zdWJHcmlkT3B0cywgdW5kZWZpbmVkLCBmYWxzZSk7IC8vIG5vZGUuc3ViR3JpZCB3aWxsIGJlIHVzZWQgYXMgb3B0aW9uIGluIG1ldGhvZCwgbm8gbmVlZCB0byBwYXNzXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgYWRkaW5nIGFuIGl0ZW0gaW50byAxIGNvbHVtbiAoX3ByZXZDb2x1bW4gaXMgc2V0IG9ubHkgd2hlbiBnb2luZyB0byAxKSBtYWtlIHN1cmVcbiAgICAgICAgLy8gd2UgZG9uJ3Qgb3ZlcnJpZGUgdGhlIGxhcmdlciAxMiBjb2x1bW4gbGF5b3V0IHRoYXQgd2FzIGFscmVhZHkgc2F2ZWQuICMxOTg1XG4gICAgICAgIGlmICh0aGlzLl9wcmV2Q29sdW1uICYmIHRoaXMub3B0cy5jb2x1bW4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyQWRkRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIHRoYXQgZXh0cmFjdHMgb3VyIEN1c3RvbUV2ZW50IGRhdGEgb3V0IGF1dG9tYXRpY2FsbHkgZm9yIHJlY2VpdmluZyBjdXN0b21cbiAgICAgKiBub3RpZmljYXRpb25zIChzZWUgZG9jIGZvciBzdXBwb3J0ZWQgZXZlbnRzKVxuICAgICAqIEBwYXJhbSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIHBvc3NpYmxlIHZhbHVlcykgb3IgbGlzdCBvZiBuYW1lcyBzcGFjZSBzZXBhcmF0ZWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdpdGggZXZlbnQgYW5kIG9wdGlvbmFsIHNlY29uZC90aGlyZCBwYXJhbVxuICAgICAqIChzZWUgUkVBRE1FIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggc2lnbmF0dXJlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZ3JpZC5vbignYWRkZWQnLCBmdW5jdGlvbihlLCBpdGVtcykgeyBsb2coJ2FkZGVkICcsIGl0ZW1zKX0gKTtcbiAgICAgKiBvclxuICAgICAqIGdyaWQub24oJ2FkZGVkIHJlbW92ZWQgY2hhbmdlJywgZnVuY3Rpb24oZSwgaXRlbXMpIHsgbG9nKGUudHlwZSwgaXRlbXMpfSApO1xuICAgICAqXG4gICAgICogTm90ZTogaW4gc29tZSBjYXNlcyBpdCBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIG5hdGl2ZSBoYW5kbGVyIGFuZCBwYXJzaW5nIHRoZSBldmVudC5cbiAgICAgKiBncmlkLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZGVkJywgZnVuY3Rpb24oZXZlbnQpIHsgbG9nKCdhZGRlZCAnLCBldmVudC5kZXRhaWwpfSApO1xuICAgICAqXG4gICAgICovXG4gICAgb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFycmF5IG9mIG5hbWVzIGJlaW5nIHBhc3NlZCBpbnN0ZWFkXG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBuYW1lcyA9IG5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB0aGlzLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NoYW5nZScgfHwgbmFtZSA9PT0gJ2FkZGVkJyB8fCBuYW1lID09PSAncmVtb3ZlZCcgfHwgbmFtZSA9PT0gJ2VuYWJsZScgfHwgbmFtZSA9PT0gJ2Rpc2FibGUnKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgQ3VzdG9tRXZlbnQgaGFuZGxlcnMgLSBjYXNoIHRoZSBnZW5lcmljIGhhbmRsZXJzIHNvIHdlIGNhbiBlYXNpbHkgcmVtb3ZlXG4gICAgICAgICAgICBsZXQgbm9EYXRhID0gKG5hbWUgPT09ICdlbmFibGUnIHx8IG5hbWUgPT09ICdkaXNhYmxlJyk7XG4gICAgICAgICAgICBpZiAobm9EYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbbmFtZV0gPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dzRXZlbnRIYW5kbGVyW25hbWVdID0gKGV2ZW50KSA9PiBjYWxsYmFjayhldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCB0aGlzLl9nc0V2ZW50SGFuZGxlcltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2RyYWcnIHx8IG5hbWUgPT09ICdkcmFnc3RhcnQnIHx8IG5hbWUgPT09ICdkcmFnc3RvcCcgfHwgbmFtZSA9PT0gJ3Jlc2l6ZXN0YXJ0JyB8fCBuYW1lID09PSAncmVzaXplJ1xuICAgICAgICAgICAgfHwgbmFtZSA9PT0gJ3Jlc2l6ZXN0b3AnIHx8IG5hbWUgPT09ICdkcm9wcGVkJyB8fCBuYW1lID09PSAncmVzaXplY29udGVudCcpIHtcbiAgICAgICAgICAgIC8vIGRyYWcmZHJvcCBzdG9wIGV2ZW50cyBORUVEIHRvIGJlIGNhbGwgdGhlbSBBRlRFUiB3ZSB1cGRhdGUgbm9kZSBhdHRyaWJ1dGVzIHNvIGhhbmRsZSB0aGVtIG91cnNlbGYuXG4gICAgICAgICAgICAvLyBkbyBzYW1lIGZvciBzdGFydCBldmVudCB0byBtYWtlIGl0IGVhc2llci4uLlxuICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbbmFtZV0gPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHcmlkU3RhY2sub24oJyArIG5hbWUgKyAnKSBldmVudCBub3Qgc3VwcG9ydGVkLCBidXQgeW91IGNhbiBzdGlsbCB1c2UgJChcIi5ncmlkLXN0YWNrXCIpLm9uKC4uLikgd2hpbGUganF1ZXJ5LXVpIGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdW5zdWJzY3JpYmUgZnJvbSB0aGUgJ29uJyBldmVudCBiZWxvd1xuICAgICAqIEBwYXJhbSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIHBvc3NpYmxlIHZhbHVlcylcbiAgICAgKi9cbiAgICBvZmYobmFtZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgYXJyYXkgb2YgbmFtZXMgYmVpbmcgcGFzc2VkIGluc3RlYWRcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IG5hbWVzID0gbmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHRoaXMub2ZmKG5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnY2hhbmdlJyB8fCBuYW1lID09PSAnYWRkZWQnIHx8IG5hbWUgPT09ICdyZW1vdmVkJyB8fCBuYW1lID09PSAnZW5hYmxlJyB8fCBuYW1lID09PSAnZGlzYWJsZScpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBuYXRpdmUgQ3VzdG9tRXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9nc0V2ZW50SGFuZGxlcltuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB0aGlzLl9nc0V2ZW50SGFuZGxlcltuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX2dzRXZlbnRIYW5kbGVyW25hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIHJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMgKi9cbiAgICBvZmZBbGwoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2dzRXZlbnRIYW5kbGVyKS5mb3JFYWNoKGtleSA9PiB0aGlzLm9mZihrZXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgd2lkZ2V0IGZyb20gdGhlIGdyaWQuXG4gICAgICogQHBhcmFtIGVsICB3aWRnZXQgb3Igc2VsZWN0b3IgdG8gbW9kaWZ5XG4gICAgICogQHBhcmFtIHJlbW92ZURPTSBpZiBgZmFsc2VgIERPTSBlbGVtZW50IHdvbid0IGJlIHJlbW92ZWQgZnJvbSB0aGUgdHJlZSAoRGVmYXVsdD8gdHJ1ZSkuXG4gICAgICogQHBhcmFtIHRyaWdnZXJFdmVudCBpZiBgZmFsc2VgIChxdWlldCBtb2RlKSBlbGVtZW50IHdpbGwgbm90IGJlIGFkZGVkIHRvIHJlbW92ZWQgbGlzdCBhbmQgbm8gJ3JlbW92ZWQnIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCAoRGVmYXVsdD8gdHJ1ZSkuXG4gICAgICovXG4gICAgcmVtb3ZlV2lkZ2V0KGVscywgcmVtb3ZlRE9NID0gdHJ1ZSwgdHJpZ2dlckV2ZW50ID0gdHJ1ZSkge1xuICAgICAgICBHcmlkU3RhY2suZ2V0RWxlbWVudHMoZWxzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnRFbGVtZW50ICYmIGVsLnBhcmVudEVsZW1lbnQgIT09IHRoaXMuZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBub3Qgb3VyIGNoaWxkIVxuICAgICAgICAgICAgbGV0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgLy8gRm9yIE1ldGVvciBzdXBwb3J0OiBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9wdWxsLzI3MlxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZW5naW5lLm5vZGVzLmZpbmQobiA9PiBlbCA9PT0gbi5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKEdyaWRTdGFjay5hZGRSZW1vdmVDQikge1xuICAgICAgICAgICAgICAgIEdyaWRTdGFjay5hZGRSZW1vdmVDQih0aGlzLmVsLCBub2RlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIG91ciBET00gZGF0YSAoY2lyY3VsYXIgbGluaykgYW5kIGRyYWcmZHJvcCBwZXJtYW5lbnRseVxuICAgICAgICAgICAgZGVsZXRlIGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVERChlbCk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5yZW1vdmVOb2RlKG5vZGUsIHJlbW92ZURPTSwgdHJpZ2dlckV2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVET00gJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpOyAvLyBpbiBiYXRjaCBtb2RlIGVuZ2luZS5yZW1vdmVOb2RlIGRvZXNuJ3QgY2FsbCBiYWNrIHRvIHJlbW92ZSBET01cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZW1vdmVFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHdpZGdldHMgZnJvbSB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlRE9NIGlmIGBmYWxzZWAgRE9NIGVsZW1lbnRzIHdvbid0IGJlIHJlbW92ZWQgZnJvbSB0aGUgdHJlZSAoRGVmYXVsdD8gYHRydWVgKS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGwocmVtb3ZlRE9NID0gdHJ1ZSkge1xuICAgICAgICAvLyBhbHdheXMgcmVtb3ZlIG91ciBET00gZGF0YSAoY2lyY3VsYXIgbGluaykgYmVmb3JlIGxpc3QgZ2V0cyBlbXB0aWVkIGFuZCBkcmFnJmRyb3AgcGVybWFuZW50bHlcbiAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBuLmVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVERChuLmVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlbW92ZUFsbChyZW1vdmVET00pO1xuICAgICAgICB0aGlzLl90cmlnZ2VyUmVtb3ZlRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgZ3JpZCBhbmltYXRpb24gc3RhdGUuICBUb2dnbGVzIHRoZSBgZ3JpZC1zdGFjay1hbmltYXRlYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0gZG9BbmltYXRlIGlmIHRydWUgdGhlIGdyaWQgd2lsbCBhbmltYXRlLlxuICAgICAqL1xuICAgIHNldEFuaW1hdGlvbihkb0FuaW1hdGUpIHtcbiAgICAgICAgaWYgKGRvQW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdncmlkLXN0YWNrLWFuaW1hdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnZ3JpZC1zdGFjay1hbmltYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgZ3JpZCBzdGF0aWMgc3RhdGUsIHdoaWNoIHBlcm1hbmVudGx5IHJlbW92ZXMvYWRkIERyYWcmRHJvcCBzdXBwb3J0LCB1bmxpa2UgZGlzYWJsZSgpL2VuYWJsZSgpIHRoYXQganVzdCB0dXJucyBpdCBvZmYvb24uXG4gICAgICogQWxzbyB0b2dnbGUgdGhlIGdyaWQtc3RhY2stc3RhdGljIGNsYXNzLlxuICAgICAqIEBwYXJhbSB2YWwgaWYgdHJ1ZSB0aGUgZ3JpZCBiZWNvbWUgc3RhdGljLlxuICAgICAqIEBwYXJhbSB1cGRhdGVDbGFzcyB0cnVlIChkZWZhdWx0KSBpZiBjc3MgY2xhc3MgZ2V0cyB1cGRhdGVkXG4gICAgICogQHBhcmFtIHJlY3Vyc2UgdHJ1ZSAoZGVmYXVsdCkgaWYgc3ViLWdyaWRzIGFsc28gZ2V0IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBzZXRTdGF0aWModmFsLCB1cGRhdGVDbGFzcyA9IHRydWUsIHJlY3Vyc2UgPSB0cnVlKSB7XG4gICAgICAgIGlmICghIXRoaXMub3B0cy5zdGF0aWNHcmlkID09PSB2YWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFsID8gdGhpcy5vcHRzLnN0YXRpY0dyaWQgPSB0cnVlIDogZGVsZXRlIHRoaXMub3B0cy5zdGF0aWNHcmlkO1xuICAgICAgICB0aGlzLl9zZXR1cFJlbW92ZURyb3AoKTtcbiAgICAgICAgdGhpcy5fc2V0dXBBY2NlcHRXaWRnZXQoKTtcbiAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShuKTsgLy8gZWl0aGVyIGRlbGV0ZSBvciBpbml0IERyYWcmZHJvcFxuICAgICAgICAgICAgaWYgKG4uc3ViR3JpZCAmJiByZWN1cnNlKVxuICAgICAgICAgICAgICAgIG4uc3ViR3JpZC5zZXRTdGF0aWModmFsLCB1cGRhdGVDbGFzcywgcmVjdXJzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRpY0NsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd2lkZ2V0IHBvc2l0aW9uL3NpemUgYW5kIG90aGVyIGluZm8uIE5vdGU6IGlmIHlvdSBuZWVkIHRvIGNhbGwgdGhpcyBvbiBhbGwgbm9kZXMsIHVzZSBsb2FkKCkgaW5zdGVhZCB3aGljaCB3aWxsIHVwZGF0ZSB3aGF0IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIGVscyAgd2lkZ2V0IG9yIHNlbGVjdG9yIG9mIG9iamVjdHMgdG8gbW9kaWZ5IChub3RlOiBzZXR0aW5nIHRoZSBzYW1lIHgseSBmb3IgbXVsdGlwbGUgaXRlbXMgd2lsbCBiZSBpbmRldGVybWluaXN0aWMgYW5kIGxpa2VseSB1bndhbnRlZClcbiAgICAgKiBAcGFyYW0gb3B0IG5ldyB3aWRnZXQgb3B0aW9ucyAoeCx5LHcsaCwgZXRjLi4pLiBPbmx5IHRob3NlIHNldCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdXBkYXRlKGVscywgb3B0KSB7XG4gICAgICAgIC8vIHN1cHBvcnQgbGVnYWN5IGNhbGwgZm9yIG5vdyA/XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdncmlkc3RhY2sudHM6IGB1cGRhdGUoZWwsIHgsIHksIHcsIGgpYCBpcyBkZXByZWNhdGVkLiBVc2UgYHVwZGF0ZShlbCwge3gsIHcsIGNvbnRlbnQsIC4uLn0pYC4gSXQgd2lsbCBiZSByZW1vdmVkIHNvb24nKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIGxldCBhID0gYXJndW1lbnRzLCBpID0gMTtcbiAgICAgICAgICAgIG9wdCA9IHsgeDogYVtpKytdLCB5OiBhW2krK10sIHc6IGFbaSsrXSwgaDogYVtpKytdIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZWxzLCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIEdyaWRTdGFjay5nZXRFbGVtZW50cyhlbHMpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgbGV0IG4gPSBlbD8uZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIGlmICghbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdyA9IFV0aWxzLmNsb25lRGVlcChvcHQpOyAvLyBtYWtlIGEgY29weSB3ZSBjYW4gbW9kaWZ5IGluIGNhc2UgdGhleSByZS11c2UgaXQgb3IgbXVsdGlwbGUgaXRlbXNcbiAgICAgICAgICAgIGRlbGV0ZSB3LmF1dG9Qb3NpdGlvbjtcbiAgICAgICAgICAgIGRlbGV0ZSB3LmlkO1xuICAgICAgICAgICAgLy8gbW92ZS9yZXNpemUgd2lkZ2V0IGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgICAgIGxldCBrZXlzID0gWyd4JywgJ3knLCAndycsICdoJ107XG4gICAgICAgICAgICBsZXQgbTtcbiAgICAgICAgICAgIGlmIChrZXlzLnNvbWUoayA9PiB3W2tdICE9PSB1bmRlZmluZWQgJiYgd1trXSAhPT0gbltrXSkpIHtcbiAgICAgICAgICAgICAgICBtID0ge307XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtW2tdID0gKHdba10gIT09IHVuZGVmaW5lZCkgPyB3W2tdIDogbltrXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdba107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgYSBtb3ZlIGFzIHdlbGwgSUZGIHRoZXJlIGlzIGFueSBtaW4vbWF4IGZpZWxkcyBzZXRcbiAgICAgICAgICAgIGlmICghbSAmJiAody5taW5XIHx8IHcubWluSCB8fCB3Lm1heFcgfHwgdy5tYXhIKSkge1xuICAgICAgICAgICAgICAgIG0gPSB7fTsgLy8gd2lsbCB1c2Ugbm9kZSBwb3NpdGlvbiBidXQgdmFsaWRhdGUgdmFsdWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgY29udGVudCBjaGFuZ2luZ1xuICAgICAgICAgICAgaWYgKHcuY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUNvbnRlbnQgPSBlbC5xdWVyeVNlbGVjdG9yKCcuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUNvbnRlbnQgJiYgaXRlbUNvbnRlbnQuaW5uZXJIVE1MICE9PSB3LmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnQuaW5uZXJIVE1MID0gdy5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGFueSBzdWItZ3JpZCBiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnN1YkdyaWQ/LmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudC5hcHBlbmRDaGlsZChuLnN1YkdyaWQuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuLnN1YkdyaWQub3B0cy5zdHlsZUluSGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnN1YkdyaWQuX3VwZGF0ZVN0eWxlcyh0cnVlKTsgLy8gZm9yY2UgY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHcuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFueSByZW1haW5pbmcgZmllbGRzIGFyZSBhc3NpZ25lZCwgYnV0IGNoZWNrIGZvciBkcmFnZ2luZyBjaGFuZ2VzLCByZXNpemUgY29uc3RyYWluXG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRkQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdykge1xuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICdfJyAmJiBuW2tleV0gIT09IHdba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBuW2tleV0gPSB3W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZENoYW5nZWQgPSBkZENoYW5nZWQgfHwgKCF0aGlzLm9wdHMuc3RhdGljR3JpZCAmJiAoa2V5ID09PSAnbm9SZXNpemUnIHx8IGtleSA9PT0gJ25vTW92ZScgfHwga2V5ID09PSAnbG9ja2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFV0aWxzLnNhbml0aXplTWluTWF4KG4pO1xuICAgICAgICAgICAgLy8gZmluYWxseSBtb3ZlIHRoZSB3aWRnZXRcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZShuLCBtKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7IC8vIG1vdmUgd2lsbCBvbmx5IHVwZGF0ZSB4LHksdyxoIHNvIHVwZGF0ZSB0aGUgcmVzdCB0b29cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUF0dHIoZWwsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRkQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtb3ZlTm9kZShuLCBtKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsZWFuTm9kZXMoKVxuICAgICAgICAgICAgLmJlZ2luVXBkYXRlKG4pXG4gICAgICAgICAgICAubW92ZU5vZGUobiwgbSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5lbmdpbmUuZW5kVXBkYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd2lkZ2V0IGhlaWdodCB0byBtYXRjaCB0aGUgY29udGVudCBoZWlnaHQgdG8gYXZvaWQgdi1zY3JvbGxiYXIgb3IgZGVhZCBzcGFjZS5cbiAgICAgKiBOb3RlOiB0aGlzIGFzc3VtZXMgb25seSAxIGNoaWxkIHVuZGVyIHJlc2l6ZVRvQ29udGVudFBhcmVudD0nLmdyaWQtc3RhY2staXRlbS1jb250ZW50JyAoc2l6ZWQgdG8gZ3JpZEl0ZW0gbWludXMgcGFkZGluZykgdGhhdCBpcyBhdCB0aGUgZW50aXJlIGNvbnRlbnQgc2l6ZSB3YW50ZWQuXG4gICAgICogdXNlQXR0clNpemUgc2V0IHRvIHRydWUgaWYgR3JpZFN0YWNrTm9kZS5oIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgYWN0dWFsIGNvbnRhaW5lciBoZWlnaHQgd2hlbiB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIGFuaW1hdGlvbiB0byBmaW5pc2ggdG8gZ2V0IGFjdHVhbCBET00gaGVpZ2h0c1xuICAgICAqL1xuICAgIHJlc2l6ZVRvQ29udGVudChlbCwgdXNlQXR0clNpemUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzaXplLXRvLWNvbnRlbnQtbWF4Jyk7XG4gICAgICAgIGlmICghZWwuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuOyAvLyAwIHdoZW4gaGlkZGVuLCBza2lwXG4gICAgICAgIGxldCBuID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBncmlkID0gbi5ncmlkO1xuICAgICAgICBpZiAoIWdyaWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlbC5wYXJlbnRFbGVtZW50ICE9PSBncmlkLmVsKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBza2lwIGlmIHdlIGFyZSBub3QgaW5zaWRlIGEgZ3JpZFxuICAgICAgICBjb25zdCBjZWxsID0gZ3JpZC5nZXRDZWxsSGVpZ2h0KCk7XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhlaWdodCA9IHVzZUF0dHJTaXplICYmIG4uaCA/IG4uaCAqIGNlbGwgOiBlbC5jbGllbnRIZWlnaHQ7IC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCBzZWVtIHRvIGZsaWNrZXIgYmFjayBhbmQgZm9ydGhcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChuLnJlc2l6ZVRvQ29udGVudFBhcmVudClcbiAgICAgICAgICAgIGl0ZW0gPSBlbC5xdWVyeVNlbGVjdG9yKG4ucmVzaXplVG9Db250ZW50UGFyZW50KTtcbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgaXRlbSA9IGVsLnF1ZXJ5U2VsZWN0b3IoR3JpZFN0YWNrLnJlc2l6ZVRvQ29udGVudFBhcmVudCk7XG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IGVsLmNsaWVudEhlaWdodCAtIGl0ZW0uY2xpZW50SGVpZ2h0OyAvLyBmdWxsIC0gYXZhaWxhYmxlIGhlaWdodCB0byBvdXIgY2hpbGQgKG1pbnVzIGJvcmRlciwgcGFkZGluZy4uLilcbiAgICAgICAgY29uc3QgaXRlbUggPSB1c2VBdHRyU2l6ZSAmJiBuLmggPyBuLmggKiBjZWxsIC0gcGFkZGluZyA6IGl0ZW0uY2xpZW50SGVpZ2h0OyAvLyBjYWxjdWxhdGVkIHRvIHdoYXQgY2VsbEhlaWdodCBpcyBvciB3aWxsIGJlY29tZSAocmF0aGVyIHRoYW4gYWN0dWFsIHRvIHByZXZlbnQgd2FpdGluZyBmb3IgYW5pbWF0aW9uIHRvIGZpbmlzaClcbiAgICAgICAgbGV0IHdhbnRlZEg7XG4gICAgICAgIGlmIChuLnN1YkdyaWQpIHtcbiAgICAgICAgICAgIC8vIHN1Yi1ncmlkIC0gdXNlIHRoZWlyIGFjdHVhbCByb3cgY291bnQgKiB0aGVpciBjZWxsIGhlaWdodFxuICAgICAgICAgICAgd2FudGVkSCA9IG4uc3ViR3JpZC5nZXRSb3coKSAqIG4uc3ViR3JpZC5nZXRDZWxsSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBjbGllbnRIZWlnaHQgJiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBpcyB1bmRlZmluZWQgZm9yIHRleHQgYW5kIG90aGVyIGxlYWYgbm9kZXMuIHVzZSA8ZGl2PiBjb250YWluZXIhXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGl0ZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yOiByZXNpemVUb0NvbnRlbnQoKSAnJHtHcmlkU3RhY2sucmVzaXplVG9Db250ZW50UGFyZW50fScuZmlyc3RFbGVtZW50Q2hpbGQgaXMgbnVsbCwgbWFrZSBzdXJlIHRvIGhhdmUgYSBkaXYgbGlrZSBjb250YWluZXIuIFNraXBwaW5nIHNpemluZy5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YW50ZWRIID0gY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IGl0ZW1IO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtSCA9PT0gd2FudGVkSClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGVpZ2h0ICs9IHdhbnRlZEggLSBpdGVtSDtcbiAgICAgICAgbGV0IGggPSBNYXRoLmNlaWwoaGVpZ2h0IC8gY2VsbCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtaW4vbWF4IGFuZCBzcGVjaWFsIHNpemluZ1xuICAgICAgICBjb25zdCBzb2Z0TWF4ID0gTnVtYmVyLmlzSW50ZWdlcihuLnNpemVUb0NvbnRlbnQpID8gbi5zaXplVG9Db250ZW50IDogMDtcbiAgICAgICAgaWYgKHNvZnRNYXggJiYgaCA+IHNvZnRNYXgpIHtcbiAgICAgICAgICAgIGggPSBzb2Z0TWF4O1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnc2l6ZS10by1jb250ZW50LW1heCcpOyAvLyBnZXQgdi1zY3JvbGwgYmFja1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLm1pbkggJiYgaCA8IG4ubWluSClcbiAgICAgICAgICAgIGggPSBuLm1pbkg7XG4gICAgICAgIGVsc2UgaWYgKG4ubWF4SCAmJiBoID4gbi5tYXhIKVxuICAgICAgICAgICAgaCA9IG4ubWF4SDtcbiAgICAgICAgaWYgKGggIT09IG4uaCkge1xuICAgICAgICAgICAgZ3JpZC5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgZ3JpZC5tb3ZlTm9kZShuLCB7IGggfSk7XG4gICAgICAgICAgICBkZWxldGUgZ3JpZC5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGNhbGwgdGhlIHVzZXIgcmVzaXplIChzbyB0aGV5IGNhbiBkbyBleHRyYSB3b3JrKSBlbHNlIG91ciBidWlsZCBpbiB2ZXJzaW9uICovXG4gICAgcmVzaXplVG9Db250ZW50Q2hlY2soZWwsIHVzZUF0dHIgPSBmYWxzZSkge1xuICAgICAgICBpZiAoR3JpZFN0YWNrLnJlc2l6ZVRvQ29udGVudENCKVxuICAgICAgICAgICAgR3JpZFN0YWNrLnJlc2l6ZVRvQ29udGVudENCKGVsLCB1c2VBdHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUb0NvbnRlbnQoZWwsIHVzZUF0dHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtYXJnaW5zIHdoaWNoIHdpbGwgc2V0IGFsbCA0IHNpZGVzIGF0IG9uY2UgLSBzZWUgYEdyaWRTdGFja09wdGlvbnMubWFyZ2luYCBmb3IgZm9ybWF0IG9wdGlvbnMgKENTUyBzdHJpbmcgZm9ybWF0IG9mIDEsMiw0IHZhbHVlcyBvciBzaW5nbGUgbnVtYmVyKS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgbWFyZ2luIHZhbHVlXG4gICAgICovXG4gICAgbWFyZ2luKHZhbHVlKSB7XG4gICAgICAgIGxldCBpc011bHRpVmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zcGxpdCgnICcpLmxlbmd0aCA+IDEpO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gc2tpcCByZS1jcmVhdGluZyBvdXIgQ1NTIGZpbGUuLi4gd29uJ3QgY2hlY2sgaWYgbXVsdGkgdmFsdWVzICh0b28gbXVjaCBoYXNzbGUpXG4gICAgICAgIGlmICghaXNNdWx0aVZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMubWFyZ2luVW5pdCA9PT0gZGF0YS51bml0ICYmIHRoaXMub3B0cy5tYXJnaW4gPT09IGRhdGEuaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtdXNlIGV4aXN0aW5nIG1hcmdpbiBoYW5kbGluZ1xuICAgICAgICB0aGlzLm9wdHMubWFyZ2luID0gdmFsdWU7XG4gICAgICAgIHRoaXMub3B0cy5tYXJnaW5Ub3AgPSB0aGlzLm9wdHMubWFyZ2luQm90dG9tID0gdGhpcy5vcHRzLm1hcmdpbkxlZnQgPSB0aGlzLm9wdHMubWFyZ2luUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2luaXRNYXJnaW4oKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGVzKHRydWUpOyAvLyB0cnVlID0gZm9yY2UgcmUtY3JlYXRlXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyBjdXJyZW50IG1hcmdpbiBudW1iZXIgdmFsdWUgKHVuZGVmaW5lZCBpZiA0IHNpZGVzIGRvbid0IG1hdGNoKSAqL1xuICAgIGdldE1hcmdpbigpIHsgcmV0dXJuIHRoaXMub3B0cy5tYXJnaW47IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGhlaWdodCBvZiB0aGUgZ3JpZCB3aWxsIGJlIGxlc3MgdGhhbiB0aGUgdmVydGljYWxcbiAgICAgKiBjb25zdHJhaW50LiBBbHdheXMgcmV0dXJucyB0cnVlIGlmIGdyaWQgZG9lc24ndCBoYXZlIGhlaWdodCBjb25zdHJhaW50LlxuICAgICAqIEBwYXJhbSBub2RlIGNvbnRhaW5zIHgseSx3LGgsYXV0by1wb3NpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmIChncmlkLndpbGxJdEZpdChuZXdXaWRnZXQpKSB7XG4gICAgICogICBncmlkLmFkZFdpZGdldChuZXdXaWRnZXQpO1xuICAgICAqIH0gZWxzZSB7XG4gICAgICogICBhbGVydCgnTm90IGVub3VnaCBmcmVlIHNwYWNlIHRvIHBsYWNlIHRoZSB3aWRnZXQnKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgd2lsbEl0Rml0KG5vZGUpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBsZWdhY3kgY2FsbCBmb3Igbm93XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdncmlkc3RhY2sudHM6IGB3aWxsSXRGaXQoeCx5LHcsaCxhdXRvUG9zaXRpb24pYCBpcyBkZXByZWNhdGVkLiBVc2UgYHdpbGxJdEZpdCh7eCwgeSwuLi59KWAuIEl0IHdpbGwgYmUgcmVtb3ZlZCBzb29uJyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBsZXQgYSA9IGFyZ3VtZW50cywgaSA9IDAsIHcgPSB7IHg6IGFbaSsrXSwgeTogYVtpKytdLCB3OiBhW2krK10sIGg6IGFbaSsrXSwgYXV0b1Bvc2l0aW9uOiBhW2krK10gfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpbGxJdEZpdCh3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUud2lsbEl0Rml0KG5vZGUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXJDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLmJhdGNoTW9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgZWxlbWVudHMgPSB0aGlzLmVuZ2luZS5nZXREaXJ0eU5vZGVzKHRydWUpOyAvLyB2ZXJpZnkgdGhleSByZWFsbHkgY2hhbmdlZFxuICAgICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lnbm9yZUxheW91dHNOb2RlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUubGF5b3V0c05vZGVzQ2hhbmdlKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgnY2hhbmdlJywgZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5naW5lLnNhdmVJbml0aWFsKCk7IC8vIHdlIGNhbGxlZCwgbm93IHJlc2V0IGluaXRpYWwgdmFsdWVzICYgZGlydHkgZmxhZ3NcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckFkZEV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUuYmF0Y2hNb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVuZ2luZS5hZGRlZE5vZGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faWdub3JlTGF5b3V0c05vZGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5sYXlvdXRzTm9kZXNDaGFuZ2UodGhpcy5lbmdpbmUuYWRkZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFkZGVkIG5vZGVzIGZyb20gYWxzbyB0cmlnZ2VyaW5nICdjaGFuZ2UnIGV2ZW50ICh3aGljaCBpcyBjYWxsZWQgbmV4dClcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmFkZGVkTm9kZXMuZm9yRWFjaChuID0+IHsgZGVsZXRlIG4uX2RpcnR5OyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudCgnYWRkZWQnLCB0aGlzLmVuZ2luZS5hZGRlZE5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyUmVtb3ZlRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZ2luZS5iYXRjaE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZWROb2Rlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnQoJ3JlbW92ZWQnLCB0aGlzLmVuZ2luZS5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckV2ZW50KHR5cGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gZGF0YSA/IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGJ1YmJsZXM6IGZhbHNlLCBkZXRhaWw6IGRhdGEgfSkgOiBuZXcgRXZlbnQodHlwZSk7XG4gICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgZHluYW1pYyBzdHlsZSBzaGVldCB1c2VkIGZvciBvdXIgbGF5b3V0ICovXG4gICAgX3JlbW92ZVN0eWxlc2hlZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgIFV0aWxzLnJlbW92ZVN0eWxlc2hlZXQodGhpcy5fc3R5bGVTaGVldENsYXNzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgdXBkYXRlZC9jcmVhdGUgdGhlIENTUyBzdHlsZXMgZm9yIHJvdyBiYXNlZCBsYXlvdXQgYW5kIGluaXRpYWwgbWFyZ2luIHNldHRpbmcgKi9cbiAgICBfdXBkYXRlU3R5bGVzKGZvcmNlVXBkYXRlID0gZmFsc2UsIG1heEgpIHtcbiAgICAgICAgLy8gY2FsbCB0byBkZWxldGUgZXhpc3Rpbmcgb25lIGlmIHdlIGNoYW5nZSBjZWxsSGVpZ2h0IC8gbWFyZ2luXG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3R5bGVzaGVldCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF4SClcbiAgICAgICAgICAgIG1heEggPSB0aGlzLmdldFJvdygpO1xuICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgLy8gaWYgdXNlciBpcyB0ZWxsaW5nIHVzIHRoZXkgd2lsbCBoYW5kbGUgdGhlIENTUyB0aGVtc2VsdmVzIGJ5IHNldHRpbmcgaGVpZ2h0cyB0byAwLiBEbyB3ZSBuZWVkIHRoaXMgb3B0cyByZWFsbHkgPz9cbiAgICAgICAgaWYgKHRoaXMub3B0cy5jZWxsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VsbEhlaWdodCA9IHRoaXMub3B0cy5jZWxsSGVpZ2h0O1xuICAgICAgICBsZXQgY2VsbEhlaWdodFVuaXQgPSB0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQ7XG4gICAgICAgIGxldCBwcmVmaXggPSBgLiR7dGhpcy5fc3R5bGVTaGVldENsYXNzfSA+IC4ke3RoaXMub3B0cy5pdGVtQ2xhc3N9YDtcbiAgICAgICAgLy8gY3JlYXRlIG9uZSBhcyBuZWVkZWRcbiAgICAgICAgaWYgKCF0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBzdHlsZSB0byBwYXJlbnQgKGluc3RlYWQgb2YgJ2hlYWQnIGJ5IGRlZmF1bHQpIHRvIHN1cHBvcnQgV2ViQ29tcG9uZW50XG4gICAgICAgICAgICBsZXQgc3R5bGVMb2NhdGlvbiA9IHRoaXMub3B0cy5zdHlsZUluSGVhZCA/IHVuZGVmaW5lZCA6IHRoaXMuZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IFV0aWxzLmNyZWF0ZVN0eWxlc2hlZXQodGhpcy5fc3R5bGVTaGVldENsYXNzLCBzdHlsZUxvY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMub3B0cy5ub25jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdHlsZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMuX21heCA9IDA7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG9uZSBvbmNlIG9ubHlcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBwcmVmaXgsIGBoZWlnaHQ6ICR7Y2VsbEhlaWdodH0ke2NlbGxIZWlnaHRVbml0fWApO1xuICAgICAgICAgICAgLy8gY29udGVudCBtYXJnaW5zXG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5vcHRzLm1hcmdpblRvcCArIHRoaXMub3B0cy5tYXJnaW5Vbml0O1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMub3B0cy5tYXJnaW5Cb3R0b20gKyB0aGlzLm9wdHMubWFyZ2luVW5pdDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMub3B0cy5tYXJnaW5SaWdodCArIHRoaXMub3B0cy5tYXJnaW5Vbml0O1xuICAgICAgICAgICAgbGV0IGxlZnQgPSB0aGlzLm9wdHMubWFyZ2luTGVmdCArIHRoaXMub3B0cy5tYXJnaW5Vbml0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBgJHtwcmVmaXh9ID4gLmdyaWQtc3RhY2staXRlbS1jb250ZW50YDtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IGAuJHt0aGlzLl9zdHlsZVNoZWV0Q2xhc3N9ID4gLmdyaWQtc3RhY2stcGxhY2Vob2xkZXIgPiAucGxhY2Vob2xkZXItY29udGVudGA7XG4gICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgY29udGVudCwgYHRvcDogJHt0b3B9OyByaWdodDogJHtyaWdodH07IGJvdHRvbTogJHtib3R0b219OyBsZWZ0OiAke2xlZnR9O2ApO1xuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIHBsYWNlaG9sZGVyLCBgdG9wOiAke3RvcH07IHJpZ2h0OiAke3JpZ2h0fTsgYm90dG9tOiAke2JvdHRvbX07IGxlZnQ6ICR7bGVmdH07YCk7XG4gICAgICAgICAgICAvLyByZXNpemUgaGFuZGxlcyBvZmZzZXQgKHRvIG1hdGNoIG1hcmdpbilcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9ID4gLnVpLXJlc2l6YWJsZS1uZWAsIGByaWdodDogJHtyaWdodH1gKTtcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9ID4gLnVpLXJlc2l6YWJsZS1lYCwgYHJpZ2h0OiAke3JpZ2h0fWApO1xuICAgICAgICAgICAgVXRpbHMuYWRkQ1NTUnVsZSh0aGlzLl9zdHlsZXMsIGAke3ByZWZpeH0gPiAudWktcmVzaXphYmxlLXNlYCwgYHJpZ2h0OiAke3JpZ2h0fTsgYm90dG9tOiAke2JvdHRvbX1gKTtcbiAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9ID4gLnVpLXJlc2l6YWJsZS1ud2AsIGBsZWZ0OiAke2xlZnR9YCk7XG4gICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgYCR7cHJlZml4fSA+IC51aS1yZXNpemFibGUtd2AsIGBsZWZ0OiAke2xlZnR9YCk7XG4gICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgYCR7cHJlZml4fSA+IC51aS1yZXNpemFibGUtc3dgLCBgbGVmdDogJHtsZWZ0fTsgYm90dG9tOiAke2JvdHRvbX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgdXBkYXRlIHRoZSBoZWlnaHQgc3BlY2lmaWMgZmllbGRzXG4gICAgICAgIG1heEggPSBtYXhIIHx8IHRoaXMuX3N0eWxlcy5fbWF4O1xuICAgICAgICBpZiAobWF4SCA+IHRoaXMuX3N0eWxlcy5fbWF4KSB7XG4gICAgICAgICAgICBsZXQgZ2V0SGVpZ2h0ID0gKHJvd3MpID0+IChjZWxsSGVpZ2h0ICogcm93cykgKyBjZWxsSGVpZ2h0VW5pdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zdHlsZXMuX21heCArIDE7IGkgPD0gbWF4SDsgaSsrKSB7IC8vIHN0YXJ0IGF0IDFcbiAgICAgICAgICAgICAgICBVdGlscy5hZGRDU1NSdWxlKHRoaXMuX3N0eWxlcywgYCR7cHJlZml4fVtncy15PVwiJHtpfVwiXWAsIGB0b3A6ICR7Z2V0SGVpZ2h0KGkpfWApO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFkZENTU1J1bGUodGhpcy5fc3R5bGVzLCBgJHtwcmVmaXh9W2dzLWg9XCIke2kgKyAxfVwiXWAsIGBoZWlnaHQ6ICR7Z2V0SGVpZ2h0KGkgKyAxKX1gKTsgLy8gc3RhcnQgYXQgMlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3R5bGVzLl9tYXggPSBtYXhIO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5iYXRjaE1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnRHcmlkSXRlbTtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0Um93KCkgKyB0aGlzLl9leHRyYURyYWdSb3c7IC8vIHRoaXMgY2hlY2tzIGZvciBtaW5Sb3cgYWxyZWFkeVxuICAgICAgICBjb25zdCBjZWxsSGVpZ2h0ID0gdGhpcy5vcHRzLmNlbGxIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHVuaXQgPSB0aGlzLm9wdHMuY2VsbEhlaWdodFVuaXQ7XG4gICAgICAgIGlmICghY2VsbEhlaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBjaGVjayBmb3IgY3NzIG1pbiBoZWlnaHQgKG5vbiBuZXN0ZWQgZ3JpZCkuIFRPRE86IHN1cHBvcnQgbWlzbWF0Y2gsIHNheTogbWluICUgd2hpbGUgdW5pdCBpcyBweC5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzc01pbkhlaWdodCA9IFV0aWxzLnBhcnNlSGVpZ2h0KGdldENvbXB1dGVkU3R5bGUodGhpcy5lbClbJ21pbkhlaWdodCddKTtcbiAgICAgICAgICAgIGlmIChjc3NNaW5IZWlnaHQuaCA+IDAgJiYgY3NzTWluSGVpZ2h0LnVuaXQgPT09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5Sb3cgPSBNYXRoLmZsb29yKGNzc01pbkhlaWdodC5oIC8gY2VsbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IG1pblJvdykge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBtaW5Sb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdncy1jdXJyZW50LXJvdycsIFN0cmluZyhyb3cpKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbWluLWhlaWdodCcpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgLy8gbmVzdGVkIGdyaWRzIGhhdmUgJ2luc2VydDowJyB0byBmaWxsIHRoZSBzcGFjZSBvZiBwYXJlbnQgYnkgZGVmYXVsdCwgYnV0IHdlIG1heSBiZSB0YWxsZXIgc28gdXNlIG1pbi1oZWlnaHQgZm9yIHBvc3NpYmxlIHNjcm9sbGJhcnNcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGVbcGFyZW50ID8gJ21pbkhlaWdodCcgOiAnaGVpZ2h0J10gPSByb3cgKiBjZWxsSGVpZ2h0ICsgdW5pdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSdyZSBhIG5lc3RlZCBncmlkIGluc2lkZSBhbiBzaXplVG9Db250ZW50IGl0ZW0sIHRlbGwgaXQgdG8gcmVzaXplIGl0c2VsZiB0b29cbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmdyaWQuZW5naW5lLmJhdGNoTW9kZSAmJiBVdGlscy5zaG91bGRTaXplVG9Db250ZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5ncmlkLnJlc2l6ZVRvQ29udGVudENoZWNrKHBhcmVudC5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcHJlcGFyZUVsZW1lbnQoZWwsIHRyaWdnZXJBZGRFdmVudCA9IGZhbHNlLCBub2RlKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRzLml0ZW1DbGFzcyk7XG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHRoaXMuX3JlYWRBdHRyKGVsKTtcbiAgICAgICAgZWwuZ3JpZHN0YWNrTm9kZSA9IG5vZGU7XG4gICAgICAgIG5vZGUuZWwgPSBlbDtcbiAgICAgICAgbm9kZS5ncmlkID0gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB7IC4uLm5vZGUgfTtcbiAgICAgICAgbm9kZSA9IHRoaXMuZW5naW5lLmFkZE5vZGUobm9kZSwgdHJpZ2dlckFkZEV2ZW50KTtcbiAgICAgICAgLy8gd3JpdGUgbm9kZSBhdHRyIGJhY2sgaW4gY2FzZSB0aGVyZSB3YXMgY29sbGlzaW9uIG9yIHdlIGhhdmUgdG8gZml4IGJhZCB2YWx1ZXMgZHVyaW5nIGFkZE5vZGUoKVxuICAgICAgICBpZiAoIVV0aWxzLnNhbWUobm9kZSwgY29weSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlQXR0cihlbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLnNob3VsZFNpemVUb0NvbnRlbnQobm9kZSkpXG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzaXplLXRvLWNvbnRlbnQnKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBjYWxsIHRvIHdyaXRlIHBvc2l0aW9uIHgseSx3LGggYXR0cmlidXRlcyBiYWNrIHRvIGVsZW1lbnQgKi9cbiAgICBfd3JpdGVQb3NBdHRyKGVsLCBuKSB7XG4gICAgICAgIGlmIChuLnggIT09IHVuZGVmaW5lZCAmJiBuLnggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZ3MteCcsIFN0cmluZyhuLngpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi55ICE9PSB1bmRlZmluZWQgJiYgbi55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2dzLXknLCBTdHJpbmcobi55KSk7XG4gICAgICAgIH1cbiAgICAgICAgbi53ID4gMSA/IGVsLnNldEF0dHJpYnV0ZSgnZ3MtdycsIFN0cmluZyhuLncpKSA6IGVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtdycpO1xuICAgICAgICBuLmggPiAxID8gZWwuc2V0QXR0cmlidXRlKCdncy1oJywgU3RyaW5nKG4uaCkpIDogZWwucmVtb3ZlQXR0cmlidXRlKCdncy1oJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGwgdG8gd3JpdGUgYW55IGRlZmF1bHQgYXR0cmlidXRlcyBiYWNrIHRvIGVsZW1lbnQgKi9cbiAgICBfd3JpdGVBdHRyKGVsLCBub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLl93cml0ZVBvc0F0dHIoZWwsIG5vZGUpO1xuICAgICAgICBsZXQgYXR0cnMgLyo6IEdyaWRTdGFja1dpZGdldCBidXQgc3RyaW5ncyAqLyA9IHtcbiAgICAgICAgICAgIGF1dG9Qb3NpdGlvbjogJ2dzLWF1dG8tcG9zaXRpb24nLFxuICAgICAgICAgICAgbm9SZXNpemU6ICdncy1uby1yZXNpemUnLFxuICAgICAgICAgICAgbm9Nb3ZlOiAnZ3Mtbm8tbW92ZScsXG4gICAgICAgICAgICBsb2NrZWQ6ICdncy1sb2NrZWQnLFxuICAgICAgICAgICAgaWQ6ICdncy1pZCcsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAobm9kZVtrZXldKSB7IC8vIDAgaXMgdmFsaWQgZm9yIHgseSBvbmx5IGJ1dCBkb25lIGFib3ZlIGFscmVhZHkgYW5kIG5vdCBpbiBsaXN0IGFueXdheVxuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyc1trZXldLCBTdHJpbmcobm9kZVtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cnNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbCB0byByZWFkIGFueSBkZWZhdWx0IGF0dHJpYnV0ZXMgZnJvbSBlbGVtZW50ICovXG4gICAgX3JlYWRBdHRyKGVsLCBjbGVhckRlZmF1bHRBdHRyID0gdHJ1ZSkge1xuICAgICAgICBsZXQgbiA9IHt9O1xuICAgICAgICBuLnggPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLXgnKSk7XG4gICAgICAgIG4ueSA9IFV0aWxzLnRvTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgnZ3MteScpKTtcbiAgICAgICAgbi53ID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy13JykpO1xuICAgICAgICBuLmggPSBVdGlscy50b051bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2dzLWgnKSk7XG4gICAgICAgIG4uYXV0b1Bvc2l0aW9uID0gVXRpbHMudG9Cb29sKGVsLmdldEF0dHJpYnV0ZSgnZ3MtYXV0by1wb3NpdGlvbicpKTtcbiAgICAgICAgbi5ub1Jlc2l6ZSA9IFV0aWxzLnRvQm9vbChlbC5nZXRBdHRyaWJ1dGUoJ2dzLW5vLXJlc2l6ZScpKTtcbiAgICAgICAgbi5ub01vdmUgPSBVdGlscy50b0Jvb2woZWwuZ2V0QXR0cmlidXRlKCdncy1uby1tb3ZlJykpO1xuICAgICAgICBuLmxvY2tlZCA9IFV0aWxzLnRvQm9vbChlbC5nZXRBdHRyaWJ1dGUoJ2dzLWxvY2tlZCcpKTtcbiAgICAgICAgbi5pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZ3MtaWQnKTtcbiAgICAgICAgLy8gcmVhZCBidXQgbmV2ZXIgd3JpdHRlbiBvdXRcbiAgICAgICAgbi5tYXhXID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1tYXgtdycpKTtcbiAgICAgICAgbi5taW5XID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1taW4tdycpKTtcbiAgICAgICAgbi5tYXhIID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1tYXgtaCcpKTtcbiAgICAgICAgbi5taW5IID0gVXRpbHMudG9OdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdncy1taW4taCcpKTtcbiAgICAgICAgLy8gdjgueCBvcHRpbWl6YXRpb24gdG8gcmVkdWNlIHVuLW5lZWRlZCBhdHRyIHRoYXQgZG9uJ3QgcmVuZGVyIG9yIGFyZSBkZWZhdWx0IENTU1xuICAgICAgICBpZiAoY2xlYXJEZWZhdWx0QXR0cikge1xuICAgICAgICAgICAgaWYgKG4udyA9PT0gMSlcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2dzLXcnKTtcbiAgICAgICAgICAgIGlmIChuLmggPT09IDEpXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdncy1oJyk7XG4gICAgICAgICAgICBpZiAobi5tYXhXKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtbWF4LXcnKTtcbiAgICAgICAgICAgIGlmIChuLm1pblcpXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdncy1taW4tdycpO1xuICAgICAgICAgICAgaWYgKG4ubWF4SClcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2dzLW1heC1oJyk7XG4gICAgICAgICAgICBpZiAobi5taW5IKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3MtbWluLWgnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYW55IGtleSBub3QgZm91bmQgKG51bGwgb3IgZmFsc2Ugd2hpY2ggaXMgZGVmYXVsdClcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgaWYgKCFuLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFuW2tleV0gJiYgbltrZXldICE9PSAwKSB7IC8vIDAgY2FuIGJlIHZhbGlkIHZhbHVlICh4LHkgb25seSByZWFsbHkpXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXRTdGF0aWNDbGFzcygpIHtcbiAgICAgICAgbGV0IGNsYXNzZXMgPSBbJ2dyaWQtc3RhY2stc3RhdGljJ107XG4gICAgICAgIGlmICh0aGlzLm9wdHMuc3RhdGljR3JpZCkge1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xuICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2dzLXN0YXRpYycsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcyk7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnZ3Mtc3RhdGljJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHdlIGFyZSBiZWluZyByZXNpemVkIC0gY2hlY2sgaWYgdGhlIG9uZSBDb2x1bW4gTW9kZSBuZWVkcyB0byBiZSB0dXJuZWQgb24vb2ZmXG4gICAgICogYW5kIHJlbWVtYmVyIHRoZSBwcmV2IGNvbHVtbnMgd2UgdXNlZCwgb3IgZ2V0IG91ciBjb3VudCBmcm9tIHBhcmVudCwgYXMgd2VsbCBhcyBjaGVjayBmb3IgY2VsbEhlaWdodD09PSdhdXRvJyAoc3F1YXJlKVxuICAgICAqIG9yIGBzaXplVG9Db250ZW50YCBncmlkSXRlbSBvcHRpb25zLlxuICAgICAqL1xuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWw/LmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyByZXR1cm4gaWYgd2UncmUgZ29uZSBvciBubyBzaXplIHlldCAod2lsbCBnZXQgY2FsbGVkIGFnYWluKVxuICAgICAgICBpZiAodGhpcy5wcmV2V2lkdGggPT09IHRoaXMuZWwuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICByZXR1cm47IC8vIG5vLW9wXG4gICAgICAgIHRoaXMucHJldldpZHRoID0gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29uUmVzaXplICcsIHRoaXMuZWwuY2xpZW50V2lkdGgpO1xuICAgICAgICB0aGlzLmJhdGNoVXBkYXRlKCk7XG4gICAgICAgIC8vIHNlZSBpZiB3ZSdyZSBuZXN0ZWQgYW5kIHRha2Ugb3VyIGNvbHVtbiBjb3VudCBmcm9tIG91ciBwYXJlbnQuLi4uXG4gICAgICAgIGxldCBjb2x1bW5DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ29sdW1uICYmIHRoaXMucGFyZW50R3JpZEl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY29sdW1uICE9PSB0aGlzLnBhcmVudEdyaWRJdGVtLncpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbih0aGlzLnBhcmVudEdyaWRJdGVtLncsICdub25lJyk7XG4gICAgICAgICAgICAgICAgY29sdW1uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIGNoZWNrIGZvciAxIGNvbHVtbiBpbi9vdXQgYmVoYXZpb3JcbiAgICAgICAgICAgIGxldCBvbmVDb2x1bW4gPSAhdGhpcy5vcHRzLmRpc2FibGVPbmVDb2x1bW5Nb2RlICYmIHRoaXMuZWwuY2xpZW50V2lkdGggPD0gdGhpcy5vcHRzLm9uZUNvbHVtblNpemUgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRzLmNvbHVtbiA9PT0gMSAmJiAhdGhpcy5fcHJldkNvbHVtbik7XG4gICAgICAgICAgICBpZiAoKHRoaXMub3B0cy5jb2x1bW4gPT09IDEpICE9PSBvbmVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5vcHRzLmFuaW1hdGUpIHRoaXMuc2V0QW5pbWF0aW9uKGZhbHNlKTsgLy8gMSA8LT4gMTIgaXMgdG9vIHJhZGljYWwsIHR1cm4gb2ZmIGFuaW1hdGlvbiBhbmQgd2UgbmVlZCBpdCBmb3Igc2l6ZVRvQ29udGVudFxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uKG9uZUNvbHVtbiA/IDEgOiB0aGlzLl9wcmV2Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5vcHRzLmFuaW1hdGUpIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRBbmltYXRpb24odHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGNvbHVtbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgdGhlIGNlbGxzIGNvbnRlbnQgc3F1YXJlIGFnYWluXG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9DZWxsSGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5jZWxsSGVpZ2h0KCk7XG4gICAgICAgIC8vIHVwZGF0ZSBhbnkgbmVzdGVkIGdyaWRzLCBvciBpdGVtcyBzaXplXG4gICAgICAgIHRoaXMuZW5naW5lLm5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICBpZiAobi5zdWJHcmlkKVxuICAgICAgICAgICAgICAgIG4uc3ViR3JpZC5vblJlc2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLl9za2lwSW5pdGlhbFJlc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuZG9Db250ZW50UmVzaXplKGNvbHVtbkNoYW5nZWQpOyAvLyB3YWl0IGZvciBhbmltIG9mIGNvbHVtbiBjaGFuZ2VkIChET00gcmVmbG93IGJlZm9yZSB3ZSBjYW4gc2l6ZSBjb3JyZWN0bHkpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9za2lwSW5pdGlhbFJlc2l6ZTtcbiAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZShmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkb0NvbnRlbnRSZXNpemUoZGVsYXkgPSB0cnVlLCB1c2VBdHRyID0gZmFsc2UsIG4gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXBkYXRlIGFueSBncmlkSXRlbSBoZWlnaHQgd2l0aCBzaXplVG9Db250ZW50LCBidXQgd2FpdCBmb3IgRE9NICRhbmltYXRpb25fc3BlZWQgdG8gc2V0dGxlIGlmIHdlIGNoYW5nZWQgY29sdW1uIGNvdW50XG4gICAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgd2F5IHRvIGtub3cgd2hhdCB0aGUgZmluYWwgKHBvc3QgYW5pbWF0aW9uKSBzaXplIG9mIHRoZSBjb250ZW50IHdpbGwgYmUgc28gd2UgY2FuIGFuaW1hdGUgdGhlIGNvbHVtbiB3aWR0aCBhbmQgaGVpZ2h0IHRvZ2V0aGVyIHJhdGhlciB0aGFuIHNlcXVlbnRpYWxseSA/XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuc2hvdWxkU2l6ZVRvQ29udGVudChuKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUb0NvbnRlbnRDaGVjayhuLmVsLCB1c2VBdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZW5naW5lLm5vZGVzLnNvbWUobiA9PiBVdGlscy5zaG91bGRTaXplVG9Db250ZW50KG4pKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gWy4uLnRoaXMuZW5naW5lLm5vZGVzXTsgLy8gaW4gY2FzZSBvcmRlciBjaGFuZ2VzIHdoaWxlIHJlc2l6aW5nIG9uZVxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuc2hvdWxkU2l6ZVRvQ29udGVudChuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVG9Db250ZW50Q2hlY2sobi5lbCwgdXNlQXR0cik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFVwZGF0ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIHRoaXMgcmVnYXJkbGVzcyBvZiBzaG91bGRTaXplVG9Db250ZW50IGJlY2F1c2Ugd2lkZ2V0IG1pZ2h0IG5lZWQgdG8gc3RyZXRjaCB0byB0YWtlIGF2YWlsYWJsZSBzcGFjZSBhZnRlciBhIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2dzRXZlbnRIYW5kbGVyWydyZXNpemVjb250ZW50J10pXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbJ3Jlc2l6ZWNvbnRlbnQnXShudWxsLCBuID8gW25dIDogdGhpcy5lbmdpbmUubm9kZXMpO1xuICAgICAgICB9LCBkZWxheSA/IDMwMCArIDEwIDogMCk7XG4gICAgfVxuICAgIC8qKiBhZGQgb3IgcmVtb3ZlIHRoZSBncmlkIGVsZW1lbnQgc2l6ZSBldmVudCBoYW5kbGVyICovXG4gICAgX3VwZGF0ZVJlc2l6ZUV2ZW50KGZvcmNlUmVtb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gb25seSBhZGQgZXZlbnQgaWYgd2UncmUgbm90IG5lc3RlZCAocGFyZW50IHdpbGwgY2FsbCB1cykgYW5kIHdlJ3JlIGF1dG8gc2l6aW5nIGNlbGxzIG9yIHN1cHBvcnRpbmcgb25lQ29sdW1uIChpLmUuIGRvaW5nIHdvcmspXG4gICAgICAgIC8vIG9yIHN1cHBvcnRpbmcgbmV3IHNpemVUb0NvbnRlbnQgb3B0aW9uLlxuICAgICAgICBjb25zdCB0cmFja1NpemUgPSAhdGhpcy5wYXJlbnRHcmlkSXRlbSAmJiAodGhpcy5faXNBdXRvQ2VsbEhlaWdodCB8fCB0aGlzLm9wdHMuc2l6ZVRvQ29udGVudCB8fCAhdGhpcy5vcHRzLmRpc2FibGVPbmVDb2x1bW5Nb2RlXG4gICAgICAgICAgICB8fCB0aGlzLmVuZ2luZS5ub2Rlcy5maW5kKG4gPT4gbi5zaXplVG9Db250ZW50KSk7XG4gICAgICAgIGlmICghZm9yY2VSZW1vdmUgJiYgdHJhY2tTaXplICYmICF0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplVGhyb3R0bGUgPSBVdGlscy50aHJvdHRsZSgoKSA9PiB0aGlzLm9uUmVzaXplKCksIHRoaXMub3B0cy5jZWxsSGVpZ2h0VGhyb3R0bGUpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLl9zaXplVGhyb3R0bGUoKSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbCk7XG4gICAgICAgICAgICB0aGlzLl9za2lwSW5pdGlhbFJlc2l6ZSA9IHRydWU7IC8vIG1ha2VXaWRnZXQgd2lsbCBvcmlnaW5hbGx5IGhhdmUgY2FsbGVkIG9uIHN0YXJ0dXBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZm9yY2VSZW1vdmUgfHwgIXRyYWNrU2l6ZSkgJiYgdGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaXplVGhyb3R0bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY29udmVydCBhIHBvdGVudGlhbCBzZWxlY3RvciBpbnRvIGFjdHVhbCBlbGVtZW50ICovXG4gICAgc3RhdGljIGdldEVsZW1lbnQoZWxzID0gJy5ncmlkLXN0YWNrLWl0ZW0nKSB7IHJldHVybiBVdGlscy5nZXRFbGVtZW50KGVscyk7IH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGdldEVsZW1lbnRzKGVscyA9ICcuZ3JpZC1zdGFjay1pdGVtJykgeyByZXR1cm4gVXRpbHMuZ2V0RWxlbWVudHMoZWxzKTsgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZ2V0R3JpZEVsZW1lbnQoZWxzKSB7IHJldHVybiBHcmlkU3RhY2suZ2V0RWxlbWVudChlbHMpOyB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBnZXRHcmlkRWxlbWVudHMoZWxzKSB7IHJldHVybiBVdGlscy5nZXRFbGVtZW50cyhlbHMpOyB9XG4gICAgLyoqIEBpbnRlcm5hbCBpbml0aWFsaXplIG1hcmdpbiB0b3AvYm90dG9tL2xlZnQvcmlnaHQgYW5kIHVuaXRzICovXG4gICAgX2luaXRNYXJnaW4oKSB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgbWFyZ2luID0gMDtcbiAgICAgICAgLy8gc3VwcG9ydCBwYXNzaW5nIG11bHRpcGxlIHZhbHVlcyBsaWtlIENTUyAoZXg6ICc1cHggMTBweCAwIDIwcHgnKVxuICAgICAgICBsZXQgbWFyZ2lucyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXJnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtYXJnaW5zID0gdGhpcy5vcHRzLm1hcmdpbi5zcGxpdCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJnaW5zLmxlbmd0aCA9PT0gMikgeyAvLyB0b3AvYm90LCBsZWZ0L3JpZ2h0IGxpa2UgQ1NTXG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luVG9wID0gdGhpcy5vcHRzLm1hcmdpbkJvdHRvbSA9IG1hcmdpbnNbMF07XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luTGVmdCA9IHRoaXMub3B0cy5tYXJnaW5SaWdodCA9IG1hcmdpbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFyZ2lucy5sZW5ndGggPT09IDQpIHsgLy8gQ2xvY2t3aXNlIGxpa2UgQ1NTXG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luVG9wID0gbWFyZ2luc1swXTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5SaWdodCA9IG1hcmdpbnNbMV07XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luQm90dG9tID0gbWFyZ2luc1syXTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luc1szXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBVdGlscy5wYXJzZUhlaWdodCh0aGlzLm9wdHMubWFyZ2luKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Vbml0ID0gZGF0YS51bml0O1xuICAgICAgICAgICAgbWFyZ2luID0gdGhpcy5vcHRzLm1hcmdpbiA9IGRhdGEuaDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWUgaWYgdG9wL2JvdHRvbS9sZWZ0L3JpZ2h0IG5lZWQgdG8gYmUgc2V0IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMub3B0cy5tYXJnaW5Ub3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpblRvcCA9IG1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBVdGlscy5wYXJzZUhlaWdodCh0aGlzLm9wdHMubWFyZ2luVG9wKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXJnaW5Ub3AgPSBkYXRhLmg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRzLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLm1hcmdpbkJvdHRvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luQm90dG9tID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHRoaXMub3B0cy5tYXJnaW5Cb3R0b20pO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpbkJvdHRvbSA9IGRhdGEuaDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdHMubWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMubWFyZ2luUmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpblJpZ2h0ID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IFV0aWxzLnBhcnNlSGVpZ2h0KHRoaXMub3B0cy5tYXJnaW5SaWdodCk7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luUmlnaHQgPSBkYXRhLmg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRzLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLm1hcmdpbkxlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpbkxlZnQgPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gVXRpbHMucGFyc2VIZWlnaHQodGhpcy5vcHRzLm1hcmdpbkxlZnQpO1xuICAgICAgICAgICAgdGhpcy5vcHRzLm1hcmdpbkxlZnQgPSBkYXRhLmg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRzLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdHMubWFyZ2luVW5pdCA9IGRhdGEudW5pdDsgLy8gaW4gY2FzZSBzaWRlIHdlcmUgc3BlbGxlZCBvdXQsIHVzZSB0aG9zZSB1bml0cyBpbnN0ZWFkLi4uXG4gICAgICAgIGlmICh0aGlzLm9wdHMubWFyZ2luVG9wID09PSB0aGlzLm9wdHMubWFyZ2luQm90dG9tICYmIHRoaXMub3B0cy5tYXJnaW5MZWZ0ID09PSB0aGlzLm9wdHMubWFyZ2luUmlnaHQgJiYgdGhpcy5vcHRzLm1hcmdpblRvcCA9PT0gdGhpcy5vcHRzLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMubWFyZ2luID0gdGhpcy5vcHRzLm1hcmdpblRvcDsgLy8gbWFrZXMgaXQgZWFzaWVyIHRvIGNoZWNrIGZvciBuby1vcHMgaW4gc2V0TWFyZ2luKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqIGRyYWcmZHJvcCBtZXRob2RzIHRoYXQgdXNlZCB0byBiZSBzdHViYmVkIG91dCBhbmQgaW1wbGVtZW50ZWQgaW4gZGQtZ3JpZHN0YWNrLnRzXG4gICAgICogYnV0IGNhdXNlZCBsb2FkaW5nIGlzc3VlcyBpbiBwcm9kIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmlkc3RhY2svZ3JpZHN0YWNrLmpzL2lzc3Vlcy8yMDM5XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAqL1xuICAgIC8qKiBnZXQgdGhlIGdsb2JhbCAoYnV0IHN0YXRpYyB0byB0aGlzIGNvZGUpIEREIGltcGxlbWVudGF0aW9uICovXG4gICAgc3RhdGljIGdldEREKCkge1xuICAgICAgICByZXR1cm4gZGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGwgdG8gc2V0dXAgZHJhZ2dpbmcgaW4gZnJvbSB0aGUgb3V0c2lkZSAoc2F5IHRvb2xiYXIpLCBieSBzcGVjaWZ5aW5nIHRoZSBjbGFzcyBzZWxlY3Rpb24gYW5kIG9wdGlvbnMuXG4gICAgICogQ2FsbGVkIGR1cmluZyBHcmlkU3RhY2suaW5pdCgpIGFzIG9wdGlvbnMsIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgZGlyZWN0bHkgKGxhc3QgcGFyYW0gYXJlIHVzZWQpIGluIGNhc2UgdGhlIHRvb2xiYXJcbiAgICAgKiBpcyBkeW5hbWljYWxseSBjcmVhdGUgYW5kIG5lZWRzIHRvIGJlIHNldCBsYXRlci5cbiAgICAgKiBAcGFyYW0gZHJhZ0luIHN0cmluZyBzZWxlY3RvciAoZXg6ICcuc2lkZWJhciAuZ3JpZC1zdGFjay1pdGVtJykgb3IgbGlzdCBvZiBkb20gZWxlbWVudHNcbiAgICAgKiBAcGFyYW0gZHJhZ0luT3B0aW9ucyBvcHRpb25zIC0gc2VlIERERHJhZ0luT3B0LiAoZGVmYXVsdDoge2hhbmRsZTogJy5ncmlkLXN0YWNrLWl0ZW0tY29udGVudCcsIGFwcGVuZFRvOiAnYm9keSd9XG4gICAgICogQHBhcmFtIHJvb3Qgb3B0aW9uYWwgcm9vdCB3aGljaCBkZWZhdWx0cyB0byBkb2N1bWVudCAoZm9yIHNoYWRvdyBkb20gcGFzIHRoZSBwYXJlbnQgSFRNTERvY3VtZW50KVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXR1cERyYWdJbihkcmFnSW4sIGRyYWdJbk9wdGlvbnMsIHJvb3QgPSBkb2N1bWVudCkge1xuICAgICAgICBpZiAoZHJhZ0luT3B0aW9ucz8ucGF1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRERNYW5hZ2VyLnBhdXNlRHJhZyA9IGRyYWdJbk9wdGlvbnMucGF1c2U7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZ0luT3B0aW9ucyA9IHsgLi4uZHJhZ0luRGVmYXVsdE9wdGlvbnMsIC4uLihkcmFnSW5PcHRpb25zIHx8IHt9KSB9O1xuICAgICAgICBsZXQgZWxzID0gKHR5cGVvZiBkcmFnSW4gPT09ICdzdHJpbmcnKSA/IFV0aWxzLmdldEVsZW1lbnRzKGRyYWdJbiwgcm9vdCkgOiBkcmFnSW47XG4gICAgICAgIGlmIChlbHMubGVuZ3RoKVxuICAgICAgICAgICAgZWxzPy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRkLmlzRHJhZ2dhYmxlKGVsKSlcbiAgICAgICAgICAgICAgICAgICAgZGQuZHJhZ0luKGVsLCBkcmFnSW5PcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzL0Rpc2FibGVzIGRyYWdnaW5nIGJ5IHRoZSB1c2VyIG9mIHNwZWNpZmljIGdyaWQgZWxlbWVudC4gSWYgeW91IHdhbnQgYWxsIGl0ZW1zLCBhbmQgaGF2ZSBpdCBhZmZlY3QgZnV0dXJlIGl0ZW1zLCB1c2UgZW5hYmxlTW92ZSgpIGluc3RlYWQuIE5vLW9wIGZvciBzdGF0aWMgZ3JpZHMuXG4gICAgICogSUYgeW91IGFyZSBsb29raW5nIHRvIHByZXZlbnQgYW4gaXRlbSBmcm9tIG1vdmluZyAoZHVlIHRvIGJlaW5nIHB1c2hlZCBhcm91bmQgYnkgYW5vdGhlciBkdXJpbmcgY29sbGlzaW9uKSB1c2UgbG9ja2VkIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQHBhcmFtIGVscyB3aWRnZXQgb3Igc2VsZWN0b3IgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB2YWwgaWYgdHJ1ZSB3aWRnZXQgd2lsbCBiZSBkcmFnZ2FibGUsIGFzc3VtaW5nIHRoZSBwYXJlbnQgZ3JpZCBpc24ndCBub01vdmUgb3Igc3RhdGljLlxuICAgICAqL1xuICAgIG1vdmFibGUoZWxzLCB2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IG1vdmUgYSBzdGF0aWMgZ3JpZCFcbiAgICAgICAgR3JpZFN0YWNrLmdldEVsZW1lbnRzKGVscykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBsZXQgbiA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFsID8gZGVsZXRlIG4ubm9Nb3ZlIDogbi5ub01vdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pOyAvLyBpbml0IEREIGlmIG5lZWQgYmUsIGFuZCBhZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzL0Rpc2FibGVzIHVzZXIgcmVzaXppbmcgb2Ygc3BlY2lmaWMgZ3JpZCBlbGVtZW50LiBJZiB5b3Ugd2FudCBhbGwgaXRlbXMsIGFuZCBoYXZlIGl0IGFmZmVjdCBmdXR1cmUgaXRlbXMsIHVzZSBlbmFibGVSZXNpemUoKSBpbnN0ZWFkLiBOby1vcCBmb3Igc3RhdGljIGdyaWRzLlxuICAgICAqIEBwYXJhbSBlbHMgIHdpZGdldCBvciBzZWxlY3RvciB0byBtb2RpZnlcbiAgICAgKiBAcGFyYW0gdmFsICBpZiB0cnVlIHdpZGdldCB3aWxsIGJlIHJlc2l6YWJsZSwgYXNzdW1pbmcgdGhlIHBhcmVudCBncmlkIGlzbid0IG5vUmVzaXplIG9yIHN0YXRpYy5cbiAgICAgKi9cbiAgICByZXNpemFibGUoZWxzLCB2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHJlc2l6ZSBhIHN0YXRpYyBncmlkIVxuICAgICAgICBHcmlkU3RhY2suZ2V0RWxlbWVudHMoZWxzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGxldCBuID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIGlmICghbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YWwgPyBkZWxldGUgbi5ub1Jlc2l6ZSA6IG4ubm9SZXNpemUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pOyAvLyBpbml0IEREIGlmIG5lZWQgYmUsIGFuZCBhZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBkaXNhYmxlcyB3aWRnZXRzIG1vdmluZy9yZXNpemluZy5cbiAgICAgKiBJZiB5b3Ugd2FudCBhIG1vcmUgcGVybWFuZW50IHdheSAod2hpY2ggZnJlZXplcyB1cCByZXNvdXJjZXMpIHVzZSBgc2V0U3RhdGljKHRydWUpYCBpbnN0ZWFkLlxuICAgICAqIE5vdGU6IG5vLW9wIGZvciBzdGF0aWMgZ3JpZFxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3I6XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgZ3JpZC5lbmFibGVNb3ZlKGZhbHNlKTtcbiAgICAgKiAgZ3JpZC5lbmFibGVSZXNpemUoZmFsc2UpO1xuICAgICAqIEBwYXJhbSByZWN1cnNlIHRydWUgKGRlZmF1bHQpIGlmIHN1Yi1ncmlkcyBhbHNvIGdldCB1cGRhdGVkXG4gICAgICovXG4gICAgZGlzYWJsZShyZWN1cnNlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnN0YXRpY0dyaWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZW5hYmxlTW92ZShmYWxzZSwgcmVjdXJzZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlUmVzaXplKGZhbHNlLCByZWN1cnNlKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdkaXNhYmxlJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZS1lbmFibGVzIHdpZGdldHMgbW92aW5nL3Jlc2l6aW5nIC0gc2VlIGRpc2FibGUoKS5cbiAgICAgKiBOb3RlOiBuby1vcCBmb3Igc3RhdGljIGdyaWQuXG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvcjpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBncmlkLmVuYWJsZU1vdmUodHJ1ZSk7XG4gICAgICogIGdyaWQuZW5hYmxlUmVzaXplKHRydWUpO1xuICAgICAqIEBwYXJhbSByZWN1cnNlIHRydWUgKGRlZmF1bHQpIGlmIHN1Yi1ncmlkcyBhbHNvIGdldCB1cGRhdGVkXG4gICAgICovXG4gICAgZW5hYmxlKHJlY3Vyc2UgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuc3RhdGljR3JpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lbmFibGVNb3ZlKHRydWUsIHJlY3Vyc2UpO1xuICAgICAgICB0aGlzLmVuYWJsZVJlc2l6ZSh0cnVlLCByZWN1cnNlKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdlbmFibGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgd2lkZ2V0IG1vdmluZy4gTm8tb3AgZm9yIHN0YXRpYyBncmlkcywgYW5kIGxvY2FsbHkgZGVmaW5lZCBpdGVtcyBzdGlsbCBvdmVycnVsZVxuICAgICAqIEBwYXJhbSByZWN1cnNlIHRydWUgKGRlZmF1bHQpIGlmIHN1Yi1ncmlkcyBhbHNvIGdldCB1cGRhdGVkXG4gICAgICovXG4gICAgZW5hYmxlTW92ZShkb0VuYWJsZSwgcmVjdXJzZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IG1vdmUgYSBzdGF0aWMgZ3JpZCFcbiAgICAgICAgZG9FbmFibGUgPyBkZWxldGUgdGhpcy5vcHRzLmRpc2FibGVEcmFnIDogdGhpcy5vcHRzLmRpc2FibGVEcmFnID0gdHJ1ZTsgLy8gRklSU1QgYmVmb3JlIHdlIHVwZGF0ZSBjaGlsZHJlbiBhcyBncmlkIG92ZXJyaWRlcyAjMTY1OFxuICAgICAgICB0aGlzLmVuZ2luZS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURyYWdEcm9wQnlOb2RlKG4pO1xuICAgICAgICAgICAgaWYgKG4uc3ViR3JpZCAmJiByZWN1cnNlKVxuICAgICAgICAgICAgICAgIG4uc3ViR3JpZC5lbmFibGVNb3ZlKGRvRW5hYmxlLCByZWN1cnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHdpZGdldCByZXNpemluZy4gTm8tb3AgZm9yIHN0YXRpYyBncmlkcy5cbiAgICAgKiBAcGFyYW0gcmVjdXJzZSB0cnVlIChkZWZhdWx0KSBpZiBzdWItZ3JpZHMgYWxzbyBnZXQgdXBkYXRlZFxuICAgICAqL1xuICAgIGVuYWJsZVJlc2l6ZShkb0VuYWJsZSwgcmVjdXJzZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHNpemUgYSBzdGF0aWMgZ3JpZCFcbiAgICAgICAgZG9FbmFibGUgPyBkZWxldGUgdGhpcy5vcHRzLmRpc2FibGVSZXNpemUgOiB0aGlzLm9wdHMuZGlzYWJsZVJlc2l6ZSA9IHRydWU7IC8vIEZJUlNUIGJlZm9yZSB3ZSB1cGRhdGUgY2hpbGRyZW4gYXMgZ3JpZCBvdmVycmlkZXMgIzE2NThcbiAgICAgICAgdGhpcy5lbmdpbmUubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEcmFnRHJvcEJ5Tm9kZShuKTtcbiAgICAgICAgICAgIGlmIChuLnN1YkdyaWQgJiYgcmVjdXJzZSlcbiAgICAgICAgICAgICAgICBuLnN1YkdyaWQuZW5hYmxlUmVzaXplKGRvRW5hYmxlLCByZWN1cnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIHJlbW92ZXMgYW55IGRyYWcmZHJvcCBwcmVzZW50IChjYWxsZWQgZHVyaW5nIGRlc3Ryb3kpICovXG4gICAgX3JlbW92ZUREKGVsKSB7XG4gICAgICAgIGRkLmRyYWdnYWJsZShlbCwgJ2Rlc3Ryb3knKS5yZXNpemFibGUoZWwsICdkZXN0cm95Jyk7XG4gICAgICAgIGlmIChlbC5ncmlkc3RhY2tOb2RlKSB7XG4gICAgICAgICAgICBkZWxldGUgZWwuZ3JpZHN0YWNrTm9kZS5faW5pdEREOyAvLyByZXNldCBvdXIgREQgaW5pdCBmbGFnXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVsLmRkRWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgY2FsbGVkIHRvIGFkZCBkcmFnIG92ZXIgdG8gc3VwcG9ydCB3aWRnZXRzIGJlaW5nIGFkZGVkIGV4dGVybmFsbHkgKi9cbiAgICBfc2V0dXBBY2NlcHRXaWRnZXQoKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGlzYWJsZSB0aGluZ3NcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkIHx8ICghdGhpcy5vcHRzLmFjY2VwdFdpZGdldHMgJiYgIXRoaXMub3B0cy5yZW1vdmFibGUpKSB7XG4gICAgICAgICAgICBkZC5kcm9wcGFibGUodGhpcy5lbCwgJ2Rlc3Ryb3knKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhcnMgc2hhcmVkIGFjcm9zcyBhbGwgbWV0aG9kc1xuICAgICAgICBsZXQgY2VsbEhlaWdodCwgY2VsbFdpZHRoO1xuICAgICAgICBsZXQgb25EcmFnID0gKGV2ZW50LCBlbCwgaGVscGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGVscGVyID0gaGVscGVyIHx8IGVsO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZXQgeyB0b3AsIGxlZnQgfSA9IGhlbHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnQgLT0gcGFyZW50LmxlZnQ7XG4gICAgICAgICAgICB0b3AgLT0gcGFyZW50LnRvcDtcbiAgICAgICAgICAgIGxldCB1aSA9IHsgcG9zaXRpb246IHsgdG9wLCBsZWZ0IH0gfTtcbiAgICAgICAgICAgIGlmIChub2RlLl90ZW1wb3JhcnlSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChsZWZ0IC8gY2VsbFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh0b3AgLyBjZWxsSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuYXV0b1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLm5vZGVCb3VuZEZpeChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhY2NlcHQgKmluaXRpYWwqIGxvY2F0aW9uIGlmIGRvZXNuJ3QgZml0ICMxNDE5IChsb2NrZWQgZHJvcCByZWdpb24sIG9yIGNhbid0IGdyb3cpLCBidXQgbWF5YmUgdHJ5IGlmIGl0IHdpbGwgZ28gc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuZ2luZS53aWxsSXRGaXQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hdXRvUG9zaXRpb24gPSB0cnVlOyAvLyBpZ25vcmUgeCx5IGFuZCB0cnkgZm9yIGFueSBzbG90Li4uXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmdpbmUud2lsbEl0Rml0KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZC5vZmYoZWwsICdkcmFnJyk7IC8vIHN0b3AgY2FsbGluZyB1c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBmdWxsIGdyaWQgb3IgY2FuJ3QgZ3Jvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLl93aWxsRml0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGF1dG8gcG9zaXRpb24gaW5zdGVhZCAjMTY4N1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuY29weVBvcyhub2RlLCBub2RlLl93aWxsRml0UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl93aWxsRml0UG9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlLXVzZSB0aGUgZXhpc3Rpbmcgbm9kZSBkcmFnZ2luZyBtZXRob2RcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0TW92aW5nKGhlbHBlciwgZXZlbnQsIHVpLCBub2RlLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmUtdXNlIHRoZSBleGlzdGluZyBub2RlIGRyYWdnaW5nIHRoYXQgZG9lcyBzbyBtdWNoIG9mIHRoZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ09yUmVzaXplKGhlbHBlciwgZXZlbnQsIHVpLCBub2RlLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkZC5kcm9wcGFibGUodGhpcy5lbCwge1xuICAgICAgICAgICAgYWNjZXB0OiAoZWwpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGVsLmdyaWRzdGFja05vZGU7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGFjY2VwdCBkcm9wIHRvIHRydWUgb24gb3Vyc2VsZiAod2hpY2ggd2UgaWdub3JlKSBzbyB3ZSBkb24ndCBnZXQgXCJjYW4ndCBkcm9wXCIgaWNvbiBpbiBIVE1MNSBtb2RlIHdoaWxlIG1vdmluZ1xuICAgICAgICAgICAgICAgIGlmIChub2RlPy5ncmlkID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5hY2NlcHRXaWRnZXRzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGFjY2VwdCBtZXRob2Qgb3IgY2xhc3MgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICBsZXQgY2FuQWNjZXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5hY2NlcHRXaWRnZXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbkFjY2VwdCA9IHRoaXMub3B0cy5hY2NlcHRXaWRnZXRzKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RvciA9ICh0aGlzLm9wdHMuYWNjZXB0V2lkZ2V0cyA9PT0gdHJ1ZSA/ICcuZ3JpZC1zdGFjay1pdGVtJyA6IHRoaXMub3B0cy5hY2NlcHRXaWRnZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuQWNjZXB0ID0gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsbHkgY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgc3BhY2UgbGVmdCAjMTU3MVxuICAgICAgICAgICAgICAgIGlmIChjYW5BY2NlcHQgJiYgbm9kZSAmJiB0aGlzLm9wdHMubWF4Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0geyB3OiBub2RlLncsIGg6IG5vZGUuaCwgbWluVzogbm9kZS5taW5XLCBtaW5IOiBub2RlLm1pbkggfTsgLy8gb25seSB3aWR0aC9oZWlnaHQgbWF0dGVycyBhbmQgYXV0b1Bvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhbkFjY2VwdCA9IHRoaXMuZW5naW5lLndpbGxJdEZpdChuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbkFjY2VwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZW50ZXJpbmcgb3VyIGdyaWQgYXJlYVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAub24odGhpcy5lbCwgJ2Ryb3BvdmVyJywgKGV2ZW50LCBlbCwgaGVscGVyKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgb3ZlciAke3RoaXMuZWwuZ3JpZHN0YWNrLm9wdHMuaWR9ICR7Y291bnQrK31gKTsgLy8gVEVTVFxuICAgICAgICAgICAgbGV0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgLy8gaWdub3JlIGRyb3AgZW50ZXIgb24gb3Vyc2VsZiAodW5sZXNzIHdlIHRlbXBvcmFyaWx5IHJlbW92ZWQpIHdoaWNoIGhhcHBlbnMgb24gYSBzaW1wbGUgZHJhZyBvZiBvdXIgaXRlbVxuICAgICAgICAgICAgaWYgKG5vZGU/LmdyaWQgPT09IHRoaXMgJiYgIW5vZGUuX3RlbXBvcmFyeVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgbm9kZS5fYWRkZWQ7IC8vIHJlc2V0IHRoaXMgdG8gdHJhY2sgcGxhY2Vob2xkZXIgYWdhaW4gaW4gY2FzZSB3ZSB3ZXJlIG92ZXIgb3RoZXIgZ3JpZCAjMTQ4NCAoZHJvcG91dCBkb2Vzbid0IGFsd2F5cyBjbGVhcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHByZXZlbnQgcGFyZW50IGZyb20gcmVjZWl2aW5nIG1zZyAod2hpY2ggbWF5IGJlIGEgZ3JpZCBhcyB3ZWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZml4ICMxNTc4IHdoZW4gZHJhZ2dpbmcgZmFzdCwgd2UgbWF5IG5vdCBnZXQgYSBsZWF2ZSBvbiB0aGUgcHJldmlvdXMgZ3JpZCBzbyBmb3JjZSBvbmUgbm93XG4gICAgICAgICAgICBpZiAobm9kZT8uZ3JpZCAmJiBub2RlLmdyaWQgIT09IHRoaXMgJiYgIW5vZGUuX3RlbXBvcmFyeVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZHJvcG92ZXIgd2l0aG91dCBsZWF2ZScpOyAvLyBURVNUXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyR3JpZCA9IG5vZGUuZ3JpZDtcbiAgICAgICAgICAgICAgICBvdGhlckdyaWQuX2xlYXZlKGVsLCBoZWxwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FjaGUgY2VsbCBkaW1lbnNpb25zICh3aGljaCBkb24ndCBjaGFuZ2UpLCBwb3NpdGlvbiBjYW4gYW5pbWF0ZSBpZiB3ZSByZW1vdmVkIGFuIGl0ZW0gaW4gb3RoZXJHcmlkIHRoYXQgYWZmZWN0cyB1cy4uLlxuICAgICAgICAgICAgY2VsbFdpZHRoID0gdGhpcy5jZWxsV2lkdGgoKTtcbiAgICAgICAgICAgIGNlbGxIZWlnaHQgPSB0aGlzLmdldENlbGxIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICAvLyBsb2FkIGFueSBlbGVtZW50IGF0dHJpYnV0ZXMgaWYgd2UgZG9uJ3QgaGF2ZSBhIG5vZGVcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9yZWFkQXR0cihlbCwgZmFsc2UpOyAvLyBkb24ndCB3aXBlIGV4dGVybmFsIChlLmcuIGRyYWcgdG9vbGJhcikgYXR0ciAjMjM1NFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLmdyaWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9pc0V4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZ3JpZCBzaXplIGJhc2VkIG9uIGVsZW1lbnQgb3V0ZXIgc2l6ZVxuICAgICAgICAgICAgaGVscGVyID0gaGVscGVyIHx8IGVsO1xuICAgICAgICAgICAgbGV0IHcgPSBub2RlLncgfHwgTWF0aC5yb3VuZChoZWxwZXIub2Zmc2V0V2lkdGggLyBjZWxsV2lkdGgpIHx8IDE7XG4gICAgICAgICAgICBsZXQgaCA9IG5vZGUuaCB8fCBNYXRoLnJvdW5kKGhlbHBlci5vZmZzZXRIZWlnaHQgLyBjZWxsSGVpZ2h0KSB8fCAxO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gY2FtZSBmcm9tIGFub3RoZXIgZ3JpZCwgbWFrZSBhIGNvcHkgYW5kIHNhdmUgdGhlIG9yaWdpbmFsIGluZm8gaW4gY2FzZSB3ZSBnbyBiYWNrIHRoZXJlXG4gICAgICAgICAgICBpZiAobm9kZS5ncmlkICYmIG5vZGUuZ3JpZCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIG5vZGUgb3JpZ2luYWwgdmFsdWVzIChtaW4vbWF4L2lkL2V0Yy4uLikgYnV0IG92ZXJyaWRlIHdpZHRoL2hlaWdodC9vdGhlciBmbGFncyB3aGljaCBhcmUgdGhpcyBncmlkIHNwZWNpZmljXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2Ryb3BvdmVyIGNsb25pbmcgbm9kZScpOyAvLyBURVNUXG4gICAgICAgICAgICAgICAgaWYgKCFlbC5fZ3JpZHN0YWNrTm9kZU9yaWcpXG4gICAgICAgICAgICAgICAgICAgIGVsLl9ncmlkc3RhY2tOb2RlT3JpZyA9IG5vZGU7IC8vIHNob3VsZG4ndCBoYXZlIG11bHRpcGxlIG5lc3RlZCFcbiAgICAgICAgICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gbm9kZSA9IHsgLi4ubm9kZSwgdywgaCwgZ3JpZDogdGhpcyB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLng7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUueTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5jbGVhbnVwTm9kZShub2RlKVxuICAgICAgICAgICAgICAgICAgICAubm9kZUJvdW5kRml4KG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgc29tZSBpbnRlcm5hbCBmaWVsZHMgd2UgbmVlZCBhZnRlciBjbGVhcmluZyB0aGVtIGFsbFxuICAgICAgICAgICAgICAgIG5vZGUuX2luaXRERCA9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2lzRXh0ZXJuYWwgPSAvLyBET00gbmVlZHMgdG8gYmUgcmUtcGFyZW50ZWQgb24gYSBkcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl90ZW1wb3JhcnlSZW1vdmVkID0gdHJ1ZTsgLy8gc28gaXQgY2FuIGJlIGluc2VydGVkIG9uRHJhZyBiZWxvd1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS53ID0gdztcbiAgICAgICAgICAgICAgICBub2RlLmggPSBoO1xuICAgICAgICAgICAgICAgIG5vZGUuX3RlbXBvcmFyeVJlbW92ZWQgPSB0cnVlOyAvLyBzbyB3ZSBjYW4gaW5zZXJ0IGl0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBhbnkgbWFya2VkIGZvciBjb21wbGV0ZSByZW1vdmFsIChOb3RlOiBkb24ndCBjaGVjayBfaXNBYm91dFRvUmVtb3ZlIGFzIHRoYXQgaXMgY2xlYXJlZCBhYm92ZSAtIGp1c3QgZG8gaXQpXG4gICAgICAgICAgICB0aGlzLl9pdGVtUmVtb3Zpbmcobm9kZS5lbCwgZmFsc2UpO1xuICAgICAgICAgICAgZGQub24oZWwsICdkcmFnJywgb25EcmFnKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGlzIGlzIGNhbGxlZCBhdCBsZWFzdCBvbmNlIHdoZW4gZ29pbmcgZmFzdCAjMTU3OFxuICAgICAgICAgICAgb25EcmFnKGV2ZW50LCBlbCwgaGVscGVyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBwYXJlbnQgZnJvbSByZWNlaXZpbmcgbXNnICh3aGljaCBtYXkgYmUgYSBncmlkIGFzIHdlbGwpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlYXZpbmcgb3VyIGdyaWQgYXJlYS4uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAub24odGhpcy5lbCwgJ2Ryb3BvdXQnLCAoZXZlbnQsIGVsLCBoZWxwZXIpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBvdXQgJHt0aGlzLmVsLmdyaWRzdGFjay5vcHRzLmlkfSAke2NvdW50Kyt9YCk7IC8vIFRFU1RcbiAgICAgICAgICAgIGxldCBub2RlID0gZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBmaXggIzE1Nzggd2hlbiBkcmFnZ2luZyBmYXN0LCB3ZSBtaWdodCBnZXQgbGVhdmUgYWZ0ZXIgb3RoZXIgZ3JpZCBnZXRzIGVudGVyICh3aGljaCBjYWxscyB1cyB0byBjbGVhbilcbiAgICAgICAgICAgIC8vIHNvIHNraXAgdGhpcyBvbmUgaWYgd2UncmUgbm90IHRoZSBhY3RpdmUgZ3JpZCByZWFsbHkuLlxuICAgICAgICAgICAgaWYgKCFub2RlLmdyaWQgfHwgbm9kZS5ncmlkID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVhdmUoZWwsIGhlbHBlcik7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugd2VyZSBjcmVhdGVkIGFzIHRlbXBvcmFyeSBuZXN0ZWQgZ3JpZCwgZ28gYmFjayB0byBiZWZvcmUgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXNTdWJHcmlkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBwYXJlbnQgZnJvbSByZWNlaXZpbmcgbXNnICh3aGljaCBtYXkgYmUgZ3JpZCBhcyB3ZWxsKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBlbmQgLSByZWxlYXNpbmcgdGhlIG1vdXNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC5vbih0aGlzLmVsLCAnZHJvcCcsIChldmVudCwgZWwsIGhlbHBlcikgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICAgICAgLy8gaWdub3JlIGRyb3Agb24gb3Vyc2VsZiBmcm9tIG91cnNlbGYgdGhhdCBkaWRuJ3QgY29tZSBmcm9tIHRoZSBvdXRzaWRlIC0gZHJhZ2VuZCB3aWxsIGhhbmRsZSB0aGUgc2ltcGxlIG1vdmUgaW5zdGVhZFxuICAgICAgICAgICAgaWYgKG5vZGU/LmdyaWQgPT09IHRoaXMgJiYgIW5vZGUuX2lzRXh0ZXJuYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHdhc0FkZGVkID0gISF0aGlzLnBsYWNlaG9sZGVyLnBhcmVudEVsZW1lbnQ7IC8vIHNraXAgaXRlbXMgbm90IGFjdHVhbGx5IGFkZGVkIHRvIHVzIGJlY2F1c2Ugb2YgY29uc3RyYWlucywgYnV0IGRvIGNsZWFudXAgIzE0MTlcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyBub3RpZnkgcHJldmlvdXMgZ3JpZCBvZiByZW1vdmFsXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZHJvcCBkZWxldGUgX2dyaWRzdGFja05vZGVPcmlnJykgLy8gVEVTVFxuICAgICAgICAgICAgbGV0IG9yaWdOb2RlID0gZWwuX2dyaWRzdGFja05vZGVPcmlnO1xuICAgICAgICAgICAgZGVsZXRlIGVsLl9ncmlkc3RhY2tOb2RlT3JpZztcbiAgICAgICAgICAgIGlmICh3YXNBZGRlZCAmJiBvcmlnTm9kZT8uZ3JpZCAmJiBvcmlnTm9kZS5ncmlkICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9HcmlkID0gb3JpZ05vZGUuZ3JpZDtcbiAgICAgICAgICAgICAgICBvR3JpZC5lbmdpbmUucmVtb3ZlTm9kZUZyb21MYXlvdXRDYWNoZShvcmlnTm9kZSk7XG4gICAgICAgICAgICAgICAgb0dyaWQuZW5naW5lLnJlbW92ZWROb2Rlcy5wdXNoKG9yaWdOb2RlKTtcbiAgICAgICAgICAgICAgICBvR3JpZC5fdHJpZ2dlclJlbW92ZUV2ZW50KCkuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYW4gZW1wdHkgc3ViLWdyaWQgdGhhdCBnb3QgYXV0by1jcmVhdGVkLCBudWtlIGl0XG4gICAgICAgICAgICAgICAgaWYgKG9HcmlkLnBhcmVudEdyaWRJdGVtICYmICFvR3JpZC5lbmdpbmUubm9kZXMubGVuZ3RoICYmIG9HcmlkLm9wdHMuc3ViR3JpZER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgb0dyaWQucmVtb3ZlQXNTdWJHcmlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIHVzZSBleGlzdGluZyBwbGFjZWhvbGRlciBub2RlIGFzIGl0J3MgYWxyZWFkeSBpbiBvdXIgbGlzdCB3aXRoIGRyb3AgbG9jYXRpb25cbiAgICAgICAgICAgIGlmICh3YXNBZGRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmNsZWFudXBOb2RlKG5vZGUpOyAvLyByZW1vdmVzIGFsbCBpbnRlcm5hbCBfeHl6IHZhbHVlc1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZC5vZmYoZWwsICdkcmFnJyk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBtYWRlIGEgY29weSAoJ2hlbHBlcicgd2hpY2ggaXMgdGVtcCkgb2YgdGhlIG9yaWdpbmFsIG5vZGUgdGhlbiBpbnNlcnQgYSBjb3B5LCBlbHNlIHdlIG1vdmUgdGhlIG9yaWdpbmFsIG5vZGUgKCMxMTAyKVxuICAgICAgICAgICAgLy8gYXMgdGhlIGhlbHBlciB3aWxsIGJlIG51a2VkIGJ5IGpxdWVyeS11aSBvdGhlcndpc2UuIFRPRE86IHVwZGF0ZSBvbGQgY29kZSBwYXRoXG4gICAgICAgICAgICBpZiAoaGVscGVyICE9PSBlbCkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gb3JpZ05vZGU7IC8vIG9yaWdpbmFsIGl0ZW0gKGxlZnQgYmVoaW5kKSBpcyByZS1zdG9yZWQgdG8gcHJlIGRyYWdnaW5nIGFzIHRoZSBub2RlIG5vdyBoYXMgZHJvcCBpbmZvXG4gICAgICAgICAgICAgICAgaWYgKHdhc0FkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpOyAvLyByZWR1Y2UgZmxpY2tlciBhcyB3ZSBjaGFuZ2UgZGVwdGggaGVyZSwgYW5kIHNpemUgZnVydGhlciBkb3duXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlREQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3YXNBZGRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbC5ncmlkc3RhY2tOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUuZWwgPSBlbDtcbiAgICAgICAgICAgIGxldCBzdWJHcmlkID0gbm9kZS5zdWJHcmlkPy5lbD8uZ3JpZHN0YWNrOyAvLyBzZXQgd2hlbiBhY3R1YWwgc3ViLWdyaWQgcHJlc2VudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgVXRpbHMuY29weVBvcyhub2RlLCB0aGlzLl9yZWFkQXR0cih0aGlzLnBsYWNlaG9sZGVyKSk7IC8vIHBsYWNlaG9sZGVyIHZhbHVlcyBhcyBtb3ZpbmcgVkVSWSBmYXN0IGNhbiB0aHJvdyB0aGluZ3Mgb2ZmICMxNTc4XG4gICAgICAgICAgICBVdGlscy5yZW1vdmVQb3NpdGlvbmluZ1N0eWxlcyhlbCk7IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlQXR0cihlbCwgbm9kZSk7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGdyaWREZWZhdWx0cy5pdGVtQ2xhc3MsIHRoaXMub3B0cy5pdGVtQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChlbCk7IC8vIEB0cy1pZ25vcmUgLy8gVE9ETzogbm93IHdvdWxkIGJlIGlkZWFsIHRpbWUgdG8gX3JlbW92ZUhlbHBlclN0eWxlKCkgb3ZlcnJpZGluZyBmbG9hdGluZyBzdHlsZXMgKG5hdGl2ZSBvbmx5KVxuICAgICAgICAgICAgaWYgKHN1YkdyaWQpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmlkLnBhcmVudEdyaWRJdGVtID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YkdyaWQub3B0cy5zdHlsZUluSGVhZClcbiAgICAgICAgICAgICAgICAgICAgc3ViR3JpZC5fdXBkYXRlU3R5bGVzKHRydWUpOyAvLyByZS1jcmVhdGUgc3ViLWdyaWQgc3R5bGVzIG5vdyB0aGF0IHdlJ3ZlIG1vdmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmFkZGVkTm9kZXMucHVzaChub2RlKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckFkZEV2ZW50KCk7IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZW5kVXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ3NFdmVudEhhbmRsZXJbJ2Ryb3BwZWQnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dzRXZlbnRIYW5kbGVyWydkcm9wcGVkJ10oeyAuLi5ldmVudCwgdHlwZTogJ2Ryb3BwZWQnIH0sIG9yaWdOb2RlICYmIG9yaWdOb2RlLmdyaWQgPyBvcmlnTm9kZSA6IHVuZGVmaW5lZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3YWl0IHRpbGwgd2UgcmV0dXJuIG91dCBvZiB0aGUgZHJhZyBjYWxsYmFjayB0byBzZXQgdGhlIG5ldyBkcmFnJnJlc2l6ZSBoYW5kbGVyIG9yIHRoZXkgbWF5IGdldCBtZXNzZWQgdXBcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJRkYgd2UgYXJlIHN0aWxsIHRoZXJlIChzb21lIGFwcGxpY2F0aW9uIHdpbGwgdXNlIGFzIHBsYWNlaG9sZGVyIGFuZCBpbnNlcnQgdGhlaXIgcmVhbCB3aWRnZXQgaW5zdGVhZCBhbmQgYmV0dGVyIGNhbGwgbWFrZVdpZGdldCgpKVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmVsICYmIG5vZGUuZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5ncmlkLl9pc1RlbXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBwYXJlbnQgZnJvbSByZWNlaXZpbmcgbXNnICh3aGljaCBtYXkgYmUgZ3JpZCBhcyB3ZWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgbWFyayBpdGVtIGZvciByZW1vdmFsICovXG4gICAgX2l0ZW1SZW1vdmluZyhlbCwgcmVtb3ZlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWwgPyBlbC5ncmlkc3RhY2tOb2RlIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIW5vZGUuZ3JpZCB8fCBlbC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRzLnJlbW92YWJsZU9wdGlvbnMuZGVjbGluZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlbW92ZSA/IG5vZGUuX2lzQWJvdXRUb1JlbW92ZSA9IHRydWUgOiBkZWxldGUgbm9kZS5faXNBYm91dFRvUmVtb3ZlO1xuICAgICAgICByZW1vdmUgPyBlbC5jbGFzc0xpc3QuYWRkKCdncmlkLXN0YWNrLWl0ZW0tcmVtb3ZpbmcnKSA6IGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2dyaWQtc3RhY2staXRlbS1yZW1vdmluZycpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB0byBzZXR1cCBhIHRyYXNoIGRyb3Agem9uZSBpZiB0aGUgdXNlciBzcGVjaWZpZXMgaXQgKi9cbiAgICBfc2V0dXBSZW1vdmVEcm9wKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5zdGF0aWNHcmlkICYmIHR5cGVvZiB0aGlzLm9wdHMucmVtb3ZhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGV0IHRyYXNoRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0cy5yZW1vdmFibGUpO1xuICAgICAgICAgICAgaWYgKCF0cmFzaEVsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgLy8gb25seSByZWdpc3RlciBPTkUgZHJvcC1vdmVyL2Ryb3BvdXQgY2FsbGJhY2sgZm9yIHRoZSAndHJhc2gnLCBhbmQgaXQgd2lsbFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXNzZWQgaW4gaXRlbSBhbmQgcGFyZW50IGdyaWQgYmVjYXVzZSB0aGUgJ3RyYXNoJyBpcyBhIHNoYXJlZCByZXNvdXJjZSBhbnl3YXksXG4gICAgICAgICAgICAvLyBhbmQgTmF0aXZlIEREIG9ubHkgaGFzIDEgZXZlbnQgQ0IgKGhhdmluZyBhIGxpc3QgYW5kIHRlY2huaWNhbGx5IGEgcGVyIGdyaWQgcmVtb3ZhYmxlT3B0aW9ucyBjb21wbGljYXRlcyB0aGluZ3MgZ3JlYXRseSlcbiAgICAgICAgICAgIGlmICghZGQuaXNEcm9wcGFibGUodHJhc2hFbCkpIHtcbiAgICAgICAgICAgICAgICBkZC5kcm9wcGFibGUodHJhc2hFbCwgdGhpcy5vcHRzLnJlbW92YWJsZU9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC5vbih0cmFzaEVsLCAnZHJvcG92ZXInLCAoZXZlbnQsIGVsKSA9PiB0aGlzLl9pdGVtUmVtb3ZpbmcoZWwsIHRydWUpKVxuICAgICAgICAgICAgICAgICAgICAub24odHJhc2hFbCwgJ2Ryb3BvdXQnLCAoZXZlbnQsIGVsKSA9PiB0aGlzLl9pdGVtUmVtb3ZpbmcoZWwsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgcHJlcGFyZXMgdGhlIGVsZW1lbnQgZm9yIGRyYWcmZHJvcCAqL1xuICAgIF9wcmVwYXJlRHJhZ0Ryb3BCeU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgZWwgPSBub2RlLmVsO1xuICAgICAgICBjb25zdCBub01vdmUgPSBub2RlLm5vTW92ZSB8fCB0aGlzLm9wdHMuZGlzYWJsZURyYWc7XG4gICAgICAgIGNvbnN0IG5vUmVzaXplID0gbm9kZS5ub1Jlc2l6ZSB8fCB0aGlzLm9wdHMuZGlzYWJsZVJlc2l6ZTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGRpc2FibGVkIGdyaWQgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zdGF0aWNHcmlkIHx8IChub01vdmUgJiYgbm9SZXNpemUpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5faW5pdEREKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlREQoZWwpOyAvLyBudWtlcyBldmVyeXRoaW5nIGluc3RlYWQgb2YganVzdCBkaXNhYmxlLCB3aWxsIGFkZCBzb21lIHN0eWxlcyBiYWNrIG5leHRcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5faW5pdEREO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndWktZHJhZ2dhYmxlLWRpc2FibGVkJywgJ3VpLXJlc2l6YWJsZS1kaXNhYmxlZCcpOyAvLyBhZGQgc3R5bGVzIG9uZSBtaWdodCBkZXBlbmQgb24gIzE0MzVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5faW5pdEREKSB7XG4gICAgICAgICAgICAvLyB2YXJpYWJsZXMgdXNlZC9jYXNoZWQgYmV0d2VlbiB0aGUgMyBzdGFydC9tb3ZlL2VuZCBtZXRob2RzLCBpbiBhZGRpdGlvbiB0byBub2RlIHBhc3NlZCBhYm92ZVxuICAgICAgICAgICAgbGV0IGNlbGxXaWR0aDtcbiAgICAgICAgICAgIGxldCBjZWxsSGVpZ2h0O1xuICAgICAgICAgICAgLyoqIGNhbGxlZCB3aGVuIGl0ZW0gc3RhcnRzIG1vdmluZy9yZXNpemluZyAqL1xuICAgICAgICAgICAgbGV0IG9uU3RhcnRNb3ZpbmcgPSAoZXZlbnQsIHVpKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhbnkgJ2RyYWdzdGFydCcgLyAncmVzaXplc3RhcnQnIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dzRXZlbnRIYW5kbGVyW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dzRXZlbnRIYW5kbGVyW2V2ZW50LnR5cGVdKGV2ZW50LCBldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggPSB0aGlzLmNlbGxXaWR0aCgpO1xuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgPSB0aGlzLmdldENlbGxIZWlnaHQodHJ1ZSk7IC8vIGZvcmNlIHBpeGVscyBmb3IgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydE1vdmluZyhlbCwgZXZlbnQsIHVpLCBub2RlLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBjYWxsZWQgd2hlbiBpdGVtIGlzIGJlaW5nIGRyYWdnZWQvcmVzaXplZCAqL1xuICAgICAgICAgICAgbGV0IGRyYWdPclJlc2l6ZSA9IChldmVudCwgdWkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnT3JSZXNpemUoZWwsIGV2ZW50LCB1aSwgbm9kZSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiogY2FsbGVkIHdoZW4gdGhlIGl0ZW0gc3RvcHMgbW92aW5nL3Jlc2l6aW5nICovXG4gICAgICAgICAgICBsZXQgb25FbmRNb3ZpbmcgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9tb3Zpbmc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX2V2ZW50O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9sYXN0VHJpZWQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIG1vdmVkIHRvIGFub3RoZXIgZ3JpZCwgd2UncmUgZG9uZSBoZXJlXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5ncmlkc3RhY2tOb2RlIHx8IHRhcmdldC5ncmlkc3RhY2tOb2RlLmdyaWQgIT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBub2RlLmVsID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlLl9pc0Fib3V0VG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyaWQgPSBlbC5ncmlkc3RhY2tOb2RlLmdyaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5fZ3NFdmVudEhhbmRsZXJbZXZlbnQudHlwZV0oZXZlbnQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5lbmdpbmUubm9kZXMucHVzaChub2RlKTsgLy8gdGVtcCBhZGQgaXQgYmFjayBzbyB3ZSBjYW4gcHJvcGVyIHJlbW92ZSBpdCBuZXh0XG4gICAgICAgICAgICAgICAgICAgIGdyaWQucmVtb3ZlV2lkZ2V0KGVsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLnJlbW92ZVBvc2l0aW9uaW5nU3R5bGVzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLl90ZW1wb3JhcnlSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnb3QgcmVtb3ZlZCAtIHJlc3RvcmUgaXRlbSBiYWNrIHRvIGJlZm9yZSBkcmFnZ2luZyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuY29weVBvcyhub2RlLCBub2RlLl9vcmlnKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVQb3NBdHRyKHRhcmdldCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5hZGROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0byBuZXcgcGxhY2Vob2xkZXIgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUG9zQXR0cih0YXJnZXQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3NFdmVudEhhbmRsZXJbZXZlbnQudHlwZV0oZXZlbnQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhRHJhZ1JvdyA9IDA7IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJIZWlnaHQoKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLmVuZFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncmVzaXplc3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobm9kZS5zaXplVG9Db250ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2l6ZVRvQ29udGVudCA9IG5vZGUuaDsgLy8gbmV3IHNvZnQgbGltaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0NvbnRlbnRSZXNpemUoZmFsc2UsIHRydWUsIG5vZGUpOyAvLyBubyBhbWluIHdhaXQgYXMgd2lsbCB1c2UgdGhlIGFjdHVhbCBzaXplZCBjb29yZGluYXRlIGF0dHJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGQuZHJhZ2dhYmxlKGVsLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG9uU3RhcnRNb3ZpbmcsXG4gICAgICAgICAgICAgICAgc3RvcDogb25FbmRNb3ZpbmcsXG4gICAgICAgICAgICAgICAgZHJhZzogZHJhZ09yUmVzaXplXG4gICAgICAgICAgICB9KS5yZXNpemFibGUoZWwsIHtcbiAgICAgICAgICAgICAgICBzdGFydDogb25TdGFydE1vdmluZyxcbiAgICAgICAgICAgICAgICBzdG9wOiBvbkVuZE1vdmluZyxcbiAgICAgICAgICAgICAgICByZXNpemU6IGRyYWdPclJlc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLl9pbml0REQgPSB0cnVlOyAvLyB3ZSd2ZSBzZXQgREQgc3VwcG9ydCBub3dcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbGx5IGZpbmUgdHVuZSBtb3ZlIHZzIHJlc2l6ZSBieSBkaXNhYmxpbmcgYW55IHBhcnQuLi5cbiAgICAgICAgZGQuZHJhZ2dhYmxlKGVsLCBub01vdmUgPyAnZGlzYWJsZScgOiAnZW5hYmxlJylcbiAgICAgICAgICAgIC5yZXNpemFibGUoZWwsIG5vUmVzaXplID8gJ2Rpc2FibGUnIDogJ2VuYWJsZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBoYW5kbGVzIGFjdHVhbCBkcmFnL3Jlc2l6ZSBzdGFydCAqL1xuICAgIF9vblN0YXJ0TW92aW5nKGVsLCBldmVudCwgdWksIG5vZGUsIGNlbGxXaWR0aCwgY2VsbEhlaWdodCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5jbGVhbk5vZGVzKClcbiAgICAgICAgICAgIC5iZWdpblVwZGF0ZShub2RlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLl93cml0ZVBvc0F0dHIodGhpcy5wbGFjZWhvbGRlciwgbm9kZSk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdfb25TdGFydE1vdmluZyBwbGFjZWhvbGRlcicpIC8vIFRFU1RcbiAgICAgICAgbm9kZS5lbCA9IHRoaXMucGxhY2Vob2xkZXI7XG4gICAgICAgIG5vZGUuX2xhc3RVaVBvc2l0aW9uID0gdWkucG9zaXRpb247XG4gICAgICAgIG5vZGUuX3ByZXZZUGl4ID0gdWkucG9zaXRpb24udG9wO1xuICAgICAgICBub2RlLl9tb3ZpbmcgPSAoZXZlbnQudHlwZSA9PT0gJ2RyYWdzdGFydCcpOyAvLyAnZHJvcG92ZXInIGFyZSBub3QgaW5pdGlhbGx5IG1vdmluZyBzbyB0aGV5IGNhbiBnbyBleGFjdGx5IHdoZXJlIHRoZXkgZW50ZXIgKHdpbGwgcHVzaCBzdHVmZiBvdXQgb2YgdGhlIHdheSlcbiAgICAgICAgZGVsZXRlIG5vZGUuX2xhc3RUcmllZDtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdkcm9wb3ZlcicgJiYgbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VuZ2luZS5hZGROb2RlIHg9JyArIG5vZGUueCk7IC8vIFRFU1RcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmFkZE5vZGUobm9kZSk7IC8vIHdpbGwgYWRkLCBmaXggY29sbGlzaW9ucywgdXBkYXRlIGF0dHIgYW5kIGNsZWFyIF90ZW1wb3JhcnlSZW1vdmVkXG4gICAgICAgICAgICBub2RlLl9tb3ZpbmcgPSB0cnVlOyAvLyBBRlRFUiwgbWFyayBhcyBtb3Zpbmcgb2JqZWN0ICh3YW50ZWQgZml4IGxvY2F0aW9uIGJlZm9yZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIG1pbi9tYXggcmVzaXplIGluZm9cbiAgICAgICAgdGhpcy5lbmdpbmUuY2FjaGVSZWN0cyhjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHRoaXMub3B0cy5tYXJnaW5Ub3AsIHRoaXMub3B0cy5tYXJnaW5SaWdodCwgdGhpcy5vcHRzLm1hcmdpbkJvdHRvbSwgdGhpcy5vcHRzLm1hcmdpbkxlZnQpO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZXN0YXJ0Jykge1xuICAgICAgICAgICAgZGQucmVzaXphYmxlKGVsLCAnb3B0aW9uJywgJ21pbldpZHRoJywgY2VsbFdpZHRoICogKG5vZGUubWluVyB8fCAxKSlcbiAgICAgICAgICAgICAgICAucmVzaXphYmxlKGVsLCAnb3B0aW9uJywgJ21pbkhlaWdodCcsIGNlbGxIZWlnaHQgKiAobm9kZS5taW5IIHx8IDEpKTtcbiAgICAgICAgICAgIGlmIChub2RlLm1heFcpIHtcbiAgICAgICAgICAgICAgICBkZC5yZXNpemFibGUoZWwsICdvcHRpb24nLCAnbWF4V2lkdGgnLCBjZWxsV2lkdGggKiBub2RlLm1heFcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubWF4SCkge1xuICAgICAgICAgICAgICAgIGRkLnJlc2l6YWJsZShlbCwgJ29wdGlvbicsICdtYXhIZWlnaHQnLCBjZWxsSGVpZ2h0ICogbm9kZS5tYXhIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsIGhhbmRsZXMgYWN0dWFsIGRyYWcvcmVzaXplICovXG4gICAgX2RyYWdPclJlc2l6ZShlbCwgZXZlbnQsIHVpLCBub2RlLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpIHtcbiAgICAgICAgbGV0IHAgPSB7IC4uLm5vZGUuX29yaWcgfTsgLy8gY291bGQgYmUgdW5kZWZpbmVkIChfaXNFeHRlcm5hbCkgd2hpY2ggaXMgb2sgKGRyYWcgb25seSBzZXQgeCx5IGFuZCB3LGggd2lsbCBkZWZhdWx0IHRvIG5vZGUgdmFsdWUpXG4gICAgICAgIGxldCByZXNpemluZztcbiAgICAgICAgbGV0IG1MZWZ0ID0gdGhpcy5vcHRzLm1hcmdpbkxlZnQsIG1SaWdodCA9IHRoaXMub3B0cy5tYXJnaW5SaWdodCwgbVRvcCA9IHRoaXMub3B0cy5tYXJnaW5Ub3AsIG1Cb3R0b20gPSB0aGlzLm9wdHMubWFyZ2luQm90dG9tO1xuICAgICAgICAvLyBpZiBtYXJnaW5zICh3aGljaCBhcmUgdXNlZCB0byBwYXNzIG1pZCBwb2ludCBieSkgYXJlIGxhcmdlIHJlbGF0aXZlIHRvIGNlbGwgaGVpZ2h0L3dpZHRoLCByZWR1Y2UgdGhlbSBkb3duICMxODU1XG4gICAgICAgIGxldCBtSGVpZ2h0ID0gTWF0aC5yb3VuZChjZWxsSGVpZ2h0ICogMC4xKSwgbVdpZHRoID0gTWF0aC5yb3VuZChjZWxsV2lkdGggKiAwLjEpO1xuICAgICAgICBtTGVmdCA9IE1hdGgubWluKG1MZWZ0LCBtV2lkdGgpO1xuICAgICAgICBtUmlnaHQgPSBNYXRoLm1pbihtUmlnaHQsIG1XaWR0aCk7XG4gICAgICAgIG1Ub3AgPSBNYXRoLm1pbihtVG9wLCBtSGVpZ2h0KTtcbiAgICAgICAgbUJvdHRvbSA9IE1hdGgubWluKG1Cb3R0b20sIG1IZWlnaHQpO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2RyYWcnKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGhhbmRsZWQgYnkgZHJvcG92ZXJcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IHVpLnBvc2l0aW9uLnRvcCAtIG5vZGUuX3ByZXZZUGl4O1xuICAgICAgICAgICAgbm9kZS5fcHJldllQaXggPSB1aS5wb3NpdGlvbi50b3A7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmRyYWdnYWJsZS5zY3JvbGwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMudXBkYXRlU2Nyb2xsUG9zaXRpb24oZWwsIHVpLnBvc2l0aW9uLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgbmV3IHBvc2l0aW9uIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG1hcmdpbiBpbiB0aGUgZGlyZWN0aW9uIHdlIGFyZSBtb3ZpbmchIChuZWVkIHRvIHBhc3MgbWlkIHBvaW50IGJ5IG1hcmdpbilcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdWkucG9zaXRpb24ubGVmdCArICh1aS5wb3NpdGlvbi5sZWZ0ID4gbm9kZS5fbGFzdFVpUG9zaXRpb24ubGVmdCA/IC1tUmlnaHQgOiBtTGVmdCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdWkucG9zaXRpb24udG9wICsgKHVpLnBvc2l0aW9uLnRvcCA+IG5vZGUuX2xhc3RVaVBvc2l0aW9uLnRvcCA/IC1tQm90dG9tIDogbVRvcCk7XG4gICAgICAgICAgICBwLnggPSBNYXRoLnJvdW5kKGxlZnQgLyBjZWxsV2lkdGgpO1xuICAgICAgICAgICAgcC55ID0gTWF0aC5yb3VuZCh0b3AgLyBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUvLyBpZiB3ZSdyZSBhdCB0aGUgYm90dG9tIGhpdHRpbmcgc29tZXRoaW5nIGVsc2UsIGdyb3cgdGhlIGdyaWQgc28gY3Vyc29yIGRvZXNuJ3QgbGVhdmUgd2hlbiB0cnlpbmcgdG8gcGxhY2UgYmVsb3cgb3RoZXJzXG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX2V4dHJhRHJhZ1JvdztcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5jb2xsaWRlKG5vZGUsIHApKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0Um93KCk7XG4gICAgICAgICAgICAgICAgbGV0IGV4dHJhID0gTWF0aC5tYXgoMCwgKHAueSArIG5vZGUuaCkgLSByb3cpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMubWF4Um93ICYmIHJvdyArIGV4dHJhID4gdGhpcy5vcHRzLm1heFJvdykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IE1hdGgubWF4KDAsIHRoaXMub3B0cy5tYXhSb3cgLSByb3cpO1xuICAgICAgICAgICAgICAgIH0gLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhRHJhZ1JvdyA9IGV4dHJhOyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0cmFEcmFnUm93ID0gMDsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2V4dHJhRHJhZ1JvdyAhPT0gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmIChub2RlLnggPT09IHAueCAmJiBub2RlLnkgPT09IHAueSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHNraXAgc2FtZVxuICAgICAgICAgICAgLy8gRE9OJ1Qgc2tpcCBvbmUgd2UgdHJpZWQgYXMgd2UgbWlnaHQgaGF2ZSBmYWlsZWQgYmVjYXVzZSBvZiBjb3ZlcmFnZSA8NTAlIGJlZm9yZVxuICAgICAgICAgICAgLy8gaWYgKG5vZGUuX2xhc3RUcmllZCAmJiBub2RlLl9sYXN0VHJpZWQueCA9PT0geCAmJiBub2RlLl9sYXN0VHJpZWQueSA9PT0geSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgICBpZiAocC54IDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBTY3JvbGxpbmcgcGFnZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIFV0aWxzLnVwZGF0ZVNjcm9sbFJlc2l6ZShldmVudCwgZWwsIGNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgLy8gZ2V0IG5ldyBzaXplXG4gICAgICAgICAgICBwLncgPSBNYXRoLnJvdW5kKCh1aS5zaXplLndpZHRoIC0gbUxlZnQpIC8gY2VsbFdpZHRoKTtcbiAgICAgICAgICAgIHAuaCA9IE1hdGgucm91bmQoKHVpLnNpemUuaGVpZ2h0IC0gbVRvcCkgLyBjZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChub2RlLncgPT09IHAudyAmJiBub2RlLmggPT09IHAuaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAobm9kZS5fbGFzdFRyaWVkICYmIG5vZGUuX2xhc3RUcmllZC53ID09PSBwLncgJiYgbm9kZS5fbGFzdFRyaWVkLmggPT09IHAuaClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHNraXAgb25lIHdlIHRyaWVkIChidXQgZmFpbGVkKVxuICAgICAgICAgICAgLy8gaWYgd2Ugc2l6ZSBvbiBsZWZ0L3RvcCBzaWRlIHRoaXMgbWlnaHQgbW92ZSB1cywgc28gZ2V0IHBvc3NpYmxlIG5ldyBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgICAgICAgICBsZXQgbGVmdCA9IHVpLnBvc2l0aW9uLmxlZnQgKyBtTGVmdDtcbiAgICAgICAgICAgIGxldCB0b3AgPSB1aS5wb3NpdGlvbi50b3AgKyBtVG9wO1xuICAgICAgICAgICAgcC54ID0gTWF0aC5yb3VuZChsZWZ0IC8gY2VsbFdpZHRoKTtcbiAgICAgICAgICAgIHAueSA9IE1hdGgucm91bmQodG9wIC8gY2VsbEhlaWdodCk7XG4gICAgICAgICAgICByZXNpemluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5fZXZlbnQgPSBldmVudDtcbiAgICAgICAgbm9kZS5fbGFzdFRyaWVkID0gcDsgLy8gc2V0IGFzIGxhc3QgdHJpZWQgKHdpbGwgbnVrZSBpZiB3ZSBnbyB0aGVyZSlcbiAgICAgICAgbGV0IHJlY3QgPSB7XG4gICAgICAgICAgICB4OiB1aS5wb3NpdGlvbi5sZWZ0ICsgbUxlZnQsXG4gICAgICAgICAgICB5OiB1aS5wb3NpdGlvbi50b3AgKyBtVG9wLFxuICAgICAgICAgICAgdzogKHVpLnNpemUgPyB1aS5zaXplLndpZHRoIDogbm9kZS53ICogY2VsbFdpZHRoKSAtIG1MZWZ0IC0gbVJpZ2h0LFxuICAgICAgICAgICAgaDogKHVpLnNpemUgPyB1aS5zaXplLmhlaWdodCA6IG5vZGUuaCAqIGNlbGxIZWlnaHQpIC0gbVRvcCAtIG1Cb3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLm1vdmVOb2RlQ2hlY2sobm9kZSwgeyAuLi5wLCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJlY3QsIHJlc2l6aW5nIH0pKSB7XG4gICAgICAgICAgICBub2RlLl9sYXN0VWlQb3NpdGlvbiA9IHVpLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2FjaGVSZWN0cyhjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIG1Ub3AsIG1SaWdodCwgbUJvdHRvbSwgbUxlZnQpO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuX3NraXBEb3duO1xuICAgICAgICAgICAgaWYgKHJlc2l6aW5nICYmIG5vZGUuc3ViR3JpZClcbiAgICAgICAgICAgICAgICBub2RlLnN1YkdyaWQub25SZXNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhRHJhZ1JvdyA9IDA7IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lckhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fd3JpdGVQb3NBdHRyKHRhcmdldCwgbm9kZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ3NFdmVudEhhbmRsZXJbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nc0V2ZW50SGFuZGxlcltldmVudC50eXBlXShldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsIGNhbGxlZCB3aGVuIGl0ZW0gbGVhdmluZyBvdXIgYXJlYSBieSBlaXRoZXIgY3Vyc29yIGRyb3BvdXQgZXZlbnRcbiAgICAgKiBvciBzaGFwZSBpcyBvdXRzaWRlIG91ciBib3VuZGFyaWVzLiByZW1vdmUgaXQgZnJvbSB1cywgYW5kIG1hcmsgdGVtcG9yYXJ5IGlmIHRoaXMgd2FzXG4gICAgICogb3VyIGl0ZW0gdG8gc3RhcnQgd2l0aCBlbHNlIHJlc3RvcmUgcHJldiBub2RlIHZhbHVlcyBmcm9tIHByZXYgZ3JpZCBpdCBjYW1lIGZyb20uXG4gICAgICovXG4gICAgX2xlYXZlKGVsLCBoZWxwZXIpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBlbC5ncmlkc3RhY2tOb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRkLm9mZihlbCwgJ2RyYWcnKTsgLy8gbm8gbmVlZCB0byB0cmFjayB3aGlsZSBiZWluZyBvdXRzaWRlXG4gICAgICAgIC8vIHRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBjdXJzb3IgbGVhdmVzIGFuZCBzaGFwZSBpcyBvdXRzaWRlLCBzbyBvbmx5IGRvIHRoaXMgb25jZVxuICAgICAgICBpZiAobm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZS5fdGVtcG9yYXJ5UmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlbW92ZU5vZGUobm9kZSk7IC8vIHJlbW92ZSBwbGFjZWhvbGRlciBhcyB3ZWxsLCBvdGhlcndpc2UgaXQncyBhIHNpZ24gbm9kZSBpcyBub3QgaW4gb3VyIGxpc3QsIHdoaWNoIGlzIGEgYmlnZ2VyIGlzc3VlXG4gICAgICAgIG5vZGUuZWwgPSBub2RlLl9pc0V4dGVybmFsICYmIGhlbHBlciA/IGhlbHBlciA6IGVsOyAvLyBwb2ludCBiYWNrIHRvIHJlYWwgaXRlbSBiZWluZyBkcmFnZ2VkXG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVtb3ZhYmxlID09PSB0cnVlKSB7IC8vIGJvb2xlYW4gdnMgYSBjbGFzcyBzdHJpbmdcbiAgICAgICAgICAgIC8vIGl0ZW0gbGVhdmluZyB1cyBhbmQgd2UgYXJlIHN1cHBvc2VkIHRvIHJlbW92ZSBvbiBsZWF2ZSAobm8gbmVlZCB0byBkcmFnIG9udG8gdHJhc2gpIG1hcmsgaXQgc29cbiAgICAgICAgICAgIHRoaXMuX2l0ZW1SZW1vdmluZyhlbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluYWxseSBpZiBpdGVtIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGFub3RoZXIgZ3JpZCwgYnV0IGxlZnQgdXMsIHJlc3RvcmUgdGhpbmdzIGJhY2sgdG8gcHJldiBpbmZvXG4gICAgICAgIGlmIChlbC5fZ3JpZHN0YWNrTm9kZU9yaWcpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZWF2ZSBkZWxldGUgX2dyaWRzdGFja05vZGVPcmlnJykgLy8gVEVTVFxuICAgICAgICAgICAgZWwuZ3JpZHN0YWNrTm9kZSA9IGVsLl9ncmlkc3RhY2tOb2RlT3JpZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5fZ3JpZHN0YWNrTm9kZU9yaWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5faXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgLy8gaXRlbSBjYW1lIGZyb20gb3V0c2lkZSAobGlrZSBhIHRvb2xiYXIpIHNvIG51a2UgYW55IG5vZGUgaW5mb1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuZWw7XG4gICAgICAgICAgICBkZWxldGUgZWwuZ3JpZHN0YWNrTm9kZTtcbiAgICAgICAgICAgIC8vIGFuZCByZXN0b3JlIGFsbCBub2RlcyBiYWNrIHRvIG9yaWdpbmFsXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5yZXN0b3JlSW5pdGlhbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGxlZ2FjeSBtZXRob2QgcmVtb3ZlZFxuICAgIGNvbW1pdCgpIHsgb2Jzb2xldGUodGhpcywgdGhpcy5iYXRjaFVwZGF0ZShmYWxzZSksICdjb21taXQnLCAnYmF0Y2hVcGRhdGUnLCAnNS4yJyk7IHJldHVybiB0aGlzOyB9XG59XG4vKiogcGFyZW50IGNsYXNzIGZvciBzaXppbmcgY29udGVudC4gZGVmYXVsdHMgdG8gJy5ncmlkLXN0YWNrLWl0ZW0tY29udGVudCcgKi9cbkdyaWRTdGFjay5yZXNpemVUb0NvbnRlbnRQYXJlbnQgPSAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50Jztcbi8qKiBzY29waW5nIHNvIHVzZXJzIGNhbiBjYWxsIEdyaWRTdGFjay5VdGlscy5zb3J0KCkgZm9yIGV4YW1wbGUgKi9cbkdyaWRTdGFjay5VdGlscyA9IFV0aWxzO1xuLyoqIHNjb3Bpbmcgc28gdXNlcnMgY2FuIGNhbGwgbmV3IEdyaWRTdGFjay5FbmdpbmUoMTIpIGZvciBleGFtcGxlICovXG5HcmlkU3RhY2suRW5naW5lID0gR3JpZFN0YWNrRW5naW5lO1xuR3JpZFN0YWNrLkdEUmV2ID0gJzkuNC4wJztcbmV4cG9ydCB7IEdyaWRTdGFjayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZHN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJHcmlkU3RhY2tFbmdpbmUiLCJVdGlscyIsIm9ic29sZXRlIiwiZ3JpZERlZmF1bHRzIiwiZHJhZ0luRGVmYXVsdE9wdGlvbnMiLCJEREdyaWRTdGFjayIsImlzVG91Y2giLCJERE1hbmFnZXIiLCJkZCIsIkdyaWRTdGFjayIsImluaXQiLCJvcHRpb25zIiwiZWxPclN0cmluZyIsImVsIiwiZ2V0R3JpZEVsZW1lbnQiLCJjb25zb2xlIiwiZXJyb3IiLCJncmlkc3RhY2siLCJjbG9uZURlZXAiLCJpbml0QWxsIiwic2VsZWN0b3IiLCJncmlkcyIsImdldEdyaWRFbGVtZW50cyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiYWRkR3JpZCIsInBhcmVudCIsIm9wdCIsImdyaWQiLCJvcHRzIiwiY2hpbGRyZW4iLCJ1bmRlZmluZWQiLCJsb2FkIiwicGFyZW50SXNHcmlkIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJhZGRSZW1vdmVDQiIsImRvYyIsImRvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJib2R5IiwiaW5uZXJIVE1MIiwiY2xhc3MiLCJhcHBlbmRDaGlsZCIsInJlZ2lzdGVyRW5naW5lIiwiZW5naW5lQ2xhc3MiLCJwbGFjZWhvbGRlciIsIl9wbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicGxhY2Vob2xkZXJUZXh0IiwiYWRkIiwicGxhY2Vob2xkZXJDbGFzcyIsIml0ZW1DbGFzcyIsImNvbnN0cnVjdG9yIiwiX2dzRXZlbnRIYW5kbGVyIiwiX2V4dHJhRHJhZ1JvdyIsInJvdyIsIm1pblJvdyIsIm1heFJvdyIsInJvd0F0dHIiLCJ0b051bWJlciIsImdldEF0dHJpYnV0ZSIsImNvbHVtbiIsImFsd2F5c1Nob3dSZXNpemVIYW5kbGUiLCJfYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSIsImRlZmF1bHRzIiwic3RhdGljR3JpZCIsInRvQm9vbCIsImRyYWdnYWJsZSIsImhhbmRsZSIsImhhbmRsZUNsYXNzIiwicmVtb3ZhYmxlT3B0aW9ucyIsImFjY2VwdCIsImRlY2xpbmUiLCJhbmltYXRlIiwiX2luaXRNYXJnaW4iLCJkaXNhYmxlT25lQ29sdW1uTW9kZSIsIl93aWR0aE9yQ29udGFpbmVyIiwib25lQ29sdW1uU2l6ZSIsIl9wcmV2Q29sdW1uIiwiZ2V0Q29sdW1uIiwicnRsIiwic3R5bGUiLCJkaXJlY3Rpb24iLCJncmFuZFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnRHcmlkSXRlbSIsImdyaWRzdGFja05vZGUiLCJzdWJHcmlkIiwiX2lzQXV0b0NlbGxIZWlnaHQiLCJjZWxsSGVpZ2h0IiwiY2VsbEhlaWdodFVuaXQiLCJfc3R5bGVTaGVldENsYXNzIiwiX2lkU2VxIiwiX3NldFN0YXRpY0NsYXNzIiwiZW5naW5lIiwiZmxvYXQiLCJvbkNoYW5nZSIsImNiTm9kZXMiLCJtYXhIIiwibm9kZXMiLCJuIiwiTWF0aCIsIm1heCIsInkiLCJoIiwiX3JlbW92ZURPTSIsInJlbW92ZSIsIl93cml0ZVBvc0F0dHIiLCJfdXBkYXRlU3R5bGVzIiwiYXV0byIsImJhdGNoVXBkYXRlIiwiZ2V0R3JpZEl0ZW1zIiwiX3ByZXBhcmVFbGVtZW50Iiwic2V0QW5pbWF0aW9uIiwic3ViR3JpZER5bmFtaWMiLCJwYXVzZURyYWciLCJwYXVzZSIsIl9zZXR1cFJlbW92ZURyb3AiLCJfc2V0dXBBY2NlcHRXaWRnZXQiLCJfdXBkYXRlUmVzaXplRXZlbnQiLCJhZGRXaWRnZXQiLCJlbHMiLCJpc0dyaWRTdGFja1dpZGdldCIsInciLCJ4IiwiY29udGVudCIsIm5vZGUiLCJhcmd1bWVudHMiLCJmaW5kIiwiX2lkIiwiZG9tQXR0ciIsIl9yZWFkQXR0ciIsInByZXBhcmVOb2RlIiwiX3dyaXRlQXR0ciIsIl9pbnNlcnROb3RBcHBlbmQiLCJwcmVwZW5kIiwibWFrZVdpZGdldCIsIm1ha2VTdWJHcmlkIiwib3BzIiwibm9kZVRvQWRkIiwic2F2ZUNvbnRlbnQiLCJzdWJHcmlkVGVtcGxhdGUiLCJzdWJHcmlkT3B0cyIsImF1dG9Db2x1bW4iLCJxdWVyeVNlbGVjdG9yIiwibmV3SXRlbSIsIm5ld0l0ZW1PcHQiLCJfcmVtb3ZlREQiLCJyZW1vdmVJbnRlcm5hbEZvclNhdmUiLCJfcHJlcGFyZURyYWdEcm9wQnlOb2RlIiwidHJhbnNpdGlvbiIsInVwZGF0ZSIsInNldFRpbWVvdXQiLCJfbW92aW5nIiwiX2lzVGVtcCIsIl9hdXRvQ29sdW1uIiwid2luZG93Iiwic2ltdWxhdGVNb3VzZUV2ZW50IiwiX2V2ZW50IiwicmVtb3ZlQXNTdWJHcmlkIiwibm9kZVRoYXRSZW1vdmVkIiwicEdyaWQiLCJyZW1vdmVXaWRnZXQiLCJzYXZlIiwic2F2ZUdyaWRPcHQiLCJzYXZlQ0IiLCJsaXN0Iiwic3ViIiwibGlzdE9yT3B0IiwibyIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luTGVmdCIsIm1hcmdpbiIsIm9yaWdTaG93IiwicmVtb3ZlSW50ZXJuYWxBbmRTYW1lIiwiaXRlbXMiLCJhZGRSZW1vdmUiLCJoYXZlQ29vcmQiLCJzb21lIiwic29ydCIsIl9pZ25vcmVMYXlvdXRzTm9kZUNoYW5nZSIsImNhY2hlTGF5b3V0IiwicHJldkNCIiwicmVtb3ZlZCIsImNvcHlOb2RlcyIsImlkIiwiaXRlbSIsInVwZGF0ZU5vZGVzIiwiZmlsdGVyIiwid2lkdGhDaGFuZ2VkIiwic2hvdWxkU2l6ZVRvQ29udGVudCIsImF1dG9Qb3NpdGlvbiIsImZpbmRFbXB0eVBvc2l0aW9uIiwic2FtZVBvcyIsIm1vdmVOb2RlIiwiZm9yY2VDb2xsaWRlIiwiY29weVBvcyIsInJlbW92ZWROb2RlcyIsImRvQ29udGVudFJlc2l6ZSIsImZsYWciLCJfdXBkYXRlQ29udGFpbmVySGVpZ2h0IiwiX3RyaWdnZXJSZW1vdmVFdmVudCIsIl90cmlnZ2VyQWRkRXZlbnQiLCJfdHJpZ2dlckNoYW5nZUV2ZW50IiwiZ2V0Q2VsbEhlaWdodCIsImZvcmNlUGl4ZWwiLCJoZWlnaHQiLCJyb3VuZCIsIm9mZnNldEhlaWdodCIsInJvd3MiLCJwYXJzZUludCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInZhbCIsIm1hcmdpbkRpZmYiLCJjZWxsV2lkdGgiLCJkYXRhIiwicGFyc2VIZWlnaHQiLCJ1bml0IiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiY29tcGFjdCIsImxheW91dCIsImRvU29ydCIsIm9sZENvbHVtbiIsImRvbU5vZGVzIiwib25lQ29sdW1uTW9kZURvbVNvcnQiLCJjb2x1bW5DaGFuZ2VkIiwiQXJyYXkiLCJmcm9tIiwibWF0Y2hlcyIsImRlc3Ryb3kiLCJyZW1vdmVET00iLCJvZmZBbGwiLCJzZXRTdGF0aWMiLCJyZW1vdmVBbGwiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJfcmVtb3ZlU3R5bGVzaGVldCIsImdldEZsb2F0IiwiZ2V0Q2VsbEZyb21QaXhlbCIsInBvc2l0aW9uIiwidXNlRG9jUmVsYXRpdmUiLCJib3giLCJjb250YWluZXJQb3MiLCJ0b3AiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJsZWZ0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInJlbGF0aXZlTGVmdCIsInJlbGF0aXZlVG9wIiwiY29sdW1uV2lkdGgiLCJ3aWR0aCIsInJvd0hlaWdodCIsImZsb29yIiwiZ2V0Um93IiwiaXNBcmVhRW1wdHkiLCJnZXRFbGVtZW50Iiwib24iLCJuYW1lIiwiY2FsbGJhY2siLCJpbmRleE9mIiwibmFtZXMiLCJzcGxpdCIsIm5vRGF0YSIsImV2ZW50IiwiZGV0YWlsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxvZyIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwidHJpZ2dlckV2ZW50IiwiZ2V0RWxlbWVudHMiLCJyZW1vdmVOb2RlIiwiZG9BbmltYXRlIiwidXBkYXRlQ2xhc3MiLCJyZWN1cnNlIiwid2FybiIsImEiLCJpIiwibSIsImsiLCJtaW5XIiwibWluSCIsIm1heFciLCJpdGVtQ29udGVudCIsInN0eWxlSW5IZWFkIiwiY2hhbmdlZCIsImRkQ2hhbmdlZCIsInNhbml0aXplTWluTWF4IiwiY2xlYW5Ob2RlcyIsImJlZ2luVXBkYXRlIiwiZW5kVXBkYXRlIiwicmVzaXplVG9Db250ZW50IiwidXNlQXR0clNpemUiLCJjbGllbnRIZWlnaHQiLCJjZWxsIiwicmVzaXplVG9Db250ZW50UGFyZW50IiwicGFkZGluZyIsIml0ZW1IIiwid2FudGVkSCIsImNoaWxkIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJjZWlsIiwic29mdE1heCIsIk51bWJlciIsImlzSW50ZWdlciIsInNpemVUb0NvbnRlbnQiLCJyZXNpemVUb0NvbnRlbnRDaGVjayIsInVzZUF0dHIiLCJyZXNpemVUb0NvbnRlbnRDQiIsInZhbHVlIiwiaXNNdWx0aVZhbHVlIiwibWFyZ2luVW5pdCIsImdldE1hcmdpbiIsIndpbGxJdEZpdCIsImJhdGNoTW9kZSIsImVsZW1lbnRzIiwiZ2V0RGlydHlOb2RlcyIsImxheW91dHNOb2Rlc0NoYW5nZSIsIl90cmlnZ2VyRXZlbnQiLCJzYXZlSW5pdGlhbCIsImFkZGVkTm9kZXMiLCJfZGlydHkiLCJ0eXBlIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiX3N0eWxlcyIsInJlbW92ZVN0eWxlc2hlZXQiLCJmb3JjZVVwZGF0ZSIsInByZWZpeCIsInN0eWxlTG9jYXRpb24iLCJjcmVhdGVTdHlsZXNoZWV0Iiwibm9uY2UiLCJfbWF4IiwiYWRkQ1NTUnVsZSIsImJvdHRvbSIsInJpZ2h0IiwiZ2V0SGVpZ2h0IiwiY3NzTWluSGVpZ2h0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInNldEF0dHJpYnV0ZSIsIlN0cmluZyIsInJlbW92ZVByb3BlcnR5IiwidHJpZ2dlckFkZEV2ZW50IiwiY29weSIsImFkZE5vZGUiLCJzYW1lIiwiYXR0cnMiLCJub1Jlc2l6ZSIsIm5vTW92ZSIsImxvY2tlZCIsImNsZWFyRGVmYXVsdEF0dHIiLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzZXMiLCJvblJlc2l6ZSIsInByZXZXaWR0aCIsIm9uZUNvbHVtbiIsIl9za2lwSW5pdGlhbFJlc2l6ZSIsImRlbGF5IiwiZm9yY2VSZW1vdmUiLCJ0cmFja1NpemUiLCJyZXNpemVPYnNlcnZlciIsIl9zaXplVGhyb3R0bGUiLCJ0aHJvdHRsZSIsImNlbGxIZWlnaHRUaHJvdHRsZSIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJtYXJnaW5zIiwiZ2V0REQiLCJzZXR1cERyYWdJbiIsImRyYWdJbiIsImRyYWdJbk9wdGlvbnMiLCJyb290IiwiaXNEcmFnZ2FibGUiLCJtb3ZhYmxlIiwicmVzaXphYmxlIiwiZGlzYWJsZSIsImVuYWJsZU1vdmUiLCJlbmFibGVSZXNpemUiLCJlbmFibGUiLCJkb0VuYWJsZSIsImRpc2FibGVEcmFnIiwiZGlzYWJsZVJlc2l6ZSIsIl9pbml0REQiLCJkZEVsZW1lbnQiLCJhY2NlcHRXaWRnZXRzIiwicmVtb3ZhYmxlIiwiZHJvcHBhYmxlIiwib25EcmFnIiwiaGVscGVyIiwidWkiLCJfdGVtcG9yYXJ5UmVtb3ZlZCIsIm5vZGVCb3VuZEZpeCIsIl93aWxsRml0UG9zIiwiX29uU3RhcnRNb3ZpbmciLCJfZHJhZ09yUmVzaXplIiwiY2FuQWNjZXB0Iiwib3RoZXJHcmlkIiwiX2xlYXZlIiwiX2lzRXh0ZXJuYWwiLCJvZmZzZXRXaWR0aCIsIl9ncmlkc3RhY2tOb2RlT3JpZyIsImNsZWFudXBOb2RlIiwiX2l0ZW1SZW1vdmluZyIsIndhc0FkZGVkIiwib3JpZ05vZGUiLCJvR3JpZCIsInJlbW92ZU5vZGVGcm9tTGF5b3V0Q2FjaGUiLCJjbG9uZU5vZGUiLCJyZW1vdmVQb3NpdGlvbmluZ1N0eWxlcyIsIl9pc0Fib3V0VG9SZW1vdmUiLCJ0cmFzaEVsIiwiaXNEcm9wcGFibGUiLCJvblN0YXJ0TW92aW5nIiwidGFyZ2V0IiwiZHJhZ09yUmVzaXplIiwib25FbmRNb3ZpbmciLCJfbGFzdFRyaWVkIiwiX29yaWciLCJzdGFydCIsInN0b3AiLCJkcmFnIiwicmVzaXplIiwiX2xhc3RVaVBvc2l0aW9uIiwiX3ByZXZZUGl4IiwiY2FjaGVSZWN0cyIsInAiLCJyZXNpemluZyIsIm1MZWZ0IiwibVJpZ2h0IiwibVRvcCIsIm1Cb3R0b20iLCJtSGVpZ2h0IiwibVdpZHRoIiwibWluIiwiZGlzdGFuY2UiLCJzY3JvbGwiLCJ1cGRhdGVTY3JvbGxQb3NpdGlvbiIsInByZXYiLCJjb2xsaWRlIiwiZXh0cmEiLCJ1cGRhdGVTY3JvbGxSZXNpemUiLCJzaXplIiwicmVjdCIsIm1vdmVOb2RlQ2hlY2siLCJfc2tpcERvd24iLCJyZXN0b3JlSW5pdGlhbCIsImNvbW1pdCIsIkVuZ2luZSIsIkdEUmV2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/gridstack.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/types.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/types.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dragInDefaultOptions: () => (/* binding */ dragInDefaultOptions),\n/* harmony export */   gridDefaults: () => (/* binding */ gridDefaults)\n/* harmony export */ });\n/**\n * types.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ // default values for grid options - used during init and when saving out\nconst gridDefaults = {\n    alwaysShowResizeHandle: \"mobile\",\n    animate: true,\n    auto: true,\n    cellHeight: \"auto\",\n    cellHeightThrottle: 100,\n    cellHeightUnit: \"px\",\n    column: 12,\n    draggable: {\n        handle: \".grid-stack-item-content\",\n        appendTo: \"body\",\n        scroll: true\n    },\n    handle: \".grid-stack-item-content\",\n    itemClass: \"grid-stack-item\",\n    margin: 10,\n    marginUnit: \"px\",\n    maxRow: 0,\n    minRow: 0,\n    oneColumnSize: 768,\n    placeholderClass: \"grid-stack-placeholder\",\n    placeholderText: \"\",\n    removableOptions: {\n        accept: \"grid-stack-item\",\n        decline: \"grid-stack-non-removable\"\n    },\n    resizable: {\n        handles: \"se\"\n    },\n    rtl: \"auto\"\n};\n/** default dragIn options */ const dragInDefaultOptions = {\n    handle: \".grid-stack-item-content\",\n    appendTo: \"body\"\n}; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JpZHN0YWNrL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FDRCx5RUFBeUU7QUFDbEUsTUFBTUEsZUFBZTtJQUN4QkMsd0JBQXdCO0lBQ3hCQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsWUFBWTtJQUNaQyxvQkFBb0I7SUFDcEJDLGdCQUFnQjtJQUNoQkMsUUFBUTtJQUNSQyxXQUFXO1FBQUVDLFFBQVE7UUFBNEJDLFVBQVU7UUFBUUMsUUFBUTtJQUFLO0lBQ2hGRixRQUFRO0lBQ1JHLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7UUFBRUMsUUFBUTtRQUFtQkMsU0FBUztJQUEyQjtJQUNuRkMsV0FBVztRQUFFQyxTQUFTO0lBQUs7SUFDM0JDLEtBQUs7QUFZVCxFQUFFO0FBQ0YsMkJBQTJCLEdBQ3BCLE1BQU1DLHVCQUF1QjtJQUNoQ2pCLFFBQVE7SUFDUkMsVUFBVTtBQUdkLEVBQUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sdWNpZGl0eS1kM2pzLy4vbm9kZV9tb2R1bGVzL2dyaWRzdGFjay9kaXN0L3R5cGVzLmpzP2ZjZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0eXBlcy50cyA5LjQuMFxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFsYWluIER1bWVzbnkgLSBzZWUgR3JpZFN0YWNrIHJvb3QgbGljZW5zZVxuICovXG4vLyBkZWZhdWx0IHZhbHVlcyBmb3IgZ3JpZCBvcHRpb25zIC0gdXNlZCBkdXJpbmcgaW5pdCBhbmQgd2hlbiBzYXZpbmcgb3V0XG5leHBvcnQgY29uc3QgZ3JpZERlZmF1bHRzID0ge1xuICAgIGFsd2F5c1Nob3dSZXNpemVIYW5kbGU6ICdtb2JpbGUnLFxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgYXV0bzogdHJ1ZSxcbiAgICBjZWxsSGVpZ2h0OiAnYXV0bycsXG4gICAgY2VsbEhlaWdodFRocm90dGxlOiAxMDAsXG4gICAgY2VsbEhlaWdodFVuaXQ6ICdweCcsXG4gICAgY29sdW1uOiAxMixcbiAgICBkcmFnZ2FibGU6IHsgaGFuZGxlOiAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JywgYXBwZW5kVG86ICdib2R5Jywgc2Nyb2xsOiB0cnVlIH0sXG4gICAgaGFuZGxlOiAnLmdyaWQtc3RhY2staXRlbS1jb250ZW50JyxcbiAgICBpdGVtQ2xhc3M6ICdncmlkLXN0YWNrLWl0ZW0nLFxuICAgIG1hcmdpbjogMTAsXG4gICAgbWFyZ2luVW5pdDogJ3B4JyxcbiAgICBtYXhSb3c6IDAsXG4gICAgbWluUm93OiAwLFxuICAgIG9uZUNvbHVtblNpemU6IDc2OCxcbiAgICBwbGFjZWhvbGRlckNsYXNzOiAnZ3JpZC1zdGFjay1wbGFjZWhvbGRlcicsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiAnJyxcbiAgICByZW1vdmFibGVPcHRpb25zOiB7IGFjY2VwdDogJ2dyaWQtc3RhY2staXRlbScsIGRlY2xpbmU6ICdncmlkLXN0YWNrLW5vbi1yZW1vdmFibGUnIH0sXG4gICAgcmVzaXphYmxlOiB7IGhhbmRsZXM6ICdzZScgfSxcbiAgICBydGw6ICdhdXRvJyxcbiAgICAvLyAqKioqIHNhbWUgYXMgbm90IGJlaW5nIHNldCAqKioqXG4gICAgLy8gZGlzYWJsZURyYWc6IGZhbHNlLFxuICAgIC8vIGRpc2FibGVPbmVDb2x1bW5Nb2RlOiBmYWxzZSxcbiAgICAvLyBkaXNhYmxlUmVzaXplOiBmYWxzZSxcbiAgICAvLyBmbG9hdDogZmFsc2UsXG4gICAgLy8gaGFuZGxlQ2xhc3M6IG51bGwsXG4gICAgLy8gb25lQ29sdW1uTW9kZURvbVNvcnQ6IGZhbHNlLFxuICAgIC8vIHJlbW92YWJsZTogZmFsc2UsXG4gICAgLy8gc3RhdGljR3JpZDogZmFsc2UsXG4gICAgLy8gc3R5bGVJbkhlYWQ6IGZhbHNlLFxuICAgIC8vcmVtb3ZhYmxlXG59O1xuLyoqIGRlZmF1bHQgZHJhZ0luIG9wdGlvbnMgKi9cbmV4cG9ydCBjb25zdCBkcmFnSW5EZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBoYW5kbGU6ICcuZ3JpZC1zdGFjay1pdGVtLWNvbnRlbnQnLFxuICAgIGFwcGVuZFRvOiAnYm9keScsXG4gICAgLy8gcmV2ZXJ0OiAnaW52YWxpZCcsXG4gICAgLy8gc2Nyb2xsOiBmYWxzZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiZ3JpZERlZmF1bHRzIiwiYWx3YXlzU2hvd1Jlc2l6ZUhhbmRsZSIsImFuaW1hdGUiLCJhdXRvIiwiY2VsbEhlaWdodCIsImNlbGxIZWlnaHRUaHJvdHRsZSIsImNlbGxIZWlnaHRVbml0IiwiY29sdW1uIiwiZHJhZ2dhYmxlIiwiaGFuZGxlIiwiYXBwZW5kVG8iLCJzY3JvbGwiLCJpdGVtQ2xhc3MiLCJtYXJnaW4iLCJtYXJnaW5Vbml0IiwibWF4Um93IiwibWluUm93Iiwib25lQ29sdW1uU2l6ZSIsInBsYWNlaG9sZGVyQ2xhc3MiLCJwbGFjZWhvbGRlclRleHQiLCJyZW1vdmFibGVPcHRpb25zIiwiYWNjZXB0IiwiZGVjbGluZSIsInJlc2l6YWJsZSIsImhhbmRsZXMiLCJydGwiLCJkcmFnSW5EZWZhdWx0T3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/types.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils),\n/* harmony export */   obsolete: () => (/* binding */ obsolete),\n/* harmony export */   obsoleteAttr: () => (/* binding */ obsoleteAttr),\n/* harmony export */   obsoleteOpts: () => (/* binding */ obsoleteOpts),\n/* harmony export */   obsoleteOptsDel: () => (/* binding */ obsoleteOptsDel)\n/* harmony export */ });\n/**\n * utils.ts 9.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */ /** checks for obsolete method names */ // eslint-disable-next-line\nfunction obsolete(self, f, oldName, newName, rev) {\n    let wrapper = (...args)=>{\n        console.warn(\"gridstack.js: Function `\" + oldName + \"` is deprecated in \" + rev + \" and has been replaced \" + \"with `\" + newName + \"`. It will be **removed** in a future release\");\n        return f.apply(self, args);\n    };\n    wrapper.prototype = f.prototype;\n    return wrapper;\n}\n/** checks for obsolete grid options (can be used for any fields, but msg is about options) */ function obsoleteOpts(opts, oldName, newName, rev) {\n    if (opts[oldName] !== undefined) {\n        opts[newName] = opts[oldName];\n        console.warn(\"gridstack.js: Option `\" + oldName + \"` is deprecated in \" + rev + \" and has been replaced with `\" + newName + \"`. It will be **removed** in a future release\");\n    }\n}\n/** checks for obsolete grid options which are gone */ function obsoleteOptsDel(opts, oldName, rev, info) {\n    if (opts[oldName] !== undefined) {\n        console.warn(\"gridstack.js: Option `\" + oldName + \"` is deprecated in \" + rev + info);\n    }\n}\n/** checks for obsolete Jquery element attributes */ function obsoleteAttr(el, oldName, newName, rev) {\n    let oldAttr = el.getAttribute(oldName);\n    if (oldAttr !== null) {\n        el.setAttribute(newName, oldAttr);\n        console.warn(\"gridstack.js: attribute `\" + oldName + \"`=\" + oldAttr + \" is deprecated on this object in \" + rev + \" and has been replaced with `\" + newName + \"`. It will be **removed** in a future release\");\n    }\n}\n/**\n * Utility methods\n */ class Utils {\n    /** convert a potential selector into actual list of html elements. optional root which defaults to document (for shadow dom) */ static getElements(els, root = document) {\n        if (typeof els === \"string\") {\n            const doc = \"getElementById\" in root ? root : undefined;\n            // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors\n            // so if we start with a number, assume it's an id and just return that one item...\n            // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562\n            if (doc && !isNaN(+els[0])) {\n                const el = doc.getElementById(els);\n                return el ? [\n                    el\n                ] : [];\n            }\n            let list = root.querySelectorAll(els);\n            if (!list.length && els[0] !== \".\" && els[0] !== \"#\") {\n                list = root.querySelectorAll(\".\" + els);\n                if (!list.length) {\n                    list = root.querySelectorAll(\"#\" + els);\n                }\n            }\n            return Array.from(list);\n        }\n        return [\n            els\n        ];\n    }\n    /** convert a potential selector into actual single element. optional root which defaults to document (for shadow dom) */ static getElement(els, root = document) {\n        if (typeof els === \"string\") {\n            const doc = \"getElementById\" in root ? root : undefined;\n            if (!els.length) return null;\n            if (doc && els[0] === \"#\") {\n                return doc.getElementById(els.substring(1));\n            }\n            if (els[0] === \"#\" || els[0] === \".\" || els[0] === \"[\") {\n                return root.querySelector(els);\n            }\n            // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS\n            if (doc && !isNaN(+els[0])) {\n                return doc.getElementById(els);\n            }\n            // finally try string, then id, then class\n            let el = root.querySelector(els);\n            if (doc && !el) {\n                el = doc.getElementById(els);\n            }\n            if (!el) {\n                el = root.querySelector(\".\" + els);\n            }\n            return el;\n        }\n        return els;\n    }\n    /** true if we should resize to content */ static shouldSizeToContent(n) {\n        return n?.grid && (!!n.sizeToContent || n.grid.opts.sizeToContent && n.sizeToContent !== false);\n    }\n    /** returns true if a and b overlap */ static isIntercepted(a, b) {\n        return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);\n    }\n    /** returns true if a and b touch edges or corners */ static isTouching(a, b) {\n        return Utils.isIntercepted(a, {\n            x: b.x - 0.5,\n            y: b.y - 0.5,\n            w: b.w + 1,\n            h: b.h + 1\n        });\n    }\n    /** returns the area a and b overlap */ static areaIntercept(a, b) {\n        let x0 = a.x > b.x ? a.x : b.x;\n        let x1 = a.x + a.w < b.x + b.w ? a.x + a.w : b.x + b.w;\n        if (x1 <= x0) return 0; // no overlap\n        let y0 = a.y > b.y ? a.y : b.y;\n        let y1 = a.y + a.h < b.y + b.h ? a.y + a.h : b.y + b.h;\n        if (y1 <= y0) return 0; // no overlap\n        return (x1 - x0) * (y1 - y0);\n    }\n    /** returns the area */ static area(a) {\n        return a.w * a.h;\n    }\n    /**\n     * Sorts array of nodes\n     * @param nodes array to sort\n     * @param dir 1 for asc, -1 for desc (optional)\n     * @param width width of the grid. If undefined the width will be calculated automatically (optional).\n     **/ static sort(nodes, dir = 1, column) {\n        column = column || nodes.reduce((col, n)=>Math.max(n.x + n.w, col), 0) || 12;\n        if (dir === -1) return nodes.sort((a, b)=>(b.x ?? 1000) + (b.y ?? 1000) * column - ((a.x ?? 1000) + (a.y ?? 1000) * column));\n        else return nodes.sort((b, a)=>(b.x ?? 1000) + (b.y ?? 1000) * column - ((a.x ?? 1000) + (a.y ?? 1000) * column));\n    }\n    /** find an item by id */ static find(nodes, id) {\n        return id ? nodes.find((n)=>n.id === id) : undefined;\n    }\n    /**\n     * creates a style sheet with style id under given parent\n     * @param id will set the 'gs-style-id' attribute to that id\n     * @param parent to insert the stylesheet as first child,\n     * if none supplied it will be appended to the document head instead.\n     */ static createStylesheet(id, parent, options) {\n        let style = document.createElement(\"style\");\n        const nonce = options?.nonce;\n        if (nonce) style.nonce = nonce;\n        style.setAttribute(\"type\", \"text/css\");\n        style.setAttribute(\"gs-style-id\", id);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (style.styleSheet) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            style.styleSheet.cssText = \"\";\n        } else {\n            style.appendChild(document.createTextNode(\"\")); // WebKit hack\n        }\n        if (!parent) {\n            // default to head\n            parent = document.getElementsByTagName(\"head\")[0];\n            parent.appendChild(style);\n        } else {\n            parent.insertBefore(style, parent.firstChild);\n        }\n        return style.sheet;\n    }\n    /** removed the given stylesheet id */ static removeStylesheet(id) {\n        let el = document.querySelector(\"STYLE[gs-style-id=\" + id + \"]\");\n        if (el && el.parentNode) el.remove();\n    }\n    /** inserts a CSS rule */ static addCSSRule(sheet, selector, rules) {\n        if (typeof sheet.addRule === \"function\") {\n            sheet.addRule(selector, rules);\n        } else if (typeof sheet.insertRule === \"function\") {\n            sheet.insertRule(`${selector}{${rules}}`);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static toBool(v) {\n        if (typeof v === \"boolean\") {\n            return v;\n        }\n        if (typeof v === \"string\") {\n            v = v.toLowerCase();\n            return !(v === \"\" || v === \"no\" || v === \"false\" || v === \"0\");\n        }\n        return Boolean(v);\n    }\n    static toNumber(value) {\n        return value === null || value.length === 0 ? undefined : Number(value);\n    }\n    static parseHeight(val) {\n        let h;\n        let unit = \"px\";\n        if (typeof val === \"string\") {\n            if (val === \"auto\") h = 0;\n            else {\n                let match = val.match(/^(-[0-9]+\\.[0-9]+|[0-9]*\\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);\n                if (!match) {\n                    throw new Error(\"Invalid height\");\n                }\n                unit = match[2] || \"px\";\n                h = parseFloat(match[1]);\n            }\n        } else {\n            h = val;\n        }\n        return {\n            h,\n            unit\n        };\n    }\n    /** copies unset fields in target to use the given default sources values */ // eslint-disable-next-line\n    static defaults(target, ...sources) {\n        sources.forEach((source)=>{\n            for(const key in source){\n                if (!source.hasOwnProperty(key)) return;\n                if (target[key] === null || target[key] === undefined) {\n                    target[key] = source[key];\n                } else if (typeof source[key] === \"object\" && typeof target[key] === \"object\") {\n                    // property is an object, recursively add it's field over... #1373\n                    this.defaults(target[key], source[key]);\n                }\n            }\n        });\n        return target;\n    }\n    /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */ static same(a, b) {\n        if (typeof a !== \"object\") return a == b;\n        if (typeof a !== typeof b) return false;\n        // else we have object, check just 1 level deep for being same things...\n        if (Object.keys(a).length !== Object.keys(b).length) return false;\n        for(const key in a){\n            if (a[key] !== b[key]) return false;\n        }\n        return true;\n    }\n    /** copies over b size & position (GridStackPosition), and optionally min/max as well */ static copyPos(a, b, doMinMax = false) {\n        if (b.x !== undefined) a.x = b.x;\n        if (b.y !== undefined) a.y = b.y;\n        if (b.w !== undefined) a.w = b.w;\n        if (b.h !== undefined) a.h = b.h;\n        if (doMinMax) {\n            if (b.minW) a.minW = b.minW;\n            if (b.minH) a.minH = b.minH;\n            if (b.maxW) a.maxW = b.maxW;\n            if (b.maxH) a.maxH = b.maxH;\n        }\n        return a;\n    }\n    /** true if a and b has same size & position */ static samePos(a, b) {\n        return a && b && a.x === b.x && a.y === b.y && (a.w || 1) === (b.w || 1) && (a.h || 1) === (b.h || 1);\n    }\n    /** given a node, makes sure it's min/max are valid */ static sanitizeMinMax(node) {\n        // remove 0, undefine, null\n        if (!node.minW) {\n            delete node.minW;\n        }\n        if (!node.minH) {\n            delete node.minH;\n        }\n        if (!node.maxW) {\n            delete node.maxW;\n        }\n        if (!node.maxH) {\n            delete node.maxH;\n        }\n    }\n    /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */ static removeInternalAndSame(a, b) {\n        if (typeof a !== \"object\" || typeof b !== \"object\") return;\n        for(let key in a){\n            let val = a[key];\n            if (key[0] === \"_\" || val === b[key]) {\n                delete a[key];\n            } else if (val && typeof val === \"object\" && b[key] !== undefined) {\n                for(let i in val){\n                    if (val[i] === b[key][i] || i[0] === \"_\") {\n                        delete val[i];\n                    }\n                }\n                if (!Object.keys(val).length) {\n                    delete a[key];\n                }\n            }\n        }\n    }\n    /** removes internal fields '_' and default values for saving */ static removeInternalForSave(n, removeEl = true) {\n        for(let key in n){\n            if (key[0] === \"_\" || n[key] === null || n[key] === undefined) delete n[key];\n        }\n        delete n.grid;\n        if (removeEl) delete n.el;\n        // delete default values (will be re-created on read)\n        if (!n.autoPosition) delete n.autoPosition;\n        if (!n.noResize) delete n.noResize;\n        if (!n.noMove) delete n.noMove;\n        if (!n.locked) delete n.locked;\n        if (n.w === 1 || n.w === n.minW) delete n.w;\n        if (n.h === 1 || n.h === n.minH) delete n.h;\n    }\n    /** return the closest parent (or itself) matching the given class */ // static closestUpByClass(el: HTMLElement, name: string): HTMLElement {\n    //   while (el) {\n    //     if (el.classList.contains(name)) return el;\n    //     el = el.parentElement\n    //   }\n    //   return null;\n    // }\n    /** delay calling the given function for given delay, preventing new calls from happening while waiting */ static throttle(func, delay) {\n        let isWaiting = false;\n        return (...args)=>{\n            if (!isWaiting) {\n                isWaiting = true;\n                setTimeout(()=>{\n                    func(...args);\n                    isWaiting = false;\n                }, delay);\n            }\n        };\n    }\n    static removePositioningStyles(el) {\n        let style = el.style;\n        if (style.position) {\n            style.removeProperty(\"position\");\n        }\n        if (style.left) {\n            style.removeProperty(\"left\");\n        }\n        if (style.top) {\n            style.removeProperty(\"top\");\n        }\n        if (style.width) {\n            style.removeProperty(\"width\");\n        }\n        if (style.height) {\n            style.removeProperty(\"height\");\n        }\n    }\n    /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */ static getScrollElement(el) {\n        if (!el) return document.scrollingElement || document.documentElement; // IE support\n        const style = getComputedStyle(el);\n        const overflowRegex = /(auto|scroll)/;\n        if (overflowRegex.test(style.overflow + style.overflowY)) {\n            return el;\n        } else {\n            return this.getScrollElement(el.parentElement);\n        }\n    }\n    /** @internal */ static updateScrollPosition(el, position, distance) {\n        // is widget in view?\n        let rect = el.getBoundingClientRect();\n        let innerHeightOrClientHeight = window.innerHeight || document.documentElement.clientHeight;\n        if (rect.top < 0 || rect.bottom > innerHeightOrClientHeight) {\n            // set scrollTop of first parent that scrolls\n            // if parent is larger than el, set as low as possible\n            // to get entire widget on screen\n            let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;\n            let offsetDiffUp = rect.top;\n            let scrollEl = this.getScrollElement(el);\n            if (scrollEl !== null) {\n                let prevScroll = scrollEl.scrollTop;\n                if (rect.top < 0 && distance < 0) {\n                    // moving up\n                    if (el.offsetHeight > innerHeightOrClientHeight) {\n                        scrollEl.scrollTop += distance;\n                    } else {\n                        scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;\n                    }\n                } else if (distance > 0) {\n                    // moving down\n                    if (el.offsetHeight > innerHeightOrClientHeight) {\n                        scrollEl.scrollTop += distance;\n                    } else {\n                        scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;\n                    }\n                }\n                // move widget y by amount scrolled\n                position.top += scrollEl.scrollTop - prevScroll;\n            }\n        }\n    }\n    /**\n     * @internal Function used to scroll the page.\n     *\n     * @param event `MouseEvent` that triggers the resize\n     * @param el `HTMLElement` that's being resized\n     * @param distance Distance from the V edges to start scrolling\n     */ static updateScrollResize(event, el, distance) {\n        const scrollEl = this.getScrollElement(el);\n        const height = scrollEl.clientHeight;\n        // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top\n        // #1745 Special situation if scrollEl is document 'html': here browser spec states that\n        // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;\n        // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.\n        const offsetTop = scrollEl === this.getScrollElement() ? 0 : scrollEl.getBoundingClientRect().top;\n        const pointerPosY = event.clientY - offsetTop;\n        const top = pointerPosY < distance;\n        const bottom = pointerPosY > height - distance;\n        if (top) {\n            // This also can be done with a timeout to keep scrolling while the mouse is\n            // in the scrolling zone. (will have smoother behavior)\n            scrollEl.scrollBy({\n                behavior: \"smooth\",\n                top: pointerPosY - distance\n            });\n        } else if (bottom) {\n            scrollEl.scrollBy({\n                behavior: \"smooth\",\n                top: distance - (height - pointerPosY)\n            });\n        }\n    }\n    /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */ static clone(obj) {\n        if (obj === null || obj === undefined || typeof obj !== \"object\") {\n            return obj;\n        }\n        // return Object.assign({}, obj);\n        if (obj instanceof Array) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return [\n                ...obj\n            ];\n        }\n        return {\n            ...obj\n        };\n    }\n    /**\n     * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.\n     * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.\n     */ static cloneDeep(obj) {\n        // list of fields we will skip during cloneDeep (nested objects, other internal)\n        const skipFields = [\n            \"parentGrid\",\n            \"el\",\n            \"grid\",\n            \"subGrid\",\n            \"engine\"\n        ];\n        // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?\n        const ret = Utils.clone(obj);\n        for(const key in ret){\n            // NOTE: we don't support function/circular dependencies so skip those properties for now...\n            if (ret.hasOwnProperty(key) && typeof ret[key] === \"object\" && key.substring(0, 2) !== \"__\" && !skipFields.find((k)=>k === key)) {\n                ret[key] = Utils.cloneDeep(obj[key]);\n            }\n        }\n        return ret;\n    }\n    /** deep clone the given HTML node, removing teh unique id field */ static cloneNode(el) {\n        const node = el.cloneNode(true);\n        node.removeAttribute(\"id\");\n        return node;\n    }\n    static appendTo(el, parent) {\n        let parentNode;\n        if (typeof parent === \"string\") {\n            parentNode = Utils.getElement(parent);\n        } else {\n            parentNode = parent;\n        }\n        if (parentNode) {\n            parentNode.appendChild(el);\n        }\n    }\n    // public static setPositionRelative(el: HTMLElement): void {\n    //   if (!(/^(?:r|a|f)/).test(getComputedStyle(el).position)) {\n    //     el.style.position = \"relative\";\n    //   }\n    // }\n    static addElStyles(el, styles) {\n        if (styles instanceof Object) {\n            for(const s in styles){\n                if (styles.hasOwnProperty(s)) {\n                    if (Array.isArray(styles[s])) {\n                        // support fallback value\n                        styles[s].forEach((val)=>{\n                            el.style[s] = val;\n                        });\n                    } else {\n                        el.style[s] = styles[s];\n                    }\n                }\n            }\n        }\n    }\n    static initEvent(e, info) {\n        const evt = {\n            type: info.type\n        };\n        const obj = {\n            button: 0,\n            which: 0,\n            buttons: 1,\n            bubbles: true,\n            cancelable: true,\n            target: info.target ? info.target : e.target\n        };\n        // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n        if (e.dataTransfer) {\n            evt[\"dataTransfer\"] = e.dataTransfer; // workaround 'readonly' field.\n        }\n        [\n            \"altKey\",\n            \"ctrlKey\",\n            \"metaKey\",\n            \"shiftKey\"\n        ].forEach((p)=>evt[p] = e[p]); // keys\n        [\n            \"pageX\",\n            \"pageY\",\n            \"clientX\",\n            \"clientY\",\n            \"screenX\",\n            \"screenY\"\n        ].forEach((p)=>evt[p] = e[p]); // point info\n        return {\n            ...evt,\n            ...obj\n        };\n    }\n    /** copies the MouseEvent properties and sends it as another event to the given target */ static simulateMouseEvent(e, simulatedType, target) {\n        const simulatedEvent = document.createEvent(\"MouseEvents\");\n        simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, e.target // relatedTarget\n        );\n        (target || e.target).dispatchEvent(simulatedEvent);\n    }\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTtRQUNBO1lBQUM7WUFBVTtZQUFXO1lBQVc7U0FBVyxDQUFDMUYsT0FBTyxDQUFDMkYsQ0FBQUEsSUFBS1IsR0FBRyxDQUFDUSxFQUFFLEdBQUdULENBQUMsQ0FBQ1MsRUFBRSxHQUFHLE9BQU87UUFDakY7WUFBQztZQUFTO1lBQVM7WUFBVztZQUFXO1lBQVc7U0FBVSxDQUFDM0YsT0FBTyxDQUFDMkYsQ0FBQUEsSUFBS1IsR0FBRyxDQUFDUSxFQUFFLEdBQUdULENBQUMsQ0FBQ1MsRUFBRSxHQUFHLGFBQWE7UUFDekcsT0FBTztZQUFFLEdBQUdSLEdBQUc7WUFBRSxHQUFHZCxHQUFHO1FBQUM7SUFDNUI7SUFDQSx1RkFBdUYsR0FDdkYsT0FBT3VCLG1CQUFtQlYsQ0FBQyxFQUFFVyxhQUFhLEVBQUUvRixNQUFNLEVBQUU7UUFDaEQsTUFBTWdHLGlCQUFpQjVLLFNBQVM2SyxXQUFXLENBQUM7UUFDNUNELGVBQWVFLGNBQWMsQ0FBQ0gsZUFDOUIsTUFDQSxNQUNBM0MsUUFDQSxHQUNBZ0MsRUFBRWUsT0FBTyxFQUNUZixFQUFFZ0IsT0FBTyxFQUNUaEIsRUFBRWlCLE9BQU8sRUFDVGpCLEVBQUVqQixPQUFPLEVBQ1RpQixFQUFFa0IsT0FBTyxFQUNUbEIsRUFBRW1CLE1BQU0sRUFDUm5CLEVBQUVvQixRQUFRLEVBQ1ZwQixFQUFFcUIsT0FBTyxFQUNULEdBQ0FyQixFQUFFcEYsTUFBTSxDQUFDLGdCQUFnQjs7UUFFeEJBLENBQUFBLFVBQVVvRixFQUFFcEYsTUFBTSxFQUFFMEcsYUFBYSxDQUFDVjtJQUN2QztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbHVjaWRpdHktZDNqcy8uL25vZGVfbW9kdWxlcy9ncmlkc3RhY2svZGlzdC91dGlscy5qcz9mOTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdXRpbHMudHMgOS40LjBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbGFpbiBEdW1lc255IC0gc2VlIEdyaWRTdGFjayByb290IGxpY2Vuc2VcbiAqL1xuLyoqIGNoZWNrcyBmb3Igb2Jzb2xldGUgbWV0aG9kIG5hbWVzICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZShzZWxmLCBmLCBvbGROYW1lLCBuZXdOYW1lLCByZXYpIHtcbiAgICBsZXQgd3JhcHBlciA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ3JpZHN0YWNrLmpzOiBGdW5jdGlvbiBgJyArIG9sZE5hbWUgKyAnYCBpcyBkZXByZWNhdGVkIGluICcgKyByZXYgKyAnIGFuZCBoYXMgYmVlbiByZXBsYWNlZCAnICtcbiAgICAgICAgICAgICd3aXRoIGAnICsgbmV3TmFtZSArICdgLiBJdCB3aWxsIGJlICoqcmVtb3ZlZCoqIGluIGEgZnV0dXJlIHJlbGVhc2UnKTtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfTtcbiAgICB3cmFwcGVyLnByb3RvdHlwZSA9IGYucHJvdG90eXBlO1xuICAgIHJldHVybiB3cmFwcGVyO1xufVxuLyoqIGNoZWNrcyBmb3Igb2Jzb2xldGUgZ3JpZCBvcHRpb25zIChjYW4gYmUgdXNlZCBmb3IgYW55IGZpZWxkcywgYnV0IG1zZyBpcyBhYm91dCBvcHRpb25zKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic29sZXRlT3B0cyhvcHRzLCBvbGROYW1lLCBuZXdOYW1lLCByZXYpIHtcbiAgICBpZiAob3B0c1tvbGROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHNbbmV3TmFtZV0gPSBvcHRzW29sZE5hbWVdO1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay5qczogT3B0aW9uIGAnICsgb2xkTmFtZSArICdgIGlzIGRlcHJlY2F0ZWQgaW4gJyArIHJldiArICcgYW5kIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYCcgK1xuICAgICAgICAgICAgbmV3TmFtZSArICdgLiBJdCB3aWxsIGJlICoqcmVtb3ZlZCoqIGluIGEgZnV0dXJlIHJlbGVhc2UnKTtcbiAgICB9XG59XG4vKiogY2hlY2tzIGZvciBvYnNvbGV0ZSBncmlkIG9wdGlvbnMgd2hpY2ggYXJlIGdvbmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZU9wdHNEZWwob3B0cywgb2xkTmFtZSwgcmV2LCBpbmZvKSB7XG4gICAgaWYgKG9wdHNbb2xkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dyaWRzdGFjay5qczogT3B0aW9uIGAnICsgb2xkTmFtZSArICdgIGlzIGRlcHJlY2F0ZWQgaW4gJyArIHJldiArIGluZm8pO1xuICAgIH1cbn1cbi8qKiBjaGVja3MgZm9yIG9ic29sZXRlIEpxdWVyeSBlbGVtZW50IGF0dHJpYnV0ZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNvbGV0ZUF0dHIoZWwsIG9sZE5hbWUsIG5ld05hbWUsIHJldikge1xuICAgIGxldCBvbGRBdHRyID0gZWwuZ2V0QXR0cmlidXRlKG9sZE5hbWUpO1xuICAgIGlmIChvbGRBdHRyICE9PSBudWxsKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuZXdOYW1lLCBvbGRBdHRyKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdncmlkc3RhY2suanM6IGF0dHJpYnV0ZSBgJyArIG9sZE5hbWUgKyAnYD0nICsgb2xkQXR0ciArICcgaXMgZGVwcmVjYXRlZCBvbiB0aGlzIG9iamVjdCBpbiAnICsgcmV2ICsgJyBhbmQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBgJyArXG4gICAgICAgICAgICBuZXdOYW1lICsgJ2AuIEl0IHdpbGwgYmUgKipyZW1vdmVkKiogaW4gYSBmdXR1cmUgcmVsZWFzZScpO1xuICAgIH1cbn1cbi8qKlxuICogVXRpbGl0eSBtZXRob2RzXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gICAgLyoqIGNvbnZlcnQgYSBwb3RlbnRpYWwgc2VsZWN0b3IgaW50byBhY3R1YWwgbGlzdCBvZiBodG1sIGVsZW1lbnRzLiBvcHRpb25hbCByb290IHdoaWNoIGRlZmF1bHRzIHRvIGRvY3VtZW50IChmb3Igc2hhZG93IGRvbSkgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudHMoZWxzLCByb290ID0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSAoJ2dldEVsZW1lbnRCeUlkJyBpbiByb290KSA/IHJvb3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBOb3RlOiB2ZXJ5IGNvbW1vbiBmb3IgcGVvcGxlIHVzZSB0byBpZD0nMSwyLDMnIHdoaWNoIGlzIG9ubHkgbGVnYWwgYXMgSFRNTDUgaWQsIGJ1dCBub3QgQ1NTIHNlbGVjdG9yc1xuICAgICAgICAgICAgLy8gc28gaWYgd2Ugc3RhcnQgd2l0aCBhIG51bWJlciwgYXNzdW1lIGl0J3MgYW4gaWQgYW5kIGp1c3QgcmV0dXJuIHRoYXQgb25lIGl0ZW0uLi5cbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JpZHN0YWNrL2dyaWRzdGFjay5qcy9pc3N1ZXMvMjIzNCNpc3N1ZWNvbW1lbnQtMTUyMzc5NjU2MlxuICAgICAgICAgICAgaWYgKGRvYyAmJiAhaXNOYU4oK2Vsc1swXSkpIHsgLy8gc3RhcnQgd2l0aCBkaWdpdFxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZG9jLmdldEVsZW1lbnRCeUlkKGVscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsID8gW2VsXSA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpc3QgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoZWxzKTtcbiAgICAgICAgICAgIGlmICghbGlzdC5sZW5ndGggJiYgZWxzWzBdICE9PSAnLicgJiYgZWxzWzBdICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIGVscyk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcjJyArIGVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtlbHNdO1xuICAgIH1cbiAgICAvKiogY29udmVydCBhIHBvdGVudGlhbCBzZWxlY3RvciBpbnRvIGFjdHVhbCBzaW5nbGUgZWxlbWVudC4gb3B0aW9uYWwgcm9vdCB3aGljaCBkZWZhdWx0cyB0byBkb2N1bWVudCAoZm9yIHNoYWRvdyBkb20pICovXG4gICAgc3RhdGljIGdldEVsZW1lbnQoZWxzLCByb290ID0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSAoJ2dldEVsZW1lbnRCeUlkJyBpbiByb290KSA/IHJvb3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWVscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZG9jICYmIGVsc1swXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5nZXRFbGVtZW50QnlJZChlbHMuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbHNbMF0gPT09ICcjJyB8fCBlbHNbMF0gPT09ICcuJyB8fCBlbHNbMF0gPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LnF1ZXJ5U2VsZWN0b3IoZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIHN0YXJ0IHdpdGggYSBkaWdpdCwgYXNzdW1lIGl0J3MgYW4gaWQgKGVycm9yIGNhbGxpbmcgcXVlcnlTZWxlY3RvcignIzEnKSkgYXMgY2xhc3MgYXJlIG5vdCB2YWxpZCBDU1NcbiAgICAgICAgICAgIGlmIChkb2MgJiYgIWlzTmFOKCtlbHNbMF0pKSB7IC8vIHN0YXJ0IHdpdGggZGlnaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmdldEVsZW1lbnRCeUlkKGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHRyeSBzdHJpbmcsIHRoZW4gaWQsIHRoZW4gY2xhc3NcbiAgICAgICAgICAgIGxldCBlbCA9IHJvb3QucXVlcnlTZWxlY3RvcihlbHMpO1xuICAgICAgICAgICAgaWYgKGRvYyAmJiAhZWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChlbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIGVsID0gcm9vdC5xdWVyeVNlbGVjdG9yKCcuJyArIGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG4gICAgLyoqIHRydWUgaWYgd2Ugc2hvdWxkIHJlc2l6ZSB0byBjb250ZW50ICovXG4gICAgc3RhdGljIHNob3VsZFNpemVUb0NvbnRlbnQobikge1xuICAgICAgICByZXR1cm4gbj8uZ3JpZCAmJiAoISFuLnNpemVUb0NvbnRlbnQgfHwgKG4uZ3JpZC5vcHRzLnNpemVUb0NvbnRlbnQgJiYgbi5zaXplVG9Db250ZW50ICE9PSBmYWxzZSkpO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0cnVlIGlmIGEgYW5kIGIgb3ZlcmxhcCAqL1xuICAgIHN0YXRpYyBpc0ludGVyY2VwdGVkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICEoYS55ID49IGIueSArIGIuaCB8fCBhLnkgKyBhLmggPD0gYi55IHx8IGEueCArIGEudyA8PSBiLnggfHwgYS54ID49IGIueCArIGIudyk7XG4gICAgfVxuICAgIC8qKiByZXR1cm5zIHRydWUgaWYgYSBhbmQgYiB0b3VjaCBlZGdlcyBvciBjb3JuZXJzICovXG4gICAgc3RhdGljIGlzVG91Y2hpbmcoYSwgYikge1xuICAgICAgICByZXR1cm4gVXRpbHMuaXNJbnRlcmNlcHRlZChhLCB7IHg6IGIueCAtIDAuNSwgeTogYi55IC0gMC41LCB3OiBiLncgKyAxLCBoOiBiLmggKyAxIH0pO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0aGUgYXJlYSBhIGFuZCBiIG92ZXJsYXAgKi9cbiAgICBzdGF0aWMgYXJlYUludGVyY2VwdChhLCBiKSB7XG4gICAgICAgIGxldCB4MCA9IChhLnggPiBiLngpID8gYS54IDogYi54O1xuICAgICAgICBsZXQgeDEgPSAoYS54ICsgYS53IDwgYi54ICsgYi53KSA/IGEueCArIGEudyA6IGIueCArIGIudztcbiAgICAgICAgaWYgKHgxIDw9IHgwKVxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIG5vIG92ZXJsYXBcbiAgICAgICAgbGV0IHkwID0gKGEueSA+IGIueSkgPyBhLnkgOiBiLnk7XG4gICAgICAgIGxldCB5MSA9IChhLnkgKyBhLmggPCBiLnkgKyBiLmgpID8gYS55ICsgYS5oIDogYi55ICsgYi5oO1xuICAgICAgICBpZiAoeTEgPD0geTApXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gbm8gb3ZlcmxhcFxuICAgICAgICByZXR1cm4gKHgxIC0geDApICogKHkxIC0geTApO1xuICAgIH1cbiAgICAvKiogcmV0dXJucyB0aGUgYXJlYSAqL1xuICAgIHN0YXRpYyBhcmVhKGEpIHtcbiAgICAgICAgcmV0dXJuIGEudyAqIGEuaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydHMgYXJyYXkgb2Ygbm9kZXNcbiAgICAgKiBAcGFyYW0gbm9kZXMgYXJyYXkgdG8gc29ydFxuICAgICAqIEBwYXJhbSBkaXIgMSBmb3IgYXNjLCAtMSBmb3IgZGVzYyAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHRoZSBncmlkLiBJZiB1bmRlZmluZWQgdGhlIHdpZHRoIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IChvcHRpb25hbCkuXG4gICAgICoqL1xuICAgIHN0YXRpYyBzb3J0KG5vZGVzLCBkaXIgPSAxLCBjb2x1bW4pIHtcbiAgICAgICAgY29sdW1uID0gY29sdW1uIHx8IG5vZGVzLnJlZHVjZSgoY29sLCBuKSA9PiBNYXRoLm1heChuLnggKyBuLncsIGNvbCksIDApIHx8IDEyO1xuICAgICAgICBpZiAoZGlyID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zb3J0KChhLCBiKSA9PiAoKGIueCA/PyAxMDAwKSArIChiLnkgPz8gMTAwMCkgKiBjb2x1bW4pIC0gKChhLnggPz8gMTAwMCkgKyAoYS55ID8/IDEwMDApICogY29sdW1uKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zb3J0KChiLCBhKSA9PiAoKGIueCA/PyAxMDAwKSArIChiLnkgPz8gMTAwMCkgKiBjb2x1bW4pIC0gKChhLnggPz8gMTAwMCkgKyAoYS55ID8/IDEwMDApICogY29sdW1uKSk7XG4gICAgfVxuICAgIC8qKiBmaW5kIGFuIGl0ZW0gYnkgaWQgKi9cbiAgICBzdGF0aWMgZmluZChub2RlcywgaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID8gbm9kZXMuZmluZChuID0+IG4uaWQgPT09IGlkKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIHN0eWxlIHNoZWV0IHdpdGggc3R5bGUgaWQgdW5kZXIgZ2l2ZW4gcGFyZW50XG4gICAgICogQHBhcmFtIGlkIHdpbGwgc2V0IHRoZSAnZ3Mtc3R5bGUtaWQnIGF0dHJpYnV0ZSB0byB0aGF0IGlkXG4gICAgICogQHBhcmFtIHBhcmVudCB0byBpbnNlcnQgdGhlIHN0eWxlc2hlZXQgYXMgZmlyc3QgY2hpbGQsXG4gICAgICogaWYgbm9uZSBzdXBwbGllZCBpdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkIGluc3RlYWQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlc2hlZXQoaWQsIHBhcmVudCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBjb25zdCBub25jZSA9IG9wdGlvbnM/Lm5vbmNlO1xuICAgICAgICBpZiAobm9uY2UpXG4gICAgICAgICAgICBzdHlsZS5ub25jZSA9IG5vbmNlO1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdncy1zdHlsZS1pZCcsIGlkKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHsgLy8gVE9ETzogb25seSBDU1NJbXBvcnRSdWxlIGhhdmUgdGhhdCBhbmQgZGlmZmVyZW50IGJlYXN0ID8/XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpOyAvLyBXZWJLaXQgaGFja1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGhlYWRcbiAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZS5zaGVldDtcbiAgICB9XG4gICAgLyoqIHJlbW92ZWQgdGhlIGdpdmVuIHN0eWxlc2hlZXQgaWQgKi9cbiAgICBzdGF0aWMgcmVtb3ZlU3R5bGVzaGVldChpZCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdTVFlMRVtncy1zdHlsZS1pZD0nICsgaWQgKyAnXScpO1xuICAgICAgICBpZiAoZWwgJiYgZWwucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvKiogaW5zZXJ0cyBhIENTUyBydWxlICovXG4gICAgc3RhdGljIGFkZENTU1J1bGUoc2hlZXQsIHNlbGVjdG9yLCBydWxlcykge1xuICAgICAgICBpZiAodHlwZW9mIHNoZWV0LmFkZFJ1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHJ1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2hlZXQuaW5zZXJ0UnVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShgJHtzZWxlY3Rvcn17JHtydWxlc319YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgdG9Cb29sKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHYgPSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gISh2ID09PSAnJyB8fCB2ID09PSAnbm8nIHx8IHYgPT09ICdmYWxzZScgfHwgdiA9PT0gJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbih2KTtcbiAgICB9XG4gICAgc3RhdGljIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSA/IHVuZGVmaW5lZCA6IE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUhlaWdodCh2YWwpIHtcbiAgICAgICAgbGV0IGg7XG4gICAgICAgIGxldCB1bml0ID0gJ3B4JztcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB2YWwubWF0Y2goL14oLVswLTldK1xcLlswLTldK3xbMC05XSpcXC5bMC05XSt8LVswLTldK3xbMC05XSspKHB4fGVtfHJlbXx2aHx2d3wlKT8kLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXQgPSBtYXRjaFsyXSB8fCAncHgnO1xuICAgICAgICAgICAgICAgIGggPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaCwgdW5pdCB9O1xuICAgIH1cbiAgICAvKiogY29waWVzIHVuc2V0IGZpZWxkcyBpbiB0YXJnZXQgdG8gdXNlIHRoZSBnaXZlbiBkZWZhdWx0IHNvdXJjZXMgdmFsdWVzICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3RhdGljIGRlZmF1bHRzKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IG51bGwgfHwgdGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgYW4gb2JqZWN0LCByZWN1cnNpdmVseSBhZGQgaXQncyBmaWVsZCBvdmVyLi4uICMxMzczXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKiogZ2l2ZW4gMiBvYmplY3RzIHJldHVybiB0cnVlIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMuIENoZWNrcyBmb3IgT2JqZWN0IHt9IGhhdmluZyBzYW1lIGZpZWxkcyBhbmQgdmFsdWVzIChqdXN0IDEgbGV2ZWwgZG93bikgKi9cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiO1xuICAgICAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBlbHNlIHdlIGhhdmUgb2JqZWN0LCBjaGVjayBqdXN0IDEgbGV2ZWwgZGVlcCBmb3IgYmVpbmcgc2FtZSB0aGluZ3MuLi5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogY29waWVzIG92ZXIgYiBzaXplICYgcG9zaXRpb24gKEdyaWRTdGFja1Bvc2l0aW9uKSwgYW5kIG9wdGlvbmFsbHkgbWluL21heCBhcyB3ZWxsICovXG4gICAgc3RhdGljIGNvcHlQb3MoYSwgYiwgZG9NaW5NYXggPSBmYWxzZSkge1xuICAgICAgICBpZiAoYi54ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhLnggPSBiLng7XG4gICAgICAgIGlmIChiLnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGEueSA9IGIueTtcbiAgICAgICAgaWYgKGIudyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYS53ID0gYi53O1xuICAgICAgICBpZiAoYi5oICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhLmggPSBiLmg7XG4gICAgICAgIGlmIChkb01pbk1heCkge1xuICAgICAgICAgICAgaWYgKGIubWluVylcbiAgICAgICAgICAgICAgICBhLm1pblcgPSBiLm1pblc7XG4gICAgICAgICAgICBpZiAoYi5taW5IKVxuICAgICAgICAgICAgICAgIGEubWluSCA9IGIubWluSDtcbiAgICAgICAgICAgIGlmIChiLm1heFcpXG4gICAgICAgICAgICAgICAgYS5tYXhXID0gYi5tYXhXO1xuICAgICAgICAgICAgaWYgKGIubWF4SClcbiAgICAgICAgICAgICAgICBhLm1heEggPSBiLm1heEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIC8qKiB0cnVlIGlmIGEgYW5kIGIgaGFzIHNhbWUgc2l6ZSAmIHBvc2l0aW9uICovXG4gICAgc3RhdGljIHNhbWVQb3MoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAmJiBiICYmIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIChhLncgfHwgMSkgPT09IChiLncgfHwgMSkgJiYgKGEuaCB8fCAxKSA9PT0gKGIuaCB8fCAxKTtcbiAgICB9XG4gICAgLyoqIGdpdmVuIGEgbm9kZSwgbWFrZXMgc3VyZSBpdCdzIG1pbi9tYXggYXJlIHZhbGlkICovXG4gICAgc3RhdGljIHNhbml0aXplTWluTWF4KG5vZGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIDAsIHVuZGVmaW5lLCBudWxsXG4gICAgICAgIGlmICghbm9kZS5taW5XKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5taW5XO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5taW5IKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5taW5IO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5tYXhXKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5tYXhXO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5tYXhIKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5tYXhIO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiByZW1vdmVzIGZpZWxkIGZyb20gdGhlIGZpcnN0IG9iamVjdCBpZiBzYW1lIGFzIHRoZSBzZWNvbmQgb2JqZWN0cyAobGlrZSBkaWZmaW5nKSBhbmQgaW50ZXJuYWwgJ18nIGZvciBzYXZpbmcgKi9cbiAgICBzdGF0aWMgcmVtb3ZlSW50ZXJuYWxBbmRTYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gYVtrZXldO1xuICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gJ18nIHx8IHZhbCA9PT0gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBiW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxbaV0gPT09IGJba2V5XVtpXSB8fCBpWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogcmVtb3ZlcyBpbnRlcm5hbCBmaWVsZHMgJ18nIGFuZCBkZWZhdWx0IHZhbHVlcyBmb3Igc2F2aW5nICovXG4gICAgc3RhdGljIHJlbW92ZUludGVybmFsRm9yU2F2ZShuLCByZW1vdmVFbCA9IHRydWUpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG4pIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gPT09ICdfJyB8fCBuW2tleV0gPT09IG51bGwgfHwgbltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbi5ncmlkO1xuICAgICAgICBpZiAocmVtb3ZlRWwpXG4gICAgICAgICAgICBkZWxldGUgbi5lbDtcbiAgICAgICAgLy8gZGVsZXRlIGRlZmF1bHQgdmFsdWVzICh3aWxsIGJlIHJlLWNyZWF0ZWQgb24gcmVhZClcbiAgICAgICAgaWYgKCFuLmF1dG9Qb3NpdGlvbilcbiAgICAgICAgICAgIGRlbGV0ZSBuLmF1dG9Qb3NpdGlvbjtcbiAgICAgICAgaWYgKCFuLm5vUmVzaXplKVxuICAgICAgICAgICAgZGVsZXRlIG4ubm9SZXNpemU7XG4gICAgICAgIGlmICghbi5ub01vdmUpXG4gICAgICAgICAgICBkZWxldGUgbi5ub01vdmU7XG4gICAgICAgIGlmICghbi5sb2NrZWQpXG4gICAgICAgICAgICBkZWxldGUgbi5sb2NrZWQ7XG4gICAgICAgIGlmIChuLncgPT09IDEgfHwgbi53ID09PSBuLm1pblcpXG4gICAgICAgICAgICBkZWxldGUgbi53O1xuICAgICAgICBpZiAobi5oID09PSAxIHx8IG4uaCA9PT0gbi5taW5IKVxuICAgICAgICAgICAgZGVsZXRlIG4uaDtcbiAgICB9XG4gICAgLyoqIHJldHVybiB0aGUgY2xvc2VzdCBwYXJlbnQgKG9yIGl0c2VsZikgbWF0Y2hpbmcgdGhlIGdpdmVuIGNsYXNzICovXG4gICAgLy8gc3RhdGljIGNsb3Nlc3RVcEJ5Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gICAgLy8gICB3aGlsZSAoZWwpIHtcbiAgICAvLyAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgcmV0dXJuIGVsO1xuICAgIC8vICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnRcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvKiogZGVsYXkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGdpdmVuIGRlbGF5LCBwcmV2ZW50aW5nIG5ldyBjYWxscyBmcm9tIGhhcHBlbmluZyB3aGlsZSB3YWl0aW5nICovXG4gICAgc3RhdGljIHRocm90dGxlKGZ1bmMsIGRlbGF5KSB7XG4gICAgICAgIGxldCBpc1dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzV2FpdGluZykge1xuICAgICAgICAgICAgICAgIGlzV2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGZ1bmMoLi4uYXJncyk7IGlzV2FpdGluZyA9IGZhbHNlOyB9LCBkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZW1vdmVQb3NpdGlvbmluZ1N0eWxlcyhlbCkge1xuICAgICAgICBsZXQgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9zaXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUubGVmdCkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUudG9wKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgndG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLndpZHRoKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgnd2lkdGgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCByZXR1cm5zIHRoZSBwYXNzZWQgZWxlbWVudCBpZiBzY3JvbGxhYmxlLCBlbHNlIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IHdpbGwsIHVwIHRvIHRoZSBlbnRpcmUgZG9jdW1lbnQgc2Nyb2xsaW5nIGVsZW1lbnQgKi9cbiAgICBzdGF0aWMgZ2V0U2Nyb2xsRWxlbWVudChlbCkge1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyAvLyBJRSBzdXBwb3J0XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZ2V4LnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxFbGVtZW50KGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgdXBkYXRlU2Nyb2xsUG9zaXRpb24oZWwsIHBvc2l0aW9uLCBkaXN0YW5jZSkge1xuICAgICAgICAvLyBpcyB3aWRnZXQgaW4gdmlldz9cbiAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQgPSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICBpZiAocmVjdC50b3AgPCAwIHx8XG4gICAgICAgICAgICByZWN0LmJvdHRvbSA+IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNldCBzY3JvbGxUb3Agb2YgZmlyc3QgcGFyZW50IHRoYXQgc2Nyb2xsc1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGlzIGxhcmdlciB0aGFuIGVsLCBzZXQgYXMgbG93IGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyB0byBnZXQgZW50aXJlIHdpZGdldCBvbiBzY3JlZW5cbiAgICAgICAgICAgIGxldCBvZmZzZXREaWZmRG93biA9IHJlY3QuYm90dG9tIC0gaW5uZXJIZWlnaHRPckNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGxldCBvZmZzZXREaWZmVXAgPSByZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBzY3JvbGxFbCA9IHRoaXMuZ2V0U2Nyb2xsRWxlbWVudChlbCk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsRWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldlNjcm9sbCA9IHNjcm9sbEVsLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCAwICYmIGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZpbmcgdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm9mZnNldEhlaWdodCA+IGlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCArPSBNYXRoLmFicyhvZmZzZXREaWZmVXApID4gTWF0aC5hYnMoZGlzdGFuY2UpID8gZGlzdGFuY2UgOiBvZmZzZXREaWZmVXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmluZyBkb3duXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5vZmZzZXRIZWlnaHQgPiBpbm5lckhlaWdodE9yQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgKz0gb2Zmc2V0RGlmZkRvd24gPiBkaXN0YW5jZSA/IGRpc3RhbmNlIDogb2Zmc2V0RGlmZkRvd247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB3aWRnZXQgeSBieSBhbW91bnQgc2Nyb2xsZWRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gc2Nyb2xsRWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgRnVuY3Rpb24gdXNlZCB0byBzY3JvbGwgdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgYE1vdXNlRXZlbnRgIHRoYXQgdHJpZ2dlcnMgdGhlIHJlc2l6ZVxuICAgICAqIEBwYXJhbSBlbCBgSFRNTEVsZW1lbnRgIHRoYXQncyBiZWluZyByZXNpemVkXG4gICAgICogQHBhcmFtIGRpc3RhbmNlIERpc3RhbmNlIGZyb20gdGhlIFYgZWRnZXMgdG8gc3RhcnQgc2Nyb2xsaW5nXG4gICAgICovXG4gICAgc3RhdGljIHVwZGF0ZVNjcm9sbFJlc2l6ZShldmVudCwgZWwsIGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbEVsID0gdGhpcy5nZXRTY3JvbGxFbGVtZW50KGVsKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAvLyAjMTcyNyBldmVudC5jbGllbnRZIGlzIHJlbGF0aXZlIHRvIHZpZXdwb3J0LCBzbyBtdXN0IGNvbXBhcmUgdGhpcyBhZ2FpbnN0IHBvc2l0aW9uIG9mIHNjcm9sbEVsIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAvLyAjMTc0NSBTcGVjaWFsIHNpdHVhdGlvbiBpZiBzY3JvbGxFbCBpcyBkb2N1bWVudCAnaHRtbCc6IGhlcmUgYnJvd3NlciBzcGVjIHN0YXRlcyB0aGF0XG4gICAgICAgIC8vIGNsaWVudEhlaWdodCBpcyBoZWlnaHQgb2Ygdmlld3BvcnQsIGJ1dCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBpcyByZWN0YW5nbGUgb2YgaHRtbCBlbGVtZW50O1xuICAgICAgICAvLyB0aGlzIGRpc2NyZXBhbmN5IGFyaXNlcyBiZWNhdXNlIGluIHJlYWxpdHkgc2Nyb2xsYmFyIGlzIGF0dGFjaGVkIHRvIHZpZXdwb3J0LCBub3QgaHRtbCBlbGVtZW50IGl0c2VsZi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKHNjcm9sbEVsID09PSB0aGlzLmdldFNjcm9sbEVsZW1lbnQoKSkgPyAwIDogc2Nyb2xsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBjb25zdCBwb2ludGVyUG9zWSA9IGV2ZW50LmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIGNvbnN0IHRvcCA9IHBvaW50ZXJQb3NZIDwgZGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHBvaW50ZXJQb3NZID4gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBjYW4gYmUgZG9uZSB3aXRoIGEgdGltZW91dCB0byBrZWVwIHNjcm9sbGluZyB3aGlsZSB0aGUgbW91c2UgaXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBzY3JvbGxpbmcgem9uZS4gKHdpbGwgaGF2ZSBzbW9vdGhlciBiZWhhdmlvcilcbiAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbEJ5KHsgYmVoYXZpb3I6ICdzbW9vdGgnLCB0b3A6IHBvaW50ZXJQb3NZIC0gZGlzdGFuY2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm90dG9tKSB7XG4gICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxCeSh7IGJlaGF2aW9yOiAnc21vb3RoJywgdG9wOiBkaXN0YW5jZSAtIChoZWlnaHQgLSBwb2ludGVyUG9zWSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIHNpbmdsZSBsZXZlbCBjbG9uZSwgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHNhbWUgdG9wIGZpZWxkcy4gVGhpcyB3aWxsIHNoYXJlIHN1YiBvYmplY3RzIGFuZCBhcnJheXMgKi9cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIChvYmopICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIFsuLi5vYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLm9iaiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgY2xvbmUgdmVyc2lvbiB0aGF0IHJldHVybnMgYSBmdWxsIGNvcHksIGNoZWNraW5nIGZvciBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzIE9OTFkuXG4gICAgICogTm90ZTogdGhpcyB3aWxsIHVzZSBhcy1pcyBhbnkga2V5IHN0YXJ0aW5nIHdpdGggZG91YmxlIF9fIChhbmQgbm90IGNvcHkgaW5zaWRlKSBzb21lIGxpYiBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvbmVEZWVwKG9iaikge1xuICAgICAgICAvLyBsaXN0IG9mIGZpZWxkcyB3ZSB3aWxsIHNraXAgZHVyaW5nIGNsb25lRGVlcCAobmVzdGVkIG9iamVjdHMsIG90aGVyIGludGVybmFsKVxuICAgICAgICBjb25zdCBza2lwRmllbGRzID0gWydwYXJlbnRHcmlkJywgJ2VsJywgJ2dyaWQnLCAnc3ViR3JpZCcsICdlbmdpbmUnXTtcbiAgICAgICAgLy8gcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIGRhdGUgZm9ybWF0ID9cbiAgICAgICAgY29uc3QgcmV0ID0gVXRpbHMuY2xvbmUob2JqKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmV0KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCBzdXBwb3J0IGZ1bmN0aW9uL2NpcmN1bGFyIGRlcGVuZGVuY2llcyBzbyBza2lwIHRob3NlIHByb3BlcnRpZXMgZm9yIG5vdy4uLlxuICAgICAgICAgICAgaWYgKHJldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiAocmV0W2tleV0pID09PSAnb2JqZWN0JyAmJiBrZXkuc3Vic3RyaW5nKDAsIDIpICE9PSAnX18nICYmICFza2lwRmllbGRzLmZpbmQoayA9PiBrID09PSBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBVdGlscy5jbG9uZURlZXAob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKiBkZWVwIGNsb25lIHRoZSBnaXZlbiBIVE1MIG5vZGUsIHJlbW92aW5nIHRlaCB1bmlxdWUgaWQgZmllbGQgKi9cbiAgICBzdGF0aWMgY2xvbmVOb2RlKGVsKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgc3RhdGljIGFwcGVuZFRvKGVsLCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IHBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IFV0aWxzLmdldEVsZW1lbnQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHB1YmxpYyBzdGF0aWMgc2V0UG9zaXRpb25SZWxhdGl2ZShlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyAgIGlmICghKC9eKD86cnxhfGYpLykudGVzdChnZXRDb21wdXRlZFN0eWxlKGVsKS5wb3NpdGlvbikpIHtcbiAgICAvLyAgICAgZWwuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIHN0YXRpYyBhZGRFbFN0eWxlcyhlbCwgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlc1tzXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgZmFsbGJhY2sgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzXS5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGVbc10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlW3NdID0gc3R5bGVzW3NdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpbml0RXZlbnQoZSwgaW5mbykge1xuICAgICAgICBjb25zdCBldnQgPSB7IHR5cGU6IGluZm8udHlwZSB9O1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICB3aGljaDogMCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IDEsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHRhcmdldDogaW5mby50YXJnZXQgPyBpbmZvLnRhcmdldCA6IGUudGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRvbid0IGNoZWNrIGZvciBgaW5zdGFuY2VvZiBEcmFnRXZlbnRgIGFzIFNhZmFyaSB1c2UgTW91c2VFdmVudCAjMTU0MFxuICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGV2dFsnZGF0YVRyYW5zZmVyJ10gPSBlLmRhdGFUcmFuc2ZlcjsgLy8gd29ya2Fyb3VuZCAncmVhZG9ubHknIGZpZWxkLlxuICAgICAgICB9XG4gICAgICAgIFsnYWx0S2V5JywgJ2N0cmxLZXknLCAnbWV0YUtleScsICdzaGlmdEtleSddLmZvckVhY2gocCA9PiBldnRbcF0gPSBlW3BdKTsgLy8ga2V5c1xuICAgICAgICBbJ3BhZ2VYJywgJ3BhZ2VZJywgJ2NsaWVudFgnLCAnY2xpZW50WScsICdzY3JlZW5YJywgJ3NjcmVlblknXS5mb3JFYWNoKHAgPT4gZXZ0W3BdID0gZVtwXSk7IC8vIHBvaW50IGluZm9cbiAgICAgICAgcmV0dXJuIHsgLi4uZXZ0LCAuLi5vYmogfTtcbiAgICB9XG4gICAgLyoqIGNvcGllcyB0aGUgTW91c2VFdmVudCBwcm9wZXJ0aWVzIGFuZCBzZW5kcyBpdCBhcyBhbm90aGVyIGV2ZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgKi9cbiAgICBzdGF0aWMgc2ltdWxhdGVNb3VzZUV2ZW50KGUsIHNpbXVsYXRlZFR5cGUsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChzaW11bGF0ZWRUeXBlLCAvLyB0eXBlXG4gICAgICAgIHRydWUsIC8vIGJ1YmJsZXNcbiAgICAgICAgdHJ1ZSwgLy8gY2FuY2VsYWJsZVxuICAgICAgICB3aW5kb3csIC8vIHZpZXdcbiAgICAgICAgMSwgLy8gZGV0YWlsXG4gICAgICAgIGUuc2NyZWVuWCwgLy8gc2NyZWVuWFxuICAgICAgICBlLnNjcmVlblksIC8vIHNjcmVlbllcbiAgICAgICAgZS5jbGllbnRYLCAvLyBjbGllbnRYXG4gICAgICAgIGUuY2xpZW50WSwgLy8gY2xpZW50WVxuICAgICAgICBlLmN0cmxLZXksIC8vIGN0cmxLZXlcbiAgICAgICAgZS5hbHRLZXksIC8vIGFsdEtleVxuICAgICAgICBlLnNoaWZ0S2V5LCAvLyBzaGlmdEtleVxuICAgICAgICBlLm1ldGFLZXksIC8vIG1ldGFLZXlcbiAgICAgICAgMCwgLy8gYnV0dG9uXG4gICAgICAgIGUudGFyZ2V0IC8vIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgKHRhcmdldCB8fCBlLnRhcmdldCkuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIm9ic29sZXRlIiwic2VsZiIsImYiLCJvbGROYW1lIiwibmV3TmFtZSIsInJldiIsIndyYXBwZXIiLCJhcmdzIiwiY29uc29sZSIsIndhcm4iLCJhcHBseSIsInByb3RvdHlwZSIsIm9ic29sZXRlT3B0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJvYnNvbGV0ZU9wdHNEZWwiLCJpbmZvIiwib2Jzb2xldGVBdHRyIiwiZWwiLCJvbGRBdHRyIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiVXRpbHMiLCJnZXRFbGVtZW50cyIsImVscyIsInJvb3QiLCJkb2N1bWVudCIsImRvYyIsImlzTmFOIiwiZ2V0RWxlbWVudEJ5SWQiLCJsaXN0IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIkFycmF5IiwiZnJvbSIsImdldEVsZW1lbnQiLCJzdWJzdHJpbmciLCJxdWVyeVNlbGVjdG9yIiwic2hvdWxkU2l6ZVRvQ29udGVudCIsIm4iLCJncmlkIiwic2l6ZVRvQ29udGVudCIsImlzSW50ZXJjZXB0ZWQiLCJhIiwiYiIsInkiLCJoIiwieCIsInciLCJpc1RvdWNoaW5nIiwiYXJlYUludGVyY2VwdCIsIngwIiwieDEiLCJ5MCIsInkxIiwiYXJlYSIsInNvcnQiLCJub2RlcyIsImRpciIsImNvbHVtbiIsInJlZHVjZSIsImNvbCIsIk1hdGgiLCJtYXgiLCJmaW5kIiwiaWQiLCJjcmVhdGVTdHlsZXNoZWV0IiwicGFyZW50Iiwib3B0aW9ucyIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsIm5vbmNlIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic2hlZXQiLCJyZW1vdmVTdHlsZXNoZWV0IiwicGFyZW50Tm9kZSIsInJlbW92ZSIsImFkZENTU1J1bGUiLCJzZWxlY3RvciIsInJ1bGVzIiwiYWRkUnVsZSIsImluc2VydFJ1bGUiLCJ0b0Jvb2wiLCJ2IiwidG9Mb3dlckNhc2UiLCJCb29sZWFuIiwidG9OdW1iZXIiLCJ2YWx1ZSIsIk51bWJlciIsInBhcnNlSGVpZ2h0IiwidmFsIiwidW5pdCIsIm1hdGNoIiwiRXJyb3IiLCJwYXJzZUZsb2F0IiwiZGVmYXVsdHMiLCJ0YXJnZXQiLCJzb3VyY2VzIiwiZm9yRWFjaCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5Iiwic2FtZSIsIk9iamVjdCIsImtleXMiLCJjb3B5UG9zIiwiZG9NaW5NYXgiLCJtaW5XIiwibWluSCIsIm1heFciLCJtYXhIIiwic2FtZVBvcyIsInNhbml0aXplTWluTWF4Iiwibm9kZSIsInJlbW92ZUludGVybmFsQW5kU2FtZSIsImkiLCJyZW1vdmVJbnRlcm5hbEZvclNhdmUiLCJyZW1vdmVFbCIsImF1dG9Qb3NpdGlvbiIsIm5vUmVzaXplIiwibm9Nb3ZlIiwibG9ja2VkIiwidGhyb3R0bGUiLCJmdW5jIiwiZGVsYXkiLCJpc1dhaXRpbmciLCJzZXRUaW1lb3V0IiwicmVtb3ZlUG9zaXRpb25pbmdTdHlsZXMiLCJwb3NpdGlvbiIsInJlbW92ZVByb3BlcnR5IiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0U2Nyb2xsRWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3dSZWdleCIsInRlc3QiLCJvdmVyZmxvdyIsIm92ZXJmbG93WSIsInBhcmVudEVsZW1lbnQiLCJ1cGRhdGVTY3JvbGxQb3NpdGlvbiIsImRpc3RhbmNlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlubmVySGVpZ2h0T3JDbGllbnRIZWlnaHQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImJvdHRvbSIsIm9mZnNldERpZmZEb3duIiwib2Zmc2V0RGlmZlVwIiwic2Nyb2xsRWwiLCJwcmV2U2Nyb2xsIiwic2Nyb2xsVG9wIiwib2Zmc2V0SGVpZ2h0IiwiYWJzIiwidXBkYXRlU2Nyb2xsUmVzaXplIiwiZXZlbnQiLCJvZmZzZXRUb3AiLCJwb2ludGVyUG9zWSIsImNsaWVudFkiLCJzY3JvbGxCeSIsImJlaGF2aW9yIiwiY2xvbmUiLCJvYmoiLCJjbG9uZURlZXAiLCJza2lwRmllbGRzIiwicmV0IiwiayIsImNsb25lTm9kZSIsInJlbW92ZUF0dHJpYnV0ZSIsImFwcGVuZFRvIiwiYWRkRWxTdHlsZXMiLCJzdHlsZXMiLCJzIiwiaXNBcnJheSIsImluaXRFdmVudCIsImUiLCJldnQiLCJ0eXBlIiwiYnV0dG9uIiwid2hpY2giLCJidXR0b25zIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkYXRhVHJhbnNmZXIiLCJwIiwic2ltdWxhdGVNb3VzZUV2ZW50Iiwic2ltdWxhdGVkVHlwZSIsInNpbXVsYXRlZEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImN0cmxLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gridstack/dist/utils.js\n");

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.css":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.css ***!
  \***************************************************/
/***/ (() => {



/***/ })

};
;